/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated from file aligner.xml (author:  Gerton Lunter ) on Sat Apr 25 19:05:34 CDT 2009 */

/*
This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
Copyright (C) 2006 by Gerton Lunter, Oxford University.

HMMoC and works based on it are free software; you can redistribute 
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

HMMOC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HMMoC; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/


#include "alignerHJ.h"

#include "mybandingHJ.h"

const extern string _AlignstateId[];
const extern string _AlignemissionId[];
const extern string _AligntransitionId[];
const extern string _AligntransF[];
const extern string _AligntransT[];
const extern string _AligntransP[];
const extern string _AligntransE[];
const extern string _AlignoutputId[];
const extern string _Alignempty;
const extern int _AlignstateNum;
const extern int _AlignemitNum;
const extern int _AligntransNum;
const extern int _AlignoutputNum;

AlignDPTable::AlignDPTable(int iLen1,int iLen2) : isInCharge(true), stateId(_AlignstateId), emissionId(_AlignemissionId), transitionId(_AligntransitionId), transitionFrom(_AligntransF), transitionTo(_AligntransT), transitionProb(_AligntransP), transitionEmit(_AligntransE), outputId(_AlignoutputId) {
    // init code:
    this->iLen1 = iLen1;
    this->iLen2 = iLen2;
    StateMemoryblock2.allocate(1+iLen1, 1+iLen2);
    StateMemoryblock1.allocate();
    StateMemoryblock3.allocate();
}


AlignDPTable::~AlignDPTable() {
    if (!isInCharge) {
        // make sure data does not get deleted:
        StateMemoryblock2.absolve();
        StateMemoryblock1.absolve();
        StateMemoryblock3.absolve();
    } // if(!isInCharge)
} // destructor

const string& AlignDPTable::getTransitionId(int id) { return id>=0 && id<_AligntransNum ? _AligntransitionId[id] : _Alignempty; }
const string& AlignDPTable::getEmissionId(int id) { return id>=0 && id<_AlignemitNum ? _AlignemissionId[id] : _Alignempty; }
const string& AlignDPTable::getStateId(int id) { return id>=0 && id<_AlignstateNum ? _AlignstateId[id] : _Alignempty; }
const string& AlignDPTable::getOutputId(int id) { return id>=0 && id<_AlignoutputNum ? _AlignoutputId[id] : _Alignempty; }
int AlignDPTable::getId(const string& sId)
{
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
        pmId = new map<string,int>();
        for (int i=0;i<_AlignstateNum;i++) {
            (*pmId)[_AlignstateId[i]] = i;         // add state identifiers
        }
        for (int i=0; i<_AlignemitNum; i++) {
            (*pmId)[_AlignemissionId[i]] = i;      // add emission identifiers
        }
        for (int i=0; i<_AligntransNum; i++) {  
            (*pmId)[_AligntransitionId[i]] = i;    // add transition identifiers
        }
        for (int i=0; i<_AlignoutputNum; i++) {
            (*pmId)[_AlignoutputId[i]] = i;        // finally, add output identifiers
        }
        bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
        if (sId == "_cleanup_") {
            delete pmId;
            } else {
            cout << "AlignDPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
        }
        return -1;
    }
    return iter->second;
}


bfloat AlignDPTable::getProb(const string sState ,int iPos0,int iPos1) const
{
    return getProb(getId(sState) ,iPos0,iPos1);
}


bfloat AlignDPTable::getProb(int iState ,int iPos0,int iPos1) const
{
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock3Secondary;
    static const int blockTable[] = {0, 1, 1, 1, 2};
    static const int stateTable[] = {0, 0, 1, 2, 0};
    switch (blockTable[iState]) {
        default:
        return 0.0;
        break;
        case 0:
        if ((iPos0+0>=0)&&(iPos0+0<=0)&&(iPos1+0>=0)&&(iPos1+0<=0)) {
            CurStateMemoryblock1Secondary = this->StateMemoryblock1.read();
            return CurStateMemoryblock1Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 1:
        if ((iPos0+0>=0)&&(iPos0+0<=iLen1+0)&&(iPos1+0>=0)&&(iPos1+0<=iLen2+0)) {
            CurStateMemoryblock2Secondary = this->StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(0))-(0));
            return CurStateMemoryblock2Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 2:
        if ((iPos0+0>=iLen1+0)&&(iPos0+0<=iLen1+0)&&(iPos1+0>=iLen2+0)&&(iPos1+0<=iLen2+0)) {
            CurStateMemoryblock3Secondary = this->StateMemoryblock3.read();
            return CurStateMemoryblock3Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
    } // switch
} // DPTable...::getProb(int,...)

const extern string _AlignstateId[];
const extern string _AlignemissionId[];
const extern string _AligntransitionId[];
const extern string _AligntransF[];
const extern string _AligntransT[];
const extern string _AligntransP[];
const extern string _AligntransE[];
const extern string _AlignoutputId[];
const extern string _Alignempty;
const extern int _AlignstateNum;
const extern int _AlignemitNum;
const extern int _AligntransNum;
const extern int _AlignoutputNum;

AlignFoldedDPTable::AlignFoldedDPTable(int iLen1,int iLen2) : isInCharge(true), stateId(_AlignstateId), emissionId(_AlignemissionId), transitionId(_AligntransitionId), transitionFrom(_AligntransF), transitionTo(_AligntransT), transitionProb(_AligntransP), transitionEmit(_AligntransE), outputId(_AlignoutputId) {
    // init code:
    this->iLen1 = iLen1;
    this->iLen2 = iLen2;
    StateMemoryblock2.allocate(1+iLen1, 1+iLen2);
    StateMemoryblock3.allocate();
    StateMemoryblock1.allocate();
}


AlignFoldedDPTable::~AlignFoldedDPTable() {
    if (!isInCharge) {
        // make sure data does not get deleted:
        StateMemoryblock2.absolve();
        StateMemoryblock3.absolve();
        StateMemoryblock1.absolve();
    } // if(!isInCharge)
} // destructor

const string& AlignFoldedDPTable::getTransitionId(int id) { return id>=0 && id<_AligntransNum ? _AligntransitionId[id] : _Alignempty; }
const string& AlignFoldedDPTable::getEmissionId(int id) { return id>=0 && id<_AlignemitNum ? _AlignemissionId[id] : _Alignempty; }
const string& AlignFoldedDPTable::getStateId(int id) { return id>=0 && id<_AlignstateNum ? _AlignstateId[id] : _Alignempty; }
const string& AlignFoldedDPTable::getOutputId(int id) { return id>=0 && id<_AlignoutputNum ? _AlignoutputId[id] : _Alignempty; }
int AlignFoldedDPTable::getId(const string& sId)
{
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
        pmId = new map<string,int>();
        for (int i=0;i<_AlignstateNum;i++) {
            (*pmId)[_AlignstateId[i]] = i;         // add state identifiers
        }
        for (int i=0; i<_AlignemitNum; i++) {
            (*pmId)[_AlignemissionId[i]] = i;      // add emission identifiers
        }
        for (int i=0; i<_AligntransNum; i++) {  
            (*pmId)[_AligntransitionId[i]] = i;    // add transition identifiers
        }
        for (int i=0; i<_AlignoutputNum; i++) {
            (*pmId)[_AlignoutputId[i]] = i;        // finally, add output identifiers
        }
        bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
        if (sId == "_cleanup_") {
            delete pmId;
            } else {
            cout << "AlignFoldedDPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
        }
        return -1;
    }
    return iter->second;
}


bfloat AlignFoldedDPTable::getProb(const string sState ,int iPos0,int iPos1) const
{
    return getProb(getId(sState) ,iPos0,iPos1);
}


bfloat AlignFoldedDPTable::getProb(int iState ,int iPos0,int iPos1) const
{
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock3Secondary;
    static const int blockTable[] = {0, 1, 1, 1, 2};
    static const int stateTable[] = {0, 0, 1, 2, 0};
    switch (blockTable[iState]) {
        default:
        return 0.0;
        break;
        case 0:
        if ((iPos0+0>=0)&&(iPos0+0<=0)&&(iPos1+0>=0)&&(iPos1+0<=0)) {
            CurStateMemoryblock1Secondary = this->StateMemoryblock1.read();
            return CurStateMemoryblock1Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 1:
        if ((iPos0+0>=0)&&(iPos0+0<=iLen1+0)&&(iPos1+0>=0)&&(iPos1+0<=iLen2+0)) {
            CurStateMemoryblock2Secondary = this->StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(0))-(0));
            return CurStateMemoryblock2Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 2:
        if ((iPos0+0>=iLen1+0)&&(iPos0+0<=iLen1+0)&&(iPos1+0>=iLen2+0)&&(iPos1+0<=iLen2+0)) {
            CurStateMemoryblock3Secondary = this->StateMemoryblock3.read();
            return CurStateMemoryblock3Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
    } // switch
} // DPTable...::getProb(int,...)

int AlignBaumWelch::transitionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "AlignBaumWelch::transitionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


int AlignBaumWelch::emissionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "AlignBaumWelch::emissionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


void AlignBaumWelch::resetCounts() {
    static bool bInited = false;
    if (!bInited) {
        static const int aTemp[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        for (int i=0; i<16; i++) {
            transitionIdentifier00[i] = aTemp[i];
            atransitionIdx[aTemp[i]] = i;
            mId[_AligntransitionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<16; i++) {
        
        transitionBaumWelchCount00[i] = 0.0;
    }
    bInited = true;
};


int AlignBaumWelch::transitionIdentifier00[];

void AlignBaumWelch::scaleCounts(bfloat scale) {
    for (int i=0; i<16; i++) {
        
        transitionBaumWelchCount00[i] *= scale;
    }
}


map<const string,int> AlignBaumWelch::mId;
int AlignBaumWelch::atransitionIdx[];
int AlignBaumWelch::aemissionIdx[];

const extern string _AlignWithBandingstateId[];
const extern string _AlignWithBandingemissionId[];
const extern string _AlignWithBandingtransitionId[];
const extern string _AlignWithBandingtransF[];
const extern string _AlignWithBandingtransT[];
const extern string _AlignWithBandingtransP[];
const extern string _AlignWithBandingtransE[];
const extern string _AlignWithBandingoutputId[];
const extern string _AlignWithBandingempty;
const extern int _AlignWithBandingstateNum;
const extern int _AlignWithBandingemitNum;
const extern int _AlignWithBandingtransNum;
const extern int _AlignWithBandingoutputNum;

AlignWithBandingDPTable::AlignWithBandingDPTable(int iLen1,int iLen2) : isInCharge(true), stateId(_AlignWithBandingstateId), emissionId(_AlignWithBandingemissionId), transitionId(_AlignWithBandingtransitionId), transitionFrom(_AlignWithBandingtransF), transitionTo(_AlignWithBandingtransT), transitionProb(_AlignWithBandingtransP), transitionEmit(_AlignWithBandingtransE), outputId(_AlignWithBandingoutputId) {
    // init code:
    this->iLen1 = iLen1;
    this->iLen2 = iLen2;
    StateMemoryblock2withbanding.allocate(1+iLen1, 1+iLen2);
    StateMemoryblock1.allocate();
    StateMemoryblock3.allocate();
}


AlignWithBandingDPTable::~AlignWithBandingDPTable() {
    if (!isInCharge) {
        // make sure data does not get deleted:
        StateMemoryblock2withbanding.absolve();
        StateMemoryblock1.absolve();
        StateMemoryblock3.absolve();
    } // if(!isInCharge)
} // destructor

const string& AlignWithBandingDPTable::getTransitionId(int id) { return id>=0 && id<_AlignWithBandingtransNum ? _AlignWithBandingtransitionId[id] : _AlignWithBandingempty; }
const string& AlignWithBandingDPTable::getEmissionId(int id) { return id>=0 && id<_AlignWithBandingemitNum ? _AlignWithBandingemissionId[id] : _AlignWithBandingempty; }
const string& AlignWithBandingDPTable::getStateId(int id) { return id>=0 && id<_AlignWithBandingstateNum ? _AlignWithBandingstateId[id] : _AlignWithBandingempty; }
const string& AlignWithBandingDPTable::getOutputId(int id) { return id>=0 && id<_AlignWithBandingoutputNum ? _AlignWithBandingoutputId[id] : _AlignWithBandingempty; }
int AlignWithBandingDPTable::getId(const string& sId)
{
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
        pmId = new map<string,int>();
        for (int i=0;i<_AlignWithBandingstateNum;i++) {
            (*pmId)[_AlignWithBandingstateId[i]] = i;         // add state identifiers
        }
        for (int i=0; i<_AlignWithBandingemitNum; i++) {
            (*pmId)[_AlignWithBandingemissionId[i]] = i;      // add emission identifiers
        }
        for (int i=0; i<_AlignWithBandingtransNum; i++) {  
            (*pmId)[_AlignWithBandingtransitionId[i]] = i;    // add transition identifiers
        }
        for (int i=0; i<_AlignWithBandingoutputNum; i++) {
            (*pmId)[_AlignWithBandingoutputId[i]] = i;        // finally, add output identifiers
        }
        bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
        if (sId == "_cleanup_") {
            delete pmId;
            } else {
            cout << "AlignWithBandingDPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
        }
        return -1;
    }
    return iter->second;
}


bfloat AlignWithBandingDPTable::getProb(const string sState ,int iPos0,int iPos1) const
{
    return getProb(getId(sState) ,iPos0,iPos1);
}


bfloat AlignWithBandingDPTable::getProb(int iState ,int iPos0,int iPos1) const
{
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock2withbandingSecondary;
    const bfloat *CurStateMemoryblock3Secondary;
    static const int blockTable[] = {0, 1, 1, 1, 2};
    static const int stateTable[] = {0, 0, 1, 2, 0};
    switch (blockTable[iState]) {
        default:
        return 0.0;
        break;
        case 0:
        if ((iPos0+0>=0)&&(iPos0+0<=0)&&(iPos1+0>=0)&&(iPos1+0<=0)) {
            CurStateMemoryblock1Secondary = this->StateMemoryblock1.read();
            return CurStateMemoryblock1Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 1:
        if ((iPos0+0>=0)&&(iPos0+0<=iLen1+0)&&(iPos1+0>=0)&&(iPos1+0<=iLen2+0)) {
            CurStateMemoryblock2withbandingSecondary = this->StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(0))-(0));
            return CurStateMemoryblock2withbandingSecondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 2:
        if ((iPos0+0>=iLen1+0)&&(iPos0+0<=iLen1+0)&&(iPos1+0>=iLen2+0)&&(iPos1+0<=iLen2+0)) {
            CurStateMemoryblock3Secondary = this->StateMemoryblock3.read();
            return CurStateMemoryblock3Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
    } // switch
} // DPTable...::getProb(int,...)

const extern string _AlignWithBandingstateId[];
const extern string _AlignWithBandingemissionId[];
const extern string _AlignWithBandingtransitionId[];
const extern string _AlignWithBandingtransF[];
const extern string _AlignWithBandingtransT[];
const extern string _AlignWithBandingtransP[];
const extern string _AlignWithBandingtransE[];
const extern string _AlignWithBandingoutputId[];
const extern string _AlignWithBandingempty;
const extern int _AlignWithBandingstateNum;
const extern int _AlignWithBandingemitNum;
const extern int _AlignWithBandingtransNum;
const extern int _AlignWithBandingoutputNum;

AlignWithBandingFoldedDPTable::AlignWithBandingFoldedDPTable(int iLen1,int iLen2) : isInCharge(true), stateId(_AlignWithBandingstateId), emissionId(_AlignWithBandingemissionId), transitionId(_AlignWithBandingtransitionId), transitionFrom(_AlignWithBandingtransF), transitionTo(_AlignWithBandingtransT), transitionProb(_AlignWithBandingtransP), transitionEmit(_AlignWithBandingtransE), outputId(_AlignWithBandingoutputId) {
    // init code:
    this->iLen1 = iLen1;
    this->iLen2 = iLen2;
    StateMemoryblock2withbanding.allocate(1+iLen1, 1+iLen2);
    StateMemoryblock3.allocate();
    StateMemoryblock1.allocate();
}


AlignWithBandingFoldedDPTable::~AlignWithBandingFoldedDPTable() {
    if (!isInCharge) {
        // make sure data does not get deleted:
        StateMemoryblock2withbanding.absolve();
        StateMemoryblock3.absolve();
        StateMemoryblock1.absolve();
    } // if(!isInCharge)
} // destructor

const string& AlignWithBandingFoldedDPTable::getTransitionId(int id) { return id>=0 && id<_AlignWithBandingtransNum ? _AlignWithBandingtransitionId[id] : _AlignWithBandingempty; }
const string& AlignWithBandingFoldedDPTable::getEmissionId(int id) { return id>=0 && id<_AlignWithBandingemitNum ? _AlignWithBandingemissionId[id] : _AlignWithBandingempty; }
const string& AlignWithBandingFoldedDPTable::getStateId(int id) { return id>=0 && id<_AlignWithBandingstateNum ? _AlignWithBandingstateId[id] : _AlignWithBandingempty; }
const string& AlignWithBandingFoldedDPTable::getOutputId(int id) { return id>=0 && id<_AlignWithBandingoutputNum ? _AlignWithBandingoutputId[id] : _AlignWithBandingempty; }
int AlignWithBandingFoldedDPTable::getId(const string& sId)
{
    static bool bInit = false;
    static map<string,int>* pmId;
    if (!bInit) {
        pmId = new map<string,int>();
        for (int i=0;i<_AlignWithBandingstateNum;i++) {
            (*pmId)[_AlignWithBandingstateId[i]] = i;         // add state identifiers
        }
        for (int i=0; i<_AlignWithBandingemitNum; i++) {
            (*pmId)[_AlignWithBandingemissionId[i]] = i;      // add emission identifiers
        }
        for (int i=0; i<_AlignWithBandingtransNum; i++) {  
            (*pmId)[_AlignWithBandingtransitionId[i]] = i;    // add transition identifiers
        }
        for (int i=0; i<_AlignWithBandingoutputNum; i++) {
            (*pmId)[_AlignWithBandingoutputId[i]] = i;        // finally, add output identifiers
        }
        bInit = true;
    }
    map<string,int>::iterator iter = pmId->find(sId);
    if (iter == pmId->end()) {
        if (sId == "_cleanup_") {
            delete pmId;
            } else {
            cout << "AlignWithBandingFoldedDPTable::getId: WARNING: identifier '" << sId << "' not found." << endl;
        }
        return -1;
    }
    return iter->second;
}


bfloat AlignWithBandingFoldedDPTable::getProb(const string sState ,int iPos0,int iPos1) const
{
    return getProb(getId(sState) ,iPos0,iPos1);
}


bfloat AlignWithBandingFoldedDPTable::getProb(int iState ,int iPos0,int iPos1) const
{
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock2withbandingSecondary;
    const bfloat *CurStateMemoryblock3Secondary;
    static const int blockTable[] = {0, 1, 1, 1, 2};
    static const int stateTable[] = {0, 0, 1, 2, 0};
    switch (blockTable[iState]) {
        default:
        return 0.0;
        break;
        case 0:
        if ((iPos0+0>=0)&&(iPos0+0<=0)&&(iPos1+0>=0)&&(iPos1+0<=0)) {
            CurStateMemoryblock1Secondary = this->StateMemoryblock1.read();
            return CurStateMemoryblock1Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 1:
        if ((iPos0+0>=0)&&(iPos0+0<=iLen1+0)&&(iPos1+0>=0)&&(iPos1+0<=iLen2+0)) {
            CurStateMemoryblock2withbandingSecondary = this->StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(0))-(0));
            return CurStateMemoryblock2withbandingSecondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
        break;
        case 2:
        if ((iPos0+0>=iLen1+0)&&(iPos0+0<=iLen1+0)&&(iPos1+0>=iLen2+0)&&(iPos1+0<=iLen2+0)) {
            CurStateMemoryblock3Secondary = this->StateMemoryblock3.read();
            return CurStateMemoryblock3Secondary[stateTable[iState]];
        } 
        else { 
            return 0.0;
            
        }
    } // switch
} // DPTable...::getProb(int,...)

int AlignWithBandingBaumWelch::transitionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "AlignWithBandingBaumWelch::transitionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


int AlignWithBandingBaumWelch::emissionIndex(string strId) const {
    map<const string,int>::const_iterator iter = mId.find(strId);
    if (iter == mId.end()) {
        cout << "AlignWithBandingBaumWelch::emissionIndex: WARNING: identifier '" << strId << "' not found." << endl;
        return -1;
    }
    return iter->second;
}


void AlignWithBandingBaumWelch::resetCounts() {
    static bool bInited = false;
    if (!bInited) {
        static const int aTemp[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        for (int i=0; i<16; i++) {
            transitionIdentifier00[i] = aTemp[i];
            atransitionIdx[aTemp[i]] = i;
            mId[_AlignWithBandingtransitionId[aTemp[i]]] = i;
        }
    }
    for (int i=0; i<16; i++) {
        
        transitionBaumWelchCount00[i] = 0.0;
    }
    bInited = true;
};


int AlignWithBandingBaumWelch::transitionIdentifier00[];

void AlignWithBandingBaumWelch::scaleCounts(bfloat scale) {
    for (int i=0; i<16; i++) {
        
        transitionBaumWelchCount00[i] *= scale;
    }
}


map<const string,int> AlignWithBandingBaumWelch::mId;
int AlignWithBandingBaumWelch::atransitionIdx[];
int AlignWithBandingBaumWelch::aemissionIdx[];

bfloat hmmocMax(bfloat i, bfloat j) { return i>j ? i : j; }
void hmmocMaxInPlace(bfloat& i, bfloat j) { if (i<j) i=j; }
ostream& operator<<(ostream& os, const Path& p)
{
    for (unsigned int i=0; i<p.size(); i++) {
        os << p.fromState(i) << "--{";
            for (unsigned int j=0; j<p.emission(i).size(); j++) {
                if (j) os<<",";
                os<<p.emission(i)[j];
            }
        os<<"};"<<p.prob(i)<<"-->"<<p.toState(i)<<endl;
    }
    return os;
}

void SimplePath::addEdge(int tr, double p, vector<int>& e, int f, int t) {
    transitions.push_back(tr);
    probs.push_back(p);
    emissions.push_back(e);
    froms.push_back(f);
    tos.push_back(t);
}

void SimplePath::reverse() 
{
    std::reverse(transitions.begin(),transitions.end());
    std::reverse(probs.begin(),probs.end());
    std::reverse(emissions.begin(),emissions.end());
    std::reverse(froms.begin(),froms.end());
    std::reverse(tos.begin(),tos.end());
}

double SimplePath::prob(int i) const {
    return probs[i];
}

int SimplePath::nextFrom(int i) const {
    if (i+1 < (int)transitions.size())
    return i+1;
    else
    return -1;
}

int SimplePath::nextTo(int i) const {
    return -1;
}

const vector<int>& SimplePath::emission(int i) const {
    return emissions[i];
}

int SimplePath::fromState(int i) const {
    return froms[i];
}

int SimplePath::toState(int i) const {
    return tos[i];
}

const string _AlignstateId[] = {"start","insert","match","delete","end"};
const string _AlignemissionId[] = {"emit2","emit12","emit1","empty"};
const string _AligntransitionId[] = {"trSE","trSM","trSI","trSD","trMM","trMI","trMD","trME","trIM","trII","trID","trIE","trDM","trDI","trDD","trDE"};
const string _AligntransF[] = {"start","start","start","start","match","match","match","match","insert","insert","insert","insert","delete","delete","delete","delete"};
const string _AligntransT[] = {"end","match","insert","delete","match","insert","delete","end","match","insert","delete","end","match","insert","delete","end"};
const string _AligntransP[] = {"probSE","probSM","probSI","probSD","probMM","probMI","probMD","probME","probIM","probII","probID","probIE","probDM","probDI","probDD","probDE"};
const string _AligntransE[] = {"empty","emit12","emit1","emit2","emit12","emit1","emit2","empty","emit12","emit1","emit2","empty","emit12","emit1","emit2","empty"};
const string _AlignoutputId[] = {"sequence1","sequence2"};
const string _Alignempty = "";
const int _AlignstateNum = 5;
const int _AlignemitNum = 4;
const int _AligntransNum = 16;
const int _AlignoutputNum = 2;




bfloat Forward(AlignDPTable** ppOutTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2) {
    bfloat iTransition[16];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock1From;
    const bfloat *CurStateMemoryblock2From;
    bfloat *CurStateMemoryblock3To;
    const bfloat *CurStateMemoryblock3From;
    int iPrevSlowCoord;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    AlignDPTable dp(iLen1,iLen2);
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    dp.StateMemoryblock1.write()[0] = 1.0;
    dp.StateMemoryblock1.written();
    iPrevSlowCoord = -1;
    for (int iPos1=0; iPos1<iLen2+1; ++iPos1) {
        for (int iPos0=0; iPos0<iLen1+1; ++iPos0) {
            if ((iPos0+0<=0)&&(iPos1+0<=0)) {
            }
            if (1) {
                if ((iPos0+-1>=0)) {
                    iSymbol[0] = iSequence1[iPos0+-1];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+-1>=0)) {
                    iSymbol[1] = iSequence2[iPos1+-1];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(0), (iPos1-(0))-(0));
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+-1>=0)&&(iPos0+-1<=0)&&(iPos1+-1>=0)&&(iPos1+-1<=0)) {
                    CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                    CurStateMemoryblock2To[1] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock1From[0];
                }
                if ((iPos0+-1>=0)&&(iPos1+-1>=0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(1))-(0), (iPos1-(1))-(0));
                    CurStateMemoryblock2To[1] += ((iTransition[12])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    CurStateMemoryblock2To[1] += ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    CurStateMemoryblock2To[1] += ((iTransition[8])*(iEmission[0]))*CurStateMemoryblock2From[0];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+0<=0)&&(iPos1+-1>=0)&&(iPos1+-1<=0)) {
                    CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                    CurStateMemoryblock2To[2] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock1From[0];
                }
                if ((iPos1+-1>=0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(1))-(0));
                    CurStateMemoryblock2To[2] += ((iTransition[14])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    CurStateMemoryblock2To[2] += ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    CurStateMemoryblock2To[2] += ((iTransition[10])*(iEmission[0]))*CurStateMemoryblock2From[0];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+-1>=0)&&(iPos0+-1<=0)&&(iPos1+0<=0)) {
                    CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                    CurStateMemoryblock2To[0] = ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock1From[0];
                }
                if ((iPos0+-1>=0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(1))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock2To[0] += ((iTransition[13])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    CurStateMemoryblock2To[0] += ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    CurStateMemoryblock2To[0] += ((iTransition[9])*(iEmission[0]))*CurStateMemoryblock2From[0];
                }
                dp.StateMemoryblock2.written();
            }
            if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                CurStateMemoryblock3To = dp.StateMemoryblock3.write();
                iEmission[0] = 1.0;
                if (1) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock3To[0] = ((iTransition[15])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    CurStateMemoryblock3To[0] += ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    CurStateMemoryblock3To[0] += ((iTransition[11])*(iEmission[0]))*CurStateMemoryblock2From[0];
                }
                if ((iPos0+0<=0)&&(iPos1+0<=0)) {
                    CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                    CurStateMemoryblock3To[0] += ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock1From[0];
                }
                dp.StateMemoryblock3.written();
            }
            iPrevSlowCoord = iPos1;
        }
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=iLen2+0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=iLen1+0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock3From = dp.StateMemoryblock3.read();
            iTempProb[0] = CurStateMemoryblock3From[0];
        }
    }
    *ppOutTable = new AlignDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





bfloat BackwardBaumWelch(AlignBaumWelch& bw,AlignDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2) {
    const bfloat *CurStateMemoryblock3Secondary;
    bfloat iTransition[16];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2Secondary;
    const bfloat *CurStateMemoryblock2From;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[3];
    AlignFoldedDPTable dp(iLen1,2);
    AlignDPTable dp2(*pInTable);
    // make sure tables don't get deleted
    dp2.isInCharge = false;
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    {
        int iPos1=iLen2+0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=iLen1+0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock3Secondary = dp2.StateMemoryblock3.read();
            iTempProb[2] = CurStateMemoryblock3Secondary[0];
            bw.scaleCounts(iTempProb[2]);
        }
    }
    iPrevSlowCoord = -1;
    for (int iPos1=(iLen2+1)-1; iPos1>=0; --iPos1) {
        for (int iPos0=(iLen1+1)-1; iPos0>=0; --iPos0) {
            if (iPrevSlowCoord != -1 && iPrevSlowCoord != iPos1) {
                dp.StateMemoryblock2.clear(iPos1);
            }
            if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
            }
            if (1) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(0), (iPos1-(0))-(0));
                CurStateMemoryblock2Secondary = dp2.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(0))-(0));
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock2To[2] = iTempProb[1] = ((iTransition[12])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    bw.transitionBaumWelchCount00[12] += iTempProb[1] * CurStateMemoryblock2Secondary[2];
                    CurStateMemoryblock2To[1] = iTempProb[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    bw.transitionBaumWelchCount00[4] += iTempProb[1] * CurStateMemoryblock2Secondary[1];
                    CurStateMemoryblock2To[0] = iTempProb[1] = ((iTransition[8])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    bw.transitionBaumWelchCount00[8] += iTempProb[1] * CurStateMemoryblock2Secondary[0];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock2To[2] += iTempProb[1] = ((iTransition[14])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    bw.transitionBaumWelchCount00[14] += iTempProb[1] * CurStateMemoryblock2Secondary[2];
                    CurStateMemoryblock2To[1] += iTempProb[1] = ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    bw.transitionBaumWelchCount00[6] += iTempProb[1] * CurStateMemoryblock2Secondary[1];
                    CurStateMemoryblock2To[0] += iTempProb[1] = ((iTransition[10])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    bw.transitionBaumWelchCount00[10] += iTempProb[1] * CurStateMemoryblock2Secondary[0];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock2To[2] += iTempProb[1] = ((iTransition[13])*(iEmission[0]))*CurStateMemoryblock2From[0];
                    bw.transitionBaumWelchCount00[13] += iTempProb[1] * CurStateMemoryblock2Secondary[2];
                    CurStateMemoryblock2To[1] += iTempProb[1] = ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2From[0];
                    bw.transitionBaumWelchCount00[5] += iTempProb[1] * CurStateMemoryblock2Secondary[1];
                    CurStateMemoryblock2To[0] += iTempProb[1] = ((iTransition[9])*(iEmission[0]))*CurStateMemoryblock2From[0];
                    bw.transitionBaumWelchCount00[9] += iTempProb[1] * CurStateMemoryblock2Secondary[0];
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    CurStateMemoryblock2To[2] += iTempProb[1] = ((iTransition[15])*(iEmission[0]))*CurStateMemoryblock3From[0];
                    bw.transitionBaumWelchCount00[15] += iTempProb[1] * CurStateMemoryblock2Secondary[2];
                    CurStateMemoryblock2To[1] += iTempProb[1] = ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock3From[0];
                    bw.transitionBaumWelchCount00[7] += iTempProb[1] * CurStateMemoryblock2Secondary[1];
                    CurStateMemoryblock2To[0] += iTempProb[1] = ((iTransition[11])*(iEmission[0]))*CurStateMemoryblock3From[0];
                    bw.transitionBaumWelchCount00[11] += iTempProb[1] * CurStateMemoryblock2Secondary[0];
                }
                dp.StateMemoryblock2.written();
            }
            if ((iPos0+0<=0)&&(iPos1+0<=0)) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.write();
                CurStateMemoryblock1Secondary = dp2.StateMemoryblock1.read();
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] = iTempProb[1] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    bw.transitionBaumWelchCount00[1] += iTempProb[1] * CurStateMemoryblock1Secondary[0];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] += iTempProb[1] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    bw.transitionBaumWelchCount00[3] += iTempProb[1] * CurStateMemoryblock1Secondary[0];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock1To[0] += iTempProb[1] = ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock2From[0];
                    bw.transitionBaumWelchCount00[2] += iTempProb[1] * CurStateMemoryblock1Secondary[0];
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    CurStateMemoryblock1To[0] += iTempProb[1] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock3From[0];
                    bw.transitionBaumWelchCount00[0] += iTempProb[1] * CurStateMemoryblock1Secondary[0];
                }
                dp.StateMemoryblock1.written();
            }
            iPrevSlowCoord = iPos1;
        }
    }
    bw.scaleCounts(1.0 / iTempProb[2]);
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock1From = dp.StateMemoryblock1.read();
            iTempProb[0] = CurStateMemoryblock1From[0];
        }
    }
    return iTempProb[0];
};



//-- Heejung start --//
bfloat Backward(AlignDPTable** ppOutTable,double iDelta,double iR,double iTau, vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2) {
    bfloat iTransition[16];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2From;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    

    //-- Heejung start --//
    //for (int i=0; i<4; i++) {
    //    iEquilibriumDistribution[i] = 1/4.0;
    //    for (int j=0; j<4; j++) {
    //        if (i==j) {
    //            iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
    //            } else {
    //            iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
    //        }
    //    }
    //}
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = pi[i];
        for (int j=0; j<4; j++)
	  iSubstitutionMatrix[i][j] = Pt[i][j];
    }
    //-- Heejung end --//
    /* Initialisation of the iT transition-probability array */
    

    double iT[16];
    //-- Heejung start --//
    /*
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    */
    iT[0] = 1.0 - 2*iDelta;         // MM  (Match-to-Match)
    iT[1] = iDelta;                 // MI  (Match-to-Insert)
    iT[2] = iDelta;                 // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR + (1.0-iR)*iDelta;      // II
    iT[5] = (1.0 - iR)*(1 - 2*iDelta); // IM
    iT[6] = (1.0 - iR)*iDelta;      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR + (1.0-iR)*iDelta;   // DD
    iT[9] = (1.0 - iR)*(1 - 2*iDelta); // DM
    iT[10]= (1.0 - iR)*iDelta;      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - 2*iDelta;         // SM  (Start-to-Match)
    iT[13]= iDelta;                 // SI 
    iT[14]= iDelta;                 // SD
    iT[15]= iTau;                      // SE
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    AlignDPTable dp(iLen1,iLen2);
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    for (int iPos1=(iLen2+1)-1; iPos1>=0; --iPos1) {
        for (int iPos0=(iLen1+1)-1; iPos0>=0; --iPos0) {
            if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
            }
            if (1) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(0), (iPos1-(0))-(0));
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock2To[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    CurStateMemoryblock2To[2] = ((iTransition[12])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    CurStateMemoryblock2To[0] = ((iTransition[8])*(iEmission[0]))*CurStateMemoryblock2From[1];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock2To[1] += ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    CurStateMemoryblock2To[2] += ((iTransition[14])*(iEmission[0]))*CurStateMemoryblock2From[2];
                    CurStateMemoryblock2To[0] += ((iTransition[10])*(iEmission[0]))*CurStateMemoryblock2From[2];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock2To[1] += ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2From[0];
                    CurStateMemoryblock2To[2] += ((iTransition[13])*(iEmission[0]))*CurStateMemoryblock2From[0];
                    CurStateMemoryblock2To[0] += ((iTransition[9])*(iEmission[0]))*CurStateMemoryblock2From[0];
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    CurStateMemoryblock2To[1] += ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock3From[0];
                    CurStateMemoryblock2To[2] += ((iTransition[15])*(iEmission[0]))*CurStateMemoryblock3From[0];
                    CurStateMemoryblock2To[0] += ((iTransition[11])*(iEmission[0]))*CurStateMemoryblock3From[0];
                }
                dp.StateMemoryblock2.written();
            }
            if ((iPos0+0<=0)&&(iPos1+0<=0)) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.write();
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[1];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] += ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2From[2];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock1To[0] += ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock2From[0];
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    CurStateMemoryblock1To[0] += ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock3From[0];
                }
                dp.StateMemoryblock1.written();
            }
            iPrevSlowCoord = iPos1;
        }
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock1From = dp.StateMemoryblock1.read();
            iTempProb[0] = CurStateMemoryblock1From[0];
        }
    }
    *ppOutTable = new AlignDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};




//-- Heejung Shim --//
double Sample(AlignDPTable* pInTable,double iDelta,double iR, double iTau, vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2, vector<vector<int> >& HMG) {

  //-- Heejung start --//
  double prob = 0;
  bfloat probT = 0;
  HMG.resize(0);
  //-- Heejung end --//
    bfloat iTransition[16];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    //SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    //-- Heejung start --//
    /*
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    */
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = pi[i];
        for (int j=0; j<4; j++)
	  iSubstitutionMatrix[i][j] = Pt[i][j];
    }
    /* Initialisation of the iT transition-probability array */
   
    //cout << "iDelta : " << iDelta << endl;
    //cout << "iTau : " << iTau << endl;
    //cout << "iR : " << iR << endl;
    double iT[16];
    /*
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    */
    iT[0] = 1.0 - 2*iDelta;         // MM  (Match-to-Match)
    iT[1] = iDelta;                 // MI  (Match-to-Insert)
    iT[2] = iDelta;                 // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR + (1.0-iR)*iDelta;      // II
    iT[5] = (1.0 - iR)*(1 - 2*iDelta); // IM
    iT[6] = (1.0 - iR)*iDelta;      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR + (1.0-iR)*iDelta;   // DD
    iT[9] = (1.0 - iR)*(1 - 2*iDelta); // DM
    iT[10]= (1.0 - iR)*iDelta;      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - 2*iDelta;         // SM  (Start-to-Match)
    iT[13]= iDelta;                 // SI 
    iT[14]= iDelta;                 // SD
    iT[15]= iTau;                      // SE

    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary vector storage */
    bfloat iTempVector[11];
    /* temporary int vector storage */
    int iTempIntVec[7];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    static const int stateTable[] = {4, 2, 1, 3, 2, 1, 3, 4, 2, 1, 3, 4, 2, 1, 3, 4};
    static const int stateFromTable[] = {0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 3, 3, 3, 3};
    static const int iPos0Table[] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0};
    static const int iPos1Table[] = {0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    AlignDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            iTempIntVec[0] = 0;
            while (iTempIntVec[0] != 4) {

	      //cout << "Heejung " << endl;
                iTempIntVec[1] = 2;
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.read();
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(0))-(0));
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {

		  //cout << "case1 " << endl;
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[4]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 4;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[12]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[12]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 12;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[1]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 1;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[8]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[8]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 8;
                        break;
                    }
                }
                if ((iPos1+1<=iLen2+0)) {
		  //cout << "case2 " << endl;
		  
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[6]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 6;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[14]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[14]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 14;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[3]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 3;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[10]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[10]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 10;
                        break;
                    }
                }
                if ((iPos0+1<=iLen1+0)) {
		  //cout << "case3 " << endl;
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[5]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 5;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[13]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[13]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 13;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[2]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 2;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[9]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[9]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 9;
                        break;
                    }
                }
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
		  //cout << "case4 " << endl;
                    iEmission[0] = 1.0;
                    CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[7]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[7]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 7;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[15]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[15]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 15;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[0]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 0;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[11]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[11]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 11;
                        break;
                    }
                }
                iTempVector[0] = iTempVector[1] = 0.0;
		//cout << "iTempIntVec[1] " << iTempIntVec[1] << endl;
                for (int i=2; i<iTempIntVec[1]; i++) {
                    iTempVector[0] += iTempVector[i];
		    //cout << "iTempVector[i] : " << iTempVector[i] << " iTempVector[0] : " << iTempVector[0] << endl;
                }
		//-- Heejung start --//
		//cout << "iTempVector[0] : " << iTempVector[0] << endl;
		probT = (double)1/iTempVector[0];
		//cout << "probT : " << probT << endl;
		//-- Heejung end --//
		
		//double fact = (random() / (double)RAND_MAX);
		//double fact = random();
		//cout << "fact : " << fact << endl;
		//fact /= (double)RAND_MAX;
		//cout << "fact : " << fact << endl;
		//cout << "(double)RAND_MAX) : " << (double)RAND_MAX << endl;
                iTempVector[0] *= (random() / (double)RAND_MAX);
		//iTempVector[0] *= fact;
		//cout << "iTempVector[0] : " << iTempVector[0] << endl;
                iTempIntVec[0] = 1;
                while (iTempVector[0]>=iTempVector[1] && ++iTempIntVec[0]<iTempIntVec[1]) {
                    iTempVector[1] += iTempVector[iTempIntVec[0]];
                } 
		//if (iTempIntVec[0]==iTempIntVec[1]) {
                //    cerr << "Error in sampler -- zero probabilities?" << endl;
                //    exit(1);
                //}

		if (iTempIntVec[0]==iTempIntVec[1]) {
		  iTempIntVec[0]--;
                }

		//-- Heejung start --//
		//cout << "iTempIntVec[0] " << iTempIntVec[0] << endl;
		//cout << "iTempVector[iTempIntVec[0]] " << iTempVector[iTempIntVec[0]] << endl;
		probT *= iTempVector[iTempIntVec[0]];
		//cout << "probT : " << probT << endl;
		prob += log(probT);
	       //-- Heejung end --//
                emit.resize(2);
                emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
                emit[1] = iPos1Table[iTempIntVec[iTempIntVec[0]]];
		//cout << "AA" << endl;
		//cout << "iTempIntVec[0] : " << iTempIntVec[0] << endl;
		//cout << "iTempIntVec[iTempIntVec[0]] : " << iTempIntVec[iTempIntVec[0]] << endl;
		//cout << "iTempVector[iTempIntVec[0]+4] : " << iTempVector[iTempIntVec[0]+4] << endl;
		//cout << "emit : " << emit[0]  << " " << emit[1] << endl;
		//cout << "stateFromTable[iTempIntVec[iTempIntVec[0]]] : " << stateFromTable[iTempIntVec[iTempIntVec[0]]] << endl;
		//cout << "stateTable[iTempIntVec[iTempIntVec[0]]] : " << stateTable[iTempIntVec[iTempIntVec[0]]] << endl;

		HMG.push_back(emit);
                iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
                iPos1 += iPos1Table[iTempIntVec[iTempIntVec[0]]];
                iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
            }
        }
    }
    return prob;
};




//-- Heejung change name--//
double CalProbSample(AlignDPTable* pInTable,double iDelta,double iR,double iTau,vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2, vector<vector<int > >& HMG) {


  
    bfloat iTransition[16];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    //-- Heejung start --//
    double prob = 0;
    bfloat probT = 0;
    int IX = 0;
    //-- Heejung end --//
    vector<int> emit;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;

    //-- Heejung start --//
    /*
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    */
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = pi[i];
        for (int j=0; j<4; j++)
	  iSubstitutionMatrix[i][j] = Pt[i][j];
    }

    /* Initialisation of the iT transition-probability array */
   
    //cout << "iDelta : " << iDelta << endl;
    //cout << "iTau : " << iTau << endl;
    //cout << "iR : " << iR << endl;
    //cout << "iSigma : " << iSigma << endl;
    double iT[16];
    /*
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    */
    iT[0] = 1.0 - 2*iDelta;         // MM  (Match-to-Match)
    iT[1] = iDelta;                 // MI  (Match-to-Insert)
    iT[2] = iDelta;                 // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR + (1.0-iR)*iDelta;      // II
    iT[5] = (1.0 - iR)*(1 - 2*iDelta); // IM
    iT[6] = (1.0 - iR)*iDelta;      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR + (1.0-iR)*iDelta;   // DD
    iT[9] = (1.0 - iR)*(1 - 2*iDelta); // DM
    iT[10]= (1.0 - iR)*iDelta;      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - 2*iDelta;         // SM  (Start-to-Match)
    iT[13]= iDelta;                 // SI 
    iT[14]= iDelta;                 // SD
    iT[15]= iTau;                      // SE
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary vector storage */
    bfloat iTempVector[11];
    /* temporary int vector storage */
    int iTempIntVec[7];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    static const int stateTable[] = {4, 2, 1, 3, 2, 1, 3, 4, 2, 1, 3, 4, 2, 1, 3, 4};
    //static const int stateFromTable[] = {0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 3, 3, 3, 3};
    static const int iPos0Table[] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0};
    static const int iPos1Table[] = {0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    AlignDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            iTempIntVec[0] = 0;
            while (iTempIntVec[0] != 4) {

                iTempIntVec[1] = 2;
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.read();
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(0))-(0));
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {

		  //cout << "case1 " << endl;
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[4]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 4;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[12]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[12]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 12;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[1]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 1;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[8]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[8]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 8;
                        break;
                    }
                }
                if ((iPos1+1<=iLen2+0)) {
		  //cout << "case2 " << endl;
		  
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[6]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 6;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[14]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[14]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 14;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[3]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 3;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[10]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[10]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 10;
                        break;
                    }
                }
                if ((iPos0+1<=iLen1+0)) {
		  //cout << "case3 " << endl;
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[5]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 5;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[13]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[13]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 13;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[2]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 2;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[9]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[9]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 9;
                        break;
                    }
                }
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
		  //cout << "case4 " << endl;
                    iEmission[0] = 1.0;
                    CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[7]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[7]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 7;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[15]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[15]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 15;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[0]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 0;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[11]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[11]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 11;
                        break;
                    }
                }
                iTempVector[0] = iTempVector[1] = 0.0;
		//cout << "iTempIntVec[1] " << iTempIntVec[1] << endl;
                for (int i=2; i<iTempIntVec[1]; i++) {
                    iTempVector[0] += iTempVector[i];
		    //cout << "iTempVector[i] : " << iTempVector[i] << " iTempVector[0] : " << iTempVector[0] << endl;
                }
		//cout << "iTempVector[0] : " << iTempVector[0] << endl;

		// Let's find which index....
		probT = 0;
		//bool hit = false;
		for (int i=2; i<iTempIntVec[1]; i++) {
		  if((HMG[IX][0] == iPos0Table[iTempIntVec[i]]) & (HMG[IX][1] == iPos1Table[iTempIntVec[i]])){
		    probT = iTempVector[i];
		    iTempIntVec[0] = i;
		    IX++;
		    //hit = true;
		    break;
                  }
                }
		if(probT == 0.0){
		  cout << "ERROR in CalProbSampling" << endl;
		  //cout << "HMG[IX-1][0] : " << HMG[IX-1][0] << " HMG[IX-1][1] : " << HMG[IX-1][1] << endl;
		  //cout << "IX : " << IX << endl;
		  //for (int i=2; i<iTempIntVec[1]; i++) {
		  //  cout << "i " << i << endl;
		  //  cout << "iPos0Table[iTempIntVec[i]] : " << iPos0Table[iTempIntVec[i]] << " iPos1Table[iTempIntVec[i]] : " << iPos1Table[iTempIntVec[i]] << endl; 
                  //  cout << "iTempVector[i] : " << iTempVector[i] << endl;
		  //}
		  //cout << "iTempIntVec[0] : " << iTempIntVec[0] << endl;
                  //cout << "probT : " << probT << endl;
		  //cout << "probT/iTempVector[0] : " << probT/iTempVector[0] << endl;
		  //cout << "logProbT : " << log(probT) << endl;
		  //if(hit==false)
		  //  cout << "NO hit" << endl;

                }
		//cout << "probT : " << probT << endl;
		//cout << "iTempVector[0] " << iTempVector[0] << endl;
		probT /= iTempVector[0];
		//cout << "probT : " << probT << endl;
		//cout << "logprobT : " << log(probT) << endl;
		prob += log(probT);
		

		//-- Heejung end --//
                iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
                iPos1 += iPos1Table[iTempIntVec[iTempIntVec[0]]];
                iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
            }
        }
    }
    //-- Heejung start --//
    if(HMG.size()!=IX)
      cout << "ERROR HMG size should be zero!" << endl;
    return prob;
    //-- Heejung end --//
};



//--- Heejung start --//
double Viterbi_recurse(AlignDPTable** ppOutTable,double iDelta,double iR, double iTau, vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2) {
    bfloat iTransition[16];
    bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock2From;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    //-- Heejung start --//
    //for (int i=0; i<4; i++) {
    //    iEquilibriumDistribution[i] = 1/4.0;
    //    for (int j=0; j<4; j++) {
    //        if (i==j) {
    //            iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
    //            } else {
    //            iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
    //        }
    //    }
    //}
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = pi[i];
        for (int j=0; j<4; j++)
	  iSubstitutionMatrix[i][j] = Pt[i][j];
    }
    //-- Heejung end --//


    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    //-- Heejung start --//
    /*
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    */
    iT[0] = 1.0 - 2*iDelta;         // MM  (Match-to-Match)
    iT[1] = iDelta;                 // MI  (Match-to-Insert)
    iT[2] = iDelta;                 // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR + (1.0-iR)*iDelta;      // II
    iT[5] = (1.0 - iR)*(1 - 2*iDelta); // IM
    iT[6] = (1.0 - iR)*iDelta;      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR + (1.0-iR)*iDelta;   // DD
    iT[9] = (1.0 - iR)*(1 - 2*iDelta); // DM
    iT[10]= (1.0 - iR)*iDelta;      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - 2*iDelta;         // SM  (Start-to-Match)
    iT[13]= iDelta;                 // SI 
    iT[14]= iDelta;                 // SD
    iT[15]= iTau;                      // SE
    //-- Heejung end --//


    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    AlignDPTable dp(iLen1,iLen2);
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    for (int iPos1=(iLen2+1)-1; iPos1>=0; --iPos1) {
        for (int iPos0=(iLen1+1)-1; iPos0>=0; --iPos0) {
            if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
            }
            if (1) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock2To = dp.StateMemoryblock2.write((iPos0-(0))-(0), (iPos1-(0))-(0));
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock2To[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    CurStateMemoryblock2To[0] = ((iTransition[8])*(iEmission[0]))*CurStateMemoryblock2From[1];
                    CurStateMemoryblock2To[2] = ((iTransition[12])*(iEmission[0]))*CurStateMemoryblock2From[1];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    hmmocMaxInPlace( CurStateMemoryblock2To[1], ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2From[2] );
                    hmmocMaxInPlace( CurStateMemoryblock2To[0], ((iTransition[10])*(iEmission[0]))*CurStateMemoryblock2From[2] );
                    hmmocMaxInPlace( CurStateMemoryblock2To[2], ((iTransition[14])*(iEmission[0]))*CurStateMemoryblock2From[2] );
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    hmmocMaxInPlace( CurStateMemoryblock2To[1], ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2From[0] );
                    hmmocMaxInPlace( CurStateMemoryblock2To[0], ((iTransition[9])*(iEmission[0]))*CurStateMemoryblock2From[0] );
                    hmmocMaxInPlace( CurStateMemoryblock2To[2], ((iTransition[13])*(iEmission[0]))*CurStateMemoryblock2From[0] );
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    hmmocMaxInPlace( CurStateMemoryblock2To[1], ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                    hmmocMaxInPlace( CurStateMemoryblock2To[0], ((iTransition[11])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                    hmmocMaxInPlace( CurStateMemoryblock2To[2], ((iTransition[15])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                }
                dp.StateMemoryblock2.written();
            }
            if ((iPos0+0<=0)&&(iPos1+0<=0)) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.write();
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2From[1];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    hmmocMaxInPlace( CurStateMemoryblock1To[0], ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2From[2] );
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2From = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    hmmocMaxInPlace( CurStateMemoryblock1To[0], ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock2From[0] );
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    hmmocMaxInPlace( CurStateMemoryblock1To[0], ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                }
                dp.StateMemoryblock1.written();
            }
            iPrevSlowCoord = iPos1;
        }
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock1From = dp.StateMemoryblock1.read();
            iTempProb[0] = CurStateMemoryblock1From[0];
        }
    }
    *ppOutTable = new AlignDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};
//-- Heejung end --//



//-- Heejung start --//
double Viterbi_trace(AlignDPTable* pInTable,double iDelta,double iR, double iTau, vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2, vector<vector<int> >& HMG) {

  //-- Heejung start --///
  HMG.resize(0);
  //-- Heejung end --//

    bfloat iTransition[16];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2To;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;


    //-- Heejung start --//
    /*
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    */
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = pi[i];
        for (int j=0; j<4; j++)
	  iSubstitutionMatrix[i][j] = Pt[i][j];
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    //-- Heejung start --//
    /*
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    */
    iT[0] = 1.0 - 2*iDelta;         // MM  (Match-to-Match)
    iT[1] = iDelta;                 // MI  (Match-to-Insert)
    iT[2] = iDelta;                 // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR + (1.0-iR)*iDelta;      // II
    iT[5] = (1.0 - iR)*(1 - 2*iDelta); // IM
    iT[6] = (1.0 - iR)*iDelta;      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR + (1.0-iR)*iDelta;   // DD
    iT[9] = (1.0 - iR)*(1 - 2*iDelta); // DM
    iT[10]= (1.0 - iR)*iDelta;      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - 2*iDelta;         // SM  (Start-to-Match)
    iT[13]= iDelta;                 // SI 
    iT[14]= iDelta;                 // SD
    iT[15]= iTau;                      // SE
    //-- Heejung end --//


    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary vector storage */
    bfloat iTempVector[11];
    /* temporary int vector storage */
    int iTempIntVec[7];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    static const int stateTable[] = {4, 2, 1, 3, 2, 1, 3, 4, 2, 1, 3, 4, 2, 1, 3, 4};
    static const int stateFromTable[] = {0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 3, 3, 3, 3};
    static const int iPos0Table[] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0};
    static const int iPos1Table[] = {0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    AlignDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            iTempIntVec[0] = 0;
            while (iTempIntVec[0] != 4) {
                iTempIntVec[1] = 2;
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.read();
                CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(0))-(0));
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[1]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 1;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[12]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[12]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 12;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[8]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[8]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 8;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*CurStateMemoryblock2To[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[4]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 4;
                        break;
                    }
                }
                if ((iPos1+1<=iLen2+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[3]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 3;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[14]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[14]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 14;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[10]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[10]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 10;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[0]*CurStateMemoryblock2To[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[6]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 6;
                        break;
                    }
                }
                if ((iPos0+1<=iLen1+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2To = dp.StateMemoryblock2.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[2]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 2;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[13]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[13]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 13;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[9]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[9]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 9;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*CurStateMemoryblock2To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[5]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 5;
                        break;
                    }
                }
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    iEmission[0] = 1.0;
                    CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[0]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 0;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[15]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[15]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 15;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[11]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[11]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 11;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[7]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[7]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 7;
                        break;
                    }
                }
                iTempVector[0] = 0.0;
                for (int i=2; i<iTempIntVec[1]; i++) {
                    if (iTempVector[i]>iTempVector[0]) {
                        iTempVector[0]=iTempVector[i];
                        iTempIntVec[0] = i;
                    }
                }
                emit.resize(2);
                emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
                emit[1] = iPos1Table[iTempIntVec[iTempIntVec[0]]];
		//-- Heejung start --//
		HMG.push_back(emit);
                //pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+4],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
		//-- Heejung end --//
                iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
                iPos1 += iPos1Table[iTempIntVec[iTempIntVec[0]]];
                iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
            }
        }
    }
    //-- Heejung start --//
    //return *pPath;
    return 0;
    //-- Heejung end --//
};
//-- Heejung end --//


const string _AlignWithBandingstateId[] = {"start","insert","match","delete","end"};
const string _AlignWithBandingemissionId[] = {"emit2","emit12","emit1","empty"};
const string _AlignWithBandingtransitionId[] = {"trSE","trSM","trSI","trSD","trMM","trMI","trMD","trME","trIM","trII","trID","trIE","trDM","trDI","trDD","trDE"};
const string _AlignWithBandingtransF[] = {"start","start","start","start","match","match","match","match","insert","insert","insert","insert","delete","delete","delete","delete"};
const string _AlignWithBandingtransT[] = {"end","match","insert","delete","match","insert","delete","end","match","insert","delete","end","match","insert","delete","end"};
const string _AlignWithBandingtransP[] = {"probSE","probSM","probSI","probSD","probMM","probMI","probMD","probME","probIM","probII","probID","probIE","probDM","probDI","probDD","probDE"};
const string _AlignWithBandingtransE[] = {"empty","emit12","emit1","emit2","emit12","emit1","emit2","empty","emit12","emit1","emit2","empty","emit12","emit1","emit2","empty"};
const string _AlignWithBandingoutputId[] = {"sequence1","sequence2"};
const string _AlignWithBandingempty = "";
const int _AlignWithBandingstateNum = 5;
const int _AlignWithBandingemitNum = 4;
const int _AlignWithBandingtransNum = 16;
const int _AlignWithBandingoutputNum = 2;




bfloat ForwardBanding(AlignWithBandingDPTable** ppOutTable,double iDelta,double iR,double iSigma,double iTau,int iWidth,vector<char>& iSequence1,vector<char>& iSequence2) {
    bfloat iTransition[16];
    bfloat *CurStateMemoryblock2withbandingTo;
    const bfloat *CurStateMemoryblock1From;
    const bfloat *CurStateMemoryblock2withbandingFrom;
    bfloat *CurStateMemoryblock3To;
    const bfloat *CurStateMemoryblock3From;
    int iPrevSlowCoord;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    MyBanding bandingInstance( iSequence1.size(), iSequence2.size(), iWidth );
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    AlignWithBandingDPTable dp(iLen1,iLen2);
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    dp.StateMemoryblock1.write()[0] = 1.0;
    dp.StateMemoryblock1.written();
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            if (1) {
            }
        }
    }
    iPrevSlowCoord = -1;
    {
        Banding<2>::Position& position = bandingInstance.forwardIterator();
        bool bLastSlowCoordInited = false;
        int iLastSlowCoord = -1;  
        do {
            if (bLastSlowCoordInited) {
                if (iLastSlowCoord > position[1]) {
                    cout << "WARNING: Banding (forward): Slowest coordinate should be nondecreasing.  Perhaps forgot to specify speed of output coordinates?" << endl;
                }
                } else {
                bLastSlowCoordInited = true;
            }
            iLastSlowCoord = position[1];
            if ((position[0]+0>=0)&&(position[0]+0<=iLen1+0)&&(position[1]+0>=0)&&(position[1]+0<=iLen2+0)) {
                if (1) {
                    if ((position[0]+-1>=0)) {
                        iSymbol[0] = iSequence1[position[0]+-1];
                    } 
                    else { 
                        iSymbol[0] = 'A' /* dummy value */;
                        
                    }
                    if ((position[1]+-1>=0)) {
                        iSymbol[1] = iSequence2[position[1]+-1];
                    } 
                    else { 
                        iSymbol[1] = 'A' /* dummy value */;
                        
                    }
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.write((position[0]-(0))-(0), (position[1]-(0))-(0));
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+-1>=0)&&(position[0]+-1<=0)&&(position[1]+-1>=0)&&(position[1]+-1<=0)) {
                        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                        CurStateMemoryblock2withbandingTo[1] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock1From[0];
                    }
                    if ((position[0]+-1>=0)&&(position[1]+-1>=0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(1))-(0), (position[1]-(1))-(0));
                        CurStateMemoryblock2withbandingTo[1] += ((iTransition[12])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                        CurStateMemoryblock2withbandingTo[1] += ((iTransition[8])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                        CurStateMemoryblock2withbandingTo[1] += ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                    }
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+0<=0)&&(position[1]+-1>=0)&&(position[1]+-1<=0)) {
                        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                        CurStateMemoryblock2withbandingTo[2] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock1From[0];
                    }
                    if ((position[1]+-1>=0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(0))-(0), (position[1]-(1))-(0));
                        CurStateMemoryblock2withbandingTo[2] += ((iTransition[14])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                        CurStateMemoryblock2withbandingTo[2] += ((iTransition[10])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                        CurStateMemoryblock2withbandingTo[2] += ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                    }
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+-1>=0)&&(position[0]+-1<=0)&&(position[1]+0<=0)) {
                        CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                        CurStateMemoryblock2withbandingTo[0] = ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock1From[0];
                    }
                    if ((position[0]+-1>=0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(1))-(0), (position[1]-(0))-(0));
                        CurStateMemoryblock2withbandingTo[0] += ((iTransition[13])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                        CurStateMemoryblock2withbandingTo[0] += ((iTransition[9])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                        CurStateMemoryblock2withbandingTo[0] += ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                    }
                    dp.StateMemoryblock2withbanding.written();
                }
                iPrevSlowCoord = position[1];
            } 
            else { 
                bandingInstance.warning();
                
            }
        } while (bandingInstance.hasNextForward());
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=iLen2+0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=iLen1+0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            if (1) {
                CurStateMemoryblock3To = dp.StateMemoryblock3.write();
                iEmission[0] = 1.0;
                if ((iPos0+0<=0)&&(iPos1+0<=0)) {
                    CurStateMemoryblock1From = dp.StateMemoryblock1.read();
                    CurStateMemoryblock3To[0] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock1From[0];
                }
                if (1) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock3To[0] += ((iTransition[15])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                    CurStateMemoryblock3To[0] += ((iTransition[11])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                    CurStateMemoryblock3To[0] += ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                }
                dp.StateMemoryblock3.written();
            }
            iPrevSlowCoord = iPos1;
        }
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=iLen2+0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=iLen1+0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock3From = dp.StateMemoryblock3.read();
            iTempProb[0] = CurStateMemoryblock3From[0];
        }
    }
    *ppOutTable = new AlignWithBandingDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





bfloat BackwardBaumWelchBanding(AlignWithBandingBaumWelch& bw,AlignWithBandingDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,int iWidth,vector<char>& iSequence1,vector<char>& iSequence2) {
    const bfloat *CurStateMemoryblock3Secondary;
    bfloat iTransition[16];
    bfloat *CurStateMemoryblock2withbandingTo;
    const bfloat *CurStateMemoryblock2withbandingSecondary;
    const bfloat *CurStateMemoryblock2withbandingFrom;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1Secondary;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    MyBanding bandingInstance( iSequence1.size(), iSequence2.size(), iWidth );
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[3];
    AlignWithBandingFoldedDPTable dp(iLen1,2);
    AlignWithBandingDPTable dp2(*pInTable);
    // make sure tables don't get deleted
    dp2.isInCharge = false;
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    {
        int iPos1=iLen2+0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=iLen1+0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock3Secondary = dp2.StateMemoryblock3.read();
            iTempProb[2] = CurStateMemoryblock3Secondary[0];
            bw.scaleCounts(iTempProb[2]);
        }
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=iLen2+0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=iLen1+0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            if (1) {
            }
        }
    }
    iPrevSlowCoord = -1;
    {
        Banding<2>::Position& position = bandingInstance.backwardIterator();
        int iCheckSlowCoordTraversal = -1;  
        do {
            if (iCheckSlowCoordTraversal != -1 && iCheckSlowCoordTraversal < position[1]) {
                cout << "WARNING: Banding (backward): Slowest coordinate be nonincreasing.  Perhaps forgot to specify speed of output coordinates?" << endl;
            }
            iCheckSlowCoordTraversal = position[1];
            if ((position[0]+0>=0)&&(position[0]+0<=iLen1+0)&&(position[1]+0>=0)&&(position[1]+0<=iLen2+0)) {
                if (iPrevSlowCoord != -1 && iPrevSlowCoord != position[1]) {
                    dp.StateMemoryblock2withbanding.clear(position[1]);
                }
                if (1) {
                    if ((position[0]+0<=iLen1+-1)) {
                        iSymbol[0] = iSequence1[position[0]+0];
                    } 
                    else { 
                        iSymbol[0] = 'A' /* dummy value */;
                        
                    }
                    if ((position[1]+0<=iLen2+-1)) {
                        iSymbol[1] = iSequence2[position[1]+0];
                    } 
                    else { 
                        iSymbol[1] = 'A' /* dummy value */;
                        
                    }
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.write((position[0]-(0))-(0), (position[1]-(0))-(0));
                    CurStateMemoryblock2withbandingSecondary = dp2.StateMemoryblock2withbanding.read((position[0]-(0))-(0), (position[1]-(0))-(0));
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+1<=iLen1+0)&&(position[1]+1<=iLen2+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(-1))-(0), (position[1]-(-1))-(0));
                        CurStateMemoryblock2withbandingTo[2] = iTempProb[1] = ((iTransition[12])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                        bw.transitionBaumWelchCount00[12] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[2];
                        CurStateMemoryblock2withbandingTo[1] = iTempProb[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                        bw.transitionBaumWelchCount00[4] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[1];
                        CurStateMemoryblock2withbandingTo[0] = iTempProb[1] = ((iTransition[8])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                        bw.transitionBaumWelchCount00[8] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[0];
                    }
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[1]+1<=iLen2+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(0))-(0), (position[1]-(-1))-(0));
                        CurStateMemoryblock2withbandingTo[2] += iTempProb[1] = ((iTransition[14])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                        bw.transitionBaumWelchCount00[14] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[2];
                        CurStateMemoryblock2withbandingTo[1] += iTempProb[1] = ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                        bw.transitionBaumWelchCount00[6] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[1];
                        CurStateMemoryblock2withbandingTo[0] += iTempProb[1] = ((iTransition[10])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                        bw.transitionBaumWelchCount00[10] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[0];
                    }
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+1<=iLen1+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(-1))-(0), (position[1]-(0))-(0));
                        CurStateMemoryblock2withbandingTo[2] += iTempProb[1] = ((iTransition[13])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                        bw.transitionBaumWelchCount00[13] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[2];
                        CurStateMemoryblock2withbandingTo[1] += iTempProb[1] = ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                        bw.transitionBaumWelchCount00[5] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[1];
                        CurStateMemoryblock2withbandingTo[0] += iTempProb[1] = ((iTransition[9])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                        bw.transitionBaumWelchCount00[9] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[0];
                    }
                    iEmission[0] = 1.0;
                    if ((position[0]+0>=iLen1+0)&&(position[1]+0>=iLen2+0)) {
                        CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                        CurStateMemoryblock2withbandingTo[2] += iTempProb[1] = ((iTransition[15])*(iEmission[0]))*CurStateMemoryblock3From[0];
                        bw.transitionBaumWelchCount00[15] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[2];
                        CurStateMemoryblock2withbandingTo[1] += iTempProb[1] = ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock3From[0];
                        bw.transitionBaumWelchCount00[7] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[1];
                        CurStateMemoryblock2withbandingTo[0] += iTempProb[1] = ((iTransition[11])*(iEmission[0]))*CurStateMemoryblock3From[0];
                        bw.transitionBaumWelchCount00[11] += iTempProb[1] * CurStateMemoryblock2withbandingSecondary[0];
                    }
                    dp.StateMemoryblock2withbanding.written();
                }
                iPrevSlowCoord = position[1];
            } 
            else { 
                bandingInstance.warning();
                
            }
        } while (bandingInstance.hasNextBackward());
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            if (1) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.write();
                CurStateMemoryblock1Secondary = dp2.StateMemoryblock1.read();
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] = iTempProb[1] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                    bw.transitionBaumWelchCount00[1] += iTempProb[1] * CurStateMemoryblock1Secondary[0];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] += iTempProb[1] = ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                    bw.transitionBaumWelchCount00[3] += iTempProb[1] * CurStateMemoryblock1Secondary[0];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock1To[0] += iTempProb[1] = ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                    bw.transitionBaumWelchCount00[2] += iTempProb[1] * CurStateMemoryblock1Secondary[0];
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    CurStateMemoryblock1To[0] += iTempProb[1] = ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock3From[0];
                    bw.transitionBaumWelchCount00[0] += iTempProb[1] * CurStateMemoryblock1Secondary[0];
                }
                dp.StateMemoryblock1.written();
            }
            iPrevSlowCoord = iPos1;
        }
    }
    bw.scaleCounts(1.0 / iTempProb[2]);
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock1From = dp.StateMemoryblock1.read();
            iTempProb[0] = CurStateMemoryblock1From[0];
        }
    }
    return iTempProb[0];
};





bfloat BackwardBanding(AlignWithBandingDPTable** ppOutTable,double iDelta,double iR,double iSigma,double iTau,int iWidth,vector<char>& iSequence1,vector<char>& iSequence2) {
    bfloat iTransition[16];
    bfloat *CurStateMemoryblock2withbandingTo;
    const bfloat *CurStateMemoryblock2withbandingFrom;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    MyBanding bandingInstance( iSequence1.size(), iSequence2.size(), iWidth );
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    AlignWithBandingDPTable dp(iLen1,iLen2);
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    {
        int iPos1=iLen2+0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=iLen1+0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            if (1) {
            }
        }
    }
    iPrevSlowCoord = -1;
    {
        Banding<2>::Position& position = bandingInstance.backwardIterator();
        int iCheckSlowCoordTraversal = -1;  
        do {
            if (iCheckSlowCoordTraversal != -1 && iCheckSlowCoordTraversal < position[1]) {
                cout << "WARNING: Banding (backward): Slowest coordinate be nonincreasing.  Perhaps forgot to specify speed of output coordinates?" << endl;
            }
            iCheckSlowCoordTraversal = position[1];
            if ((position[0]+0>=0)&&(position[0]+0<=iLen1+0)&&(position[1]+0>=0)&&(position[1]+0<=iLen2+0)) {
                if (1) {
                    if ((position[0]+0<=iLen1+-1)) {
                        iSymbol[0] = iSequence1[position[0]+0];
                    } 
                    else { 
                        iSymbol[0] = 'A' /* dummy value */;
                        
                    }
                    if ((position[1]+0<=iLen2+-1)) {
                        iSymbol[1] = iSequence2[position[1]+0];
                    } 
                    else { 
                        iSymbol[1] = 'A' /* dummy value */;
                        
                    }
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.write((position[0]-(0))-(0), (position[1]-(0))-(0));
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+1<=iLen1+0)&&(position[1]+1<=iLen2+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(-1))-(0), (position[1]-(-1))-(0));
                        CurStateMemoryblock2withbandingTo[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                        CurStateMemoryblock2withbandingTo[2] = ((iTransition[12])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                        CurStateMemoryblock2withbandingTo[0] = ((iTransition[8])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                    }
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[1]+1<=iLen2+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(0))-(0), (position[1]-(-1))-(0));
                        CurStateMemoryblock2withbandingTo[1] += ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                        CurStateMemoryblock2withbandingTo[2] += ((iTransition[14])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                        CurStateMemoryblock2withbandingTo[0] += ((iTransition[10])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                    }
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+1<=iLen1+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(-1))-(0), (position[1]-(0))-(0));
                        CurStateMemoryblock2withbandingTo[1] += ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                        CurStateMemoryblock2withbandingTo[2] += ((iTransition[13])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                        CurStateMemoryblock2withbandingTo[0] += ((iTransition[9])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                    }
                    iEmission[0] = 1.0;
                    if ((position[0]+0>=iLen1+0)&&(position[1]+0>=iLen2+0)) {
                        CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                        CurStateMemoryblock2withbandingTo[1] += ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock3From[0];
                        CurStateMemoryblock2withbandingTo[2] += ((iTransition[15])*(iEmission[0]))*CurStateMemoryblock3From[0];
                        CurStateMemoryblock2withbandingTo[0] += ((iTransition[11])*(iEmission[0]))*CurStateMemoryblock3From[0];
                    }
                    dp.StateMemoryblock2withbanding.written();
                }
                iPrevSlowCoord = position[1];
            } 
            else { 
                bandingInstance.warning();
                
            }
        } while (bandingInstance.hasNextBackward());
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            if (1) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.write();
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] += ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    CurStateMemoryblock1To[0] += ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0];
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    CurStateMemoryblock1To[0] += ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock3From[0];
                }
                dp.StateMemoryblock1.written();
            }
            iPrevSlowCoord = iPos1;
        }
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock1From = dp.StateMemoryblock1.read();
            iTempProb[0] = CurStateMemoryblock1From[0];
        }
    }
    *ppOutTable = new AlignWithBandingDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};




//-- Heejung --//
Path& SampleBanding(AlignWithBandingDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2, double* prob) {
    *prob = 0;
    bfloat iTransition[16];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2withbandingTo;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    /*
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    */
    iT[0] = 1.0 - 2*iDelta;         // MM  (Match-to-Match)
    iT[1] = iDelta;                 // MI  (Match-to-Insert)
    iT[2] = iDelta;                 // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR + (1.0-iR)*iDelta;      // II
    iT[5] = (1.0 - iR)*(1 - 2*iDelta); // IM
    iT[6] = (1.0 - iR)*iDelta;      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR + (1.0-iR)*iDelta;   // DD
    iT[9] = (1.0 - iR)*(1 - 2*iDelta); // DM
    iT[10]= (1.0 - iR)*iDelta;      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - 2*iDelta;         // SM  (Start-to-Match)
    iT[13]= iDelta;                 // SI 
    iT[14]= iDelta;                 // SD
    iT[15]= iTau;                      // SE
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary vector storage */
    bfloat iTempVector[11];
    /* temporary int vector storage */
    int iTempIntVec[7];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    static const int stateTable[] = {4, 2, 1, 3, 2, 1, 3, 4, 2, 1, 3, 4, 2, 1, 3, 4};
    static const int stateFromTable[] = {0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 3, 3, 3, 3};
    static const int iPos0Table[] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0};
    static const int iPos1Table[] = {0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    AlignWithBandingDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            iTempIntVec[0] = 0;
            while (iTempIntVec[0] != 4) {
                iTempIntVec[1] = 2;
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.read();
                CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(0))-(0));
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[8]*iEmission[0]*CurStateMemoryblock2withbandingTo[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[8]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 8;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[12]*iEmission[0]*CurStateMemoryblock2withbandingTo[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[12]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 12;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock2withbandingTo[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[1]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 1;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*CurStateMemoryblock2withbandingTo[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[4]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 4;
                        break;
                    }
                }
                if ((iPos1+1<=iLen2+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[10]*iEmission[0]*CurStateMemoryblock2withbandingTo[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[10]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 10;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[14]*iEmission[0]*CurStateMemoryblock2withbandingTo[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[14]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 14;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock2withbandingTo[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[3]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 3;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[0]*CurStateMemoryblock2withbandingTo[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[6]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 6;
                        break;
                    }
                }
                if ((iPos0+1<=iLen1+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[9]*iEmission[0]*CurStateMemoryblock2withbandingTo[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[9]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 9;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[13]*iEmission[0]*CurStateMemoryblock2withbandingTo[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[13]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 13;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*CurStateMemoryblock2withbandingTo[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[2]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 2;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*CurStateMemoryblock2withbandingTo[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[5]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 5;
                        break;
                    }
                }
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    iEmission[0] = 1.0;
                    CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[11]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[11]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 11;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[15]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[15]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 15;
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[0]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 0;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[7]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[7]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 7;
                        break;
                    }
                }
                iTempVector[0] = iTempVector[1] = 0.0;
                for (int i=2; i<iTempIntVec[1]; i++) {
                    iTempVector[0] += iTempVector[i];
                }
                iTempVector[0] *= (random() / (double)RAND_MAX);
                iTempIntVec[0] = 1;
                while (iTempVector[0]>=iTempVector[1] && ++iTempIntVec[0]<iTempIntVec[1]) {
                    iTempVector[1] += iTempVector[iTempIntVec[0]];
                }
                if (iTempIntVec[0]==iTempIntVec[1]) {
                    cerr << "Error in sampler -- zero probabilities?" << endl;
                    exit(1);
                }
                emit.resize(2);
                emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
                emit[1] = iPos1Table[iTempIntVec[iTempIntVec[0]]];
                pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+4],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
                iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
                iPos1 += iPos1Table[iTempIntVec[iTempIntVec[0]]];
                iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
            }
        }
    }
    return *pPath;
};





bfloat ViterbiBanding_recurse(AlignWithBandingDPTable** ppOutTable,double iDelta,double iR,double iSigma,double iTau,int iWidth,vector<char>& iSequence1,vector<char>& iSequence2) {
    bfloat iTransition[16];
    bfloat *CurStateMemoryblock2withbandingTo;
    const bfloat *CurStateMemoryblock2withbandingFrom;
    const bfloat *CurStateMemoryblock3From;
    bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock1From;
    int iPrevSlowCoord;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    MyBanding bandingInstance( iSequence1.size(), iSequence2.size(), iWidth );
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    /* temporary storage for extended-exponent reals */
    register bfloat iTempProb[1];
    AlignWithBandingDPTable dp(iLen1,iLen2);
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    dp.StateMemoryblock3.write()[0] = 1.0;
    dp.StateMemoryblock3.written();
    iPrevSlowCoord = -1;
    {
        int iPos1=iLen2+0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=iLen1+0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            if (1) {
            }
        }
    }
    iPrevSlowCoord = -1;
    {
        Banding<2>::Position& position = bandingInstance.backwardIterator();
        int iCheckSlowCoordTraversal = -1;  
        do {
            if (iCheckSlowCoordTraversal != -1 && iCheckSlowCoordTraversal < position[1]) {
                cout << "WARNING: Banding (backward): Slowest coordinate be nonincreasing.  Perhaps forgot to specify speed of output coordinates?" << endl;
            }
            iCheckSlowCoordTraversal = position[1];
            if ((position[0]+0>=0)&&(position[0]+0<=iLen1+0)&&(position[1]+0>=0)&&(position[1]+0<=iLen2+0)) {
                if (1) {
                    if ((position[0]+0<=iLen1+-1)) {
                        iSymbol[0] = iSequence1[position[0]+0];
                    } 
                    else { 
                        iSymbol[0] = 'A' /* dummy value */;
                        
                    }
                    if ((position[1]+0<=iLen2+-1)) {
                        iSymbol[1] = iSequence2[position[1]+0];
                    } 
                    else { 
                        iSymbol[1] = 'A' /* dummy value */;
                        
                    }
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.write((position[0]-(0))-(0), (position[1]-(0))-(0));
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+1<=iLen1+0)&&(position[1]+1<=iLen2+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(-1))-(0), (position[1]-(-1))-(0));
                        CurStateMemoryblock2withbandingTo[2] = ((iTransition[12])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                        CurStateMemoryblock2withbandingTo[1] = ((iTransition[4])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                        CurStateMemoryblock2withbandingTo[0] = ((iTransition[8])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                    }
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[1]+1<=iLen2+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(0))-(0), (position[1]-(-1))-(0));
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[2], ((iTransition[14])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2] );
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[1], ((iTransition[6])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2] );
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[0], ((iTransition[10])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2] );
                    }
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    if ((position[0]+1<=iLen1+0)) {
                        CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((position[0]-(-1))-(0), (position[1]-(0))-(0));
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[2], ((iTransition[13])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0] );
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[1], ((iTransition[5])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0] );
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[0], ((iTransition[9])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0] );
                    }
                    iEmission[0] = 1.0;
                    if ((position[0]+0>=iLen1+0)&&(position[1]+0>=iLen2+0)) {
                        CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[2], ((iTransition[15])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[1], ((iTransition[7])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                        hmmocMaxInPlace( CurStateMemoryblock2withbandingTo[0], ((iTransition[11])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                    }
                    dp.StateMemoryblock2withbanding.written();
                }
                iPrevSlowCoord = position[1];
            } 
            else { 
                bandingInstance.warning();
                
            }
        } while (bandingInstance.hasNextBackward());
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            if (1) {
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.write();
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    CurStateMemoryblock1To[0] = ((iTransition[1])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[1];
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos1+1<=iLen2+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    hmmocMaxInPlace( CurStateMemoryblock1To[0], ((iTransition[3])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[2] );
                }
                iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                iEmission[0] = iTempResult[0];
                if ((iPos0+1<=iLen1+0)) {
                    CurStateMemoryblock2withbandingFrom = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    hmmocMaxInPlace( CurStateMemoryblock1To[0], ((iTransition[2])*(iEmission[0]))*CurStateMemoryblock2withbandingFrom[0] );
                }
                iEmission[0] = 1.0;
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    CurStateMemoryblock3From = dp.StateMemoryblock3.read();
                    hmmocMaxInPlace( CurStateMemoryblock1To[0], ((iTransition[0])*(iEmission[0]))*CurStateMemoryblock3From[0] );
                }
                dp.StateMemoryblock1.written();
            }
            iPrevSlowCoord = iPos1;
        }
    }
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            CurStateMemoryblock1From = dp.StateMemoryblock1.read();
            iTempProb[0] = CurStateMemoryblock1From[0];
        }
    }
    *ppOutTable = new AlignWithBandingDPTable(dp);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    return iTempProb[0];
};





Path& ViterbiBanding_trace(AlignWithBandingDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2) {
    bfloat iTransition[16];
    const bfloat *CurStateMemoryblock1To;
    const bfloat *CurStateMemoryblock2withbandingTo;
    const bfloat *CurStateMemoryblock3To;
    int iPrevSlowCoord;
    SimplePath* pPath = new SimplePath();
    vector<int> emit;
    int iLen1 = iSequence1.size();   // The sequence lengths are not passed as parameters, but are
    int iLen2 = iSequence2.size();   // computed from the vector<char> itself
    
    /* Initialisation of the arrays iEquilibriumDistribution and iMatrix,
    according to a Jukes-Cantor model */
    
    double iEquilibriumDistribution[4];
    double iSubstitutionMatrix[4][4];
    unsigned char iTranslate[256];
    for (int i=0; i<256; i++) {
        iTranslate[i]= 0;
    }
    iTranslate[(unsigned)'A'] = 0;   // It is important that this is in alphabetical order, to
    iTranslate[(unsigned)'a'] = 0;   // make the indices correspond to those used for Baum-Welch
    iTranslate[(unsigned)'C'] = 1;
    iTranslate[(unsigned)'c'] = 1;
    iTranslate[(unsigned)'G'] = 2;
    iTranslate[(unsigned)'g'] = 2;
    iTranslate[(unsigned)'T'] = 3;
    iTranslate[(unsigned)'t'] = 3;
    
    for (int i=0; i<4; i++) {
        iEquilibriumDistribution[i] = 1/4.0;
        for (int j=0; j<4; j++) {
            if (i==j) {
                iSubstitutionMatrix[i][j] = 1/4.0 + (3/4.0)*exp(-4.0*iSigma/3.0);
                } else {
                iSubstitutionMatrix[i][j] = 1/4.0 - (1/4.0)*exp(-4.0*iSigma/3.0);
            }
        }
    }
    /* Initialisation of the iT transition-probability array */
    
    double iT[16];
    iT[0] = 1.0 - iDelta - iTau;    // MM  (Match-to-Match)
    iT[1] = iDelta/2;               // MI  (Match-to-Insert)
    iT[2] = iDelta/2;               // MD  (Match-to-Delete)
    iT[3] = iTau;                   // ME  (Match-to-End)
    iT[4] = iR;                     // II
    iT[5] = 1.0 - iR - iTau;        // IM
    iT[6] = 0;                      // ID
    iT[7] = iTau;                   // IE
    iT[8] = iR;                     // DD
    iT[9] = 1.0 - iR - iTau;        // DM
    iT[10]= 0;                      // DI
    iT[11]= iTau;                   // DE
    iT[12]= 1.0 - iDelta;           // SM  (Start-to-Match)
    iT[13]= iDelta/2;               // SI 
    iT[14]= iDelta/2;               // SD
    iT[15]= 0;                      // SE
    int iSymbol[2];
    if (false && iSymbol[0] == iSymbol[0]) {}   // avoid 'unused variable' warnings
    bfloat iEmission[1];
    /* temporary vector storage */
    bfloat iTempVector[11];
    /* temporary int vector storage */
    int iTempIntVec[7];
    /* temporary storage for ordinary reals */
    register double iTempResult[1];
    iTransition[0] = iT[15];
    
    iTransition[1] = iT[12];
    
    iTransition[2] = iT[13];
    
    iTransition[3] = iT[14];
    
    iTransition[4] = iT[0];
    
    iTransition[5] = iT[1];
    
    iTransition[6] = iT[2];
    
    iTransition[7] = iT[3];
    
    iTransition[8] = iT[5];
    
    iTransition[9] = iT[4];
    
    iTransition[10] = iT[6];
    
    iTransition[11] = iT[7];
    
    iTransition[12] = iT[9];
    
    iTransition[13] = iT[10];
    
    iTransition[14] = iT[8];
    
    iTransition[15] = iT[11];
    static const int stateTable[] = {4, 2, 1, 3, 2, 1, 3, 4, 2, 1, 3, 4, 2, 1, 3, 4};
    static const int stateFromTable[] = {0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 3, 3, 3, 3};
    static const int iPos0Table[] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0};
    static const int iPos1Table[] = {0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    AlignWithBandingDPTable dp(*pInTable);
    // make sure tables don't get deleted
    dp.isInCharge = false;
    iPrevSlowCoord = -1;
    {
        int iPos1=0;
        if (iPos1==iPos1) {} // avoid 'unused variable' warnings
        {
            int iPos0=0;
            if (iPos0==iPos0) {} // avoid 'unused variable' warnings
            iTempIntVec[0] = 0;
            while (iTempIntVec[0] != 4) {
                iTempIntVec[1] = 2;
                if ((iPos0+0<=iLen1+-1)) {
                    iSymbol[0] = iSequence1[iPos0+0];
                } 
                else { 
                    iSymbol[0] = 'A' /* dummy value */;
                    
                }
                if ((iPos1+0<=iLen2+-1)) {
                    iSymbol[1] = iSequence2[iPos1+0];
                } 
                else { 
                    iSymbol[1] = 'A' /* dummy value */;
                    
                }
                CurStateMemoryblock1To = dp.StateMemoryblock1.read();
                CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(0))-(0));
                if ((iPos0+1<=iLen1+0)&&(iPos1+1<=iLen2+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ] * (iSubstitutionMatrix[ iTranslate[ iSymbol[0] ] ])[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[1]*iEmission[0]*CurStateMemoryblock2withbandingTo[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[1]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 1;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[8]*iEmission[0]*CurStateMemoryblock2withbandingTo[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[8]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 8;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[4]*iEmission[0]*CurStateMemoryblock2withbandingTo[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[4]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 4;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[12]*iEmission[0]*CurStateMemoryblock2withbandingTo[1];
                        iTempVector[iTempIntVec[1]+4] = iTransition[12]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 12;
                        break;
                    }
                }
                if ((iPos1+1<=iLen2+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[1] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.read((iPos0-(0))-(0), (iPos1-(-1))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[3]*iEmission[0]*CurStateMemoryblock2withbandingTo[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[3]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 3;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[10]*iEmission[0]*CurStateMemoryblock2withbandingTo[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[10]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 10;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[6]*iEmission[0]*CurStateMemoryblock2withbandingTo[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[6]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 6;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[14]*iEmission[0]*CurStateMemoryblock2withbandingTo[2];
                        iTempVector[iTempIntVec[1]+4] = iTransition[14]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 14;
                        break;
                    }
                }
                if ((iPos0+1<=iLen1+0)) {
                    iTempResult[0] = iEquilibriumDistribution[ iTranslate[ iSymbol[0] ] ];
                    iEmission[0] = iTempResult[0];
                    CurStateMemoryblock2withbandingTo = dp.StateMemoryblock2withbanding.read((iPos0-(-1))-(0), (iPos1-(0))-(0));
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[2]*iEmission[0]*CurStateMemoryblock2withbandingTo[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[2]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 2;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[9]*iEmission[0]*CurStateMemoryblock2withbandingTo[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[9]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 9;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[5]*iEmission[0]*CurStateMemoryblock2withbandingTo[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[5]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 5;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[13]*iEmission[0]*CurStateMemoryblock2withbandingTo[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[13]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 13;
                        break;
                    }
                }
                CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                if ((iPos0+0>=iLen1+0)&&(iPos1+0>=iLen2+0)) {
                    iEmission[0] = 1.0;
                    CurStateMemoryblock3To = dp.StateMemoryblock3.read();
                    switch (iTempIntVec[0]) {
                        default:
                        break;
                        case 0:
                        iTempVector[iTempIntVec[1]] = iTransition[0]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[0]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 0;
                        break;
                        case 1:
                        iTempVector[iTempIntVec[1]] = iTransition[11]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[11]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 11;
                        break;
                        case 2:
                        iTempVector[iTempIntVec[1]] = iTransition[7]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[7]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 7;
                        break;
                        case 3:
                        iTempVector[iTempIntVec[1]] = iTransition[15]*iEmission[0]*CurStateMemoryblock3To[0];
                        iTempVector[iTempIntVec[1]+4] = iTransition[15]*iEmission[0];
                        iTempIntVec[iTempIntVec[1]++] = 15;
                        break;
                    }
                }
                iTempVector[0] = 0.0;
                for (int i=2; i<iTempIntVec[1]; i++) {
                    if (iTempVector[i]>iTempVector[0]) {
                        iTempVector[0]=iTempVector[i];
                        iTempIntVec[0] = i;
                    }
                }
                emit.resize(2);
                emit[0] = iPos0Table[iTempIntVec[iTempIntVec[0]]];
                emit[1] = iPos1Table[iTempIntVec[iTempIntVec[0]]];
                pPath->addEdge(iTempIntVec[iTempIntVec[0]],iTempVector[iTempIntVec[0]+4],emit,stateFromTable[iTempIntVec[iTempIntVec[0]]],stateTable[iTempIntVec[iTempIntVec[0]]]);
                iPos0 += iPos0Table[iTempIntVec[iTempIntVec[0]]];
                iPos1 += iPos1Table[iTempIntVec[iTempIntVec[0]]];
                iTempIntVec[0] = stateTable[iTempIntVec[iTempIntVec[0]]];
            }
        }
    }
    return *pPath;
};



/* --- end of HMMoC-generated file --- */
