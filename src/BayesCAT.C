


#include <vector>
#include <cmath>
#include <iostream>
#include <stdlib.h>
#include <math.h>
#include <fstream>
#include <string>
#define MAX(a,b)   ((a) < (b) ? (b) : (a))
#define MIN(a,b)   ((a) < (b) ? (a) : (b))
#define ABS(a) ((a) < (0) ? ((-1)*a) : (a))





using std::vector;
//#include "mpi.h"

#include "mybandingHJ.h"



//bool enumerateCombinations(int n, int k, int j[])
/*-------------------------------------------------------------------
 Description:
   Enumerates all possible combinations of choosing k objects from n
   distint objects.  Initialize the enumeration by setting j[0] to a
   negative value.  Then, each call to enumerateCombinations will
   generate the next combinations and place it in j[0..k-1].  A
   return value of false indicates there are no more combinations to
   generate.  j needs to be allocated with a size for at least k
   elements.

 Language:
   C++

 Usage:
   int comb[10] = {-1};
   while(enumerateCombinations(10, 5, comb)){
       // do something with comb[0..4]
   }


 From http://doodleproject.sourceforge.net/algorithms/combinatorics/enumerateCombinations.html

 Reference:
   Tucker, Allen.  Applied Combinatorics.  3rd Ed.  1994.
-------------------------------------------------------------------*/
/*{
    int i;
    if(j[0] < 0){
        for(i = 0; i < k; ++i){
            j[i] = i;
        }
        return true;
    } else {
        for(i = k - 1; i >= 0 && j[i] >= n - k + i; --i){}
        if(i >= 0){
            j[i]++;
            int m;
            for(m = i + 1; m < k; ++m){
                j[m] = j[m-1] + 1;
            }
            return true;
        } else {
            return false;
        }
    }
}
*/



bool enumerateCombinations(int n, int k, vector<int> &j)
/*-------------------------------------------------------------------
 Description:
   Enumerates all possible combinations of choosing k objects from n
   distint objects.  Initialize the enumeration by setting j[0] to a
   negative value.  Then, each call to enumerateCombinations will
   generate the next combinations and place it in j[0..k-1].  A
   return value of false indicates there are no more combinations to
   generate.  j needs to be allocated with a size for at least k
   elements.

 Language:
   C++

 Usage:
   int comb[10] = {-1};
   while(enumerateCombinations(10, 5, comb)){
       // do something with comb[0..4]
   }


 From http://doodleproject.sourceforge.net/algorithms/combinatorics/enumerateCombinations.html

 Reference:
   Tucker, Allen.  Applied Combinatorics.  3rd Ed.  1994.
-------------------------------------------------------------------*/
{
    int i;
    if(j[0] < 0){
        for(i = 0; i < k; ++i){
            j[i] = i;
        }
        return true;
    } else {
        for(i = k - 1; i >= 0 && j[i] >= n - k + i; --i){}
        if(i >= 0){
            j[i]++;
            int m;
            for(m = i + 1; m < k; ++m){
                j[m] = j[m-1] + 1;
            }
            return true;
        } else {
            return false;
        }
    }
}






//----- Importance sampling start ----//
#ifndef RNG_H
#define RNG_H
#include <cstdlib>
#include <ctime>
#include <climits>






static const double PI   =  3.1415926535897932;
static const double AD_l =  0.6931471805599453;
static const double AD_a =  5.7133631526454228;
static const double AD_b =  3.4142135623730950;
static const double AD_c = -1.6734053240284925;
static const double AD_p =  0.9802581434685472;
static const double AD_A =  5.6005707569738080;
static const double AD_B =  3.3468106480569850;
static const double AD_H =  0.0026106723602095;
static const double AD_D =  0.0857864376269050;

typedef signed int sint;
typedef unsigned int uint;
typedef signed long slong;
typedef unsigned long ulong;
#if ULONG_MAX == 4294967295ul
inline ulong ULONG32(slong x) { return (ulong(x)); }
inline ulong ULONG32(ulong x) { return (ulong(x)); }
inline ulong ULONG32(double x) { return (ulong(x)); }
inline slong UL32toSL32(ulong x) { return (slong(x)); }
#else
inline ulong ULONG32(slong x) { return (ulong(x) & 0xfffffffful); }
inline ulong ULONG32(ulong x) { return (x & 0xfffffffful); }
inline ulong ULONG32(double x) { return (ulong(x) & 0xfffffffful); }
inline slong UL32toSL32(ulong x)
  { return (x < 0x80000000ul ? slong(x) : -1 * (0x80000000ul - (x & 0x7ffffffful))); }
#endif

class RNG
{
 private:
  static ulong tm; // Used to ensure different RNGs have different seeds.
  ulong z, w, jsr, jcong; // Seeds

  ulong kn[128], ke[256];
  double wn[128], fn[128], we[256],fe[256];

 public:
  RNG() { init(); zigset(); }
  RNG(ulong x_) :
    z(x_), w(x_), jsr(x_), jcong(x_) { zigset(); }
  RNG(ulong z_, ulong w_, ulong jsr_, ulong jcong_ ) :
    z(z_), w(w_), jsr(jsr_), jcong(jcong_) { zigset(); }
  ~RNG() { }

#if ULONG_MAX == 4294967295ul
  // 32 bit unsigned longs
  ulong znew() 
    { return (z = 36969 * (z & 0xfffful) + (z >> 16)); }
  ulong wnew() 
    { return (w = 18000 * (w & 0xfffful) + (w >> 16)); }
  ulong MWC()  
    { return ((znew() << 16) + wnew()); }
  ulong SHR3()
    { jsr ^= (jsr << 17); jsr ^= (jsr >> 13); return (jsr ^= (jsr << 5)); }
  ulong CONG() 
    { return (jcong = 69069 * jcong + 1234567); }
  ulong rand_int32()       // [0,2^32-1]
    { return ((MWC() ^ CONG()) + SHR3()); }
  ulong rand_int()         // [0,2^32-1]
    { return ((MWC() ^ CONG()) + SHR3()); }
#elif ULONG_MAX == 18446744073709551615ul
#ifdef RNG_C
#warning "Compiling RNG class for 64-bit architecture"
#endif
  // 64-bit unsigned longs
  // This is not as elegant and fast as it could be, but it works.
  ulong znew() 
    { return (z = ((36969 * (z & 0xfffful) + (z >> 16)) & 0xfffffffful)); }
  ulong wnew() 
    { return (w = ((18000 * (w & 0xfffful) + (w >> 16)) & 0xfffffffful)); }
  ulong MWC()  
    { return (((znew() << 16) + wnew()) & 0xfffffffful); }
  ulong SHR3()
    { jsr ^= (jsr << 17); jsr ^= (jsr >> 13);
      return (jsr = ((jsr ^= (jsr << 5)) & 0xfffffffful)); }
  ulong CONG() 
    { return (jcong = ((69069 * jcong + 1234567) & 0xfffffffful)); }
  ulong rand_int32()         // [0,2^32-1]
    { return (((MWC() ^ CONG()) + SHR3()) & 0xfffffffful); }
  ulong rand_int()           // [0,2^64-1]
    { return (rand_int32() | (rand_int32() << 32)); }
#endif
  double RNOR() {
    slong h = UL32toSL32(rand_int32()), i = h & 127;
    return (((ulong)std::abs(h) < kn[i]) ? h * wn[i] : nfix(h, i));
  }
  double REXP() {
    ulong j = rand_int32(), i = j & 255;
    return ((j < ke[i]) ? j * we[i] : efix(j, i));
  }

  double nfix(slong h, ulong i);
  double efix(ulong j, ulong i);
  void zigset();

  void init()
    { z = w = jsr = jcong = ulong(time(0)) + tm; tm += 123457; }
  void init(ulong z_, ulong w_, ulong jsr_, ulong jcong_ )
    { z = z_; w = w_; jsr = jsr_; jcong = jcong_; }

  // For a faster but lower quality RNG, uncomment the following
  // line, and comment out the original definition of rand_int above.
  // In practice, the faster RNG will be fine for simulations
  // that do not simulate more than a few billion random numbers.
  // ulong rand_int() { return SHR3(); }
  long rand_int31()          // [0,2^31-1]
    { return ((long) rand_int32() >> 1);}
  double rand_closed01()     // [0,1]
    { return ((double) rand_int() / double(ULONG_MAX)); }
  double rand_open01()       // (0,1)
    { return (((double) rand_int() + 1.0) / (ULONG_MAX + 2.0)); }
  double rand_halfclosed01() // [0,1)
    { return ((double) rand_int() / (ULONG_MAX + 1.0)); }
  double rand_halfopen01()   // (0,1]
    { return (((double) rand_int() + 1.0) / (ULONG_MAX + 1.0)); }

  // Continuous Distributions
  double uniform(double x = 0.0, double y = 1.0)
    { return rand_closed01() * (y - x) + x; }
  double normal(double mu = 0.0, double sd = 1.0)
    { return RNOR() * sd + mu; }
  double exponential(double lambda = 1)
    { return REXP() / lambda; }
  double gamma(double shape = 1, double scale = 1);
  double chi_square(double df)
    { return gamma(df / 2.0, 0.5); }
  double beta(double a1, double a2)
    { const double x1 = gamma(a1, 1); return (x1 / (x1 + gamma(a2, 1))); }

  void uniform(vector<double>& res, double x = 0.0, double y = 1.0) {
    for (vector<double>::iterator i = res.begin(); i != res.end(); ++i)
      *i = uniform(x, y);
  }
  void normal(vector<double>& res, double mu = 0.0, double sd = 1.0) {
    for (vector<double>::iterator i = res.begin(); i != res.end(); ++i)
      *i = normal(mu, sd);
  }
  void exponential(vector<double>& res, double lambda = 1) {
    for (vector<double>::iterator i = res.begin(); i != res.end(); ++i)
      *i = exponential(lambda);
  }
  void gamma(vector<double>& res, double shape = 1, double scale = 1) {
    for (vector<double>::iterator i = res.begin(); i != res.end(); ++i)
      *i = gamma(shape, scale);
  }
  void chi_square(vector<double>& res, double df) {
    for (vector<double>::iterator i = res.begin(); i != res.end(); ++i)
      *i = chi_square(df);
  }
  void beta(vector<double>& res, double a1, double a2) {
    for (vector<double>::iterator i = res.begin(); i != res.end(); ++i)
      *i = beta(a1, a2);
  }

  // Discrete Distributions
  int poisson(double mu);
  int binomial(double p, int n);
  void multinom(unsigned int n, const vector<double>& probs, vector<uint>& samp);
  void multinom(unsigned int n, const double* prob, uint K, uint* samp);

  void poisson(vector<int>& res, double lambda) {
    for (vector<int>::iterator i = res.begin(); i != res.end(); ++i)
      *i = poisson(lambda);
  }
  void binomial(vector<int>& res, double p, int n) {
    for (vector<int>::iterator i = res.begin(); i != res.end(); ++i)
      *i = binomial(p, n);
  }

}; // class RNG

#endif // RNG_H
//----- Importance sampling end ----//




// from MEME
#define BITS 64.0
#define LOGZERO -1e100			/* log of number close to zero */
#define LOGZEROI -2147483647		/* log of number close  zero (integer)*/
#define LOG_SUM1(logx, logy) (((((logy)<=LOGZERO) || ((logx)-(logy))>BITS)) ? \
    (logx) : (logx) + log( 1 + exp((logy) - (logx) ) ) )
#define LOG_SUM(logx, logy) ( ( (logx) > (logy) ) ? \
  LOG_SUM1( (logx), (logy) ) : LOG_SUM1( (logy), (logx) ) )



using namespace std;

// print vector
void print_vecd(vector<double> seq){
  
  cout << endl;
  for(int i=0; i< seq.size(); i++)
    cout << seq[i] << " " ;
  cout << endl;

}
void print_veci(vector<int> seq){
  
  cout << endl;
  for(int i=0; i< seq.size(); i++)
    cout << seq[i] << " " ;
  cout << endl;

}


// check whether vector contains specific element or not
bool is_element(vector<int> seq, int elt){

  bool res = false;
  for(int k = 0; k < seq.size(); k++){
    if(seq[k] == elt){
      res = true;
      break;
    }
  }
  return res; 
}



/*** NNI start ***/
// return the position of elt in seq
// if seq doesn't include elt, return -1
int where_element(vector<int> seq, int elt){

  int res = -1;
  for(int k = 0; k < seq.size(); k++){
    if(seq[k] == elt){
      res = k;
      break;
    }
  }
  return res; 
}
/*** NNI end ***/



// check whether two vectors with same size contain exactly same elements
bool same_vec(vector<int> seq1, vector<int> seq2){

  bool res = false;

  if(seq1.size()!= seq2.size()){

    cout << "ERROR! Two vectors sizes are different! " << endl;

  }else{

    int size = seq1.size();

    for(int k = 0; k < size; k++){
      res = is_element(seq2, seq1[k]);
      if(!res)
	break;
    }
  }

  return res; 
}



// Return sum of element in a vector
double sum_vec(vector<double> seq){

  double res = 0;
  for(int k = 0; k < seq.size(); k++){
    res += seq[k];
  }

  return res;

}



/**** NNI start ****/
// Return sum of element in a vector
int sum_veci(vector<int> seq){

  int res = 0;
  for(int k = 0; k < seq.size(); k++){
    res += seq[k];
  }

  return res;

}
/**** NNI end ****/





// Return maximum element in a vector
double max_vec(vector<double> seq){

  double max = seq[0];
  for(int k = 1; k < seq.size(); k++){
    max = MAX(max, seq[k]);
  }

  return max;

}


// Return maximum element in a vector
int max_veci(vector<int> seq){

  int max = seq[0];
  for(int k = 1; k < seq.size(); k++){
    max = MAX(max, seq[k]);
  }

  return max;

}



// Return position in a vector where minimum value resides
int which_min_vec(vector<double> seq){

  double min = seq[0];
  int min_posi = 0;
  for(int k = 1; k < seq.size(); k++){
    if(min > seq[k]){
      min_posi = k;
      min = seq[k];
    }
  }

  return min_posi;

}

//-- v34 start --//
// Return position in a vector where minimum value resides
int which_max_vec(vector<double> seq){

  double max = seq[0];
  int max_posi = 0;
  for(int k = 1; k < seq.size(); k++){
    if(max < seq[k]){
      max_posi = k;
      max = seq[k];
    }
  }

  return max_posi;

}
//-- v34 end --//


// return position where proportion > 0.5
// -1 if there's no position
//-- v34 start --//
int which_halfprop(vector<double> seq){

  double max = seq[0];
  int max_posi = 0;
  double sum;
  sum = seq[0];
  for(int k = 1; k < seq.size(); k++){
    sum += seq[k];
    if(max < seq[k]){
      max_posi = k;
      max = seq[k];
    }
  }

  if(seq[max_posi]/sum < 0.5)
    max_posi = -1;

  return max_posi;

}
//-- v34 end --//






//-- v30 start --//
// Return positions in a vector where maximum value resides
void which_max_vec(vector<int> seq, vector<int>& max_posi){

  max_posi.resize(0);

  double max = seq[0];
  max_posi.push_back(0);

  for(int k = 1; k < seq.size(); k++){
    if(max == seq[k])
      max_posi.push_back(k);
    else if(max < seq[k]){
      max = seq[k];
      max_posi.resize(0);
      max_posi.push_back(k);
    }
  }

}
//-- v30 end --//






bool equal(double A, double B){

  double diff = A - B;
  bool res; 
  if((diff < 1e-10) && (-1e-10 < diff))
    res = true;
  else 
    res = false;

  return res;
}





//  gamma.cpp -- computation of gamma function.
//      Algorithms and coefficient values from "Computation of Special
//      Functions", Zhang and Jin, John Wiley and Sons, 1996.
//
//  (C) 2003, C. Bond. All rights reserved.
//
// Returns gamma function of argument 'x'.
//
// NOTE: Returns 1e308 if argument is a negative integer or 0,
//      or if argument exceeds 171.
//
double gamma(double x)
{
    int i,k,m;
    double ga,gr,r,z;

    static double g[] = {
        1.0,
        0.5772156649015329,
       -0.6558780715202538,
       -0.420026350340952e-1,
        0.1665386113822915,
       -0.421977345555443e-1,
       -0.9621971527877e-2,
        0.7218943246663e-2,
       -0.11651675918591e-2,
       -0.2152416741149e-3,
        0.1280502823882e-3,
       -0.201348547807e-4,
       -0.12504934821e-5,
        0.1133027232e-5,
       -0.2056338417e-6,
        0.6116095e-8,
        0.50020075e-8,
       -0.11812746e-8,
        0.1043427e-9,
        0.77823e-11,
       -0.36968e-11,
        0.51e-12,
       -0.206e-13,
       -0.54e-14,
        0.14e-14};

    if (x > 171.0) return 1e308;    // This value is an overflow flag.
    if (x == (int)x) {
        if (x > 0.0) {
            ga = 1.0;               // use factorial
            for (i=2;i<x;i++) {
               ga *= i;
            }
         }
         else
            ga = 1e308;
     }
     else {
        if (fabs(x) > 1.0) {
            z = fabs(x);
            m = (int)z;
            r = 1.0;
            for (k=1;k<=m;k++) {
                r *= (z-k);
            }
            z -= m;
        }
        else
            z = x;
        gr = g[24];
        for (k=23;k>=0;k--) {
            gr = gr*z+g[k];
        }
        ga = 1.0/(gr*z);
        if (fabs(x) > 1.0) {
            ga *= r;
            if (x < 0.0) {
                ga = -M_PI/(x*ga*sin(M_PI*x));
            }
        }
    }
    return ga;
}




// lgamma.cpp -- log gamma function of real argument.
//      Algorithms and coefficient values from "Computation of Special
//      Functions", Zhang and Jin, John Wiley and Sons, 1996.
//
//  (C) 2003, C. Bond. All rights reserved.
//
//  Returns log(gamma) of real argument.
//  NOTE: Returns 1e308 if argument is 0 or negative.
//
double lgamma(double x)
{
    double x0,x2,xp,gl,gl0;
    int n,k;
    static double a[] = {
        8.333333333333333e-02,
       -2.777777777777778e-03,
        7.936507936507937e-04,
       -5.952380952380952e-04,
        8.417508417508418e-04,
       -1.917526917526918e-03,
        6.410256410256410e-03,
       -2.955065359477124e-02,
        1.796443723688307e-01,
       -1.39243221690590};
    
    x0 = x;
    if (x <= 0.0) return 1e308;
    else if ((x == 1.0) || (x == 2.0)) return 0.0;
    else if (x <= 7.0) {
        n = (int)(7-x);
        x0 = x+n;
    }
    x2 = 1.0/(x0*x0);
    xp = 2.0*M_PI;
    gl0 = a[9];
    for (k=8;k>=0;k--) {
        gl0 = gl0*x2 + a[k];
    }
    gl = gl0/x0+0.5*log(xp)+(x0-0.5)*log(x0)-x0;
    if (x <= 7.0) {
        for (k=1;k<=n;k++) {
            gl -= log(x0-1.0);
            x0 -= 1.0;
        }
    }
    return gl;
}
        



//---- importance sampling start -----//

ulong RNG::tm = 1234567;

//________________________________________________________________________
// RNG::RNOR generates normal variates with rejection.
// nfix() generates variates after rejection in RNOR.
// Despite rejection, this method is faster than Box-Muller.

double RNG::nfix(slong h, ulong i)
{
  const double r = 3.442620; 	// The starting of the right tail
  
  double x, y;
  for(;;) {
    x = h * wn[i];

    // If i == 0, handle the base strip
    if (i == 0) {
      do {
	x = -log(rand_open01()) * 0.2904764;   // .2904764 is 1/r
	y = -log(rand_open01());
      } while (y + y < x * x);
      return ((h > 0) ? r + x : -r - x);
    }
    
    // If i > 0, handle the wedges of other strips
    if (fn[i] + rand_open01() * (fn[i - 1] - fn[i]) < exp(-.5 * x * x))
      return x;
    
    // start all over
    h = UL32toSL32(rand_int32());
    i = h & 127;
    if (ULONG32(std::abs(h)) < kn[i])
      return (h * wn[i]);
  }

} // RNG::nfix

// __________________________________________________________________________
// RNG::REXP generates exponential variates with rejection.
// efix() generates variates after rejection in REXP.
  
double RNG::efix(ulong j, ulong i)
{
  for (;;) {
    if (i == 0)
      return (7.69711 - log(rand_open01()));
    
    const double x = j * we[i];
    if (fe[i] + rand_open01() * (fe[i - 1] - fe[i]) < exp(-x)) 
      return x;
    
    j = rand_int32();
    i = (j & 255);
    if (j < ke[i])
      return (j * we[i]);	
  }
  
} // RNG::efix

// __________________________________________________________________________
// This procedure creates the tables used by RNOR and REXP

void RNG::zigset()
{
  static bool inited = 0;
  if (inited)
    return;
  inited = 1;
  
  // Set up tables for RNOR
  const double m1 = 2147483648.0; // 2^31
  const double vn = 9.91256303526217e-3;
  double tn = 3.442619855899;
  double q = vn / exp(-.5 * tn * tn);
  kn[0] = ULONG32((tn / q) * m1); kn[1] = 0;
  wn[0] = q / m1; wn[127] = tn / m1;
  fn[0]=1.; fn[127] = exp(-.5 * tn * tn);		
  for (uint i = 126; i > 0; i--) {
    const double dn = sqrt(-2 * log(vn / tn + exp(-.5 * tn * tn)));
    kn[i + 1] = ULONG32((dn / tn) * m1);
    fn[i] = exp(-.5 * dn * dn);        
    wn[i] = dn / m1;
    tn = dn;
  }
  
  // Set up tables for REXP
  const double m2 = 4294967296.0; // 2^32
  const double ve = 3.949659822581572e-3;
  double te = 7.697117470131487;
  q = ve / exp(-te);
  ke[0] = ULONG32((te / q) * m2); ke[1] = 0;
  we[0] = q / m2; we[255] = te / m2;
  fe[0] = 1.; fe[255] = exp(-te);		
  for (uint i = 254; i > 0; i--) {
    const double de = -log(ve / te + exp(-te));
    ke[i+1] = ULONG32((de / te) * m2);
    fe[i] = exp(-de);
    we[i] = de / m2;
    te = de;
  }

} // RNG::zigset

// __________________________________________________________________________
// Generate a gamma variate with parameters 'shape' and 'scale'

double RNG::gamma(double shape, double scale)
{
  if (shape < 1.)
    return gamma(shape + 1., scale) * pow(rand_open01(), 1.0 / shape);

  const double d = shape - 1. / 3.;
  const double c = 1. / sqrt(9. * d);
  double x, v;
  for (;;) {
    do {
      x = RNOR();
      v = 1.0 + c * x;
    } while (v <= 0.0);
    v = v * v * v;
    const double u = rand_open01();
    const double x2 = x * x;
    if (u < 1.0 - 0.0331 * x2 * x2)
      return (d * v / scale);
    if (log(u) < 0.5 * x2 + d * (1.0 - v + log(v)))
      return (d * v / scale);
  }

} // RNG::gamma

// __________________________________________________________________________
// Generate a Poisson variate 
// Code essentially copied from R source that is essentially
// ACM Algorithm 599 KPOISS converted to C.

int RNG::poisson(double mu)
{
  const double a0=-0.5, a1= 0.3333333, a2=-0.2500068, a3= 0.2000118,
    a4=-0.1661269, a5= 0.1421878, a6=-0.1384794, a7= 0.1250060;

  const double one_7 = 1.0 / 7.0, one_12 = 1.0 / 12.0, one_24 = 1.0 / 24.0;

  const double fact[10] =
    { 1., 1., 2., 6., 24., 120., 720., 5040., 40320., 362880.  };

  static int l, m;

  static double b1, b2, c, c0, c1, c2, c3;
  static double pp[36], p0, p, q, s, d, omega;
  static double big_l;/* integer "w/o overflow" */
  static double muprev = 0., muprev2 = 0.;/*, muold     = 0.*/

  double del, difmuk= 0., E= 0., fk= 0., fx, fy, g, px, py, t, u= 0., v, x;
  int pois = -1;
  int k, kflag, big_mu, new_big_mu = 0;

  if (mu <= 0.)
    return 0;

  big_mu = mu >= 10.;
  if(big_mu)
    new_big_mu = 0;

  if (!(big_mu && mu == muprev)) {

    if (big_mu) {
      new_big_mu = 1;
      muprev = mu;
      s = sqrt(mu);
      d = 6. * mu * mu;
      big_l = floor(mu - 1.1484);
    }
    else {
      if (mu != muprev) {
        muprev = mu;
        m = (int) ((1.0 < mu) ? mu : 1.0);
        l = 0; /* pp[] is already ok up to pp[l] */
        q = p0 = p = exp(-mu);
      }

      for (;;) {
        u = rand_open01();
        if (u <= p0)
          return 0;

        if (l != 0) {
          for (k = (u <= 0.458) ? 1 : ((l < m) ? l : m);  k <= l; k++)
            if (u <= pp[k])
              return k;
          if (l == 35) /* u > pp[35] */
            continue;
        }
        l++;
        for (k = l; k <= 35; k++) {
          p *= mu / k;
          q += p;
          pp[k] = q;
          if (u <= q) {
            l = k;
            return k;
          }
        }
        l = 35;
      }
    }

  }

  g = mu + s * RNOR();
  if (g >= 0.) {
    pois = int(g);
    if (pois >= big_l)
      return pois;
    fk = pois;
    difmuk = mu - fk;
    u = rand_open01();
    if (d * u >= difmuk * difmuk * difmuk)
      return pois;
  }

  if (new_big_mu || mu != muprev2) {
    muprev2 = mu;
    omega = 1.0 / (sqrt(2.0 * PI) * s);
    b1 = one_24 / mu;
    b2 = 0.3 * b1 * b1;
    c3 = one_7 * b1 * b2;
    c2 = b2 - 15. * c3;
    c1 = b1 - 6. * b2 + 45. * c3;
    c0 = 1. - b1 + 3. * b2 - 15. * c3;
    c = 0.1069 / mu;
  }

  if (g >= 0.) {
    kflag = 0;
    goto Step_F;
  }


  for (;;) {
    E = REXP();
    u = 2 * rand_open01() - 1.;
    t = 1.8 + ((u > 0) ? std::abs(E) : -std::abs(E));
    if (t > -0.6744) {
      pois = int(mu + s * t);
      fk = pois;
      difmuk = mu - fk;
      kflag = 1;
Step_F:
      if (pois < 10) {
        px = -mu;
        py = pow(mu, pois) / fact[pois];
      }
      else {
        del = one_12 / fk;
        del = del * (1. - 4.8 * del * del);
        v = difmuk / fk;
        if (std::abs(v) <= 0.25)
          px = fk * v * v * (((((((a7 * v + a6) * v + a5) * v + a4) *
                      v + a3) * v + a2) * v + a1) * v + a0)
            - del;
        else
          px = fk * log(1. + v) - difmuk - del;
        py = 1.0 / (sqrt(2.0 * PI) * sqrt(fk));
      }
      x = (0.5 - difmuk) / s;
      x *= x;/* x^2 */
      fx = -0.5 * x;
      fy = omega * (((c3 * x + c2) * x + c1) * x + c0);
      if (kflag > 0) {
        if (c * std::abs(u) <= py * exp(px + E) - fy * exp(fx + E))
          break;
      } else
        if (fy - u * fy <= py * exp(px - fx))
          break;
    }
  }
  return pois;

} // RNG::poisson

// __________________________________________________________________________
// Generate a binomial variate 
// Code essentially copied from R source that is essentially
// ACM Algorithm 678 BTPEC converted to C.

int RNG::binomial(double pp, int n)
{
  static double c, fm, npq, p1, p2, p3, p4, qn, xl, xll, xlr, xm, xr;

  static double psave = -1.0;
  static int nsave = -1, m = 0;

  double f, x;

  if (n <= 0 || pp <= 0.) return 0;
  if (pp >= 1.) return n;

  const double p = (pp < 1. - pp) ? pp : 1. - pp;
  const double q = 1. - p;
  const double np = n * p;
  const double r = p / q;
  const double g = r * (n + 1);

  if (pp != psave || n != nsave) {
    psave = pp;
    nsave = n;
    if (np < 30.0) {
      qn = pow(q, (double) n);
      goto L_np_small;
    } else {
      double ffm = np + p;
      m = (int) ffm;
      fm = m;
      npq = np * q;
      p1 = (int)(2.195 * sqrt(npq) - 4.6 * q) + 0.5;
      xm = fm + 0.5;
      xl = xm - p1;
      xr = xm + p1;
      c = 0.134 + 20.5 / (15.3 + fm);
      double al = (ffm - xl) / (ffm - xl * p);
      xll = al * (1.0 + 0.5 * al);
      al = (xr - ffm) / (xr * q);
      xlr = al * (1.0 + 0.5 * al);
      p2 = p1 * (1.0 + c + c);
      p3 = p2 + c / xll;
      p4 = p3 + c / xlr;
    }
  } else if (n == nsave) {
    if (np < 30.0)
      goto L_np_small;
  }

  int i, ix;
  for (;;) {
    double u = rand_open01() * p4;
    double v = rand_open01();
    if (u <= p1) {
      ix = (int) (xm - p1 * v + u);
      goto finish;
    }
    if (u <= p2) {
      x = xl + (u - p1) / c;
      v = v * c + 1.0 - std::abs(xm - x) / p1;
      if (v > 1.0 || v <= 0.)
        continue;
      ix = (int) x;
    } else {
      if (u > p3) {
        ix = (int) (xr - log(v) / xlr);
        if (ix > n)
          continue;
        v *= (u - p3) * xlr;
      } else {/* left tail */
        ix = (int) (xl + log(v) / xll);
        if (ix < 0)
          continue;
        v *= (u - p2) * xll;
      }
    }
    int k = std::abs(ix - m);
    if (k <= 20 || k >= npq / 2 - 1) {
      f = 1.0;
      if (m < ix) {
        for (i = m + 1; i <= ix; i++)
          f *= (g / i - r);
      } else if (m != ix) {
        for (i = ix + 1; i <= m; i++)
          f /= (g / i - r);
      }
      if (v <= f)
        goto finish;
    } else {
      double amaxp, ynorm, alv;
      amaxp = (k / npq) * ((k * (k / 3. + 0.625) + 0.1666666666666) /
               npq + 0.5);
      ynorm = -k * k / (2.0 * npq);
      alv = log(v);
      if (alv < ynorm - amaxp)
        goto finish;
      if (alv <= ynorm + amaxp) {
        double x1, f1, z, w, z2, x2, f2, w2;
        x1 = ix + 1;
        f1 = fm + 1.0;
        z = n + 1 - fm;
        w = n - ix + 1.0;
        z2 = z * z;
        x2 = x1 * x1;
        f2 = f1 * f1;
        w2 = w * w;
        if (alv <= xm * log(f1 / x1) + (n - m + 0.5) * log(z / w) +
	  (ix - m) * log(w * p / (x1 * q)) + (13860.0 - (462.0 -
	  (132.0 - (99.0 - 140.0 / f2) / f2) / f2) / f2) / f1 / 166320.0 +
	  (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / z2) / z2) / z2) / z2) /
	  z / 166320.0 + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / x2) /
	  x2) / x2) / x2) / x1 / 166320.0 + (13860.0 - (462.0 - (132.0 -
	  (99.0 - 140.0 / w2) / w2) / w2) / w2) / w / 166320.)
          goto finish;
      }
    }
  }

 L_np_small:
  for (;;) {
    ix = 0;
    f = qn;
    double u = rand_open01();
    for (;;) {
      if (u < f)
        goto finish;
      if (ix > 110)
        break;
      u -= f;
      ix++;
      f *= (g / ix - r);
    }
  }

 finish:
  if (psave > 0.5)
     ix = n - ix;
  return ix;

} // RNG::binomial

// __________________________________________________________________________

// Generate a sample of size 'n' from a multinomial distribution with
// probabilities given in 'probs'.  Inspired by R source code.

void RNG::multinom(uint n, const vector<double>& probs, vector<uint>& samp)
{
  samp.resize(probs.size());
  RNG::multinom(n, &probs[0], (uint) probs.size(), &samp[0]);
}

void RNG::multinom(uint size, const double* probs, uint num_probs, uint* samp)
{
  if (num_probs == 0) return;
  for (uint i = 0; i < num_probs; i++) samp[i] = 0;
  if (size == 0) return;

  vector<double> fixed_probs(num_probs);
  double total_prob = 0.;
  for (uint i = 0; i < num_probs; i++) {
    const double pp = probs[i];
    //if (std::isfinite(pp) && pp >= 0)
    if ((pp == pp) && pp >= 0)
      total_prob += (fixed_probs[i] = pp);
  }

  if (total_prob == 0.) return;

  for (uint i = 0; i < num_probs-1; i++) {
    if (fixed_probs[i] > 0.) {
      samp[i] = binomial(fixed_probs[i] / total_prob, size);
      size -= samp[i];
    }
    if (size == 0) return;
    total_prob -= fixed_probs[i];
  }
  samp[num_probs - 1] = size;

} // RNG::multinomial

// __________________________________________________________________________
// rng.C

//----------- importance sampling END --------------------//






class Edge_HMG;


class Node_HMG{
public:
  Node_HMG(int n, bool r, vector<int> HMG) {
    number = n;
    root = r;
    hmg = HMG;
    count = 1;
    proportion = 0;
    visit = false;
    hasLeftEdge = false;
    hasRightEdge = false;
    hasParentEdge = false;
  }
  ~Node_HMG() {}
  void setLeftEdge(Edge_HMG* l) { LeftEdge = l; }
  void setRightEdge(Edge_HMG* r) { RightEdge = r; }
  void setParentEdge(Edge_HMG* p) { ParentEdge = p; }
  void setHasLeftEdge(bool l) { hasLeftEdge = l; }
  void setHasRightEdge(bool r) { hasRightEdge = r; }
  void setHasParentEdge(bool p) { hasParentEdge = p; }  
  void setCount(int c) { count = c; }
  void incCount() { count++; }
  bool getRoot() const { return root; }
  int getCount() { return count; }
  Edge_HMG* getLeftEdge() const { return LeftEdge; }
  Edge_HMG* getRightEdge() const { return RightEdge; }
  Edge_HMG* getParentEdge() const { return ParentEdge; }
  bool getHasLeftEdge() const { return hasLeftEdge; }
  bool getHasRightEdge() const { return hasRightEdge; }
  bool getHasParentEdge() const { return hasParentEdge; }  
  vector<int> getHMG() { return hmg; }
  Node_HMG* getParent();
  Node_HMG* getLeftChild();
  Node_HMG* getRightChild();
  bool getVisit() const { return visit; }
  void setVisit(bool v) { visit = v; }
  int getnumber() const { return number; }
  void calProportion(int total) { proportion = count/(double)total; }
  double getProportion() const { return proportion; }
private:
  int number;
  bool root;
  vector<int> hmg;
  int count;
  double proportion;
  bool visit;
  bool hasLeftEdge;
  bool hasRightEdge;
  bool hasParentEdge;
  Edge_HMG* LeftEdge;
  Edge_HMG* RightEdge;
  Edge_HMG* ParentEdge;
};


class Edge_HMG{
public:
  Edge_HMG(int n) {
    number = n;
  }
  Edge_HMG(int n, Node_HMG* s,Node_HMG* e) { 
    number = n;
    Start = s;
    End = e;
  }
  ~Edge_HMG() {}
  int getnumber() const { return number; }
  void setStart(Node_HMG* s) {
    Start = s;
  }
  void setEnd(Node_HMG* e) {
    End = e;
  }  
  Node_HMG* getStart() const { return Start; }
  Node_HMG* getEnd() const { return End; }  
private:
  int number;
  Node_HMG* Start;
  Node_HMG* End;
};





class Tree_HMG{
public:
  Tree_HMG(){
    numNodes = 0;
    numEdges = 0;
    nodes.resize(0);
    edges.resize(0);
    //nodes.push_back(new Node_HMG(numNodes++, true, hmg)); 
  }
  ~Tree_HMG() {
    for(vector<Node_HMG*>::iterator p=nodes.begin();p!=nodes.end();p++)
      delete *p;
    nodes.resize(0);
    for(vector<Edge_HMG*>::iterator p=edges.begin();p!=edges.end();p++)
      delete *p;
    edges.resize(0);
  }
  int getNumNodes() const { return numNodes; }
  void createRoot(vector<int> );
  void createLeftChild(Node_HMG*, vector<int>);
  void createRightChild(Node_HMG*, vector<int>);
  int compareHMGs(vector<int>, vector<int>);
  int compareHMGsWithInconclusive(vector<int>, vector<int>);
  void insertHMG(Node_HMG*, vector<int>);
  void constructHMGTree(vector<vector<int> >);
  void GetProportion(int MCnum);
  void getOrderedSigTreeHMG(vector<vector<int> >&);
  void getOrderedTreeHMG(vector<vector<int> >&);
  void printAllHMGtoCheck(ofstream&);
  void printAllHMG(ofstream&);
  void reOrderHMGs(vector<vector<int> >&);
private:
  int numNodes;
  int numEdges;
  Node_HMG* root;
  vector<Node_HMG*> nodes;
  vector<Edge_HMG*> edges;
};




Node_HMG* Node_HMG::getParent(){
  return getParentEdge()->getStart(); }
Node_HMG* Node_HMG::getLeftChild(){
  return getLeftEdge()->getEnd(); }
Node_HMG* Node_HMG::getRightChild(){
  return getRightEdge()->getEnd(); }

void Tree_HMG::createRoot(vector<int> HMG){

  nodes.push_back(new Node_HMG(numNodes++, true, HMG));
  root = nodes[0];

}


void Tree_HMG::createRightChild(Node_HMG* cNode, vector<int> HMG){

  nodes.push_back(new Node_HMG(numNodes++, false, HMG));
  edges.push_back(new Edge_HMG(numEdges++, cNode, nodes[numNodes-1]));
  cNode->setRightEdge(edges[numEdges-1]);
  cNode->setHasRightEdge(true);
  nodes[numNodes-1]->setParentEdge(edges[numEdges-1]);
  nodes[numNodes-1]->setHasParentEdge(true);  

}

void Tree_HMG::createLeftChild(Node_HMG* cNode, vector<int> HMG){

  //cout << "createLeftChild 1" << endl;
  nodes.push_back(new Node_HMG(numNodes++, false, HMG));
  //cout << "createLeftChild 2" << endl;
  edges.push_back(new Edge_HMG(numEdges++, cNode, nodes[numNodes-1]));
  //cout << "createLeftChild 3" << endl;
  cNode->setLeftEdge(edges[numEdges-1]);
  //cout << "createLeftChild 4" << endl;
  cNode->setHasLeftEdge(true);
  //cout << "createLeftChild 5" << endl;
  nodes[numNodes-1]->setParentEdge(edges[numEdges-1]);
  //cout << "createLeftChild 6" << endl;
  nodes[numNodes-1]->setHasParentEdge(true);
  //cout << "createLeftChild 7" << endl;
}





// HMG1 < HMG2  return 1
// HMG1 = HMG2  return 0
// HMG1 > HMG2  return -1
int Tree_HMG::compareHMGs(vector<int> HMG1, vector<int> HMG2){

  int lenHMG1 = HMG1.size();
  int lenHMG2 = HMG2.size();
  int i;
  int res = 0;

  if(lenHMG1 != lenHMG2){
    cout << "ERROR in Tree_HMG::compareHMGs! Sizes of two HMGs should be same." << endl;
  }else{
    for(i = 0; i < lenHMG1; i++){
      if((HMG1[i] >= 0) & (HMG2[i] >= 0)){
	if(HMG1[i] < HMG2[i]){
	  res = 1;
	  break;
	}else if(HMG1[i] > HMG2[i]){
	  res = -1;
	  break;	
	}
      }
    }
    if(res == 0){
      for(i = 0; i < lenHMG1; i++){
	if(HMG1[i] < HMG2[i]){
	  res = 1;
	  break;
	}else if(HMG1[i] > HMG2[i]){
	  res = -1;
	  break;	
	}
      }
    }     
  }

  return res;

}

    



// HMG1 < HMG2  return 1
// Inconclusive  return 0
// HMG1 > HMG2  return -1
int Tree_HMG::compareHMGsWithInconclusive(vector<int> HMG1, vector<int> HMG2){

  int lenHMG1 = HMG1.size();
  int lenHMG2 = HMG2.size();
  int i;
  int res = 0;

  if(lenHMG1 != lenHMG2){
    cout << "ERROR in Tree_HMG::compareHMGs! Sizes of two HMGs should be same." << endl;
  }else{
    for(i = 0; i < lenHMG1; i++){
      if((HMG1[i] >= 0) & (HMG2[i] >= 0)){
	if(HMG1[i] < HMG2[i]){
	  res = 1;
	  break;
	}else if(HMG1[i] > HMG2[i]){
	  res = -1;
	  break;	
	}
      }
    }
  }

  return res;

}





void Tree_HMG::reOrderHMGs(vector<vector<int> > &alignS){




  //int i, j, k;
  int i, j;
  int numHMGs = alignS.size();
  //int numLeaves = alignS[0].size();
  //int max;
  //int maxPosi;

  vector<int> temp(0);
  int res; 

  for(i = 1 ; i < numHMGs ; i++){
    res = compareHMGsWithInconclusive(alignS[i-1], alignS[i]);
    if(res!=1){
      if(i == 1){
	if(res == -1){
	  temp = alignS[i];
	  alignS.erase(alignS.begin() + i);
	  alignS.insert(alignS.begin() + i - 1, temp);
	  temp.resize(0);
        }
      }else{
	for(j = (i-2); j >= 0; j--){
	  res = compareHMGsWithInconclusive(alignS[j], alignS[i]);
	  if(res==1){
	    temp = alignS[i];
	    alignS.erase(alignS.begin() + i);
	    alignS.insert(alignS.begin() + j + 1, temp);
	    temp.resize(0);	    
	    break;
          }
        }
	if(res!=1){
	  temp = alignS[i];
	  alignS.erase(alignS.begin() + i);
	  alignS.insert(alignS.begin() + 0, temp);
	  temp.resize(0); 
        }
      }
    }
  }

}



void Tree_HMG::insertHMG(Node_HMG* cNode, vector<int> HMG){

  int res; 

  //cout << "insertHMG 1" << endl;

  res = compareHMGs(cNode->getHMG(), HMG);

  //cout << "insertHMG 2" << endl;

  if(res == 1){

    //cout << "insertHMG res = 1" << endl;
    
    if(cNode->getHasRightEdge()){
      //cout << "insertHMG 4" << endl;
      insertHMG(cNode->getRightChild(), HMG);
      //cout << "insertHMG 5" << endl;
    }else{
      //cout << "insertHMG 6" << endl;
      createRightChild(cNode, HMG);
      //cout << "insertHMG 7" << endl;
    }
    //cout << "insertHMG 8" << endl;
    
    
  }else if(res == -1){

    //cout << "insertHMG res = - 1" << endl;

    if(cNode->getHasLeftEdge()){
      //cout << "insertHMG 10" << endl;
      Node_HMG* A = cNode->getLeftChild();
      //cout << "insertHMG 10.1" << endl;
      insertHMG(A, HMG);
      //cout << "insertHMG 11" << endl;
    }else{
      //cout << "insertHMG 12" << endl;
      createLeftChild(cNode, HMG);
      //cout << "insertHMG 13" << endl;
    }
    //cout << "insertHMG 14" << endl;
    
  }else if(res == 0){

    //cout << "insertHMG res == 0" << endl;

    cNode->incCount();
    //cout << "insertHMG 16" << endl;

  }else{

    cout << "ERROR in Tree_HMG::insertHMG! res should be one of -1, 1, or 0." << endl;
 
  }

  //cout << "insertHMG 17" << endl;

}



void Tree_HMG::constructHMGTree(vector<vector<int> > HMG){

  int lenHMG = HMG.size();
  int midPosi = (lenHMG+1) / 2;
  int i;
  // save from (midPosi - 1) to 0 and from midPosi to (lenHMG - 1)


  //cout << "constructHMGTree 1" << endl;
  //cout << "lenHMG : " << lenHMG << " midPosi : " << midPosi << endl;

  if(getNumNodes()==0){ // create root
 

    //cout << "constructHMGTree 2" << endl;

    createRoot(HMG[midPosi - 1]);
    //cout << "constructHMGTree 3" << endl;
    
    for(i = (midPosi - 2); i >= 0; i--){
      //cout << "constructHMGTree 3.0" << endl;
      insertHMG(root, HMG[i]);
      //cout << "constructHMGTree 3.1" << endl;
    }
    //cout << "constructHMGTree 4" << endl;
    for(i = midPosi ; i <= (lenHMG - 1); i++){
      //cout << "constructHMGTree 4.0" << endl;
      insertHMG(root, HMG[i]); 
      //cout << "constructHMGTree 4.1" << endl;
    }

    //cout << "constructHMGTree 5" << endl;



  }else{   // root is already created

    //cout << "constructHMGTree 6" << endl;

    for(i = (midPosi - 1); i >= 0; i--){
      insertHMG(root, HMG[i]);
      //cout << "constructHMGTree 6.1" << endl;
    }

    //cout << "constructHMGTree 7" << endl;
    for(i = midPosi ; i <= (lenHMG - 1); i++){
      insertHMG(root, HMG[i]);       
      //cout << "constructHMGTree 7.1" << endl;
    }

    
    //cout << "constructHMGTree 8" << endl;
  } 


  
  //cout << "constructHMGTree 9" << endl;
}

void Tree_HMG::GetProportion(int MCnum){

  for(int i = 0; i < numNodes; i++){
    nodes[i]->calProportion(MCnum);
  }

}


void Tree_HMG::getOrderedTreeHMG(vector<vector<int> > &alignS){

  bool done = false;
  Node_HMG* cNode = root;

  //cout << "A1 " << endl;
  while(cNode->getHasLeftEdge()){
    //cout << "A2 " << endl;
    cNode = cNode->getLeftChild();
  }

  while(!cNode->getHasLeftEdge()){
    //cout << "A3 " << endl;
    //if(cNode->getProportion() > 0.5)
      alignS.push_back(cNode->getHMG());
    cNode->setVisit(true);
    //cout << "A4 " << endl;

    while(!cNode->getHasRightEdge()){

      //cout << "A5 " << endl;
      while(cNode->getHasParentEdge()){

	//cout << "A6 " << endl;
  
	cNode = cNode->getParent();
	


	//cout << "A7 : " << cNode->getnumber() << endl;
	if(!cNode->getVisit()){
	  //cout << "A8 " << endl;
	  break;
        }
	
	//cout << "A9 " << endl;
      }
      //cout << "A10 " << endl;
      
      if(!cNode->getVisit()){
	//cout << "A12 " << endl;
      //if(cNode->getProportion() > 0.5)
	alignS.push_back(cNode->getHMG());
	cNode->setVisit(true);
      }else{
	//cout << "A11 " << endl;
	done = true;
	break;
      }
      //cout << "A13 " << endl;

    }  

    if(done){
      //cout << "A14 " << endl;
      break;
    }

    //cout << "A15 " << endl;
  
    cNode = cNode->getRightChild();


    //cout << "A16 " << endl;

    while(cNode->getHasLeftEdge()){
      //cout << "A17 " << endl;
      cNode = cNode->getLeftChild();
    }
    //cout << "A18 " << endl;

  }    
  //cout << "A19 " << endl;
  
  
}




void Tree_HMG::getOrderedSigTreeHMG(vector<vector<int> > &alignS){

  bool done = false;
  Node_HMG* cNode = root;

  //cout << "A1 " << endl;
  while(cNode->getHasLeftEdge()){
    //cout << "A2 " << endl;
    cNode = cNode->getLeftChild();
  }

  while(!cNode->getHasLeftEdge()){
    //cout << "A3 " << endl;
    if(cNode->getProportion() > 0.5)
      alignS.push_back(cNode->getHMG());
    cNode->setVisit(true);
    //cout << "A4 " << endl;

    while(!cNode->getHasRightEdge()){

      //cout << "A5 " << endl;
      while(cNode->getHasParentEdge()){

	//cout << "A6 " << endl;
  
	cNode = cNode->getParent();
	


	//cout << "A7 : " << cNode->getnumber() << endl;
	if(!cNode->getVisit()){
	  //cout << "A8 " << endl;
	  break;
        }
	
	//cout << "A9 " << endl;
      }
      //cout << "A10 " << endl;
      
      if(!cNode->getVisit()){
	//cout << "A12 " << endl;
	if(cNode->getProportion() > 0.5)
	  alignS.push_back(cNode->getHMG());
	cNode->setVisit(true);
      }else{
	//cout << "A11 " << endl;
	done = true;
	break;
      }
      //cout << "A13 " << endl;

    }  

    if(done){
      //cout << "A14 " << endl;
      break;
    }

    //cout << "A15 " << endl;
  
    cNode = cNode->getRightChild();


    //cout << "A16 " << endl;

    while(cNode->getHasLeftEdge()){
      //cout << "A17 " << endl;
      cNode = cNode->getLeftChild();
    }
    //cout << "A18 " << endl;

  }    
  //cout << "A19 " << endl;
  
  
}




void Tree_HMG::printAllHMG(ofstream& c){

  int i, j, len;

  c << "\n" << "print All HMG information! " << endl;   
  for(i = 0; i < numNodes; i++){
    len = nodes[i]->getHMG().size();
    for(j = 0; j < len; j++)
      c << nodes[i]->getHMG()[j] << " ";
    c << nodes[i]->getCount() << endl;

  }

}




void Tree_HMG::printAllHMGtoCheck(ofstream& c){

  int i, j, len;

  c << "\n" << "print All HMG information! " << endl;   
  for(i = 0; i < numNodes; i++){
    c << "Node i : " << i << endl;
    len = nodes[i]->getHMG().size();
    for(j = 0; j < len; j++)
      c << nodes[i]->getHMG()[j] << " ";
    c << endl;
    c << "Count : " << nodes[i]->getCount() << endl;
    c << "Proportion : " << nodes[i]->getProportion() << endl;
    c << "Root : " << nodes[i]->getRoot() << endl;
    c << "Visit : " << nodes[i]->getVisit() << endl;
    c << "Parent Edge : ";
    if(nodes[i]->getHasParentEdge())
      c << nodes[i]->getParentEdge()->getnumber() << endl;
    else
      c << "-1" << endl;
    c << "Left Edge : ";
    if(nodes[i]->getHasLeftEdge())
      c << nodes[i]->getLeftEdge()->getnumber() << endl;
    else
      c << "-1" << endl;
    c << "Right Edge : ";
    if(nodes[i]->getHasRightEdge())
      c << nodes[i]->getRightEdge()->getnumber() << endl;
    else
      c << "-1" << endl;
  }
  for(i = 0; i < numEdges; i++){
    c << "Edge i : " << i << endl;
    c << "Start : " << edges[i]->getStart()->getnumber() << endl;
    c << "End : " << edges[i]->getEnd()->getnumber() << endl;
  }
}





      



class Edge;


class Rand{
public:
  Rand(unsigned int seed1 = 1234, unsigned int seed2 = 5678) : I1(seed1), I2(seed2){}
  void setSeed(unsigned int i1 = 1234, unsigned int i2 = 5678){ I1 = i1; I2 = i2;}
  //void getSeed(unsigned int& i1 = 1234, unsigned int& i2){ i1 = I1; i2 = I2;} 
  double runif(){

    I1 = 36969*(I1 & 0177777) + (I1>>16);
    I2 = 18000*(I2 & 0177777) + (I2>>16);
   
    return ((I1 << 16)^(I2 & 0177777))*2.328306437080797e-10;
  }
  int rgeom(double p);
  int rgeom0(double p);
  int rTRgeom(double p, int N);
  int rwunif(vector<double> weight);
  //-- v30 start --//
  int rwunif(vector<int> weight);
  //-- v30 end --//
  double rRatioOfExps(double epsilon);
  vector<double> rDirichlet(vector<double> alpha, RNG&);
private:
  unsigned int I1, I2;
  vector<double> sumwt;
};



class GEO{
public:
  double den1(int x, double r){ return r*(pow((1-r),x)); } // 0, 1, 2, ..
  double den2(int x, double r){ return r*(pow((1-r),(x-1))); } // 1, 2, ..
  double cum2(int x, double r){ return 1-(pow((1-r),x));}
  double del2(int x, double r){ return x - ((1-r)*(1-pow((1-r),x))/r);}
private:
};






//-- v27 start --//
/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated from file aligner.xml (author:  Gerton Lunter ) on Sat Apr 25 19:05:34 CDT 2009 */

/*
This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
Copyright (C) 2006 by Gerton Lunter, Oxford University.

HMMoC and works based on it are free software; you can redistribute 
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

HMMOC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HMMoC; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/








class Parameters{
public:
  void setParameters(double r, double ri, double rd, double lambda, double mu, double gamma, vector<double> pi){ r_in = r; ri_in = ri; rd_in = rd; lambda_in = lambda; mu_in = mu; pi_in = pi; gamma_in = gamma;}
  void setGamma(double gamma) { gamma_in = gamma; }
  double getGamma() const { return gamma_in; }
  void setR(double r) { r_in = r; }
  double getR() const { return r_in; }
  void setRi(double ri) { ri_in = ri; }
  double getRi() const { return ri_in; }
  void setRd(double rd) { rd_in = rd; }
  double getRd() const { return rd_in; }
  void setLambda(double lambda) { lambda_in = lambda; }
  double getLambda() const { return lambda_in; }
  void setMu(double mu) { mu_in = mu; }
  double getMu() const { return mu_in; }  
  double getDelta() const { return delta_in; }
  void setDelta(double delta) { delta_in = delta; }
  void setZeta(double zeta){ zeta_in = zeta; }
  double getZeta() const { return zeta_in; }
  void setWindowLen(double windowLen){ windowLen_in = windowLen; }
  double getWindowLen() const { return windowLen_in; } 
  void setWindowLen_UpIDHonEdge(double windowLen_UpIDHonEdge){ windowLen_UpIDHonEdge_in = windowLen_UpIDHonEdge; }
  double getWindowLen_UpIDHonEdge() const { return windowLen_UpIDHonEdge_in; }
  void setWindowLen_UpIDHonEdgeLike(double windowLen_UpIDHonEdgeLike){ windowLen_UpIDHonEdgeLike_in = windowLen_UpIDHonEdgeLike; }
  double getWindowLen_UpIDHonEdgeLike() const { return windowLen_UpIDHonEdgeLike_in; } 
  void setWindowLen_SPRonSubTreeWithinWindow(double windowLen_SPRonSubTreeWithinWindow){ windowLen_SPRonSubTreeWithinWindow_in = windowLen_SPRonSubTreeWithinWindow; }
  double getWindowLen_SPRonSubTreeWithinWindow() const { return windowLen_SPRonSubTreeWithinWindow_in; } 
  void setWindowLen_SPRonSubTreeWithTargetWithinWindow(double windowLen_SPRonSubTreeWithTargetWithinWindow){ windowLen_SPRonSubTreeWithTargetWithinWindow_in = windowLen_SPRonSubTreeWithTargetWithinWindow; }
  double getWindowLen_SPRonSubTreeWithTargetWithinWindow() const { return windowLen_SPRonSubTreeWithTargetWithinWindow_in; } 

  void setPi(vector<double> pi) { pi_in = pi; }
  vector<double> getPi() const { return pi_in; }
  double getPi(int posi) const { 
    if(posi >= pi_in.size()){
      cout << "ERROR in getPi(posi)! Not available position." << endl;
    }else{
      return pi_in[posi]; }
  }
  // for JK model
  void setQ(vector<vector<double> > Q) { Q_in = Q; }
  vector<vector<double> > getQ() const { return Q_in; }  
  // for HKY substitution model
  void setKappa(double kappa) { kappa_in = kappa; }
  double getKappa() const { return kappa_in; }

  void setSPRonSubTreeWithTarget_c(double SPRonSubTreeWithTarget_c) { SPRonSubTreeWithTarget_c_in = SPRonSubTreeWithTarget_c; }
  double getSPRonSubTreeWithTarget_c() const { return SPRonSubTreeWithTarget_c_in; }

  void setUpIDHandSeq_epsilon(double UpIDHandSeq_epsilon) { UpIDHandSeq_epsilon_in = UpIDHandSeq_epsilon; }
  double getUpIDHandSeq_epsilon() const { return UpIDHandSeq_epsilon_in; }
  void setUpIDHandSeq_r(double UpIDHandSeq_r) { UpIDHandSeq_r_in = UpIDHandSeq_r; }
  double getUpIDHandSeq_r() const { return UpIDHandSeq_r_in; }



  void setTmpInt(int v) { tmpInt = v; }
  int getTmpInt() { return tmpInt; }  
  void setTmpDouble(double v) { tmpDouble = v; }
  double getTmpDouble() { return tmpDouble; } 


  void setR_alpha(double r_alpha) { r_alpha_in = r_alpha; }
  double getR_alpha() const { return r_alpha_in; }
  void setR_beta(double r_beta) { r_beta_in = r_beta; }
  double getR_beta() const { return r_beta_in; }
  void setR_c(double r_c) { r_c_in = r_c; }
  double getR_c() const { return r_c_in; }

  void setRd_alpha(double rd_alpha) { rd_alpha_in = rd_alpha; }
  double getRd_alpha() const { return rd_alpha_in; }
  void setRd_beta(double rd_beta) { rd_beta_in = rd_beta; }
  double getRd_beta() const { return rd_beta_in; }
  void setRd_epsilon(double rd_epsilon) { rd_epsilon_in = rd_epsilon; }
  double getRd_epsilon() const { return rd_epsilon_in; }  
  void setRd_c(double rd_c) { rd_c_in = rd_c; }
  double getRd_c() const { return rd_c_in; }


  void setLambda_epsilon(double lambda_epsilon) { lambda_epsilon_in = lambda_epsilon; }
  double getLambda_epsilon() const { return lambda_epsilon_in; }
  void setLambda_c(double lambda_c) { lambda_c_in = lambda_c; }
  double getLambda_c() const { return lambda_c_in; }

  void setKappa_epsilon(double kappa_epsilon) { kappa_epsilon_in = kappa_epsilon; }
  double getKappa_epsilon() const { return kappa_epsilon_in; }
  void setKappa_c(double kappa_c) { kappa_c_in = kappa_c; }
  double getKappa_c() const { return kappa_c_in; }

  void setGamma_epsilon(double gamma_epsilon) { gamma_epsilon_in = gamma_epsilon; }
  double getGamma_epsilon() const { return gamma_epsilon_in; }
  void setGamma_c(double gamma_c) { gamma_c_in = gamma_c; }
  double getGamma_c() const { return gamma_c_in; }
  void setGamma_alpha(double gamma_alpha) { gamma_alpha_in = gamma_alpha; }
  double getGamma_alpha() const { return gamma_alpha_in; }
  void setGamma_beta(double gamma_beta) { gamma_beta_in = gamma_beta; }
  double getGamma_beta() const { return gamma_beta_in; }





  void setPi_alpha(vector<double> pi_alpha) { pi_alpha_in = pi_alpha; }
  vector<double> getPi_alpha() const { return pi_alpha_in; }
  void setPi_c(double pi_c) { pi_c_in = pi_c; }
  double getPi_c() const { return pi_c_in; }

  void iniPr(int size) { 
    Pr_in.resize(size);
    for(int i= 0; i < size; i++)
      Pr_in[i] = 0;
  }       
  void iniIr(int size) { 
    Ir_in.resize(size);
    for(int i= 0; i < size; i++)
      Ir_in[i] = 0;
  }    
  void setPr(int posi, double Pr_each) { Pr_in[posi] = Pr_each; }
  void setIr(int posi, int Ir_each) { Ir_in[posi] = Ir_each; }
  double getPr(int posi) { return Pr_in[posi]; }
  int getIr(int posi) { return Ir_in[posi]; }

  void iniPrT(int size) { 
    PrT_in.resize(size);
    for(int i= 0; i < size; i++)
      PrT_in[i] = 0;
  }       
  void iniIrT(int size) { 
    IrT_in.resize(size);
    for(int i= 0; i < size; i++)
      IrT_in[i] = 0;
  }    
  void setPrT(int posi, double Pr_each) { PrT_in[posi] = Pr_each; }
  void setIrT(int posi, int Ir_each) { IrT_in[posi] = Ir_each; }
  double getPrT(int posi) { return PrT_in[posi]; }
  int getIrT(int posi) { return IrT_in[posi]; }


  int getSPRonSingle() { return SPRonSingle; }
  void setSPRonSingle(int tmp) { SPRonSingle = tmp; }

  //--- v20 start ---//
  double getInsertDownWei() const { return insertDownWei_in; }
  void setInsertDownWei(double tmp) { insertDownWei_in = tmp; }

  double getC_noEvent() const { return c_noEvent_in; }
  void setC_noEvent(double tmp) { c_noEvent_in = tmp; }

  double getWeiID() const { return weiID_in; }
  void setWeiID(double tmp) { weiID_in = tmp; }

  double getImulFacSD() const { return ImulFacSD_in; }
  void setImulFacSD(double tmp) { ImulFacSD_in = tmp; }

  double getDmulFacSD() const { return DmulFacSD_in; }
  void setDmulFacSD(double tmp) { DmulFacSD_in = tmp; }

  double getProbTargetFragI() const { return probTargetFragI_in; }
  void setProbTargetFragI(double tmp) { probTargetFragI_in = tmp; }

  double getProbTargetFragD() const { return probTargetFragD_in; }
  void setProbTargetFragD(double tmp) { probTargetFragD_in = tmp; }
  //--- v20 end ---//

  //--- v21 start ---//
  double getDelProb() const { return delProb_in; }
  void setDelProb(double tmp) { delProb_in = tmp; }
  //--- v21 end ---//

  //--- v24 start ---//
  int getMaxCases() const { return MaxCases_in; }
  void setMaxCases(int tmp) { MaxCases_in = tmp; }
  //--- v24 end ---//

  //--- v26 start ---//
  double getPowWei() const { return powWei_in; }
  void setPowWei(double tmp) { powWei_in = tmp; }
  //--- v26 end ---//

private:
  double r_in, ri_in, rd_in, lambda_in, mu_in, gamma_in;
  double zeta_in; // used when generate multiplication factor for edge proposal
  double delta_in;  // used when update IDH on Edge based on likelihood
  vector<vector<double> > Q_in;
  vector<double> pi_in;
  double kappa_in;  // used in HKY substitution model
  double r_alpha_in; // hyper parameters for r
  double r_beta_in; 
  double r_c_in; 
  double rd_alpha_in; // hyper parameters for rd
  double rd_beta_in; 
  double rd_c_in; 
  double rd_epsilon_in; 
  double lambda_epsilon_in; // hyper parameters for lambda
  double lambda_c_in; 
  double kappa_epsilon_in; // hyper parameters for kappa
  double kappa_c_in;
  double gamma_epsilon_in; // hyper parameters for gamma
  double gamma_c_in;
  double gamma_alpha_in; // hyper parameters for gamma
  double gamma_beta_in;   
  vector<double> pi_alpha_in; //  hyper parameters for pi
  double pi_c_in; 
  double SPRonSubTreeWithTarget_c_in; 
  double UpIDHandSeq_epsilon_in;
  double UpIDHandSeq_r_in;
  int tmpInt;
  double tmpDouble;
  vector<double> Pr_in;
  vector<int> Ir_in;  
  vector<double> PrT_in;
  vector<int> IrT_in;  
  int SPRonSingle;
  // Make window length separately
  double windowLen_in; // used when update IDH on Edge as window size
  double windowLen_UpIDHonEdge_in;
  double windowLen_UpIDHonEdgeLike_in;
  double windowLen_SPRonSubTreeWithinWindow_in;
  double windowLen_SPRonSubTreeWithTargetWithinWindow_in;

  //-- v20 start ---//
  double insertDownWei_in; // use in calWeightIn called from runEdgeWithDeletionConstraint

  // All used in runEdgeWithTarget, proposHistoryWithTarget
  double c_noEvent_in;
  double weiID_in;
  double ImulFacSD_in;
  double DmulFacSD_in;
  double probTargetFragI_in;
  double probTargetFragD_in;
  //-- v20 end -----//

  //--- v21 start ---//
  double delProb_in;
  //--- v21 end ---//


  //--- v24 start --//
  int MaxCases_in;
  //--- v24 end --//


  //-- v26 start --//
  double powWei_in;
  //-- v26 end --//
};


/*
class Parameters{
public:
  void setParameters(double r, double ri, double rd, double lambda, double mu, vector<vector<double> > Q, vector<double> pi){ r_in = r; ri_in = ri; rd_in = rd; lambda_in = lambda; mu_in = mu; Q_in = Q; pi_in = pi;}
  double getR() const { return r_in; }
  double getRi() const { return ri_in; }
  double getRd() const { return rd_in; }
  double getLambda() const { return lambda_in; }
  double getMu() const { return mu_in; }  
  vector<vector<double> > getQ() const { return Q_in; }  
  vector<double> getPi() const { return pi_in; }
private:
  double r_in, ri_in, rd_in, lambda_in, mu_in;
  vector<vector<double> > Q_in;
  vector<double> pi_in;
};
*/


// Indel History without EVENTnum
class InDelHistory{
public:
  InDelHistory(){
    nume = 0; 
    v.resize(0); 
    id.resize(0); 
    p.resize(0); 
    l.resize(0); 
    n.resize(0); 
    hmg.resize(0);
  }
  bool checkCorrectIDH();
  InDelHistory(int NumE, vector<double> V, vector<int> ID, vector<int> P, vector<int> L, vector<int> N, vector<vector<int> > HMG){ nume = NumE; v = V; id = ID; p = P; l = L; n = N; hmg = HMG;}
  void setHistory(int NumE, vector<double> V, vector<int> ID, vector<int> P, vector<int> L, vector<int> N, vector<vector<int> > HMG){ nume = NumE; v = V; id = ID; p = P; l = L; n = N; hmg = HMG;}
  void setV(vector<double> V){ v = V;}
  void setV(double val, int posi) { v[posi] = val; }
  void setHMG(vector<int> hmgin, int posi) { hmg[posi] = hmgin; }
  void setN(int val, int posi) { n[posi] = val; }
  void setP(vector<int> P){ p = P;}
  void setHMG(vector<vector<int> > HMG) { hmg = HMG; }
  void setP(int Pi, int posi){ p[posi] = Pi;}
  // Be careful!!!
  // If event is added to the last position, addHistory should be used!
  // insertHistory can be used only when event is added to beginings or middle of events. 
  void addHistory(bool includedummy, double Vi, int IDi, int Pi, int Li, int Ni, vector<int> HMGi){ 
    v.push_back(Vi); 
    id.push_back(IDi); 
    p.push_back(Pi); 
    l.push_back(Li); 
    n.push_back(Ni); 
    hmg.push_back(HMGi); 
    if(!includedummy)
      nume++;
  }
  void insertHistory(bool includedummy, int posi, double Vi, int IDi, int Pi, int Li, int Ni, vector<int> HMGi){ 
    v.insert(v.begin() + posi, 1, Vi); 
    id.insert(id.begin() + posi, 1, IDi); 
    p.insert(p.begin() + posi, 1, Pi); 
    l.insert(l.begin() + posi, 1, Li); 
    n.insert(n.begin() + posi, 1, Ni); 
    hmg.insert(hmg.begin() + posi, 1, HMGi);
    if(!includedummy)
      nume++;
  }  
  /*
  void insertHistory(bool includedummy, int posi, double Vi, int IDi, int Pi, int Li, int Ni, vector<int> HMGi){ 
    if(!includedummy){
      v.insert(v.begin() + posi +1, 1, Vi); 
      id.insert(id.begin() + posi +1, 1, IDi); 
      p.insert(p.begin() + posi +1, 1, Pi); 
      l.insert(l.begin() + posi +1, 1, Li); 
      n.insert(n.begin() + posi +1, 1, Ni); 
      hmg.insert(hmg.begin() + posi +1, 1, HMGi);
    }else{
      v.insert(v.begin() + posi, 1, Vi); 
      id.insert(id.begin() + posi, 1, IDi); 
      p.insert(p.begin() + posi, 1, Pi); 
      l.insert(l.begin() + posi, 1, Li); 
      n.insert(n.begin() + posi, 1, Ni); 
      hmg.insert(hmg.begin() + posi, 1, HMGi);
    }      
    if(!includedummy)
      nume++;
  } 
  */ 
  //The erase() function either deletes the element at location loc, or deletes the elements between start and end (including start but not including end). The return value is the element after the last element erased.
  // erase elements from start to end
  void eraseHistory(bool includedummy){  
    v.pop_back(); 
    id.pop_back(); 
    p.pop_back(); 
    l.pop_back(); 
    n.pop_back(); 
    hmg.pop_back(); 
    if(!includedummy)
      nume--;
  }
  void eraseHistory(bool includedummy, int posi){  
    v.erase(v.begin() + posi); 
    id.erase(id.begin() + posi); 
    p.erase(p.begin() + posi); 
    l.erase(l.begin() + posi); 
    n.erase(n.begin() + posi); 
    hmg.erase(hmg.begin() + posi); 
    if(!includedummy)
      nume--;
  }
  void eraseHistory(bool includedummy, int start, int end){  
    v.erase(v.begin() + start, v.begin() + end + 1 ); 
    id.erase(id.begin() + start, id.begin() + end + 1 ); 
    p.erase(p.begin() + start, p.begin() + end + 1 ); 
    l.erase(l.begin() + start, l.begin() + end + 1 ); 
    n.erase(n.begin() + start, n.begin() + end + 1 ); 
    hmg.erase(hmg.begin() + start, hmg.begin() + end + 1 );
    if(includedummy)
      nume -= (end - start);
    else
      nume -= (end - start + 1);
  }
  int getIDHsize() const { return v.size(); }
  int getNumE() const { return nume; }
  double getV(int i) const { return v[i]; }
  int getID(int i) const { return id[i]; }
  int getP(int i) const { return p[i]; }
  vector<int> getP() const { return p; }
  int getL(int i) const { return l[i]; }
  int getN(int i) const { return n[i]; }
  int getHMG(int i, int j) const { return hmg[i][j]; }
  vector<int> getHMG(int i) const { return hmg[i]; }
  vector<vector<int> > getHMG() const { return hmg; }
  void printIDH(){
    cout << endl << "#### print IDH ####" << endl;
    cout << "numE " << getNumE() << endl;
    for(int j =0; j<=(getNumE()+1); j++){ 
      cout << "ID " << getID(j) << endl;
      cout << "L " << getL(j) << endl;
      cout << "P " << getP(j) << endl;
      cout << "V " << getV(j) << endl;
      cout << "N " << getN(j) << endl;
      cout << "HMG "  << endl;
      for(int m=0; m < getHMG(j).size(); m++)
	cout << getHMG(j,m) << " ";
      cout << endl;
    }
  }
  void printIDHwoHMG(){
    cout << endl << "#### print IDH ####" << endl;
    cout << "numE " << getNumE() << endl;
    for(int j =0; j<=(getNumE()+1); j++){ 
      cout << "ID " << getID(j) << endl;
      cout << "L " << getL(j) << endl;
      cout << "P " << getP(j) << endl;
      cout << "V " << getV(j) << endl;
      cout << "N " << getN(j) << endl;
      //cout << "HMG "  << endl;
      //for(int m=0; m < getHMG(j).size(); m++)
      //	cout << getHMG(j,m) << " ";
      //cout << endl;
    }
  }
  void ReverseIDH();
  int IsDelEventContainingOnlyBases(int, vector<int>);
private:
  int nume;
  vector<double> v;
  vector<int> id;
  vector<int> p;
  vector<int> l;
  vector<int> n;
  vector<vector<int> > hmg;
};








class Node{
public:
  Node() {
    current = 0;
    number = -1;
    edges.resize(2);
    subtreeprob.resize(2);
    rootSites.resize(2);
    LinkedSites.resize(2);
    logLikelihood.resize(2);
    //-- v32 start --//
    sumOflogFs.resize(2);
    //-- v32 end --//
  }
  /*
  Node(int n, bool lf, bool r,int index) {
    current = 0;
    number = n;
    leaf = lf;
    root = r;
    parentIndex=index;
    if(leaf && root)
      numEdges = 0;
    else if(leaf)
      numEdges = 1;
    else
      numEdges = 3;
 
    edges.resize(2);
    subtreeprob_in.resize(2);
    rootSites.resize(2);
    for(int i=0;i<2;i++){
      edges[i].resize(numEdges);
      subtreeprob_in[i].resize(4);
      rootSites[i].resize(0);
    }    
  }
  Node(int n, int seqL, bool lf, bool r,int index) {
    current = 0;
    number = n;
    seqLen[0] = seqL;
    leaf = lf;
    root = r;
    parentIndex=index;
    if(leaf && root)
      numEdges = 0;
    else if(leaf)
      numEdges = 1;
    else
      numEdges = 3;
 
    edges.resize(2);
    subtreeprob_in.resize(2);
    rootSites.resize(2);
    for(int i=0;i<2;i++){
      edges[i].resize(numEdges);
      subtreeprob_in[i].resize(4);
      rootSites[i].resize(0);
    }    
  }
  Node(int n, vector<int> Seq, bool lf, bool r,int index) {
    seq = Seq; 
    seqLen[0] = seq.size();
    current = 0;
    number = n;
    leaf = lf;
    root = r;
    parentIndex = index;
    if(leaf && root)
      numEdges = 0;
    else if(leaf)
      numEdges = 1;
    else
      numEdges = 3;
 
    edges.resize(2);
    subtreeprob_in.resize(2);
    rootSites.resize(2);
    for(int i=0;i<2;i++){
      edges[i].resize(numEdges);
      subtreeprob_in[i].resize(4);
      rootSites[i].resize(0);
    }  
  }

  */

  Node(int n, bool lf, bool r,int index, int NumEdge, int NumLetters) {
    //-- v23 start --//
    onLine = false;
    child_v2.resize(0);
    Pt.resize(0);
    subtreeprob_v2.resize(0);
    //-- v23 end --//
    current = 0;
    number = n;
    leaf = lf;
    root = r;
    numLetters = NumLetters;
    parentIndex[current]=index;
    if(leaf && root)
      numEdges = 0;
    else if(leaf)
      numEdges = 1;
    else
      numEdges = NumEdge;
 
    edges.resize(2);
    logLikelihood.resize(2);
    if(!getRoot()){
      subtreeprob.resize(2);
      rootSites.resize(2);
    }else{
      LinkedSites.resize(2);
    }
    for(int i=0;i<2;i++){
      edges[i].resize(numEdges);
      logLikelihood[i].resize(2);
      if(!getRoot()){
	subtreeprob[i].resize(numLetters);
	rootSites[i].resize(0);
      }else{
	LinkedSites[i].resize(0);
      }
    }    

    //-- v32 start --//
    if(!getRoot())
      sumOflogFs.resize(2);
    //-- v32 end --//
  }
  /*
  Node(int n, int seqL, bool lf, bool r,int index, int NumEdge) {
    current = 0;
    number = n;
    seqLen[0] = seqL;
    leaf = lf;
    root = r;
    parentIndex=index;
    if(leaf && root)
      numEdges = 0;
    else if(leaf)
      numEdges = 1;
    else
      numEdges = NumEdge;
 
    edges.resize(2);
    subtreeprob_in.resize(2);
    rootSites.resize(2);
    for(int i=0;i<2;i++){
      edges[i].resize(numEdges);
      subtreeprob_in[i].resize(4);
      rootSites[i].resize(0);
    }    
  }
  */
  Node(int n, vector<int> Seq, bool lf, bool r,int index, int NumEdge, int NumLetters) {
    //-- v23 start --//
    onLine = false;
    child_v2.resize(0);
    Pt.resize(0);
    subtreeprob_v2.resize(0);
    //-- v23 end --//
    current = 0;
    number = n;
    leaf = lf;
    root = r;
    seq = Seq; 
    seqLen[current] = seq.size();
    numLetters = NumLetters;
    parentIndex[current] = index;
    if(leaf && root)
      numEdges = 0;
    else if(leaf)
      numEdges = 1;
    else
      numEdges = NumEdge;
 
    edges.resize(2);
    logLikelihood.resize(2);
    if(!getRoot()){
      subtreeprob.resize(2);
      rootSites.resize(2);
    }else{
      LinkedSites.resize(2);
    }
    for(int i=0;i<2;i++){
      edges[i].resize(numEdges);
      logLikelihood[i].resize(0);
      if(!getRoot()){
	subtreeprob[i].resize(numLetters);
	rootSites[i].resize(0);
      }else{
	LinkedSites[i].resize(0);
      }
    }  

    //-- v32 start --//
    if(!getRoot())
      sumOflogFs.resize(2);
    //-- v32 end --//

  }
  ~Node() {
    //-- v23 start --//
    child_v2.resize(0);
    Pt.resize(0);
    subtreeprob_v2.resize(0);
    //-- v23 end --//
    for(int i=0;i<2;i++){
      edges[i].resize(0);
      logLikelihood[i].resize(0);
      if(!getRoot()){
	subtreeprob[i].resize(0);
	rootSites[i].resize(0);
      }else{
	LinkedSites[i].resize(0);
      }
    }
    edges.resize(0);
    logLikelihood.resize(0);
    if(!getRoot()){
      subtreeprob.resize(0);
      rootSites.resize(0);
    }else{
      LinkedSites.resize(0);
    }
    ChangedHMG.resize(0);

    //-- v32 start --//
    if(!getRoot())
      sumOflogFs.resize(0);
    //-- v32 end --//

  }
  void setEdge(int i,Edge* e,int c) { edges[c][i] = e; }
  void setEdge(int i,Edge* e) { edges[current][i] = e; }
  void setEdge(Edge* Cedge, Edge* Nedge) { // Set Nedge at a position of Cedge
    for(int i = 0; i < numEdges; i++){
      if(edges[current][i] == Cedge)
	edges[current][i] = Nedge;
    }
  }    
  void setParentEdge(Edge* e, int c) { edges[c][getparentIndex(c)] = e;}
  void setParentEdge(Edge* e) { edges[current][getparentIndex(current)] = e;}
  void changeParentEdge(Edge* e) { // Change parent edge into a given edge "e" 
    for(int i = 0; i < numEdges; i++){
      if(edges[current][i] == e){
	edges[current][i] = edges[current][getparentIndex(current)];
	edges[current][getparentIndex(current)] = e;
      }
    }  
  }
  void setSeqLen(int seqlen){ seqLen[current] = seqlen;}
  void setSeqLen(int seqlen, int c){ seqLen[c] = seqlen;}
  void setLeaf(bool b) { leaf = b; }
  void setRoot(bool b) { root = b; }
  int getnumber() const { return number; }
  int getnumEdges() const { return numEdges; }  
  int getSeqLen() const { return seqLen[current]; }
  int getSeqLen(int c) const { return seqLen[c]; }
  int getSeq(int i) const { return seq[i]; } 
  void setSeq(vector<int> seqInput) { 
    seq.resize(0);
    seq = seqInput;
    seqLen[current] = seq.size();
  }
  void resetSeq() { seq.resize(seqLen[current]); }
  void setSeq(int pos, int letter){
    if(seq.size() <= pos)
      cout << "ERRPR in setSeq!  Not available position. " << endl;
    seq[pos] = letter;
  } 
  int getparentIndex() const { return parentIndex[current]; }
  int getparentIndex(int c) const { return parentIndex[c]; }
  bool getLeaf() const { return leaf; }
  bool getRoot() const { return root; }
  int getNumLetters() const { return numLetters; }

  Edge* getEdge(int i) const { return edges[current][i]; }
  Edge* getEdge(int i,int c) const { return edges[c][i]; }
  Edge* leftEdge(Edge*, Edge*); // Called only from node which has three edges connected
  Edge* getParentEdge() const { return edges[current][parentIndex[current]]; }
  //Edge* getLeftEdge() const { return edges[current][0]; } 
  //Edge* getRightEdge() const { return edges[current][1]; } 
  vector<Edge*> getEdges() const { return edges[current]; }

  //Node* getChild(int i) const { getEdge(i)->getOtherNode(this); }
  //Node* getChild(int i, int c) const { getEdge(i,c)->getOtherNode(this); } 
  //Node* getLC() const { getLeftEdge()->getOtherNode(this); }
  //Node* getRC() const { getRightEdge()->getOtherNode(this); }
  //Node* getParent() const { return getParentEdge()->getOtherNode(this); }
  Node* getParent(); 


  // return Edge number which point input edge
  // For importance sampling
  int getEdgeNum(Edge *e);

  void resetSubtreeprob(){
    for(int i = 0; i < subtreeprob[current].size() ; i++)
      subtreeprob[current][i].resize(0);
  }
  void resetSubtreeprob(int c){
    for(int i = 0; i < subtreeprob[c].size() ; i++)
      subtreeprob[c][i].resize(0);
  }




  double getsubtreeprob(int i, int j) const { return subtreeprob[current][i][j]; }
  double getsubtreeprob(int i, int j, int c) const { return subtreeprob[c][i][j]; }


  void set0ChangedHMG() {
    ChangedHMG.resize(0);
    for(int i = 0; i < seqLen[current]; i++)
      ChangedHMG.push_back(0);
  }

  void resetChangedHMG() { 
    ChangedHMG.resize(0);
  }

  int getChangedHMG(int i) const { return ChangedHMG[i]; }
 
  void set0rootSites() {
    rootSites[current].resize(0);
    for(int i = 0; i < seqLen[current]; i++)
      rootSites[current].push_back(0);
  }
  void set0rootSites(int c) {
    rootSites[c].resize(0);
    for(int i = 0; i < seqLen[current]; i++)
      rootSites[c].push_back(0);
  }
  void setrootSites(int i, int m) { rootSites[current][i] = m; }
  void setrootSites(int i, int m, int c) { rootSites[c][i] = m; }

  int getrootSitesSize() const { return rootSites[current].size(); }
  int getrootSitesSize(int c) const { return rootSites[c].size(); }
  int getrootSites(int i) const { return rootSites[current][i]; }
  int getrootSites(int i, int c) const { return rootSites[c][i]; }

  void set0LinkedSites() {
    LinkedSites[current].resize(0);
    for(int i = 0; i < seqLen[current]; i++)
      LinkedSites[current].push_back(0);
  }
  void set0LinkedSites(int c) {
    LinkedSites[c].resize(0);
    for(int i = 0; i < seqLen[current]; i++)
      LinkedSites[c].push_back(0);
  }
  void setLinkedSites(int i, int m) { LinkedSites[current][i] = m; }
  void setLinkedSites(int i, int m, int c) { LinkedSites[c][i] = m; }

  int getLinkedSitesSize() const { return LinkedSites[current].size(); }
  int getLinkedSitesSize(int c) const { return LinkedSites[c].size(); }
  int getLinkedSites(int i) const { return LinkedSites[current][i]; }
  int getLinkedSites(int i, int c) const { return LinkedSites[c][i]; }

  void set0logLikelihood() {
    logLikelihood[current].resize(0);
    for(int i = 0; i < seqLen[current]; i++)
      logLikelihood[current].push_back(0);
  }
  void set0logLikelihood(int c) {
    logLikelihood[c].resize(0);
    for(int i = 0; i < seqLen[current]; i++)
      logLikelihood[c].push_back(0);
  }
  void setlogLikelihood(int i, double m) { logLikelihood[current][i] = m; }
  void setlogLikelihood(int i, double m, int c) { logLikelihood[c][i] = m; }

  double getlogLikelihood(int i) const { return logLikelihood[current][i]; }
  double getlogLikelihood(int i, int c) const { return logLikelihood[c][i]; } 

  double likeliData(const Parameters&, int);
  double likeliData(const Parameters&);
  //double likeliDataR(const Parameters&, int);  // should be called from a root
  //double likeliDataR(const Parameters&); 
  double likeliData_v2(const Parameters&);
  double likeliDataR_v2(const Parameters&); 
  //void calHMG();



  void CalloglikeliofRootSites(const Parameters&); //Just re-calculate loglikelihood of Root Site in this node after changing tree structure  
  void CalloglikeliofRootSitesOrReuse(const Parameters&); //Just re-calculate loglikelihood of Root Site in this node if necessary. If possible, use the previous loglikelihood  
  void CalloglikeliofUpdatedRootSites(const Parameters&); //Update Root Sites in the updated tree structure and re-calculate loglikelihood of updated Root Sites in this node 
  void UpdateRootSites(const Parameters&); //Update Root Sites in the updated tree structure and re-calculate loglikelihood of updated Root Sites in this node if necessary. If possible, use the previous loglikelihood  
  double rootSitelogLikelihood(const Parameters&, int); //Calculate loglikelihood of given position in rooted Sites 
  void findRootSites(); //Update Root Sites in the updated tree structure 
  double CalSubTreeProb(const Parameters&); //Calculate Gijk in this node  
  void CalloglikeliofLinkedSites(const Parameters&);  //Just re-calculate loglikelihood of Linked Site in this node after changing tree structure  
  void CalloglikeliofUpdatedLinkedSites(const Parameters&); //Update Linked Sites in the updated tree structure and re-calculate loglikelihood of updated Linked Sites in this node  
  double linkedSitelogLikelihood(const Parameters&, int);  // Calculate loglikelihood of given position in Linked Sites 
  void findLinkedSites(); // Update Linked Sites in the updated tree structure

  void printNode();
  void printNode(int c);
  void printNode(ofstream&);
  void getAlignment(int, vector<int>&, vector<vector<int> >&);


  /*** NNI start ***/
  void getAlignment(int, vector<int>&, vector<vector<int> >&, vector<int>);
  void getAlignmentLastPart(vector<vector<int> >&, vector<int>);
  /*** NNI end ***/

  double CalSubTreeProbForSitesWithChangedHMG(const Parameters&, int);
  double CalSubTreeProbForSitesWithChangedG(const Parameters&, int);
  void CalloglikeliofRootSitesWithChangedHMG(const Parameters&, int);
  void CalloglikeliofRootSitesWithChangedG(const Parameters&, int);
  void CalloglikeliofLinkedSitesWithChangedG(const Parameters&, int);
  void CalloglikeliofLinkedSitesWithChangedHMG(const Parameters&, int);
  void UpdateAllinfoToRootWithChangedHMG(const Parameters&, Node*); 

  void save() {
    edges[1-current] = edges[current];
    seqLen[1-current] = seqLen[current];
    logLikelihood[1-current] = logLikelihood[current];      
    parentIndex[1-current] = parentIndex[current];
    if(!getRoot()){
      subtreeprob[1-current] = subtreeprob[current];
      rootSites[1-current] = rootSites[current];
      //-- v32 start --//
      sumOflogFs[1-current] = sumOflogFs[current];
      //-- v32 end --//
    }else{
      LinkedSites[1-current] = LinkedSites[current];
    }
  }
  void restore() {
    edges[current] = edges[1-current];
    seqLen[current] = seqLen[1-current];
    logLikelihood[current] = logLikelihood[1-current];
    parentIndex[current] = parentIndex[1-current];
    if(!getRoot()){
      subtreeprob[current] = subtreeprob[1-current];
      rootSites[current] = rootSites[1-current];
      //-- v32 start --//
      sumOflogFs[current] = sumOflogFs[1-current];
      //-- v32 end --//
    }else{
      LinkedSites[current] = LinkedSites[1-current];
    }
  }

  void save_logLikeliData() {
    logLikelihood[1-current] = logLikelihood[current];      
    parentIndex[1-current] = parentIndex[current];
    if(!getRoot()){
      subtreeprob[1-current] = subtreeprob[current];
      //-- v32 start --//
      sumOflogFs[1-current] = sumOflogFs[current];
      //-- v32 end --//
    }
  }
  void restore_logLikeliData(){
    logLikelihood[current] = logLikelihood[1-current];
    if(!getRoot()){
      subtreeprob[current] = subtreeprob[1-current];
      //-- v32 start --//
      sumOflogFs[current] = sumOflogFs[1-current];
      //-- v32 end --//
    }
  }

  void calLastLinkedPosi();
  int getLastLinkedPosi() const { return lastLinkedPosi; }
  /*** NNI start ****/
  bool checkNode();
  /*** NNI end ****/

  //-- v23 start --//
  bool getOnLine() const { return onLine; }
  double getsubtreeprob_v2(int i, int j) const { return subtreeprob_v2[i][j]; }
  vector<vector<double> > getPt() { return Pt; }
  void ReadyForCalSubTreeProbHere(int, double, Parameters&);
  void FinishForCalSubTreeProbHere();
  void CalSubTreeProbHere();
  void getProbFromSubTreeProb(vector<double>&, int posi);
  void getProbFromSubTreeProb(vector<vector<double> >&);
  //-- v23 end --//

  //-- v29 start --//
  void CalPt(double, Parameters&);
  void Ptreset() { Pt.resize(0); }
  //-- v29 end --//

  //-- v30 start --//
  void relatedLeavesReset() { relatedLeaves.resize(0); }
  void relatedPosiReset() { relatedPosi.resize(0); }
  vector<int> getRelatedLeaves(int i) { return relatedLeaves[i]; }
  vector<int> getRelatedPosi(int i) { return relatedPosi[i]; }
  void RelatedLeaves_push_back(vector<int> t) { 
    relatedLeaves.push_back(t);
    t.resize(0);
  }
  void RelatedPosi_push_back(vector<int> t) { 
    relatedPosi.push_back(t);
    t.resize(0);
  }
  void leavesBelowReset() { leavesBelow.resize(0); }
  vector<int> getleavesBelow() { return leavesBelow; }
  void setleavesBelow(vector<int> t) { leavesBelow = t; }
  //-- v30 end --//

  //-- v32 start --//
  double getsumOflogFs(int i) { return sumOflogFs[current][i]; }
  //-- v32 end --//


  /*
  void saveToTemp() {
    edges[2] = edges[current];
    seqLen[2] = seqLen[current];
    logLikelihood[2] = logLikelihood[current];      
    parentIndex[2] = parentIndex[current];
    if(!getRoot()){
      subtreeprob[2] = subtreeprob[current];
      rootSites[2] = rootSites[current];
    }else{
      LinkedSites[2] = LinkedSites[current];
    }
  }
  void restoreFromTemp() {
    edges[current] = edges[2];
    seqLen[current] = seqLen[2];
    logLikelihood[current] = logLikelihood[2];
    parentIndex[current] = parentIndex[2];
    if(!getRoot()){
      subtreeprob[current] = subtreeprob[2];
      rootSites[current] = rootSites[2];
    }else{
      LinkedSites[current] = LinkedSites[2];
    }
  }
  */
private:
  int number;
  int current;
  bool leaf;
  bool root;
  int numLetters;
  int parentIndex[2]; // index in edges that points to parent (-1 for root)
  int numEdges; // 1 for a leaf, 3 for non-root internal node
  vector<vector<Edge*> > edges; // length is numEdges;
  vector<int> seq;
  int seqLen[2];
  vector<vector<vector<double> > > subtreeprob;
  vector<vector<int> > rootSites;
  vector<vector<int> > LinkedSites;
  vector<vector<double> > logLikelihood;
  vector<int> ChangedHMG; // keep track whose gijk are updated.

  // Used when getting alignment
  int lastLinkedPosi;
  /*** NNI start ***/
  bool Hitlast;
  /*** NNI end ***/

  //--- v23 start --//
  // Used to calculate conditional prob Gijk
  vector<int> child_v2; // index for children edge 
  bool onLine;   // on the line of reverse direction
  vector<vector<double> >  subtreeprob_v2;  
  vector<vector<double> > Pt;
  //--- v23 end --//

  //-- v30 start --//
  vector<vector<int> > relatedLeaves;
  vector<vector<int> > relatedPosi;
  vector<int> leavesBelow;
  //-- v30 end --//

  //-- v32 start --//
  vector<vector<double> > sumOflogFs;
  //-- v32 end --//

};


class Edge{
public:
  Edge() {
    //-- v23 start --//
    onLine = false;
    HMG_v2.resize(0);
    //-- v23 end --//
    current = 0;             
    number = -1;
    HMG.resize(2);
    IDH.resize(2);
    for(int i=0;i<2;i++){
      HMG[i].resize(0);
      IDH[i] = new InDelHistory();
    }
  }
  Edge(int n) {
    //-- v23 start --//
    onLine = false;
    HMG_v2.resize(0);
    //-- v23 end --//
    current = 0;
    number = n;
    HMG.resize(2);
    IDH.resize(2);
    for(int i=0;i<2;i++){
      HMG[i].resize(0);
      IDH[i] = new InDelHistory();
    }
  }
  Edge(int n, double len) {
    //-- v23 start --//
    onLine = false;
    HMG_v2.resize(0);
    //-- v23 end --//
    current = 0;
    number = n;
    edgeLen[current] = len;
    HMG.resize(2);
    IDH.resize(2);
    for(int i=0;i<2;i++){
      HMG[i].resize(0);
      IDH[i] = new InDelHistory();
    }
  }
  Edge(int n,Node* s,Node* e) {
    
    //-- v23 start --//
    onLine = false;
    HMG_v2.resize(0);
    //-- v23 end --//
 
    number = n;
    current = 0;
    for(int i=0;i<2;i++) {
      start[i] = s;
      end[i] = e;
    }
    HMG.resize(2);
    IDH.resize(2);
    for(int i=0;i<2;i++){
      HMG[i].resize(0);
      IDH[i] = new InDelHistory();
    }
  }
  ~Edge() {

    //-- v23 start --//
    HMG_v2.resize(0);
    //-- v23 end --//
    
    for(int i=0;i<2;i++){
      HMG[i].resize(0);
      delete IDH[i];
    }
    HMG.resize(0);
    IDH.resize(0);
  }
  void setStart(Node* s,int c) {
    start[c] = s;
  }
  void setEnd(Node* e,int c) {
    end[c] = e;
  }
  void setStart(Node* s) {
    start[current] = s;
  }
  void setEnd(Node* e) {
    end[current] = e;
  }
  Node* getStart(int c) const { return start[c]; }
  Node* getEnd(int c) const { return end[c]; }
  Node* getStart() const { return start[current]; }
  Node* getEnd() const { return end[current]; }


  int getnumber() const { return number; }
  
  double getEdgeLen() const { return edgeLen[current]; }
  double getEdgeLen(int c) const { return edgeLen[c]; }

  double getlogLikeliIDH() const { return logLikeliIDH[current]; }
  double setlogLikeliIDH(double b) { logLikeliIDH[current] = b; }
  double getlogLikeliEdge() const { return logLikeliEdge[current]; }
  double setlogLikeliEdge(double b) { logLikeliEdge[current] = b; }
  void setEdgeLen(double len) { edgeLen[current] = len; }
  void setEdgeLen(double len, int c) { edgeLen[c] = len; }

  Edge* getParentEdge();
  Node* getOtherNode(const Node* n) const { return (start[0] == n ? end[0] : start[0]); }

  void calHMG();
  vector<int> getHMG() const { return HMG[current]; };
  int getHMG(int i) const { return HMG[current][i]; };
  int getHMG(int i, int c) const { return HMG[c][i]; };



  InDelHistory* getIDH() { return IDH[current]; }
  InDelHistory* getIDH(int c) { return IDH[c]; }

  void save() {
    logLikeliIDH[1-current] = logLikeliIDH[current];
    logLikeliEdge[1-current] = logLikeliEdge[current];
    start[1-current] = start[current];
    end[1-current] = end[current];
    edgeLen[1-current] = edgeLen[current];
    (*IDH[1-current]) = (*IDH[current]);
    HMG[1-current] = HMG[current];  
  }
  void restore() {
    logLikeliIDH[current] = logLikeliIDH[1-current];
    logLikeliEdge[current] = logLikeliEdge[1-current];
    start[current] = start[1-current];
    end[current] = end[1-current];
    edgeLen[current] = edgeLen[1-current];
    (*IDH[current]) = (*IDH[1-current]);
    HMG[current] = HMG[1-current];
  }

  void save_logLikeliIDH() {
    logLikeliIDH[1-current] = logLikeliIDH[current];
  }
  void restore_logLikeliIDH() {
    logLikeliIDH[current] = logLikeliIDH[1-current];
  }

  void save_logLikeliEdges() {
    logLikeliEdge[1-current] = logLikeliEdge[current];
  }
  void restore_logLikeliEdges() {
    logLikeliEdge[current] = logLikeliEdge[1-current];
  }


  /*
  void saveToTemp() {
    logLikeliIDH[2] = logLikeliIDH[current];
    logLikeliEdge[2] = logLikeliEdge[current];
    start[2] = start[current];
    end[2] = end[current];
    edgeLen[2] = edgeLen[current];
    (*IDH[2]) = (*IDH[current]);
    HMG[2] = HMG[current];  
  }
  void restoreFromTemp() {
    logLikeliIDH[current] = logLikeliIDH[2];
    logLikeliEdge[current] = logLikeliEdge[2];
    start[current] = start[2];
    end[current] = end[2];
    edgeLen[current] = edgeLen[2];
    (*IDH[current]) = (*IDH[2]);
    HMG[current] = HMG[2];
  }
  */
  void runEdge(Rand&,const Parameters&, int);
  void runEdge(Rand&,const Parameters&);
  void runEdge2(Rand&, const Parameters&);
  void generateSeqAtEndNode(Rand&, const Parameters&);
  int generateLetter(int, vector<vector<double> >, double, int, Rand&);
  void generateIDHandSeq(Rand&, const Parameters&);
  void generateIDH(Rand&, const Parameters&);
  double fDel(int x, double rd){ return x - ((1-rd)*(1 - pow(1-rd, x))/ rd);} 
  double likeliHistory(const Parameters& , int);
  double likeliHistory(const Parameters&);
  double CalculatelogLikeliEdge(const Parameters&);
  double ProposHistory(const Parameters&);
  double ProposHistory2(const Parameters&);
  void ReverseIDH();  
  void changeStartEnd();
  void ReverseEdge();
  void printEdge();
  void printEdge(int c);
  void printEdge(ofstream&);
 
  int getNumHMG() const { return numHMG; }
  int getNumSub() const { return numSub; }
  void setNumHMG(int p) { numHMG = p;}
  void setNumSub(int p) { numSub = p;}  
  void incNumHMG() { numHMG++;}
  void incNumSub() { numSub++;} 

  //-- v23 start --//
  bool getOnLine() const { return onLine; }
  int getHMG_v2(int i) const { return HMG_v2[i]; }
  void setNewHMG();
  void reSetNewHMG();
  //-- v23 end --//


private:
  int number;
  int current;  // indicates which of the two states is current
  Node* start[2];
  Node* end[2];
  double edgeLen[2];
  vector<InDelHistory*> IDH;
  vector<vector<int> > HMG;
  double logLikeliIDH[2];
  double logLikeliEdge[2];
  
  int numHMG;
  int numSub;

  //-- v23 start --//
  vector<int> HMG_v2;
  bool onLine;
  //-- v23 end --//

}; // end of class Edge







class Tree {
public:
  Tree(int,Rand&,const Parameters&, vector<vector<int> >, double);
  int convChar(char);
  Tree(int,Rand&, Parameters&, vector<string>);
  Tree(int,Rand&,const Parameters&, vector<vector<int> >);
  Tree(int, Rand&, Parameters&, double, int);
  Tree(int, Rand&, RNG&, Parameters&);
  ~Tree() {
    for(vector<Node*>::iterator p=nodes.begin();p!=nodes.end();p++)
      delete *p;
    nodes.resize(0);
    for(vector<Edge*>::iterator p=edges.begin();p!=edges.end();p++)
      delete *p;
    edges.resize(0);
    for(int i=0;i<2;i++)
      UpdatedNodeinRootSites[i].resize(0);
    UpdatedNodeinRootSites.resize(0);
  }
  Node* getRoot() const { return root; }
  Edge* getEdge(int i) const { return edges[i]; }
  Node* getNode(int i) const { return nodes[i]; }
  void GetSplits(Edge*, Node*, vector<int>&);
  int GetSplitsIndex(Edge*, vector<vector<int> >, int);
  //double getLogLikelihood() { return logLikelihood[current]; }
  //double getLogLikelihood(int c) { return logLikelihood[c]; }
  //void setLogLikelihood(double x) { logLikelihood[current] = x; }
  //void setLogLikelihood(double x, int c) { logLikelihood[c] = x; }
  void calculateLogLikelihood(const Parameters&);
  double CalculatelogLikeliEdges(const Parameters&);
  double likeliHistory(const Parameters&, int);
  double likeliHistory(const Parameters&);
  double likeliData(const Parameters&, int);
  //double likeliData(const Parameters&);
  double calPriorParas(const Parameters&);
  double likeliData();
  void UpdateAllinfoToRoot(const Parameters&, Node*);
  void UpdateAllinfoTogivenNode(const Parameters&, Node*, Node*);
  void combineIDHonTwoEdges(Edge* , Edge* );
  void separateIDHintoTwoEdges(Edge* , Edge* , double);
  void ConstructSetofEdgesinMaximumStep(int, int, vector<int>&, Edge*, Node*);



  /*** NNI start ***/
  double NNIwithFixedHMG(Rand&, RNG&, const Parameters&, ofstream&, int);
  double NNIwithFixedHMG(Rand&, RNG&, const Parameters&);
  int countNumID(vector<vector<int> > );
  void countNumIDonEachEdge(vector<vector<int> >, vector<int>&, int);
  double generateNewIDHfromPairwiseAlignment(vector<int>, vector<int>, double, InDelHistory*, Rand&, const Parameters&);
  double calProbIDHfromPairwiseAlignment(vector<int>, vector<int>, double, InDelHistory*, const Parameters&);
  void reOrderHMGs(vector<vector<int> >&);
  int compareHMGsWithInconclusive(vector<int>, vector<int>);

  /*** NNI end ***/
    



  double SPRonSubTree(Rand&,Parameters&, int, ofstream&, ofstream&);
  double SPRonSubTreeWithinWindow(Rand&,Parameters&, int,ofstream&, ofstream&);
  double SPRonSubTreeWithTarget(Rand&,Parameters&, int,ofstream&, ofstream&);
  double SPRonSubTreeWithTargetWithinWindow(Rand&,Parameters&, int,ofstream&, ofstream&);


  double SPRonSingleEdge(Rand&,const Parameters&,ofstream&);
  double SPRonSingleEdgeAsPartOfSPRonSubTree(Rand&,const Parameters&, int, int, int,ofstream&);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(Rand&,const Parameters&, int, int, int, double,ofstream&);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithTarget(Rand&,const Parameters&, int, int, int, double, double, double,ofstream&);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithTargetWithinWindow(Rand&,const Parameters&, int, int, int, double, double, double, double,ofstream&);



  double SPRonSubTree(Rand&,Parameters&, int, ofstream&, ofstream&, int);
  double SPRonSubTreeWithinWindow(Rand&,Parameters&, int,ofstream&, ofstream&, int);
  double SPRonSubTreeWithTarget(Rand&,Parameters&, int,ofstream&, ofstream&, int);
  double SPRonSubTreeWithTargetWithinWindow(Rand&,Parameters&, int,ofstream&, ofstream&, int);

  double SPRonSubTreeWithinWindowGivenWindowLen(Rand&,Parameters&, int,ofstream&, ofstream&, int);
  double SPRonSubTreeWithTargetWithinWindowGivenWindowLen(Rand&,Parameters&, int,ofstream&, ofstream&, int);


  double SPRonSingleEdge(Rand&,const Parameters&,ofstream&, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTree(Rand&,const Parameters&, int, int, int,ofstream&, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(Rand&,const Parameters&, int, int, int, double,ofstream&, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithTarget(Rand&,const Parameters&, int, int, int, double, double, double,ofstream&, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithTargetWithinWindow(Rand&,const Parameters&, int, int, int, double, double, double, double,ofstream&, int);



  double UpIDHonEdgeWithFixedHMG(Rand&, Parameters&, ofstream&);
  double UpIDHonEdgeWithFixedHMG(Rand&, Parameters&, ofstream&, int);




  double SPRonSubTreeWithFixedHMG(Rand&,Parameters&, int, ofstream&, ofstream&, int);
  double SPRonSubTreeWithFixedHMG(Rand&,Parameters&, int, ofstream&, ofstream&);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMG(Rand&, Parameters&, int, int, int,ofstream&, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMG(Rand&, Parameters&, int, int, int,ofstream&);
  
  
  double generateNewIDHonEdgeWhileKeepingHMG(Rand&,Parameters&, vector<int>, vector<int>, vector<int>, double, InDelHistory*, vector<vector<int> >);
  double calProbIDHonEdgeWhileKeepingHMG(Parameters&, vector<int>, vector<int>, vector<int>, double, InDelHistory*, vector<vector<int> >);

  double generateNewIDHonEdgeWhileKeepingHMG(Rand&,Parameters&, vector<int>, vector<int>, vector<int>, double, InDelHistory*);
  double calProbIDHonEdgeWhileKeepingHMG(Parameters&, vector<int>, vector<int>, vector<int>, double, InDelHistory*);



  void calWeight(vector<int>, int, vector<int>, vector<double>&);

  //--- v20 start ---//
  void calWeightIn(vector<int>, vector<int>, vector<double>&, double);
  //--- v20 end ---//

  void runEdgeWithDeletionConstraint(Rand&, const Parameters&, InDelHistory*, int, int, double, vector<int>, vector<vector<double> >&);
  double ProposHistoryWithDeletionConstraint(const Parameters&, InDelHistory*, vector<int>, vector<vector<double> >);
  double ProposHistoryWithDeletionConstraint(const Parameters&, InDelHistory*, vector<int>);



  double extractSubIDH(InDelHistory*, InDelHistory*, int, double);
  double insertSubIDH(InDelHistory*, InDelHistory*, int);
  double runEdge(Rand&, const Parameters&, InDelHistory*, int, int, double);
  



  double moveNodeOnTwoEdges(Edge*, Edge*, double, double);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeLike(bool, Rand&,const Parameters&, int, int, double, int, vector<InDelHistory*>, bool);
  double SPRonSubTreeAsPartOfSPRonSubTreeLike(bool, Rand&, const Parameters&, int, int, double, int, int, vector<InDelHistory*>, int, bool); 
  int findCloseNode(Node*, Edge*, Edge*);
  double SPRonSubTreeLike(Rand&,Parameters&, int, ofstream&, ofstream&);
  double UpEdgeLen(Rand&, const Parameters&,ofstream&);
  double UpEdgeLen_v2(Rand&, const Parameters&);
  double fDel(int x, double rd){ return x - ((1-rd)*(1 - pow(1-rd, x))/ rd);} 
  void UpdateAllinfoToRootWithChangedHMG(const Parameters&, Node*);
  double UpIDHonEdge(Rand&, const Parameters&,ofstream&);
  double UpIDHonEdgeLike(Rand&, Parameters&, int, int,ofstream&);
  void getHiddenHMG(vector<int>&, vector<int>, int);
  int inHotSpotRegion(vector<vector<int> >, vector<vector<int> >, vector<int>, int);
  double UpIDHandSeq(Rand&, Parameters&,ofstream&);
  double UpIDHandSeq_v2(Rand&, Parameters&,ofstream&);
  bool UpR(Rand&, RNG&, Parameters&);
  bool UpRd(Rand&, RNG&, Parameters&);
  bool UpLambda(Rand&, Parameters&);
  bool UpKappa(Rand&, Parameters&);
  bool UpGamma(Rand&, Parameters&);
  bool UpPi(Rand&, RNG&, Parameters&);

  bool UpR(Rand&, RNG&, Parameters&,ofstream&);
  bool UpRd(Rand&, RNG&, Parameters&,ofstream&);
  bool UpLambda(Rand&, Parameters&,ofstream&);
  bool UpKappa(Rand&, Parameters&,ofstream&);
  bool UpGamma(Rand&, Parameters&,ofstream&);
  bool UpPi(Rand&, RNG&, Parameters&,ofstream&);


  double SPRonSubTreeLike(Rand&,Parameters&, int, ofstream&, ofstream&, int);
  double UpEdgeLen(Rand&, const Parameters&,ofstream&, int);
  double UpIDHonEdge(Rand&, const Parameters&,ofstream&, int);
  double UpIDHonEdgeLike(Rand&, Parameters&, int, int,ofstream&, int);
  double UpIDHonEdgeRandomWindow(Rand&, const Parameters&,ofstream&, int);
  double UpIDHonEdgeLikeRandomWindow(Rand&, Parameters&, int, int,ofstream&, int);
  double UpIDHandSeq(Rand&, Parameters&,ofstream&, int);
  double UpIDHandSeq_v2(Rand&, Parameters&,ofstream&, int);

  double SPRonSubTree_v0(Rand&,Parameters&, int);
  double SPRonSingleEdge_v0(Rand&,const Parameters&);
  double SPRonSingleEdgeAsPartOfSPRonSubTree_v0(Rand&,const Parameters&, int, int, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeLike_v0(bool, Rand&,const Parameters&, int, int, double, int, vector<InDelHistory*>, bool);
  double SPRonSubTreeAsPartOfSPRonSubTreeLike_v0(bool, Rand&, const Parameters&, int, int, double, int, int, vector<InDelHistory*>, int, bool); 
  double SPRonSubTreeLike_v0(Rand&,const Parameters&, int);
  double UpEdgeLen_v0(Rand&, const Parameters&);
  double UpIDHonEdge_v0(Rand&, const Parameters&);
  double UpIDHonEdgeLike_v0(Rand&, Parameters&, int, int);
  double UpIDHandSeq_v0(Rand&, Parameters&);
  double UpOneIDH(Rand&, Parameters&, ofstream&);
  double UpOneIDHfixHMG(Rand&, Parameters&, ofstream&);

  

  double ProposHistory(const Parameters&, InDelHistory*);



  void checkTree();
  void printTree();
  void printTree(int c);
  void printTree(ofstream&);


  void resetSubtreeprob();
  void resetSubtreeprob(int c);

  void set0UpdatedNodeinRootSites() {
    UpdatedNodeinRootSites[current].resize(0);
    for(int i = 0; i < UpdatedNodeinRootSites[1-current].size(); i++)
      UpdatedNodeinRootSites[current].push_back(0);
  }
  double getLogLikeliEdges() const { return logLikeliEdges[current]; }
  double getLogLikeliData() const { return logLikeliData[current]; } 
  double getLogLikeliIDH() const { return logLikeliIDH[current]; } 
  int getnumNodes() const { return numNodes; }
  int getnumEdges() const { return numEdges; }
  double EdgeSum();

  int findSmallest(vector<int>&,Node*,Edge*) const;

  void print(ofstream&);
  void printBL(ofstream&);
  void printInt(ofstream&,vector<int>&,Node*,Edge*) const;
  void printIntBL(ofstream&,vector<int>&,Node*,Edge*) const;
  void getAlignments(vector<vector<int> >&);

  /*** NNI ***/
  void getAlignments(vector<vector<int> >&, vector<int>, int);
  /*** NNI ***/
  void printAlignments(ofstream&, vector<vector<int> >&);
  void printAlignments_v2(ofstream&, vector<vector<int> >&);
  void printAlignmentsPosi(ofstream&, vector<vector<int> >&);
  void printAlignmentsPosi_v2(ofstream&, vector<vector<int> >&);
  void printSeq(ofstream&);

  void save() {
    //logLikelihood[1-current] = logLikelihood[current];
    logLikeliData[1-current] = logLikeliData[current];
    logLikeliIDH[1-current] = logLikeliIDH[current];
    logLikeliEdges[1-current] = logLikeliEdges[current];
    UpdatedNodeinRootSites[1-current] = UpdatedNodeinRootSites[current];
    for(int i=0; i < numNodes; i++)
      nodes[i]->save();
    for(int i=0; i < numEdges; i++)
      edges[i]->save();  
  }
  void restore() {
    //logLikelihood[current] = logLikelihood[1-current];
    logLikeliData[current] = logLikeliData[1-current];
    logLikeliIDH[current] = logLikeliIDH[1-current];
    logLikeliEdges[current] = logLikeliEdges[1-current];
    UpdatedNodeinRootSites[current] = UpdatedNodeinRootSites[1-current];
    for(int i=0; i < numNodes; i++)
      nodes[i]->restore();
    for(int i=0; i < numEdges; i++)
      edges[i]->restore();  
  }
  void save_logLikeliData() {
    logLikeliData[1-current] = logLikeliData[current];
    for(int i=0; i < numNodes; i++)
      nodes[i]->save_logLikeliData();
  }
  void restore_logLikeliData() {
    logLikeliData[current] = logLikeliData[1-current];
    for(int i=0; i < numNodes; i++)
      nodes[i]->restore_logLikeliData();  
  }
  void save_logLikeliIDH() {
    logLikeliIDH[1-current] = logLikeliIDH[current];
    for(int i=0; i < numEdges; i++)
      edges[i]->save_logLikeliIDH();  
  }
  void restore_logLikeliIDH() {
    logLikeliIDH[current] = logLikeliIDH[1-current];
    for(int i=0; i < numEdges; i++)
      edges[i]->restore_logLikeliIDH();  
  }
  void save_logLikeliEdges() {
    logLikeliEdges[1-current] = logLikeliEdges[current];
    for(int i=0; i < numEdges; i++)
      edges[i]->save_logLikeliEdges();  
  }
  void restore_logLikeliEdges() {
    logLikeliEdges[current] = logLikeliEdges[1-current];
    for(int i=0; i < numEdges; i++)
      edges[i]->restore_logLikeliEdges();  
  }


  /*
  void saveToTemp() {
    //logLikelihood[1-current] = logLikelihood[current];
    logLikeliData[2] = logLikeliData[current];
    logLikeliIDH[2] = logLikeliIDH[current];
    logLikeliEdges[2] = logLikeliEdges[current];
    UpdatedNodeinRootSites[2] = UpdatedNodeinRootSites[current];
    for(int i=0; i < numNodes; i++)
      nodes[i]->saveToTemp();
    for(int i=0; i < numEdges; i++)
      edges[i]->saveToTemp();  
  }
  void restoreFromTemp() {
    //logLikelihood[current] = logLikelihood[1-current];
    logLikeliData[current] = logLikeliData[2];
    logLikeliIDH[current] = logLikeliIDH[2];
    logLikeliEdges[current] = logLikeliEdges[2];
    UpdatedNodeinRootSites[current] = UpdatedNodeinRootSites[2];
    for(int i=0; i < numNodes; i++)
      nodes[i]->restoreFromTemp();
    for(int i=0; i < numEdges; i++)
      edges[i]->restoreFromTemp();  
  }
  */


  /*** NNI.v2 start ***/
  double getlogLikeliIDH() const { return logLikeliIDH[current]; }
  double setlogLikeliIDH(double b) { logLikeliIDH[current] = b; }
  /*** NNI.v2 end ***/

  //-- v23 start --//
  double UpIDHonEdgeWithFixedHMGbyDistance(Rand&, Parameters&, ofstream&);
  double UpIDHonEdgeWithFixedHMGbyDistance(Rand&, Parameters&, ofstream&, int);
  //-- v23 end --//

  //-- v24 start --//
  double UpIDHonEdgeWithFixedHMGbyDistanceAndAdjust(Rand&, Parameters&, ofstream&);
  double UpIDHonEdgeWithFixedHMGbyDistanceAndAdjust(Rand&, Parameters&, ofstream&, int);
  double generateNewIDHonEdgeWhileKeepingHMGandAdjust(Rand&,Parameters&, vector<int>, vector<int>, vector<int>, vector<int>, double, InDelHistory*, vector<vector<double> >&, vector<vector<double> >&,  vector<vector<double> >&, vector<vector<double> >&, vector<double>&, int, int);
  double calProbIDHonEdgeWhileKeepingHMGandAdjust(Parameters&, vector<int>, vector<int>, vector<int>, vector<int>, double, InDelHistory*, vector<vector<double> >&, vector<vector<double> >&,  vector<vector<double> >&, vector<vector<double> >&, vector<double>&, int, int);

  //-- v24 end --//

  //-- v27 start --//
  double UpIDHonEdgebyDP(Rand&, Parameters&, ofstream&);
  double UpIDHonEdgebyDP(Rand&, Parameters&, ofstream&, int);
  double generateNewIDHfromPairwiseAlignment(vector<vector<int> >, double, InDelHistory*, Rand&, const Parameters&);
  double calProbIDHfromPairwiseAlignment(vector<vector<int> >, double, InDelHistory*, const Parameters&);
  void getPairwiseAlignmentsFromHMG(vector<int>, int, int, vector<vector<int> >&);
  //-- v27 end --//


  //-- v28 start --//
  double SPRonSubTreebyDP(Rand&,Parameters&, int, ofstream&, ofstream&, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTreebyDP(Rand&, Parameters&, int, int, int, ofstream&, int);

  //-- v28 end --//


  //-- v30 start --//
  // This node is included in a given Set. This function return node number which is also in a given set and two edges apart from this node. 
  // If there's no node which is two steps apart and in a given set, return -1
  int getCloseNodeNumberInGivenSet(int, vector<int>&, int);
  // Exactly same as generateNewIDHfromPairwiseAlignment, but it doesn't calculate proposal prob
  void generateNewIDHfromPairwiseAlignmentWOprobCal(vector<vector<int> >, double, InDelHistory*, Rand&, const Parameters&);
  //-- v30 end --//


  //-- v34 start --//
  double UpIDHonEdgebyDPbestLetters(Rand&, Parameters&, ofstream&, int);
  double SPRonSubTreebyDPbestLetters(Rand&,Parameters&, int, ofstream&, ofstream&, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTreebyDPbestLetters(Rand&, Parameters&, int, int, int, ofstream&, int);
  //-- v34 end --//


  //-- v35 start --//
  double UpIDHonEdgeWithFixedHMGbyDP(Rand&, Parameters&, ofstream&, int);
  double SPRonSubTreeWithFixedHMGbyDP(Rand&,Parameters&, int, ofstream&, ofstream&, int);
  double SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMGbyDP(Rand&, Parameters&, int, int, int, ofstream&, int);
  //-- v35 end --//


private:
  int current;
  int numLeaves;
  int numNodes;
  int numEdges;
  int outGroupNode;
  //-- v29 start --//
  int numLetters;
  //-- v29 end --//
  Node* root;
  vector<Node*> nodes;
  vector<Edge*> edges;
  //double logLikelihood[2];
  double logLikeliData[2];
  double logLikeliIDH[2];
  double logLikeliEdges[2];
  vector<vector<int> > UpdatedNodeinRootSites; //set 1 at node position with updated Rootsites, ow set 0 
};






vector<double> Rand::rDirichlet(vector<double> alpha, RNG &rng){

  int len = alpha.size();
  int i;
  vector<double> x(0);


  if(len < 2){
    cout << "ERROR in rDirichlet! Size of alpha should be at least 2." << endl;
  }else{

    for(i = 0; i < len; i++)
      x.push_back(rng.gamma(alpha[i], 1));
    
    double sum = sum_vec(x);
    
    for(i = 0; i < len; i++)
      x[i] = x[i]/sum;

  }

  return x;

}


double Rand::rRatioOfExps(double epsilon){

  double Fx;
  double x;

  Fx = Rand::runif();
  x = (Fx/(1-Fx))/epsilon;
  while(x < 0){
    Fx = Rand::runif();
    x = (Fx/(1-Fx))/epsilon;
  }
  return x;
}



int Rand::rwunif(vector<double> weight){

  sumwt.resize(0);
  double psum = 0;
  double x;
  int y;
  for(int k=0;k<weight.size();k++){
    if(weight[k]<0){
      cout << "ERROR! All weight should be positive or zero." << endl;
    }
    psum += weight[k];
    sumwt.push_back(psum);
  }
  x = Rand::runif()*sumwt[weight.size()-1];
  for(int k=0;k<weight.size();k++){
    if(x <= sumwt[k]){
      y = k;
      break;
    }
  }
  return y;
}




//-- v30 start --//
int Rand::rwunif(vector<int> weight){

  sumwt.resize(0);
  double psum = 0;
  double x;
  int y;
  for(int k=0;k<weight.size();k++){
    psum += (double)weight[k];
    sumwt.push_back(psum);
  }
  if(sumwt[weight.size()-1]==0)
    cout << "ERROR in rwunif2 !! " << endl;
  x = Rand::runif()*sumwt[weight.size()-1];
  for(int k=0;k<weight.size();k++){
    if(x <= sumwt[k]){
      y = k;
      break;
    }
  }
  return y;
}
//-- v30 end --// 

int Rand::rgeom(double p){

  double Fx;
  int x;
  Fx=Rand::runif();

  if((p <=0) || (p>=1)){
    cout << "ERROR" << endl;
  }else{
    x=int(log(1-Fx) / log(1-p) + .5);        //round the value
    while(x<1){
      Fx=Rand::runif();
      x=int(log(1-Fx) / log(1-p)+.5);
    }
  }
  return x;
}// end rGeom




int Rand::rgeom0(double p){

  double Fx;
  int x;
  Fx=Rand::runif();

  if((p <=0) || (p>=1)){
    cout << "ERROR" << endl;
  }else{
    x=int(log(1-Fx) / log(1-p) + .5) -  1;        //round the value
    while(x<0){
      Fx=Rand::runif();
      x=int(log(1-Fx) / log(1-p)+.5) - 1;
    }
  }
  return x;
}// end rGeom




int Rand::rTRgeom(double p, int N){
  double Fx, Fx2;
  int x;
  Fx=Rand::runif();
  Fx2 = Fx*(1-pow(1-p,N));
  x=int(log(1-Fx2) / log(1-p) + .5);        //round the value
  while(x<1 || x>N){
    //cout << "In There " << endl;
    Fx=Rand::runif();
    Fx2 = Fx*(1-pow(1-p,N));
    x=int(log(1-Fx2) / log(1-p)+.5);
    //cout << "Fx " << Fx << "Fx2 " << Fx2 << "p " << p << "N " << N << "x " << x << endl;
  }
  return x;
}  






void InDelHistory::ReverseIDH(){

  int i, k;

  int currentIndex; 
  int tmphmg;
  int N0;
  int Nend;
  double edgelen;

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);


  int numE = getNumE();
  edgelen = getV(numE+1);
  Nend = getN(numE+1);
  N0 = getN(0);


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);
  for( k = 0; k <= Nend; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);


  
  for(i = numE; i >= 1; i--){
    
    currentIndex = HMG0.size()-1;
    if(getID(i)==1){
      HMGin = HMG0[currentIndex];
      for( k = 0; k < getL(i); k++)
	HMGin.erase(HMGin.begin()+ getP(i));
      V.push_back(edgelen - getV(i));
      ID.push_back(-1);
      P.push_back(getP(i));
      L.push_back(getL(i));
      N.push_back(N[currentIndex] - L[currentIndex+1]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
    }else{

      HMGin = HMG0[currentIndex];
      tmphmg = -1;
      for( k = 0; k < getL(i); k++)
	HMGin.insert(HMGin.begin()+ getP(i),tmphmg);
      V.push_back(edgelen - getV(i));
      ID.push_back(1);
      P.push_back(getP(i));
      L.push_back(getL(i));
      N.push_back(N[currentIndex] + L[currentIndex+1]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);

    }

  }

  V.push_back(edgelen);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);    
  HMG0.push_back(HMG0[numE]);
 

  setHistory(numE, V, ID, P, L, N, HMG0); 

  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0); 
  HMG0.resize(0);
  HMGin.resize(0);

}



//-- v30 start --//
// This node is included in a given Set. This function return index of node number which is also in a given set and two edges apart from this node. 
// If there's no node which is two steps apart and in a given set, return -1
int Tree::getCloseNodeNumberInGivenSet(int nodeNum, vector<int>& Set, int pEdgeNum){

  int res;
  Node* tNode;
  Edge* tEdge;
  

  //cout << "In getCloseNodeNumberInGivenSet" << endl;
  //cout << "Set " << endl;
  //print_veci(Set);
  //cout << "nodeNum : " << nodeNum << endl;
  //cout << "pEdgeNum : " << pEdgeNum << endl;

  if(!is_element(Set,nodeNum)){
    cout << "ERROR in getCloseNodeNumberInGivenSet! This node is not in a given set! " << endl;
    res = -1;
  }else{
    tNode = edges[pEdgeNum]->getOtherNode(nodes[nodeNum]);
    //cout << "tNode->getnumber() " <<  tNode->getnumber() << endl;

    if(is_element(Set,tNode->getnumber())){
      cout << "ERROR in getCloseNodeNumberInGivenSet! Parent node is in a given set!" << endl;
      res = -1;
    }else{
      int numEdge = tNode->getnumEdges();
      int inttmp, posi;
      int EdgeIX;
      res = -1;
      for(int i=0; i < numEdge; i++){
	EdgeIX = tNode->getEdge(i)->getnumber();
	//cout << "EdgeIX : " << EdgeIX << endl;
	if(EdgeIX != pEdgeNum){
	  inttmp = edges[EdgeIX]->getOtherNode(tNode)->getnumber();
	  posi = where_element(Set, inttmp);
	  if(posi >= 0){
	    res = posi;
	    break;
          }
        }
      }
    }
  }

  return res;

}
//-- v30 end --//



Node* Node::getParent()
{ 
return getParentEdge()->getOtherNode(this); }



int Node::getEdgeNum(Edge *e)
{  
  int EdgeNum;
  for(int i = 0; i < numEdges; i++){
    if(edges[current][i] == e ){
      EdgeNum = i;
      break;
    }
  }
  
  return EdgeNum;
}




//Just re-calculate loglikelihood of Linked Site in this node after changing tree structure  
void Node::CalloglikeliofLinkedSites(const Parameters &params){
  
  int h;

  set0logLikelihood();

  for(h=0; h< seqLen[current]; h++){
    if(LinkedSites[current][h] == 1)
      logLikelihood[current][h] = linkedSitelogLikelihood(params, h);
  }

}




void Node::CalloglikeliofLinkedSitesWithChangedHMG(const Parameters &params, int EdgeNumToCheck){
  
  int h;

  //set0logLikelihood();

  Edge* tempEdge;

  if(getLeaf()){

    cout << "ERROR! CalloglikeliofLinkedSitesWithChangedHMG cannot be applied to leaf!" << endl;

  }else{  // else if (getLeaf())

    tempEdge = getEdge(EdgeNumToCheck);

    for(h=0; h< seqLen[current]; h++){

      if(tempEdge->getHMG(h, 0) != tempEdge->getHMG(h, 1)){ 

	if(LinkedSites[current][h] == 1)
	  logLikelihood[current][h] = linkedSitelogLikelihood(params, h);
	else
	  logLikelihood[current][h] = 0;
      }
   
    }
  }
}






void Node::CalloglikeliofLinkedSitesWithChangedG(const Parameters &params, int EdgeNumToCheck){
  
  int h;

  //set0logLikelihood();

  //cout << " In CalloglikeliofLinkedSitesWithChangedG " << endl;

  Edge* tempEdge;
  Node* Cnode;

  if(getLeaf()){

    cout << "ERROR! CalloglikeliofLinkedSitesWithChangedHMG cannot be applied to leaf!" << endl;

  }else{  // else if (getLeaf())

    tempEdge = getEdge(EdgeNumToCheck);
    Cnode = tempEdge->getEnd();
    
    for(h=0; h< seqLen[current]; h++){

      //cout << "h : " << h << endl;
      //cout << "tempEdge->getHMG(h)   " << tempEdge->getHMG(h) << endl;
      //cout << "Cnode->getChangedHMG(tempEdge->getHMG(h))   " << Cnode->getChangedHMG(tempEdge->getHMG(h)) << endl;

      //if((tempEdge->getHMG(h)>=0) & (Cnode->getChangedHMG(tempEdge->getHMG(h))==1)){ 

      if(tempEdge->getHMG(h)>=0){

	if(Cnode->getChangedHMG(tempEdge->getHMG(h))==1){
       
	  if(LinkedSites[current][h] == 1)
	    logLikelihood[current][h] = linkedSitelogLikelihood(params, h);
	  else
	    logLikelihood[current][h] = 0;
	}
      }
    }
    Cnode->resetChangedHMG();

  }
}






// Update Linked Sites in the updated tree structure  
void Node::findLinkedSites(){
  
  int h, unLinked, k;  
  Edge* cEdge;

  set0LinkedSites();
 
  for(h=0; h< seqLen[current]; h++){
    unLinked = 0;
    for(k = 0; k < numEdges; k++){
      cEdge = getEdge(k);
      if(cEdge->getHMG(h)<0){
	unLinked++;
      }
    }
    if(unLinked < numEdges)  // This site is root, but doesn't connected to any child nodes 
      LinkedSites[current][h] = 1;
  }
}


//Update Linked Sites in the updated tree structure and re-calculate loglikelihood of updated Linked Sites in this node  
void Node::CalloglikeliofUpdatedLinkedSites(const Parameters &params){
  
  int h, i, b, k, m, seqlen, matchedSite;  
  double tmpres0, tmpres1;

  set0logLikelihood();
  set0LinkedSites();
 
  for(h=0; h< seqLen[current]; h++){
    logLikelihood[current][h] = linkedSitelogLikelihood(params, h);
    if(logLikelihood[current][h]!=0)
      LinkedSites[current][h] = 1;
  }
}





//Just re-calculate loglikelihood of Root Site in this node after changing tree structure  
void Node::CalloglikeliofRootSites(const Parameters &params){
  
  int h;
  
  //cout << "ININININ CalloglikeliofRootSites " << endl;
  //cout << "Node number :" << getnumber() << endl;
  set0logLikelihood();

  for(h=0; h< seqLen[current]; h++){
    if(rootSites[current][h] == 1)
      logLikelihood[current][h] = rootSitelogLikelihood(params, h);
  }


}




//Just re-calculate loglikelihood of Root Site in this node after changing tree structure  
void Node::CalloglikeliofRootSitesWithChangedHMG(const Parameters &params, int EdgeNumToCheck){
  
  int h;
  
  //cout << "ININININ CalloglikeliofRootSites " << endl;
  //cout << "Node number :" << getnumber() << endl;
  //set0logLikelihood();

  Edge* tempEdge;

  if(getLeaf()){

    cout << "ERROR! CalloglikeliofRootSitesWithChangedHMG cannot be applied to leaf!" << endl;

  }else{  // else if (getLeaf())

    set0ChangedHMG();

    tempEdge = getEdge(EdgeNumToCheck);

    for(h=0; h< seqLen[current]; h++){


      if(tempEdge->getHMG(h, 0) != tempEdge->getHMG(h, 1)){ 

	ChangedHMG[h] = 1;

	if(rootSites[current][h] == 1)
	  logLikelihood[current][h] = rootSitelogLikelihood(params, h);
        else
	  logLikelihood[current][h] = 0;

      }
    }
  }

}




//Just re-calculate loglikelihood of Root Site in this node after changing tree structure  
void Node::CalloglikeliofRootSitesWithChangedG(const Parameters &params, int EdgeNumToCheck){
  
  int h;
  
  //cout << " In CalloglikeliofRootSitesWithChangedG " << endl;
  //cout << "ININININ CalloglikeliofRootSites " << endl;
  //cout << "Node number :" << getnumber() << endl;
  //set0logLikelihood();

  Edge* tempEdge;
  Node* Cnode;

  if(getLeaf()){

    cout << "ERROR! CalloglikeliofRootSitesWithChangedHMG cannot be applied to leaf!" << endl;

  }else{  // else if (getLeaf())

    set0ChangedHMG();

    tempEdge = getEdge(EdgeNumToCheck);
    Cnode = tempEdge->getEnd();

    for(h=0; h< seqLen[current]; h++){

      //cout << "h : " << h << endl;
      //cout << "tempEdge->getHMG(h)   " << tempEdge->getHMG(h) << endl;
      //cout << "Cnode->getChangedHMG(tempEdge->getHMG(h))   " << Cnode->getChangedHMG(tempEdge->getHMG(h)) << endl;
      

      //if((tempEdge->getHMG(h)>=0) & (Cnode->getChangedHMG(tempEdge->getHMG(h))==1)){ 

      if(tempEdge->getHMG(h)>=0){
	if(Cnode->getChangedHMG(tempEdge->getHMG(h))==1){
	
	  ChangedHMG[h] = 1;
	  
	  if(rootSites[current][h] == 1)
	    logLikelihood[current][h] = rootSitelogLikelihood(params, h);
	  else
	    logLikelihood[current][h] = 0;

	}
      }
    }

    Cnode->resetChangedHMG();

  }

}










//Just re-calculate loglikelihood of Root Site in this node if necessary. If possible, use the previous loglikelihood  
void Node::CalloglikeliofRootSitesOrReuse(const Parameters &params){
  
  int h;
 
  for(h=0; h< getrootSitesSize(); h++){
    if(getrootSites(h) == 1){
      if(getlogLikelihood(h)==0)
	setlogLikelihood(h, rootSitelogLikelihood(params, h));
    }else
      setlogLikelihood(h, 0);
  }
}


//Update Root Sites in the updated tree structure 
void Node::findRootSites(){

  int h, m, seqlen, matchedSite, stSite, enSite;  
  
  //cout << " In findRootSites " << endl;

  set0rootSites();
 
  Edge* pEdge = getParentEdge();
  
  matchedSite = 0;

  seqlen = pEdge->getOtherNode(this)->getSeqLen(); 

  //cout << "Parent Edge number : " << pEdge->getnumber() << " Parent node number : " <<  pEdge->getOtherNode(this)->getnumber() << " seqlen : " << seqlen << endl;

  for(h=0; h< seqlen; h++){
 
    if(pEdge->getHMG(h)>=0){
      stSite = matchedSite;
      enSite = pEdge->getHMG(h)-1;
      if(stSite <= enSite){
	for(m = stSite; m <= enSite; m++)
	  setrootSites(m, 1);
      }
      matchedSite = enSite+2;
    }
  }

  stSite = matchedSite;
  enSite = getSeqLen();   
  if(stSite <= enSite){
    for(m = stSite; m < enSite; m++)
      setrootSites(m, 1);
  }

}





//Update Root Sites in the updated tree structure and re-calculate loglikelihood of updated Root Sites in this node if necessary. If possible, use the previous loglikelihood  
void Node::UpdateRootSites(const Parameters &params){

  int h, i, m, seqlen, matchedSite, stSite, enSite;  

  set0rootSites();

  Edge* pEdge = getParentEdge();
  
  matchedSite = 0;

  seqlen = getParentEdge()->getOtherNode(this)->getSeqLen(); 

  for(h=0; h< seqlen; h++){
    
    if(pEdge->getHMG(h)>=0){
      stSite = matchedSite;
      enSite = pEdge->getHMG(h)-1;
      if(stSite <= enSite){
	for(m = stSite; m <= enSite; m++){
	  setrootSites(m, 1);
	  if(getlogLikelihood(m)==0)
	    setlogLikelihood(m, rootSitelogLikelihood(params, m));
        }
      }
      matchedSite = enSite+2;
    }
  }

  stSite = matchedSite;
  enSite = getSeqLen();   
  if(stSite <= enSite){
    for(m = stSite; m < enSite; m++){
      setrootSites(m, 1);
      if(getlogLikelihood(m)==0)
	setlogLikelihood(m, rootSitelogLikelihood(params, m));
    }
  }

  for(m = 0; m < getrootSitesSize(); m++){
    if(getrootSites(m)==0)
      setlogLikelihood(m, 0);
  }
}



//Update Root Sites in the updated tree structure and re-calculate loglikelihood of updated Root Sites in this node  
void Node::CalloglikeliofUpdatedRootSites(const Parameters &params){

  int h, m, seqlen, matchedSite, stSite, enSite;  
  
  set0rootSites();
  set0logLikelihood();

  Edge* pEdge = getParentEdge();
  
  matchedSite = 0;

  seqlen = getParentEdge()->getOtherNode(this)->getSeqLen(); 

  for(h=0; h< seqlen; h++){
    
    if(pEdge->getHMG(h)>=0){
      stSite = matchedSite;
      enSite = pEdge->getHMG(h)-1;
      if(stSite <= enSite){
	for(m = stSite; m <= enSite; m++){
	  setrootSites(m, 1);
	  setlogLikelihood(m, rootSitelogLikelihood(params, m));
	}
      }
      matchedSite = enSite+2;
    }
  }

  stSite = matchedSite;
  enSite = getSeqLen();   
  if(stSite <= enSite){
    for(m = stSite; m < enSite; m++){
      setrootSites(m, 1);
      setlogLikelihood(m, rootSitelogLikelihood(params, m));
    }
  }

}

 
// Calculate loglikelihood of given position in rooted Sites 
double Node::rootSitelogLikelihood(const Parameters &params, int h){



  //cout << "rootSitelogLikelihood " << getnumber() << " " << h << endl;

  //cout << "INININ rootSitelogLikelihood " << endl;
  //cout << "position in rooted Sites : " << h << endl;

  vector<double> pi(0);
  double res, tmpres0, tmpres1;
  int inttmp, i, k, unLinked;
 

  pi = params.getPi();
  Edge* cEdge;


  //-- v32 start --//
  double maxVal;
  //-- v32 end --//


  if(getLeaf()){

    inttmp = seq[h];
    //-- v32 start --//
    res = 0;
    //-- v32 end --//
    for( i = 0; i < numLetters; i++){
      if(inttmp%2==1){
	//-- v32 start --//
	res += log(pi[i]);
	//res += log(pi[i]);
	//-- v32 end --//
      }
      inttmp /= 2;
    }

  }else{

    //cout << "Not leaf " << endl;




    tmpres0 = 0;
    i = 0;
    
    maxVal = 0;
    tmpres1 = pi[i];
    unLinked = 0;
    for(k = 0; k < numEdges; k++){
      if( k != getparentIndex()){
	cEdge = getEdge(k);
	if(cEdge->getHMG(h)>=0){
	    maxVal += cEdge->getEnd()->getsumOflogFs(cEdge->getHMG(h));
	    tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	}else{
	  unLinked++;
	}
      }
    }

    if(unLinked!=(numEdges-1)){

      tmpres0 += tmpres1;   
      for(i = 1; i < numLetters; i++){

	tmpres1 = pi[i];
	for(k = 0; k < numEdges; k++){
	  if( k != getparentIndex()){
	    cEdge = getEdge(k);
	 
	    if(cEdge->getHMG(h)>=0){
	      tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	 
	    }
	  }
	}

	tmpres0 += tmpres1;
      }

    }

    if(unLinked==(numEdges-1)){  // This site is root, but doesn't connected to any child nodes 
      res = 0;
    }else{
      //-- v32 start --//
      //res = log(tmpres0);
      res = log(tmpres0) + maxVal;
      //cout << "res : " << res << " log(tmpres0) " <<   log(tmpres0) << " maxVal " << maxVal << endl;
      //-- v32 end --//
    }

  }

  return res;

}



 
// Calculate loglikelihood of given position in Linked Sites 
double Node::linkedSitelogLikelihood(const Parameters &params, int h){

  vector<double> pi(0);
  double res, tmpres0, tmpres1;
  int inttmp, i, k, unLinked;
 
  pi = params.getPi();
  Edge* cEdge;

  //-- v32 start --//
  double maxVal;
  //-- v32 end --//


  tmpres0 = 0;
  
  i = 0;
  maxVal = 0;
  tmpres1 = pi[i];
  unLinked = 0;
  for(k = 0; k < numEdges; k++){
    cEdge = getEdge(k);
    if(cEdge->getHMG(h)>=0){
      //-- v32 start --//
      maxVal += cEdge->getEnd()->getsumOflogFs(cEdge->getHMG(h));
      //-- v32 end --//
      tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
    }else{
      unLinked++;
    }
  }

  if(unLinked!=numEdges){
  
    tmpres0 += tmpres1;

    for(i = 1; i < numLetters; i++){
  
      tmpres1 = pi[i];
 
      for(k = 0; k < numEdges; k++){
	cEdge = getEdge(k);
	if(cEdge->getHMG(h)>=0){
	  tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	}
      }
   
      tmpres0 += tmpres1;
    }

  }
  if(unLinked==numEdges){  // This site is root, but doesn't connected to any child nodes 
    res = 0;
  }else{
    //-- v32 start --//
    //res = log(tmpres0);
    res = log(tmpres0) + maxVal;
    //-- v32 end --//
  }

  return res;
}





// Calculate Gijk in this node
double Node::CalSubTreeProb(const Parameters &params){


  //cout << "CalSubTreeProb " << getnumber() << endl;

  vector<vector<double> > Pt;
  vector<double> Qtmp(0);
  vector<double> pi(0);
  int inttmp;
  int h, i, b, k, m, j;
  double tmpres0, tmpres1;
  //-- v32 start --//
  double maxVal;
  bool done;
  //-- v32 end --//
  
  Edge* pEdge = getParentEdge();
  Edge* cEdge;



 
  pi = params.getPi();


  // JC substitution model
  /*
  vector<vector<double> > Q;
  double p0, p1;
  Q = params.getQ();  
  p1 = 0.25*(1-exp(-4*Q[0][2]*getParentEdge()->getEdgeLen()));
  p0 = 1 - 3*p1;

  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);  
  */


  

  // HKY substitution model
  // Pt[b][i] = Pr(b->i)
 
  double mu, kappa, piA, piC, piG, piT, piR, piY, pi_j, bold_pi_j;
  piA = pi[0];
  piC = pi[1];
  piG = pi[2];
  piT = pi[3];
  piR=piA+piG;
  piY=piC+piT;

  kappa = params.getKappa();
  mu = 1/(2*(kappa*(piA*piG + piC*piT) + piR*piY));
 
  double br = getParentEdge()->getEdgeLen();
  double tmp;
  int child, parent; 
  for(parent = 1; parent <= 8; parent = parent*2){
    
    for(child = 1; child <= 8 ; child = child*2){

      if(child==1){ // A
	pi_j=piA;
	bold_pi_j=piR;
      }else if(child==2){ // C
	pi_j=piC;
	bold_pi_j=piY;
      }else if(child==4){// G
	pi_j=piG;
	bold_pi_j=piR;
      }else if(child==8){// T
	pi_j=piT;
	bold_pi_j=piY;
      }

      double A=1+bold_pi_j*(kappa-1);

      if(parent==child){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(bold_pi_j-pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)+exp(c-a)));
	
      }else if((parent==1 && child==4)||(parent==4 && child==1)||(parent==2 &&
								  child==8)||(parent==8 && child==2)){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)-exp(c-a)));
	
      }else{
	tmp=exp(log(pi_j)+log(1-1/exp(mu*br)));
      }

      if(tmp>1)
	tmp=1;
      else if(tmp<0)
	tmp=0;

      Qtmp.push_back(tmp);

    }

    Pt.push_back(Qtmp);
    Qtmp.resize(0);
  }
  
  // the end of HKY substitution model

  
  if(getLeaf()){
    
    for(b = 0; b < numLetters; b++)
      subtreeprob[current][b].resize(0);

    //-- v32 start --//
    sumOflogFs[current].resize(0);
    //-- v32 end --//


    /*
    for(h=0; h< seqLen[current]; h++){
      inttmp = seq[h];
      for( i = 0; i < numLetters; i++){
	if(inttmp%2==1){
	  for( b = 0; b < numLetters; b++){
	    subtreeprob[current][b].push_back(Pt[b][i]);
	  }
	}
	inttmp /= 2;
      }
    }
    */
    // data2 start
    for( b = 0; b < numLetters; b++){
      subtreeprob[current][b].resize(seqLen[current]);
      for(h=0; h< seqLen[current]; h++)
	subtreeprob[current][b][h] = 0;
    }

    //-- v32 start --//
    sumOflogFs[current].resize(seqLen[current]);

    for(h=0; h< seqLen[current]; h++){
      inttmp = seq[h];
     
      //cout << "h : " << h << " inttmp : " << inttmp << endl;
      for( i = 0; i < numLetters; i++){
	if(inttmp%2==1){
	  maxVal = 0;
	  for( b = 0; b < numLetters; b++){
	    subtreeprob[current][b][h] += Pt[b][i];
	    if(subtreeprob[current][b][h] > maxVal)
	      maxVal = subtreeprob[current][b][h];
	  }
	  //cout << "HAHA i << " << i << " maxVal : " << maxVal << endl;
	  //for( b = 0; b < numLetters; b++)
	  //  cout << subtreeprob[current][b][h] << " ";
	  //cout << endl;
	}
	inttmp /= 2;
      }
      for( b = 0; b < numLetters; b++)
	subtreeprob[current][b][h] /= maxVal;
      sumOflogFs[current][h] = log(maxVal);
      //cout << "sumOflogFs[current][h] : " <<  sumOflogFs[current][h]  << endl;
      //for( b = 0; b < numLetters; b++)
      //	cout << subtreeprob[current][b][h] << " ";
      //cout << endl;
    }
    //-- v32 end --//
    // data2 end
  }else{  // else if (getLeaf())

    
    //for(b = 0; b < numLetters; b++)
    //  subtreeprob[current][b].resize(0);
 
    for( b = 0; b < numLetters; b++){
      subtreeprob[current][b].resize(seqLen[current]);
      for(h=0; h< seqLen[current]; h++)
	subtreeprob[current][b][h] = 0;
    }
 
    //-- v32 start --//
    sumOflogFs[current].resize(0);
    sumOflogFs[current].resize(seqLen[current]);


    for(h=0; h< seqLen[current]; h++){
      
      maxVal = 0;
    
      sumOflogFs[current][h] = 0;

      for(k = 0; k < numEdges; k++){
	if( k != getparentIndex()){
	  cEdge = getEdge(k);
	  if(cEdge->getHMG(h)>=0){
	    sumOflogFs[current][h] += cEdge->getEnd()->getsumOflogFs(cEdge->getHMG(h));
	  }
	}
      }

      //cout << "h : " << h << endl;
      for(b = 0; b < numLetters; b++){
	
	tmpres0 = 0;
        for(i = 0; i < numLetters; i++){
	  tmpres1 = Pt[b][i];
	  //cout << "i : " << i << " tmpres1 : " << tmpres1 << endl;
	  for(k = 0; k < numEdges; k++){
	    if( k != getparentIndex()){
	      cEdge = getEdge(k);
	      if(cEdge->getHMG(h)>=0){
		tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	      }
	    }
	  }
	  tmpres0 += tmpres1;
	  //cout << "b : " << b << " tmpres0 : " << tmpres0 << endl;
	}
	//cout << "tmpres0 " << tmpres0 << endl;
	subtreeprob[current][b][h] = tmpres0;
	if(subtreeprob[current][b][h] > maxVal)
	  maxVal = subtreeprob[current][b][h];
	//cout << "maxVal : " << maxVal << endl;
      }
      for( b = 0; b < numLetters; b++)
	subtreeprob[current][b][h] /= maxVal;
      //cout << "maxVal : " << maxVal << endl;
      sumOflogFs[current][h] += log(maxVal);
      //cout << "sumOflogFs[current][h] : " << sumOflogFs[current][h] << endl;
    }  // end of for

  } // end of else

}




// Calculate Gijk in this node
double Node::CalSubTreeProbForSitesWithChangedHMG(const Parameters &params, int EdgeNumToCheck){

  vector<vector<double> > Pt;
  vector<double> Qtmp(0), pi(0);
  int inttmp;
  int h, i, b, k, m, j;
  double tmpres0, tmpres1;

  //-- v32 start --//
  double maxVal;
  bool done;
  //-- v32 end --//
  
  Edge* pEdge = getParentEdge();
  Edge* cEdge;
  Edge* tempEdge;

  pi = params.getPi();



  // JC substitution model
  /*
  vector<vector<double> > Q;
  double p0, p1;
  Q = params.getQ();  
  p1 = 0.25*(1-exp(-4*Q[0][2]*getParentEdge()->getEdgeLen()));
  p0 = 1 - 3*p1;

  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);  
  */

  // HKY substitution model
  // Pt[b][i] = Pr(b->i)
 
  double mu, kappa, piA, piC, piG, piT, piR, piY, pi_j, bold_pi_j;
  piA = pi[0];
  piC = pi[1];
  piG = pi[2];
  piT = pi[3];
  piR=piA+piG;
  piY=piC+piT;

  kappa = params.getKappa();
  mu = 1/(2*(kappa*(piA*piG + piC*piT) + piR*piY));
 
  double br = getParentEdge()->getEdgeLen();
  double tmp;
  int child, parent; 
  for(parent = 1; parent <= 8; parent = parent*2){
    
    for(child = 1; child <= 8 ; child = child*2){

      if(child==1){ // A
	pi_j=piA;
	bold_pi_j=piR;
      }else if(child==2){ // C
	pi_j=piC;
	bold_pi_j=piY;
      }else if(child==4){// G
	pi_j=piG;
	bold_pi_j=piR;
      }else if(child==8){// T
	pi_j=piT;
	bold_pi_j=piY;
      }

      double A=1+bold_pi_j*(kappa-1);

      if(parent==child){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(bold_pi_j-pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)+exp(c-a)));
	
      }else if((parent==1 && child==4)||(parent==4 && child==1)||(parent==2 &&
								  child==8)||(parent==8 && child==2)){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)-exp(c-a)));
	
      }else{
	tmp=exp(log(pi_j)+log(1-1/exp(mu*br)));
      }

      if(tmp>1)
	tmp=1;
      else if(tmp<0)
	tmp=0;

      Qtmp.push_back(tmp);

    }

    Pt.push_back(Qtmp);
    Qtmp.resize(0);
  }
  
  // the end of HKY substitution model




  if(getLeaf()){

    cout << "ERROR! CalSubTreeProbForSitesWithChangedHMG cannot be applied to leaf!" << endl;

  }else{  // else if (getLeaf())

    
    //for(b = 0; b < numLetters; b++)
    //  subtreeprob[current][b].resize(0);
    set0ChangedHMG();
  
    tempEdge = getEdge(EdgeNumToCheck);


    for(h=0; h< seqLen[current]; h++){

      if(tempEdge->getHMG(h, 0) != tempEdge->getHMG(h, 1)){ 

	//-- v32 start --//
	maxVal = 0;
	//done = false;
	sumOflogFs[current][h] = 0;
	for(k = 0; k < numEdges; k++){
	  if( k != getparentIndex()){
	    cEdge = getEdge(k);
	    if(cEdge->getHMG(h)>=0){
	      sumOflogFs[current][h] += cEdge->getEnd()->getsumOflogFs(cEdge->getHMG(h));
	    }
	  }
        }

	//-- v32 end --//
	
	ChangedHMG[h] = 1;

	for(b = 0; b < numLetters; b++){
	  tmpres0 = 0;
	  for(i = 0; i < numLetters; i++){
	    tmpres1 = Pt[b][i];
	    for(k = 0; k < numEdges; k++){
	      if( k != getparentIndex()){
		cEdge = getEdge(k);
		if(cEdge->getHMG(h)>=0){
		  tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
		}
	      }
	    }
	    tmpres0 += tmpres1;
	  }
	  subtreeprob[current][b][h] = tmpres0;
	  if(subtreeprob[current][b][h] > maxVal)
	  maxVal = subtreeprob[current][b][h];
	}
	for( b = 0; b < numLetters; b++)
	  subtreeprob[current][b][h] /= maxVal;
	sumOflogFs[current][h] += log(maxVal);
      }
    }  // end of for

  } // end of else

}




double Node::CalSubTreeProbForSitesWithChangedG(const Parameters &params, int EdgeNumToCheck){


  //cout << " IN CalSubTreeProbForSitesWithChangedG " << endl;

  vector<vector<double> > Pt;
  vector<double> Qtmp(0), pi(0);
  int inttmp;
  int h, i, b, k, m, j;
  double tmpres0, tmpres1;

  
  Edge* pEdge = getParentEdge();
  Edge* cEdge;
  Edge* tempEdge;
  Node* Cnode;

  pi = params.getPi();

  // JC substitution model
  /*
  vector<vector<double> > Q;
  double p0, p1;
  Q = params.getQ(); 
  Q = params.getQ();  

  p1 = 0.25*(1-exp(-4*Q[0][2]*getParentEdge()->getEdgeLen()));
  p0 = 1 - 3*p1;

  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);  
  */



  // HKY substitution model
  // Pt[b][i] = Pr(b->i)
 
  double mu, kappa, piA, piC, piG, piT, piR, piY, pi_j, bold_pi_j;
  piA = pi[0];
  piC = pi[1];
  piG = pi[2];
  piT = pi[3];
  piR=piA+piG;
  piY=piC+piT;

  kappa = params.getKappa();
  mu = 1/(2*(kappa*(piA*piG + piC*piT) + piR*piY));
 
  double br = getParentEdge()->getEdgeLen();
  double tmp;
  int child, parent; 
  for(parent = 1; parent <= 8; parent = parent*2){
    
    for(child = 1; child <= 8 ; child = child*2){

      if(child==1){ // A
	pi_j=piA;
	bold_pi_j=piR;
      }else if(child==2){ // C
	pi_j=piC;
	bold_pi_j=piY;
      }else if(child==4){// G
	pi_j=piG;
	bold_pi_j=piR;
      }else if(child==8){// T
	pi_j=piT;
	bold_pi_j=piY;
      }

      double A=1+bold_pi_j*(kappa-1);

      if(parent==child){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(bold_pi_j-pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)+exp(c-a)));
	
      }else if((parent==1 && child==4)||(parent==4 && child==1)||(parent==2 &&
								  child==8)||(parent==8 && child==2)){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)-exp(c-a)));
	
      }else{
	tmp=exp(log(pi_j)+log(1-1/exp(mu*br)));
      }

      if(tmp>1)
	tmp=1;
      else if(tmp<0)
	tmp=0;

      Qtmp.push_back(tmp);

    }

    Pt.push_back(Qtmp);
    Qtmp.resize(0);
  }
  
  // the end of HKY substitution model



  if(getLeaf()){

    cout << "ERROR! CalSubTreeProbForSitesWithChangedHMG cannot be applied to leaf!" << endl;

  }else{  // else if (getLeaf())

    
    //for(b = 0; b < numLetters; b++)
    //  subtreeprob[current][b].resize(0);

    set0ChangedHMG();
    tempEdge = getEdge(EdgeNumToCheck);
    Cnode = tempEdge->getEnd();

    for(h=0; h< seqLen[current]; h++){

      //cout << "h : " << h << endl;
      //cout << "tempEdge->getHMG(h)   " << tempEdge->getHMG(h) << endl;
      //cout << "Cnode->getChangedHMG(tempEdge->getHMG(h))   " << Cnode->getChangedHMG(tempEdge->getHMG(h)) << endl;
      
      //if((tempEdge->getHMG(h)>=0) & (Cnode->getChangedHMG(tempEdge->getHMG(h))==1)){ 

      if(tempEdge->getHMG(h)>=0){

	if(Cnode->getChangedHMG(tempEdge->getHMG(h))==1){ 

	  ChangedHMG[h] = 1;
	  
	  for(b = 0; b < numLetters; b++){
	    tmpres0 = 0;
	    for(i = 0; i < numLetters; i++){
	      tmpres1 = Pt[b][i];
	      for(k = 0; k < numEdges; k++){
		if( k!= getparentIndex()){
		  cEdge = getEdge(k);
		  if(cEdge->getHMG(h)>=0)
		    tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
		}
	      }
	      tmpres0 += tmpres1;
	    }
	    subtreeprob[current][b][h] = tmpres0;
	  }
	}
      }
    }  // end of for

    Cnode->resetChangedHMG();

  } // end of else

}





 

/*
double Node::likeliData(const Parameters &params, int c){

  vector<vector<double> > Q, Pt;
  vector<double> Qtmp(0), pi(0);
  double p0, p1;
  int inttmp;
  int h, i, b, k, m;
  double tmpres0, tmpres1;
  vector<int> matchedSites(0);
  int stSite, enSite;


  for(h = 0; h < (numEdges-1); h++)
    matchedSites.push_back(0);

  
  Edge* pEdge = getParentEdge();
  Edge* cEdge;

  Q = params.getQ();  
  pi = params.getPi();

  p1 = 0.25*(1-exp(-4*Q[0][2]*getParentEdge()->getEdgeLen(c)));
  p0 = 1 - 3*p1;

  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);  


  if(getLeaf()){
    
    for(h=0; h< seqLen[c]; h++){
      inttmp = seq[h];
      for( i = 0; i < numLetters; i++){
	if(inttmp%2==1){
	  for( b = 0; b < numLetters; b++){
	    subtreeprob[c][b].push_back(Pt[b][i]);
	  }
	}
	inttmp /= 2;
      }
    }
  
  }else{

    for(k = 0; k < (numEdges-1); k++){
      cEdge = getEdge(k);
      cEdge->getEnd()->likeliData(params, c);
      cEdge->getEnd()->set0rootSites();
      cEdge->getEnd()->set0logLikelihood();
    }

    for(h=0; h< seqLen[c]; h++){
      for(b = 0; b < numLetters; b++){ 
	tmpres0 = 0;
        for(i = 0; i < numLetters; i++){
	  tmpres1 = Pt[b][i];
	  for(k = 0; k < (numEdges-1); k++){
	    cEdge = getEdge(k);
            if(cEdge->getHMG(h)>=0){
	      tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	      stSite = matchedSites[k];
	      enSite = cEdge->getHMG(h)-1;
              if(stSite <= enSite){
		for(m = stSite; m <= enSite; m++){
		  cEdge->getEnd()->setrootSites(m, 1);
		  cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
                }
	      }
	      matchedSites[k] = enSite+2;
	    }
	  }
	  tmpres0 += tmpres1;
	}
	subtreeprob[c][b].push_back(tmpres0);
      }



    }


      for(k = 0; k < (numEdges-1); k++){
	cEdge = getEdge(k);
	stSite = matchedSites[k];
	enSite = cEdge->getEnd()->getSeqLen();
	if(stSite <= enSite){
	  for(m = stSite; m < enSite; m++){
	    cEdge->getEnd()->setrootSites(m, 1);
	    cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	  }
	}
      }


    
  }

}

*/


double Node::likeliData(const Parameters &params){

  vector<vector<double> > Pt;
  vector<double> Qtmp(0), pi(0);
  int inttmp;
  int h, i, b, k, m, j;
  double tmpres0, tmpres1;
  vector<int> matchedSites(0);
  int stSite, enSite;

  for(h = 0; h < numEdges; h++)
    matchedSites.push_back(0);
  
  Edge* pEdge = getParentEdge();
  Edge* cEdge;

  //cout << "Node num " << getnumber() << endl;

  //cout << "In likeliData 1" << endl;
  

  pi = params.getPi();

  //cout << "In likeliData 2" << endl;

  // JC substitution model
  /*
  vector<vector<double> > Q;
  double p0, p1;
  Q = params.getQ();  
  p1 = 0.25*(1-exp(-4*Q[0][2]*getParentEdge()->getEdgeLen()));
  p0 = 1 - 3*p1;

  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);  
  */


  // HKY substitution model
  // Pt[b][i] = Pr(b->i)
 
  double mu, kappa, piA, piC, piG, piT, piR, piY, pi_j, bold_pi_j;
  piA = pi[0];
  piC = pi[1];
  piG = pi[2];
  piT = pi[3];
  piR=piA+piG;
  piY=piC+piT;

  //cout << "In likeliData 3" << endl;

  kappa = params.getKappa();

  //cout << "In likeliData 4" << endl;

  mu = 1/(2*(kappa*(piA*piG + piC*piT) + piR*piY));
 
  //cout << "In likeliData 5" << endl;

  double br = getParentEdge()->getEdgeLen();

  //cout << "In likeliData 6" << endl;

  double tmp;
  int child, parent; 
  for(parent = 1; parent <= 8; parent = parent*2){
    
    //cout << "parent : " << parent << endl;
    for(child = 1; child <= 8 ; child = child*2){

      //cout << "child : " << child << endl;
      if(child==1){ // A
	pi_j=piA;
	bold_pi_j=piR;
      }else if(child==2){ // C
	pi_j=piC;
	bold_pi_j=piY;
      }else if(child==4){// G
	pi_j=piG;
	bold_pi_j=piR;
      }else if(child==8){// T
	pi_j=piT;
	bold_pi_j=piY;
      }

      double A=1+bold_pi_j*(kappa-1);

      if(parent==child){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(bold_pi_j-pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)+exp(c-a)));
	
      }else if((parent==1 && child==4)||(parent==4 && child==1)||(parent==2 &&
								  child==8)||(parent==8 && child==2)){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)-exp(c-a)));
	
      }else{
	tmp=exp(log(pi_j)+log(1-1/exp(mu*br)));
      }

      if(tmp>1)
	tmp=1;
      else if(tmp<0)
	tmp=0;



      Qtmp.push_back(tmp);
      //cout << "In likeliData 7" << endl;


    }


    Pt.push_back(Qtmp);
    Qtmp.resize(0);
    //cout << "In likeliData 8" << endl;
    
  }
  
  // the end of HKY substitution model




  if(getLeaf()){

    /*
    for(h=0; h< seqLen[current]; h++){
      inttmp = seq[h];
      for( i = 0; i < numLetters; i++){
	if(inttmp%2==1){
	  for( b = 0; b < numLetters; b++){
	    //cout << "In likeliData 9" << endl;
	    subtreeprob[current][b].push_back(Pt[b][i]);
	    //cout << "In likeliData 10" << endl;
	  }
	}
	inttmp /= 2;
      }
    }
    */
    // data2 start
    for( b = 0; b < numLetters; b++){
      subtreeprob[current][b].resize(seqLen[current]);
      for(h=0; h< seqLen[current]; h++)
	subtreeprob[current][b][h] = 0;
	//cout << "A : " << b << endl;
	//print_vecd(subtreeprob[current][b]);
    }
    for(h=0; h< seqLen[current]; h++){
      inttmp = seq[h];
      //cout << "L1 :" << inttmp << endl;
      for( i = 0; i < numLetters; i++){
	//cout << "L2 : " << inttmp << endl;
	if(inttmp%2==1){
	  //cout << "L3: " << i << endl; 

	  for( b = 0; b < numLetters; b++){
	    //cout << "M : " << b << " " << i << " " << Pt[b][i] << " " << subtreeprob[current][b][i] << endl;
	    subtreeprob[current][b][h] += Pt[b][i];
	  }
	}
	inttmp /= 2;
      }
      //for( b = 0; b < numLetters; b++){
      //	cout << "B : " << b << endl;
      //	print_vecd(subtreeprob[current][b]);
      //}
    }
    // data2 end


    /*

  cout << "likeliData " << endl;
  cout << "number " << getnumber() << endl;
  cout << "leaf " << getLeaf() << endl;
  cout << "root " << getRoot() << endl;

  cout << " p1 " << p1 << " p0 " << p0 << endl;
  cout << "Pt " << endl;
  for(i = 0; i<Pt.size(); i++){
    for(j=0; j<Pt[i].size(); j++)
      cout << Pt[i][j] << " " ;
    cout << endl;
  }


    cout << endl;
    cout << "Leaf " << endl;
    for(j=0; j<4; j++){
      for(i = 0; i < getSeqLen(); i++)
	cout << getsubtreeprob(j,i) << " " ;
      cout << endl;
    }
    cout << endl;

    */
  
  }else{

    for(k = 0; k < numEdges; k++){
      if(k != getparentIndex()){
	cEdge = getEdge(k);
	cEdge->getEnd()->likeliData(params);
	cEdge->getEnd()->set0rootSites();
	cEdge->getEnd()->set0logLikelihood();
      }
    }


    for(h=0; h< seqLen[current]; h++){
      for(b = 0; b < numLetters; b++){
	tmpres0 = 0;
        for(i = 0; i < numLetters; i++){
	  tmpres1 = Pt[b][i];
	  for(k = 0; k < numEdges; k++){
	    if(k != getparentIndex()){
	      cEdge = getEdge(k);
	      if(cEdge->getHMG(h)>=0){
		tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
		stSite = matchedSites[k];
		enSite = cEdge->getHMG(h)-1;
		if(stSite <= enSite){
		  for(m = stSite; m <= enSite; m++){
		    cEdge->getEnd()->setrootSites(m, 1);
		    cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
		  }
		}
		matchedSites[k] = enSite+2;
	      }
	    }
          }
	  tmpres0 += tmpres1;
	}
	subtreeprob[current][b].push_back(tmpres0);
      }

    }


      for(k = 0; k < numEdges; k++){
	if(k != getparentIndex()){
	  cEdge = getEdge(k);
	  stSite = matchedSites[k];
	  enSite = cEdge->getEnd()->getSeqLen();   
	  if(stSite <= enSite){
	    for(m = stSite; m < enSite; m++){
	      cEdge->getEnd()->setrootSites(m, 1);
	      cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	    }
	  }
	}
      }
      /*
  cout << "likeliData " << endl;
  cout << "number " << getnumber() << endl;
  cout << "leaf " << getLeaf() << endl;
  cout << "root " << getRoot() << endl;

  cout << " p1 " << p1 << " p0 " << p0 << endl;
  cout << "Pt " << endl;
  for(i = 0; i<Pt.size(); i++){
    for(j=0; j<Pt[i].size(); j++)
      cout << Pt[i][j] << " " ;
    cout << endl;
  }



    cout << endl;
    cout << "Not Leaf " << endl;
    for(j=0; j<4; j++){
      for(i = 0; i < getSeqLen(); i++)
	cout << getsubtreeprob(j,i) << " " ;
      cout << endl;
    }
    cout << endl;


    for(k = 0; k < (numEdges-1); k++){
      cEdge = getEdge(k);
      cout << " Edge number " << k << endl;
      for(i = 0; i < cEdge->getEnd()->getrootSitesSize(); i++){
	cout << " i " << i << " root " << cEdge->getEnd()->getrootSites(i) << " loglikeli " << cEdge->getEnd()->getlogLikelihood(i) << endl;
      }
    }

      */ 
  }

}



double Node::likeliData_v2(const Parameters &params){

  vector<vector<double> > Pt;
  vector<double> Qtmp(0), pi(0);
  int inttmp;
  int h, i, b, k, m, j;
  double tmpres0, tmpres1;
  //-- v32 start --//
  double maxVal;
  bool done;
  //-- v32 end --//
  vector<int> matchedSites(0);
  int stSite, enSite;

  for(h = 0; h < numEdges; h++)
    matchedSites.push_back(0);
  
  Edge* pEdge = getParentEdge();
  Edge* cEdge;

  //cout << "Node num " << getnumber() << endl;

  //cout << "In likeliData 1" << endl;
  

  pi = params.getPi();

  //cout << "In likeliData 2" << endl;

  // JC substitution model
  /*
  vector<vector<double> > Q;
  double p0, p1;
  Q = params.getQ();  
  p1 = 0.25*(1-exp(-4*Q[0][2]*getParentEdge()->getEdgeLen()));
  p0 = 1 - 3*p1;

  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Qtmp.push_back(p1);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p1);
  Qtmp.push_back(p0);
  Pt.push_back(Qtmp);
  Qtmp.resize(0);  
  */


  // HKY substitution model
  // Pt[b][i] = Pr(b->i)
 
  double mu, kappa, piA, piC, piG, piT, piR, piY, pi_j, bold_pi_j;
  piA = pi[0];
  piC = pi[1];
  piG = pi[2];
  piT = pi[3];
  piR=piA+piG;
  piY=piC+piT;

  //cout << "In likeliData 3" << endl;

  kappa = params.getKappa();

  //cout << "In likeliData 4" << endl;

  mu = 1/(2*(kappa*(piA*piG + piC*piT) + piR*piY));
 
  //cout << "In likeliData 5" << endl;

  double br = getParentEdge()->getEdgeLen();

  //cout << "In likeliData 6" << endl;

  double tmp;
  int child, parent; 
  for(parent = 1; parent <= 8; parent = parent*2){
    
    //cout << "parent : " << parent << endl;
    for(child = 1; child <= 8 ; child = child*2){

      //cout << "child : " << child << endl;
      if(child==1){ // A
	pi_j=piA;
	bold_pi_j=piR;
      }else if(child==2){ // C
	pi_j=piC;
	bold_pi_j=piY;
      }else if(child==4){// G
	pi_j=piG;
	bold_pi_j=piR;
      }else if(child==8){// T
	pi_j=piT;
	bold_pi_j=piY;
      }

      double A=1+bold_pi_j*(kappa-1);

      if(parent==child){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(bold_pi_j-pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)+exp(c-a)));
	
      }else if((parent==1 && child==4)||(parent==4 && child==1)||(parent==2 &&
								  child==8)||(parent==8 && child==2)){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)-exp(c-a)));
	
      }else{
	tmp=exp(log(pi_j)+log(1-1/exp(mu*br)));
      }

      if(tmp>1)
	tmp=1;
      else if(tmp<0)
	tmp=0;



      Qtmp.push_back(tmp);
      //cout << "In likeliData 7" << endl;


    }


    Pt.push_back(Qtmp);
    Qtmp.resize(0);
    //cout << "In likeliData 8" << endl;
    
  }
  
  // the end of HKY substitution model


  for( b = 0; b < numLetters; b++){
    //cout << "In likeliData 9" << endl;
    subtreeprob[current][b].resize(0);
    //cout << "In likeliData 10" << endl;
  }

  //-- v32 start --//
  sumOflogFs[current].resize(0);
  //-- v32 end --//


  if(getLeaf()){


    //cout << "leaf " << getnumber() << endl; 
    /*
    for(h=0; h< seqLen[current]; h++){
      inttmp = seq[h];
      for( i = 0; i < numLetters; i++){
	if(inttmp%2==1){
	  for( b = 0; b < numLetters; b++){
	    //cout << "In likeliData 9" << endl;
	    subtreeprob[current][b].push_back(Pt[b][i]);
	    //cout << "In likeliData 10" << endl;
	  }
	}
	inttmp /= 2;
      }
    }
    */


    // data2 start
    /*
    for( b = 0; b < numLetters; b++){
      subtreeprob[current][b].resize(numLetters);
      for(i = 0; i < numLetters; i++)
	subtreeprob[current][b][i] = 0;
    }
    for(h=0; h< seqLen[current]; h++){
      inttmp = seq[h];
      for( i = 0; i < numLetters; i++){
	if(inttmp & 1 ==1){
	  for( b = 0; b < numLetters; b++){
	    subtreeprob[current][b][i] += Pt[b][i];
	  }
	}
	inttmp >>= 1;
      }
    }
    */
    for( b = 0; b < numLetters; b++){
      subtreeprob[current][b].resize(seqLen[current]);
      for(h=0; h< seqLen[current]; h++)
	subtreeprob[current][b][h] = 0;
    }


    //-- v32 start --//
    sumOflogFs[current].resize(seqLen[current]);

    for(h=0; h< seqLen[current]; h++){
      inttmp = seq[h];
      for( i = 0; i < numLetters; i++){
	if(inttmp%2==1){
	  maxVal = 0;
	  for( b = 0; b < numLetters; b++){
	    subtreeprob[current][b][h] += Pt[b][i];
	    if(subtreeprob[current][b][h] > maxVal)
	      maxVal = subtreeprob[current][b][h];
	  }
	}
	inttmp /= 2;
      }
      for( b = 0; b < numLetters; b++)
	subtreeprob[current][b][h] /= maxVal;
      sumOflogFs[current][h] = log(maxVal);
      //cout << "h : " << h << endl;
      //cout << "sumOflogFs[current][h] : " << sumOflogFs[current][h] << endl;
      //for( b = 0; b < numLetters; b++){
      //	cout << "subtreeprob[current][b][h] : " << subtreeprob[current][b][h] << endl;
      //	cout << "subtreeprob[current][b][h]*exp(sumOflogFs[current][h]) " << subtreeprob[current][b][h]*exp(sumOflogFs[current][h]) << endl;
      //}
    }
    //-- v32 end --//

    /*

  cout << "likeliData " << endl;
  cout << "number " << getnumber() << endl;
  cout << "leaf " << getLeaf() << endl;
  cout << "root " << getRoot() << endl;

  cout << " p1 " << p1 << " p0 " << p0 << endl;
  cout << "Pt " << endl;
  for(i = 0; i<Pt.size(); i++){
    for(j=0; j<Pt[i].size(); j++)
      cout << Pt[i][j] << " " ;
    cout << endl;
  }


    cout << endl;
    cout << "Leaf " << endl;
    for(j=0; j<4; j++){
      for(i = 0; i < getSeqLen(); i++)
	cout << getsubtreeprob(j,i) << " " ;
      cout << endl;
    }
    cout << endl;

    */
  
  }else{


    //    cout << "not leaf : " << getnumber() << endl;

    for(k = 0; k < numEdges; k++){
      if(k != getparentIndex()){
	cEdge = getEdge(k);
	cEdge->getEnd()->likeliData_v2(params);
	cEdge->getEnd()->set0rootSites();
	cEdge->getEnd()->set0logLikelihood();
      }
    }
    
    //cout << "done " << endl;

    //-- v32 start --//
    for( b = 0; b < numLetters; b++){
      subtreeprob[current][b].resize(seqLen[current]);
      for(h=0; h< seqLen[current]; h++)
	subtreeprob[current][b][h] = 0;
    }
    
    sumOflogFs[current].resize(seqLen[current]);

    for(h=0; h< seqLen[current]; h++){
      maxVal = 0;
      sumOflogFs[current][h] = 0;
      //done = false;

      for(k = 0; k < numEdges; k++){
	if(k != getparentIndex()){
	  cEdge = getEdge(k);
	  if(cEdge->getHMG(h)>=0){
	    sumOflogFs[current][h] += cEdge->getEnd()->getsumOflogFs(cEdge->getHMG(h));
	    stSite = matchedSites[k];
	    enSite = cEdge->getHMG(h)-1;
	    if(stSite <= enSite){
	      for(m = stSite; m <= enSite; m++){
		cEdge->getEnd()->setrootSites(m, 1);
		cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	      }
	    }
	    matchedSites[k] = enSite+2;
	  }
	}
      }

      for(b = 0; b < numLetters; b++){
	tmpres0 = 0;
        for(i = 0; i < numLetters; i++){
	  tmpres1 = Pt[b][i];
	  for(k = 0; k < numEdges; k++){
	    if(k != getparentIndex()){
	      cEdge = getEdge(k);
	      if(cEdge->getHMG(h)>=0){
		//if(!done){
		//  if(i == 1){
		//    done = true;
                //  }else{
		//    sumOflogFs[current][h] += cEdge->getEnd()->getsumOflogFs(cEdge->getHMG(h));
		    //cout << "sumOflogFs[current][h] : " << sumOflogFs[current][h] << endl;
		// }
                //}
		//done = true;
		
	     
		tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	      }
	    }
          }
	  tmpres0 += tmpres1;
	}
	subtreeprob[current][b][h] = tmpres0;
	if(subtreeprob[current][b][h] > maxVal)
	  maxVal = subtreeprob[current][b][h];
      }
      for( b = 0; b < numLetters; b++)
	subtreeprob[current][b][h] /= maxVal;
      //cout << " final sumOflogFs[current][h] : " << sumOflogFs[current][h] << endl;
      //cout << "maxVal " << maxVal << endl;
      sumOflogFs[current][h] += log(maxVal);
      //cout << "h : " << h << endl;
      //cout << "sumOflogFs[current][h] : " << sumOflogFs[current][h] << endl;
      //for( b = 0; b < numLetters; b++){
      //	cout << "subtreeprob[current][b][h] : " << subtreeprob[current][b][h] << endl;
      //	cout << "subtreeprob[current][b][h]*exp(sumOflogFs[current][h]) " << subtreeprob[current][b][h]*exp(sumOflogFs[current][h]) << endl;
      //}

    }
    //-- v32 end --//

      for(k = 0; k < numEdges; k++){
	if(k != getparentIndex()){
	  cEdge = getEdge(k);
	  stSite = matchedSites[k];
	  enSite = cEdge->getEnd()->getSeqLen();   
	  if(stSite <= enSite){
	    for(m = stSite; m < enSite; m++){
	      cEdge->getEnd()->setrootSites(m, 1);
	      cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	    }
	  }
	}
      }
      /*
  cout << "likeliData " << endl;
  cout << "number " << getnumber() << endl;
  cout << "leaf " << getLeaf() << endl;
  cout << "root " << getRoot() << endl;

  cout << " p1 " << p1 << " p0 " << p0 << endl;
  cout << "Pt " << endl;
  for(i = 0; i<Pt.size(); i++){
    for(j=0; j<Pt[i].size(); j++)
      cout << Pt[i][j] << " " ;
    cout << endl;
  }



    cout << endl;
    cout << "Not Leaf " << endl;
    for(j=0; j<4; j++){
      for(i = 0; i < getSeqLen(); i++)
	cout << getsubtreeprob(j,i) << " " ;
      cout << endl;
    }
    cout << endl;


    for(k = 0; k < (numEdges-1); k++){
      cEdge = getEdge(k);
      cout << " Edge number " << k << endl;
      for(i = 0; i < cEdge->getEnd()->getrootSitesSize(); i++){
	cout << " i " << i << " root " << cEdge->getEnd()->getrootSites(i) << " loglikeli " << cEdge->getEnd()->getlogLikelihood(i) << endl;
      }
    }

      */ 
  }

}





/*
double Node::likeliDataR(const Parameters &params, int c){

  vector<vector<double> > Q, Pt;
  vector<double> Qtmp(0), pi(0);
  double p0, p1;
  int inttmp;
  int h, i, b, k, m;
  double tmpres0, tmpres1;
  vector<int> matchedSites(0);
  int stSite, enSite;
  int unLinked;

  if(!getRoot()){
    cout << "ERROR in likeliDataR! This function should be called from a root." << endl;
  }else{
    
    Edge* cEdge;

    for(h = 0; h < numEdges; h++)
      matchedSites.push_back(0);

    set0LinkedSites();
    set0logLikelihood();

 
    pi = params.getPi();

  

    for(k = 0; k < numEdges; k++){
      cEdge = getEdge(k);
      cEdge->getEnd()->likeliData_v2(params, c);
      cEdge->getEnd()->set0rootSites();
      cEdge->getEnd()->set0logLikelihood();
    }

    for(h = 0; h < seqLen[c]; h++){
      tmpres0 = 0;
      for(i = 0; i < numLetters; i++){
	tmpres1 = pi[i];
	unLinked = 0;
	for(k = 0; k < numEdges; k++){
	  cEdge = getEdge(k);
	  if(cEdge->getHMG(h)>=0){
	    tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	    stSite = matchedSites[k];
	    enSite = cEdge->getHMG(h)-1;
	    if(stSite <= enSite){
	      for(m = stSite; m <= enSite; m++){
		cEdge->getEnd()->setrootSites(m, 1);
		cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	      }
            }
	    matchedSites[k] = enSite+2;
	  }else{
	    unLinked++;
	  }
	}
	if(unLinked==numEdges){
	  break;
	}else{
	  LinkedSites[c][h] = 1;
        }
	tmpres0 += tmpres1;
      }

      if(unLinked==numEdges){
	logLikelihood[c].push_back(0);
      }else{
	logLikelihood[c].push_back(log(tmpres0));
      }


     
    }

      for(k = 0; k < (numEdges-1); k++){
	cEdge = getEdge(k);
	stSite = matchedSites[k];
	enSite = cEdge->getEnd()->getSeqLen();
	if(stSite <= enSite){
	  for(m = stSite; m < enSite; m++){
	    cEdge->getEnd()->setrootSites(m, 1);
	    cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	  }
	}
      }







  }
}

*/


/*
double Node::likeliDataR(const Parameters &params){

  vector<double> pi(0);
  int inttmp;
  int h, i, b, k, m;
  double tmpres0, tmpres1;
  vector<int> matchedSites(0);
  int stSite, enSite;
  int unLinked;

  //cout << "Node num " << getnumber() << endl;


  //cout << "In likeliDataR 1" << endl;


  if(!getRoot()){
    cout << "ERROR in likeliDataR! This function should be called from a root." << endl;
  }else{
    
    Edge* cEdge;

    for(h = 0; h < numEdges; h++)
      matchedSites.push_back(0);

    //cout << "In likeliDataR 2" << endl;
 
    set0LinkedSites();
    set0logLikelihood();


    //cout << "In likeliDataR 3" << endl;

    pi = params.getPi();

    //cout << "In likeliDataR 4" << endl;

    for(k = 0; k < numEdges; k++){
      cEdge = getEdge(k);
      //cout << "In likeliDataR 4.1" << endl;
      cEdge->getEnd()->likeliData(params);
      //cout << "In likeliDataR 4.2" << endl;
      cEdge->getEnd()->set0rootSites();
      //cout << "In likeliDataR 4.3" << endl;
      cEdge->getEnd()->set0logLikelihood();
      //cout << "In likeliDataR 4.4" << endl;
    }

    //cout << "In likeliDataR 5" << endl;


    for(h = 0; h < seqLen[current]; h++){
      tmpres0 = 0;
      for(i = 0; i < numLetters; i++){
	//cout << "In likeliDataR 6" << endl;
	tmpres1 = pi[i];
	//cout << "In likeliDataR 7" << endl;
	unLinked = 0;
	for(k = 0; k < numEdges; k++){
	  cEdge = getEdge(k);
	  if(cEdge->getHMG(h)>=0){
	    //cout << "In likeliDataR 8" << endl;
	    tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	    //cout << "In likeliDataR 9" << endl;
	    stSite = matchedSites[k];
	    enSite = cEdge->getHMG(h)-1; 
	    if(stSite <= enSite){
	      for(m = stSite; m <= enSite; m++){
		//cout << "In likeliDataR 10" << endl;
		cEdge->getEnd()->setrootSites(m, 1);
	      	cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
		//cout << "In likeliDataR 11" << endl;
	      }
            }	
	    matchedSites[k] = enSite+2; 
	  }else{
	    unLinked++;
	  }
	}
	if(unLinked==numEdges){
	  break;
	}else{
	  LinkedSites[current][h] = 1;
        }
	tmpres0 += tmpres1; 
      }
      //cout << "In likeliDataR 12" << endl;
      if(unLinked==numEdges){
	setlogLikelihood(h, 0); 
      }else{
	setlogLikelihood(h, log(tmpres0)); 
      }
      //cout << "In likeliDataR 13" << endl;


     
    }



      for(k = 0; k < numEdges; k++){
	cEdge = getEdge(k);
	stSite = matchedSites[k];
	enSite = cEdge->getEnd()->getSeqLen();
	if(stSite <= enSite){
	  for(m = stSite; m < enSite; m++){
	    //cout << "In likeliDataR 14" << endl;
	    cEdge->getEnd()->setrootSites(m, 1);
	    cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	    //cout << "In likeliDataR 15" << endl;
	  }
	}
      }


      /*
  cout << "likeliData ROOT ROOT ROOT" << endl;
  cout << "number " << getnumber() << endl;
  cout << "leaf " << getLeaf() << endl;
  cout << "root " << getRoot() << endl;


    for(k = 0; k < numEdges; k++){
      cEdge = getEdge(k);
      cout << " Edge number " << k << endl;
      for(i = 0; i < cEdge->getEnd()->getrootSitesSize(); i++){
	cout << " i " << i << " root " << cEdge->getEnd()->getrootSites(i) << " loglikeli " << cEdge->getEnd()->getlogLikelihood(i) << endl;
      }
    }


      for(i = 0; i < getLinkedSitesSize(); i++){
	cout << " i " << i << " Linked " << getLinkedSites(i) << " loglikeli " << getlogLikelihood(i) << endl;
      }
*/

/*

  }
}
*/


double Node::likeliDataR_v2(const Parameters &params){

  vector<double> pi(0);
  int inttmp;
  int h, i, b, k, m;
  double tmpres0, tmpres1;
  vector<int> matchedSites(0);
  int stSite, enSite;
  int unLinked;

  //-- v32 start --//
  double maxVal;
  //-- v32 end --//


  //cout << "Node num " << getnumber() << endl;


  //cout << "In likeliDataR 1" << endl;


  if(!getRoot()){
    cout << "ERROR in likeliDataR! This function should be called from a root." << endl;
  }else{
    
    Edge* cEdge;

    for(h = 0; h < numEdges; h++)
      matchedSites.push_back(0);

    //cout << "In likeliDataR 2" << endl;
 
    set0LinkedSites();
    set0logLikelihood();


    //cout << "In likeliDataR 3" << endl;

    pi = params.getPi();

    //cout << "In likeliDataR 4" << endl;

    for(k = 0; k < numEdges; k++){
      cEdge = getEdge(k);
      //cout << "In likeliDataR 4.1" << endl;
      cEdge->getEnd()->likeliData_v2(params);
      //cout << "In likeliDataR 4.2" << endl;
      cEdge->getEnd()->set0rootSites();
      //cout << "In likeliDataR 4.3" << endl;
      cEdge->getEnd()->set0logLikelihood();
      //cout << "In likeliDataR 4.4" << endl;
    }

    //cout << "In likeliDataR 5" << endl;





    for(h = 0; h < seqLen[current]; h++){
      tmpres0 = 0;

      i = 0;
      maxVal = 0;
      tmpres1 = pi[i];

      unLinked = 0;
      for(k = 0; k < numEdges; k++){
	cEdge = getEdge(k);
	if(cEdge->getHMG(h)>=0){
	  maxVal += cEdge->getEnd()->getsumOflogFs(cEdge->getHMG(h));
	  tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	
	  stSite = matchedSites[k];
	  enSite = cEdge->getHMG(h)-1; 
	  if(stSite <= enSite){
	    for(m = stSite; m <= enSite; m++){
	      cEdge->getEnd()->setrootSites(m, 1);
	      cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	    }
	  }	
	  matchedSites[k] = enSite+2; 
	}else{
	  unLinked++;
	}
      }

      if(unLinked!=numEdges){

	LinkedSites[current][h] = 1;
	tmpres0 += tmpres1; 
	
	for(i = 1; i < numLetters; i++){
       
	  tmpres1 = pi[i];

	  for(k = 0; k < numEdges; k++){
	    cEdge = getEdge(k);
	    if(cEdge->getHMG(h)>=0){
	      tmpres1 *= cEdge->getEnd()->getsubtreeprob(i, cEdge->getHMG(h));
	    }
	  }
	  tmpres0 += tmpres1; 
	}

      }


      if(unLinked==numEdges){
	setlogLikelihood(h, 0); 
      }else{
	setlogLikelihood(h, log(tmpres0) + maxVal);
      }
     
    }



    for(k = 0; k < numEdges; k++){
      cEdge = getEdge(k);
      stSite = matchedSites[k];
      enSite = cEdge->getEnd()->getSeqLen();
      if(stSite <= enSite){
	for(m = stSite; m < enSite; m++){
	  //cout << "In likeliDataR 14" << endl;
	  cEdge->getEnd()->setrootSites(m, 1);
	  cEdge->getEnd()->setlogLikelihood(m, cEdge->getEnd()->rootSitelogLikelihood(params, m));
	  //cout << "In likeliDataR 15" << endl;
	}
      }
    }
    

      /*
  cout << "likeliData ROOT ROOT ROOT" << endl;
  cout << "number " << getnumber() << endl;
  cout << "leaf " << getLeaf() << endl;
  cout << "root " << getRoot() << endl;


    for(k = 0; k < numEdges; k++){
      cEdge = getEdge(k);
      cout << " Edge number " << k << endl;
      for(i = 0; i < cEdge->getEnd()->getrootSitesSize(); i++){
	cout << " i " << i << " root " << cEdge->getEnd()->getrootSites(i) << " loglikeli " << cEdge->getEnd()->getlogLikelihood(i) << endl;
      }
    }


      for(i = 0; i < getLinkedSitesSize(); i++){
	cout << " i " << i << " Linked " << getLinkedSites(i) << " loglikeli " << getlogLikelihood(i) << endl;
      }
   

      */




  }
}








// Called only from node which has three edges connected
Edge* Node::leftEdge(Edge* edge1, Edge* edge2){

  int numEdges = getnumEdges();
  Edge* Tedge;
  
  if(numEdges != 3){
    cout << "Error! leftEdge should be called only from node which has three edges connected." << endl;
  }else{
    for(int i = 0; i < numEdges; i++){
      Tedge = getEdge(i);
      if((Tedge!=edge1) && (Tedge!=edge2))
	return Tedge;
    }
  }
}

void Node::printNode(){

  int m, j, c;
  c = current;
  
  cout << "******* Print Node **********" << endl;
  cout << "number " << getnumber() << endl;
  cout << "leaf " << getLeaf() << endl;
  cout << "root " << getRoot() << endl;
  cout << "numEdges " << getnumEdges() << endl;
  cout << "parentIndex " << getparentIndex() << endl;
    for(int m=0; m < getnumEdges(); m++)
      cout << "Edge number " << m << " Edge name " << getEdge(m)->getnumber() << endl;
    cout << "seqLen " << getSeqLen() << endl;
    if(getLeaf()){
      for(int m = 0; m < getSeqLen(); m++)
	cout << getSeq(m) << " " ;
      cout << endl;
    }

    /*** NNI.v2 start ***/
  if(getRoot()){
    cout << "LinkedSites " << endl;
    for(m =0; m < LinkedSites[c].size() ; m++)
      cout << LinkedSites[c][m] << " ";
    cout << endl;
    cout << "logLikelihood " << endl;
    for(m =0; m < logLikelihood[c].size() ; m++)
      cout << logLikelihood[c][m] << " ";
    cout << endl;
  }else{
    cout << "rootSites " << endl;
    for(m =0; m < rootSites[c].size() ; m++)
      cout << rootSites[c][m] << " ";
    cout << endl;
    cout << "logLikelihood " << endl;
    for(m =0; m < logLikelihood[c].size() ; m++)
      cout << logLikelihood[c][m] << " ";
    cout << endl;   
    cout << "subtreeprob " << endl;
    for(m =0; m < subtreeprob[c].size() ; m++){
      for(j=0; j < subtreeprob[c][m].size(); j++)
	cout << subtreeprob[c][m][j] << " ";
      cout << endl;
    }
    cout << endl;
    //-- v32 start --//
    cout << "sumOflogFs " << endl;
    for(m =0; m < sumOflogFs[c].size() ; m++){
      cout << sumOflogFs[c][m] << " ";
    }
    cout << endl;
    //-- v32 end --//
  }
  /*** NNI.v2 end ***/



}


void Node::printNode(int c){
  
  int m, j;

  cout << "******* Print Node **********" << endl;
  cout << "number " << getnumber() << endl;
  cout << "leaf " << getLeaf() << endl;
  cout << "root " << getRoot() << endl;
  cout << "numEdges " << getnumEdges() << endl;
  cout << "parentIndex " << getparentIndex(c) << endl;
  for(m=0; m < getnumEdges(); m++)
    cout << "Edge number " << m << " Edge name " << getEdge(m, c)->getnumber() << endl;
  cout << "seqLen " << getSeqLen(c) << endl;
  if(getLeaf()){
    for(m = 0; m < getSeqLen(c); m++)
      cout << getSeq(m) << " " ;
    cout << endl;
  }
  if(getRoot()){
    cout << "LinkedSites " << endl;
    for(m =0; m < LinkedSites[c].size() ; m++)
      cout << LinkedSites[c][m] << " ";
    cout << endl;
    cout << "logLikelihood " << endl;
    for(m =0; m < logLikelihood[c].size() ; m++)
      cout << logLikelihood[c][m] << " ";
    cout << endl;
  }else{
    cout << "rootSites " << endl;
    for(m =0; m < rootSites[c].size() ; m++)
      cout << rootSites[c][m] << " ";
    cout << endl;
    cout << "logLikelihood " << endl;
    for(m =0; m < logLikelihood[c].size() ; m++)
      cout << logLikelihood[c][m] << " ";
    cout << endl;   
    cout << "subtreeprob " << endl;
    for(m =0; m < subtreeprob[c].size() ; m++){
      for(j=0; j < subtreeprob[c][m].size(); j++)
	cout << subtreeprob[c][m][j] << " ";
      cout << endl;
    }
    cout << endl;
  }

}


void Node::printNode(ofstream& co){

  int c = 0;
  int m, j;

  co << "******* Print Node **********" << endl;
  co << "number " << getnumber() << endl;
  co << "leaf " << getLeaf() << endl;
  co << "root " << getRoot() << endl;
  co << "numEdges " << getnumEdges() << endl;
  co << "parentIndex " << getparentIndex(c) << endl;
  for(m=0; m < getnumEdges(); m++)
    co << "Edge number " << m << " Edge name " << getEdge(m, c)->getnumber() << endl;
  co << "seqLen " << getSeqLen(c) << endl;
  if(getLeaf()){
    for(m = 0; m < getSeqLen(c); m++)
      co << getSeq(m) << " " ;
    co << endl;
  }
  if(getRoot()){
    co << "LinkedSites " << endl;
    for(m =0; m < LinkedSites[c].size() ; m++)
      co << LinkedSites[c][m] << " ";
    co << endl;
    co << "logLikelihood " << endl;
    for(m =0; m < logLikelihood[c].size() ; m++)
      co << logLikelihood[c][m] << " ";
    co << endl;
  }else{
    co << "rootSites " << endl;
    for(m =0; m < rootSites[c].size() ; m++)
      co << rootSites[c][m] << " ";
    co << endl;
    co << "logLikelihood " << endl;
    for(m =0; m < logLikelihood[c].size() ; m++)
      co << logLikelihood[c][m] << " ";
    co << endl;   
    co << "subtreeprob " << endl;
    for(m =0; m < subtreeprob[c].size() ; m++){
      for(j=0; j < subtreeprob[c][m].size(); j++)
	co << subtreeprob[c][m][j] << " ";
      co << endl;
    }
    co << endl;
  }

}





void Edge::printEdge(){
  
  cout << "******* Print Edge **********" << endl;
  cout << "number " << getnumber() << endl;
  cout << "edgeLen " <<  getEdgeLen()  << endl;
  cout << "Start Node" << getStart()->getnumber() << endl;
  cout << "End Node" << getEnd()->getnumber() << endl;
  cout << endl << "#### FROM cIDH ####" << endl;
  cout << "numE " << getIDH()->getNumE() << endl;
  //-- v30 start --//
  if(getIDH()->getNumE() > 0){
    for(int j =0; j<=(getIDH()->getNumE()+1); j++){ 
      cout << "ID " << getIDH()->getID(j) << endl;
      cout << "L " << getIDH()->getL(j) << endl;
      cout << "P " << getIDH()->getP(j) << endl;
      cout << "V " << getIDH()->getV(j) << endl;
      cout << "N " << getIDH()->getN(j) << endl;
      cout << "HMG "  << endl;
      for(int m=0; m < getIDH()->getHMG(j).size(); m++)
	cout << getIDH()->getHMG(j,m) << " ";
      cout << endl;
    }
  }
  //-- v30 end --//
  cout << "HMG in Edge " << endl;
  for(int m=0; m < HMG[current].size(); m++)
    cout << HMG[current][m] << " ";       
  cout << endl;

}

void Edge::printEdge(int c){
  
  cout << "******* Print Edge **********" << endl;
  cout << "number " << getnumber() << endl;
  cout << "edgeLen " <<  getEdgeLen(c)  << endl;
  cout << "Start Node " << getStart(c)->getnumber() << endl;
  cout << "End Node " << getEnd(c)->getnumber() << endl;
  cout << endl << "#### FROM cIDH ####" << endl;
  cout << "numE " << getIDH(c)->getNumE() << endl;
  for(int j =0; j<=(getIDH(c)->getNumE()+1); j++){ 
    cout << "ID " << getIDH(c)->getID(j) << endl;
    cout << "L " << getIDH(c)->getL(j) << endl;
    cout << "P " << getIDH(c)->getP(j) << endl;
    cout << "V " << getIDH(c)->getV(j) << endl;
    cout << "N " << getIDH(c)->getN(j) << endl;
    cout << "HMG "  << endl;
    for(int m=0; m < getIDH(c)->getHMG(j).size(); m++)
      cout << getIDH(c)->getHMG(j,m) << " ";
    cout << endl;
  }
  cout << "HMG in Edge " << endl;
  for(int m=0; m < HMG[c].size(); m++)
    cout << HMG[c][m] << " ";       
  cout << endl;

}


void Edge::printEdge(ofstream& c){
  
  c << "******* Print Edge **********" << endl;
  c << "number " << getnumber() << endl;
  c << "edgeLen " <<  getEdgeLen()  << endl;
  c << "Start Node" << getStart()->getnumber() << endl;
  c << "End Node" << getEnd()->getnumber() << endl;
  c << endl << "#### FROM cIDH ####" << endl;
  c << "numE " << getIDH()->getNumE() << endl;
  for(int j =0; j<=(getIDH()->getNumE()+1); j++){ 
    c << "ID " << getIDH()->getID(j) << endl;
    c << "L " << getIDH()->getL(j) << endl;
    c << "P " << getIDH()->getP(j) << endl;
    c << "V " << getIDH()->getV(j) << endl;
    c << "N " << getIDH()->getN(j) << endl;
    c << "HMG "  << endl;
    for(int m=0; m < getIDH()->getHMG(j).size(); m++)
      c << getIDH()->getHMG(j,m) << " ";
    c << endl;
  }
  c << "HMG in Edge " << endl;
  for(int m=0; m < HMG[current].size(); m++)
    c << HMG[current][m] << " ";       
  c << endl;

}


   

void Edge::calHMG(){

  //cout << "In calHMG " << endl;

  vector<int> hmg(0);
  
  hmg = IDH[current]->getHMG(IDH[current]->getNumE());

  //cout << "hmg " << endl;
  //print_veci(hmg);

  HMG[current].resize(0);

  //for(int k = 0; k < start[current]->getSeqLen(); k++){
  for(int k = 0; k < IDH[current]->getN(0); k++){
    HMG[current].push_back(-1);
  }

  //cout << "IDH[current]->getN(0) " << IDH[current]->getN(0) << endl;
  /*** shim HMG ****/  
  //for(int k = 0; k < hmg.size(); k++){
  //  if(hmg[k]!=hmg[k+1]){
  //    HMG[current][hmg[k]] = k;
  //  }
  //}

  for(int k = 0; k < (hmg.size()-1); k++){
    if(hmg[k]!=-1){
      HMG[current][hmg[k]] = k;
    }  
  }


  hmg.resize(0);

}


Edge* Edge::getParentEdge() {
  return start[current]->getParentEdge();
}




//-- v20 start --//
/*
void Edge::runEdge(Rand &rand, const Parameters &params){

  int c = current;

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int N0 = start[c]->getSeqLen(c); 
  int Nend = end[c]->getSeqLen(c);
  int i, k, d;
  int numE;
  double eta;
  double dt, tempTime, Time;
  double prob1;   


  Time = edgeLen[c];
  

 
  //cout<< "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << " N0 " << N0 << " Nend " << Nend << " Time " << Time << endl;

  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



  // Generate Events
  while(1){
    eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   
    dt = -log(1.0-rand.runif()) / eta;  

    tempTime = tempTime+dt;
    if(tempTime<0){
      cerr << "Error: tempTime<0" << endl;
      exit(1);
    }
 
    if(tempTime - Time < 0){

      V.push_back(tempTime);
      prob1 = (N[i-1]+1)*lambda / eta;

      if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position
	
        P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	L.push_back(rand.rgeom(ri));
	ID.push_back(1);
	N.push_back(N[i-1]+L[i]);
        HMGin = HMG0[i-1];
	int tmphmg = -1;
        for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin()+ P[i],tmphmg);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);

      }else{   // propose a deletion, at a position with a length

        //propose length first
	//for( d = 1; d <= N[i-1] ; d++){
	//  Lwt.push_back( rd * pow(1-rd,d-1) * (N[i-1] - d + 1) );
        //}
	//L.push_back( (rand.rwunif(Lwt) + 1) );   
	//Lwt.resize(0);
        L.push_back(rand.rTRgeom(rd,N[i-1])); 
        P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
        ID.push_back(-1);
	N.push_back(N[i-1]-L[i]);
        HMGin = HMG0[i-1];
        for( k = 0; k<L[i]; k++){
	  HMGin.erase(HMGin.begin()+ P[i]);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);
      }  
      i++;
    }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
      if(N[i-1]<Nend){
	ID.push_back(1);
        L.push_back(Nend-N[i-1]);
        P.push_back((int)(rand.runif() * (N[i-1]+1)));
	V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	N.push_back(Nend);
        HMGin = HMG0[i-1];
	int tmphmg = -1;
        for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin() + P[i],tmphmg);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);
      }else if(N[i-1]>Nend){
	ID.push_back(-1);
	L.push_back(N[i-1]-Nend);
	P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
        V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	N.push_back(Nend);
        HMGin = HMG0[i-1];
        for( k = 0; k<L[i]; k++){
	  HMGin.erase(HMGin.begin()+ P[i]);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);

      }else{
	i--;
      }

      break;
    }// end of if(tempTime-Time<0)

  }// end of while(1).


  numE = i;
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
 

  IDH[c]->setHistory(numE, V, ID, P, L, N, HMG0); 
  //IDH[c] = new InDelHistory(numE, V, ID, P, L, N, HMG0);
  //IDH[1-c] = new InDelHistory();



  calHMG();



  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


}
*/
//--- v20 end ---//


//--- v20 start ---//
void Edge::runEdge(Rand &rand, const Parameters &params){

  int c = current;

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int N0 = start[c]->getSeqLen(c); 
  int Nend = end[c]->getSeqLen(c);
  int i, k, d;
  int numE;
  double eta;
  double dt, tempTime, Time;
  double prob1;   

  //-- v20 start --//
  double C_noEvent = params.getC_noEvent(); 
  double WeiID = params.getWeiID();
  double ImulFacSD = params.getImulFacSD();
  double DmulFacSD = params.getDmulFacSD();
  double ProbTargetFragI = params.getProbTargetFragI();
  double ProbTargetFragD = params.getProbTargetFragD();
  bool go = true;
  double probNoE;
  double LimI, LimD;
  int difLen;
  LimI = 1/ri + ImulFacSD*sqrt(1-ri)/ri;
  LimD = 1/rd + DmulFacSD*sqrt(1-rd)/rd;
  //-- v20 end --//

  Time = edgeLen[c];
  

 
  //cout<< "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << " N0 " << N0 << " Nend " << Nend << " Time " << Time << endl;

  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);


  // Generate Events
  while(1){


    eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   

    //--- v20 start ---//
    probNoE = exp(-eta*(Time - V[i-1])/C_noEvent);


    go = true;
    if((N[i-1]==Nend) & (rand.runif()- probNoE < 0))
      go = false;

    if(go){     // Generate Events 
      //-- v20 end ---//
    
      dt = -log(1.0-rand.runif()) / eta;  

      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error: tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime - Time < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;


	//--- v20 start ---//
	if(N[i-1] < Nend)
	  prob1 *= (1 + WeiID);   // give up weight to insertion
	else if(N[i-1] > Nend)
	  prob1 = 1 - (1-prob1)*(1 + WeiID); // give up weight to deletion 
	//--- v20 end ---//
	


	if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position
   
	  ID.push_back(1);

	  //--- v20 start ---//
	  //L.push_back(rand.rgeom(ri));
	  difLen = Nend - N[i-1];
	  if((0 < difLen) & (difLen < LimI)){
	    if(rand.runif() - ProbTargetFragI < 0)
	      L.push_back(difLen);
	    else
	      L.push_back(rand.rgeom(ri));
	  }else{
	    L.push_back(rand.rgeom(ri));
          }
	  //--- v20 end ---//

	  N.push_back(N[i-1]+L[i]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  HMGin = HMG0[i-1];
	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(1-rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  ID.push_back(-1);
	  
	  //--- v20 start ---//
	  //L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  difLen = N[i-1] - Nend;
	  if((0 < difLen) & (difLen < LimD)){
	    if(rand.runif() - ProbTargetFragD < 0)
	      L.push_back(difLen);
	    else
	      L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  }else{
	    L.push_back(rand.rTRgeom(rd,N[i-1])); 
          }
	  //--- v20 end ---//
	  
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	}  
	i++;
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<Nend){
	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG0[i-1];
	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>Nend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{
	  i--;
	}
	
	break;
      }// end of if(tempTime-Time<0)
      
      //-- v20 start --//
    }else{  // Else if(go) - don't generate Event
      i--;
      break; 
    }    
    //-- v20 end --//
    
  }// end of while(1).


  numE = i;
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
 

  IDH[c]->setHistory(numE, V, ID, P, L, N, HMG0); 
  //IDH[c] = new InDelHistory(numE, V, ID, P, L, N, HMG0);
  //IDH[1-c] = new InDelHistory();



  calHMG();



  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


}



// Generate IDH on edge, but we just know sequence length of starting node so sequence length of ending node will be determined by generated IDH.
void Edge::runEdge2(Rand &rand, const Parameters &params){


  int c = current;

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int N0 = start[c]->getSeqLen(c);
  int Nend;
  int i, k, d;
  int numE;
  double eta;
  double dt, tempTime, Time;
  double prob1;   


  Time = edgeLen[c];
  
  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);



  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);


  // Generate Events
  while(1){
    eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   
    dt = -log(1.0-rand.runif()) / eta;  

    tempTime = tempTime+dt;
    if(tempTime<0){
      cerr << "Error: tempTime<0" << endl;
      exit(1);
    }
 
    if(tempTime - Time < 0){

      V.push_back(tempTime);
      prob1 = (N[i-1]+1)*lambda / eta;

      if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position
	
        P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	L.push_back(rand.rgeom(ri));
	ID.push_back(1);
	N.push_back(N[i-1]+L[i]);
        HMGin = HMG0[i-1];
	int tmphmg = -1;
        for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin()+ P[i],tmphmg);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);

      }else{   // propose a deletion, at a position with a length

        //propose length first
	//for( d = 1; d <= N[i-1] ; d++){
	//  Lwt.push_back( rd * pow(1-rd,d-1) * (N[i-1] - d + 1) );
        //}
	//L.push_back( (rand.rwunif(Lwt) + 1) );   
	//Lwt.resize(0);
        L.push_back(rand.rTRgeom(rd,N[i-1])); 
        P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
        ID.push_back(-1);
	N.push_back(N[i-1]-L[i]);
        HMGin = HMG0[i-1];
        for( k = 0; k<L[i]; k++){
	  HMGin.erase(HMGin.begin()+ P[i]);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);
      }  
      i++;
    }else{         
      i--;
      Nend = N[i];
      numE = i;
      break;
    }
  }

 
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
 

  IDH[c]->setHistory(numE, V, ID, P, L, N, HMG0); 

  end[c]->setSeqLen(Nend);

  //IDH[c] = new InDelHistory(numE, V, ID, P, L, N, HMG0);
  //IDH[1-c] = new InDelHistory();

  /*


    cout << endl << "#### FROM cIDH ####" << endl;
    cout << "numE " << IDH[c]->getNumE() << endl;
    for(int j =0; j<=(IDH[c]->getNumE()+1); j++){ 
      cout << "ID " << IDH[c]->getID(j) << endl;
      cout << "L " << IDH[c]->getL(j) << endl;
      cout << "P " << IDH[c]->getP(j) << endl;
      cout << "V " << IDH[c]->getV(j) << endl;
      cout << "N " << IDH[c]->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(int m=0; m < IDH[c]->getHMG(j).size(); m++){
	cout << IDH[c]->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
 

  */

  calHMG();



  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


}






void Edge::ReverseIDH(){

  int i, k;

  int c = current;

  int currentIndex; 
  int tmphmg;
  int N0;
  int Nend;
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);
  int numE; 
  double edgelen = edgeLen[current];

  numE = IDH[c]->getNumE();

  Nend = IDH[c]->getN(numE+1);
  N0 = IDH[c]->getN(0);

  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);
  for( k = 0; k <= Nend; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);


  
  for(i = numE; i >= 1; i--){
    
    currentIndex = HMG0.size()-1;
    if(IDH[c]->getID(i)==1){
      HMGin = HMG0[currentIndex];
      for( k = 0; k < IDH[c]->getL(i); k++)
	HMGin.erase(HMGin.begin()+ IDH[c]->getP(i));
      V.push_back(edgelen - IDH[c]->getV(i));
      ID.push_back(-1);
      P.push_back(IDH[c]->getP(i));
      L.push_back(IDH[c]->getL(i));
      N.push_back(N[currentIndex] - L[currentIndex+1]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
    }else{

      HMGin = HMG0[currentIndex];
      /*** shim HMG ****/
      //tmphmg = HMGin[IDH[c]->getP(i)];
      tmphmg = -1;
      for( k = 0; k < IDH[c]->getL(i); k++)
	HMGin.insert(HMGin.begin()+ IDH[c]->getP(i),tmphmg);
      V.push_back(edgelen - IDH[c]->getV(i));
      ID.push_back(1);
      P.push_back(IDH[c]->getP(i));
      L.push_back(IDH[c]->getL(i));
      N.push_back(N[currentIndex] + L[currentIndex+1]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);

    }

  }

  V.push_back(edgelen);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);    
  HMG0.push_back(HMG0[numE]);
 

  IDH[c]->setHistory(numE, V, ID, P, L, N, HMG0); 

  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0); 
  HMG0.resize(0);
  HMGin.resize(0);




}




void Edge::changeStartEnd(){

  Node* tmpNode;

  tmpNode = getStart();
  setStart(getEnd());
  setEnd(tmpNode);  

}
 
void Edge::ReverseEdge(){

  ReverseIDH(); 
  changeStartEnd();
  calHMG();  

}


//--- v20 start ---//
/*
void Edge::runEdge(Rand &rand, const Parameters &params, int c){


  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int N0 = start[c]->getSeqLen(c); 
  int Nend = end[c]->getSeqLen(c);
  int i, k, d;
  int numE;
  double eta;
  double dt, tempTime, Time;
  double prob1;   


  Time = edgeLen[c];
  

 
  //cout<< "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << " N0 " << N0 << " Nend " << Nend << " Time " << Time << endl;

  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



  // Generate Events
  while(1){
    eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   
    dt = -log(1.0-rand.runif()) / eta;  

    tempTime = tempTime+dt;
    if(tempTime<0){
      cerr << "Error: tempTime<0" << endl;
      exit(1);
    }
 
    if(tempTime - Time < 0){

      V.push_back(tempTime);
      prob1 = (N[i-1]+1)*lambda / eta;

      if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position
	
        P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	L.push_back(rand.rgeom(ri));
	ID.push_back(1);
	N.push_back(N[i-1]+L[i]);
        HMGin = HMG0[i-1];
	int tmphmg = -1;
        for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin()+ P[i],tmphmg);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);

      }else{   // propose a deletion, at a position with a length

        //propose length first
	//for( d = 1; d <= N[i-1] ; d++){
	//  Lwt.push_back( rd * pow(1-rd,d-1) * (N[i-1] - d + 1) );
        //}
	//L.push_back( (rand.rwunif(Lwt) + 1) );   
	//Lwt.resize(0);
        L.push_back(rand.rTRgeom(rd,N[i-1])); 
        P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
        ID.push_back(-1);
	N.push_back(N[i-1]-L[i]);
        HMGin = HMG0[i-1];
        for( k = 0; k<L[i]; k++){
	  HMGin.erase(HMGin.begin()+ P[i]);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);
      }  
      i++;
    }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
      if(N[i-1]<Nend){
	ID.push_back(1);
        L.push_back(Nend-N[i-1]);
        P.push_back((int)(rand.runif() * (N[i-1]+1)));
	V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	N.push_back(Nend);
        HMGin = HMG0[i-1];
	int tmphmg = -1;
        for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin() + P[i],tmphmg);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);
      }else if(N[i-1]>Nend){
	ID.push_back(-1);
	L.push_back(N[i-1]-Nend);
	P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
        V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	N.push_back(Nend);
        HMGin = HMG0[i-1];
        for( k = 0; k<L[i]; k++){
	  HMGin.erase(HMGin.begin()+ P[i]);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);

      }else{
	i--;
      }

      break;
    }// end of if(tempTime-Time<0)

  }// end of while(1).


  numE = i;
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
 
  IDH[c]->setHistory(numE, V, ID, P, L, N, HMG0);
  //IDH[c] = new InDelHistory(numE, V, ID, P, L, N, HMG0);
  //IDH[1-c] = new InDelHistory();

  calHMG();



  



  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


}
*/
//--- v20 end ---//



//--- v20 start ---//
void Edge::runEdge(Rand &rand, const Parameters &params, int c){


  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int N0 = start[c]->getSeqLen(c); 
  int Nend = end[c]->getSeqLen(c);
  int i, k, d;
  int numE;
  double eta;
  double dt, tempTime, Time;
  double prob1;   


  //-- v20 start --//
  double C_noEvent = params.getC_noEvent(); 
  double WeiID = params.getWeiID();
  double ImulFacSD = params.getImulFacSD();
  double DmulFacSD = params.getDmulFacSD();
  double ProbTargetFragI = params.getProbTargetFragI();
  double ProbTargetFragD = params.getProbTargetFragD();
  bool go = true;
  double probNoE;
  double LimI, LimD;
  int difLen;
  LimI = 1/ri + ImulFacSD*sqrt(1-ri)/ri;
  LimD = 1/rd + DmulFacSD*sqrt(1-rd)/rd;
  //-- v20 end --//

  Time = edgeLen[c];
  

 
  //cout<< "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << " N0 " << N0 << " Nend " << Nend << " Time " << Time << endl;

  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



  // Generate Events
  while(1){
    eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   


    //--- v20 start ---//
    probNoE = exp(-eta*(Time - V[i-1])/C_noEvent);


    go = true;
    if((N[i-1]==Nend) & (rand.runif()- probNoE < 0))
      go = false;

    if(go){     // Generate Events 
      //-- v20 end ---//

      dt = -log(1.0-rand.runif()) / eta;  

      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error: tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime - Time < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;


	//--- v20 start ---//
	if(N[i-1] < Nend)
	  prob1 *= (1 + WeiID);   // give up weight to insertion
	else if(N[i-1] > Nend)
	  prob1 = 1 - (1-prob1)*(1 + WeiID); // give up weight to deletion 
	//--- v20 end ---//
	

	
	if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position
	  
	  ID.push_back(1);

	  //--- v20 start ---//
	  //L.push_back(rand.rgeom(ri));
	  difLen = Nend - N[i-1];
	  if((0 < difLen) & (difLen < LimI)){
	    if(rand.runif() - ProbTargetFragI < 0)
	      L.push_back(difLen);
	    else
	      L.push_back(rand.rgeom(ri));
	  }else{
	    L.push_back(rand.rgeom(ri));
          }
	  //--- v20 end ---//

	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N	  
	  N.push_back(N[i-1]+L[i]);
	  HMGin = HMG0[i-1];
	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(1-rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);


	  ID.push_back(-1);

	  //--- v20 start ---//
	  //L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  difLen = N[i-1] - Nend;
	  if((0 < difLen) & (difLen < LimD)){
	    if(rand.runif() - ProbTargetFragD < 0)
	      L.push_back(difLen);
	    else
	      L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  }else{
	    L.push_back(rand.rTRgeom(rd,N[i-1])); 
          }
	  //--- v20 end ---//

	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	}  
	i++;
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<Nend){
	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG0[i-1];
	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>Nend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{
	  i--;
	}
	
	break;
      }// end of if(tempTime-Time<0)
      
      //-- v20 start --//
    }else{  // Else if(go) - don't generate Event
      i--;
      break; 
    }    
    //-- v20 end --//


  }// end of while(1).
    
    
  numE = i;
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
 
  IDH[c]->setHistory(numE, V, ID, P, L, N, HMG0);
  //IDH[c] = new InDelHistory(numE, V, ID, P, L, N, HMG0);
  //IDH[1-c] = new InDelHistory();

  calHMG();



  



  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


}
//--- v20 end ---//


// Exponentail distribution 
double Edge::CalculatelogLikeliEdge(const Parameters &para)
{

  double gamma = para.getGamma();
  logLikeliEdge[current] = -gamma*edgeLen[current] + log(gamma);

  return logLikeliEdge[current];
}

double Edge::likeliHistory(const Parameters &para, int c)
{

  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i;

  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  
  double logProb;
  double res, fD;

  int numE = IDH[c]->getNumE();

  if(numE==0)                           // no event 
    res = -((IDH[c]->getN(0)+1)*lambda + fDel(IDH[c]->getN(0),rd)*mu) * (IDH[c]->getV(numE+1));
  else{
    logProb = 0.0;
    for( i=1; i<=numE; i++){
      fD = fDel(IDH[c]->getN(i-1),rd);   
      logProb -= ((IDH[c]->getN(i-1)+1)*lambda + fD*mu) * (IDH[c]->getV(i) - IDH[c]->getV(i-1));
           

      if(IDH[c]->getID(i)==1)
	logProb += (logLambda + logRi + (IDH[c]->getL(i)-1) * logRi1);
      else
	logProb += (logMu + logRd + (IDH[c]->getL(i)-1) * logRd1);



    }// end of for



    logProb -= ((IDH[c]->getN(numE)+1)*lambda + fDel(IDH[c]->getN(numE),rd)*mu) * (IDH[c]->getV(numE+1) - IDH[c]->getV(numE));

    res = logProb;  
  }

  logLikeliIDH[c] = res;

  return res;
}
 


double Edge::likeliHistory(const Parameters &para)
{

  //cout << "In likeliHistory " << endl;

  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i;
  int c;

  c = current;

  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  
  double logProb;
  double res, fD;

  int numE = IDH[c]->getNumE();


  //IDH[c]->printIDH();

  //cout << "lambda : " << lambda << " mu : "  << mu << " r : " << r << " ri : " << ri << " rd : " << rd << " numE : " << numE << endl;


  if(numE==0)                           // no event 
    res = -((IDH[c]->getN(0)+1)*lambda + fDel(IDH[c]->getN(0),rd)*mu) * (IDH[c]->getV(numE+1));
  else{
    logProb = 0.0;
    for( i=1; i<=numE; i++){
      //cout << "i : " << i << endl;
      fD = fDel(IDH[c]->getN(i-1),rd);   
      logProb -= ((IDH[c]->getN(i-1)+1)*lambda + fD*mu) * (IDH[c]->getV(i) - IDH[c]->getV(i-1));
           
      //cout << "logProb A : " << -((IDH[c]->getN(i-1)+1)*lambda + fD*mu) * (IDH[c]->getV(i) - IDH[c]->getV(i-1)) << endl;

      if(IDH[c]->getID(i)==1){
	logProb += (logLambda + logRi + (IDH[c]->getL(i)-1) * logRi1);
	//cout << "logProb B : " << (logLambda + logRi + (IDH[c]->getL(i)-1) * logRi1) << endl;
      }else{
	logProb += (logMu + logRd + (IDH[c]->getL(i)-1) * logRd1);
	//cout << "logProb B : " << (logMu + logRd + (IDH[c]->getL(i)-1) * logRd1) << endl;
      }


    }// end of for



    logProb -= ((IDH[c]->getN(numE)+1)*lambda + fDel(IDH[c]->getN(numE),rd)*mu) * (IDH[c]->getV(numE+1) - IDH[c]->getV(numE));


    //cout << "logProb C : " << -((IDH[c]->getN(numE)+1)*lambda + fDel(IDH[c]->getN(numE),rd)*mu) * (IDH[c]->getV(numE+1) - IDH[c]->getV(numE)) << endl;

    res = logProb;  
  }
  
  //cout << "res : " << res << endl;

  logLikeliIDH[c] = res;

  return res;
}



//--- v20 start --//
/*
double Edge::ProposHistory(const Parameters &para)
{



  //cout << "In proposHistory !!! " << endl;

  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i;

  //cout << "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << endl;

  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  double logProb, logProb1, logProb2;
  double res, fD;

  int numE = IDH[current]->getNumE();

  //cout << "numE " << numE << endl;

  if(numE==0)                           // no event is proposed
    res = -((IDH[current]->getN(0)+1)*lambda + fDel(IDH[current]->getN(0),rd)*mu) * (IDH[current]->getV(numE+1));
  else{
    int numE1 = numE-1;

    logProb = 0.0; 
    for( i=1; i<numE; i++){
      fD = fDel(IDH[current]->getN(i-1),rd);   
      logProb -= ((IDH[current]->getN(i-1)+1)*lambda + fD*mu) * (IDH[current]->getV(i) - IDH[current]->getV(i-1));
      if(IDH[current]->getID(i)==1)
	logProb += (logLambda + logRi + (IDH[current]->getL(i)-1) * logRi1);
      else
	logProb += (log(fD) + logMu - log((double)(IDH[current]->getN(i-1)-IDH[current]->getL(i)+1)) - log(1-pow(1-rd, IDH[current]->getN(i-1))) + logRd + (IDH[current]->getL(i)-1) * logRd1);
    }// end of for

    //cout << "A logProb " << logProb << endl;

    fD = fDel(IDH[current]->getN(numE1),rd); 
    logProb2 = logProb - ((IDH[current]->getN(numE1)+1)*lambda + fD*mu) * (IDH[current]->getV(numE) - IDH[current]->getV(numE1)) - ((IDH[current]->getN(numE)+1)*lambda + fDel(IDH[current]->getN(numE),rd)*mu) * (IDH[current]->getV(numE+1) - IDH[current]->getV(numE));

    if(IDH[current]->getID(numE)==1)
	logProb2 += (logLambda + logRi + (IDH[current]->getL(numE)-1) * logRi1);
    else
        logProb2 += (log(fD) + logMu - log((double)(IDH[current]->getN(numE-1) - IDH[current]->getL(numE)+1)) - log(1-pow(1-rd, IDH[current]->getN(numE-1))) + logRd + (IDH[current]->getL(numE)-1) * logRd1);


    //cout << "B logProb2 " << logProb2 << endl;

    // the numE-th event is proposed according uniform
    logProb1 = logProb - ((IDH[current]->getN(numE1)+1)*lambda + fD*mu) * (IDH[current]->getV(numE+1) - IDH[current]->getV(numE1)) - log(IDH[current]->getV(numE+1) - IDH[current]->getV(numE1));

    if(IDH[current]->getID(numE)==1)
      logProb1 -= log((double)IDH[current]->getN(numE1)+1); 
    else
      logProb1 -= log((double)IDH[current]->getN(numE1)+1 - IDH[current]->getL(numE));


    //cout << "C logProb1 " << logProb1 << endl;

    double tuning = (logProb1>logProb2 ? logProb1 : logProb2);
    logProb1 -= tuning;
    logProb2 -= tuning;
    res = log(exp(logProb1) + exp(logProb2)) + tuning;
  }

  //cout << "res " << res << endl;

  return res;
}
*/
//---- v20 end ----//


//--- v20 start --//
double Edge::ProposHistory(const Parameters &para)
{



  //cout << "In proposHistory !!! " << endl;

  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i;




  //cout << "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << endl;

  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  double logProb, logProb1, logProb2;
  double res, fD;




  int numE = IDH[current]->getNumE();

  //cout << "numE " << numE << endl;

  //-- v20 start --//
  InDelHistory* cIDH = getIDH();
  double logProbA, logProbB;
  double C_noEvent = para.getC_noEvent(); 
  double WeiID = para.getWeiID();
  double ImulFacSD = para.getImulFacSD();
  double DmulFacSD = para.getDmulFacSD();
  double ProbTargetFragI = para.getProbTargetFragI();
  double ProbTargetFragD = para.getProbTargetFragD();
  double logprobNoE;
  double eta;
  double LimI, LimD;
  int difLen;
  int Nend = cIDH->getN(numE+1);
  double Time = cIDH->getV(numE+1);
  LimI = 1/ri + ImulFacSD*sqrt(1-ri)/ri;
  LimD = 1/rd + DmulFacSD*sqrt(1-rd)/rd;
  //-- v20 end --//



  if(numE==0){
    // no event is proposed
    //-- v20 start --//
    eta = (cIDH->getN(0)+1)*lambda + fDel(cIDH->getN(0),rd)*mu;
    logprobNoE = -eta*Time/C_noEvent;
    res = LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - eta*Time);
    //-- v20 end ---//
  }else{
    int numE1 = numE-1;

    logProb = 0.0; 

    for( i=1; i<numE; i++){


      fD = fDel(cIDH->getN(i-1),rd);   
      eta = (cIDH->getN(i-1)+1)*lambda + fD*mu;
      
      if(cIDH->getID(i)==1){ // insertion

	difLen = Nend - cIDH->getN(i-1);
	if(difLen == 0){          // insertion - 1

	  logprobNoE = -eta*(Time - cIDH->getV(i-1))/C_noEvent;
	  logProb += log(1 - exp(logprobNoE)) -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + logLambda + logRi + (cIDH->getL(i)-1) * logRi1;

	}else if(difLen >= LimI){ // insertion - 3

	  logProb += -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + logLambda + log(1+WeiID) + logRi + (cIDH->getL(i)-1) * logRi1;

	}else if(difLen < 0){     // insertion - 4

	  logProb += -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + log((cIDH->getN(i-1)+1)*lambda - fD*mu*WeiID) - log((double)cIDH->getN(i-1)+1) + logRi + (cIDH->getL(i)-1) * logRi1;

        }else{                     // insertion - 2

	  if(difLen == cIDH->getL(i)){
	    
	    logProb += -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + logLambda + log(1+WeiID) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (cIDH->getL(i)-1) * logRi1);

          }else{

	    logProb += -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + logLambda + log(1+WeiID) + log(1-ProbTargetFragI)+ logRi + (cIDH->getL(i)-1) * logRi1;

          }
        }

      }else{     // deletion
	
	difLen = cIDH->getN(i-1) - Nend;

	if(difLen == 0){          // deletion - 1

	  logprobNoE = -eta*(Time - cIDH->getV(i-1))/C_noEvent;
	  logProb += log(1 - exp(logprobNoE)) -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + log(fD) + logMu - log((double)(cIDH->getN(i-1)- cIDH->getL(i) + 1)) - log(1-pow(1-rd, cIDH->getN(i-1))) + logRd + (cIDH->getL(i)-1) * logRd1;

	}else if(difLen >= LimD){ // deletion - 3

	  logProb += -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(cIDH->getN(i-1)- cIDH->getL(i) + 1)) - log(1-pow(1-rd, cIDH->getN(i-1))) + logRd + (cIDH->getL(i)-1) * logRd1;

	}else if(difLen < 0){     // deletion - 4

	  logProb += -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + log(fD*mu - (cIDH->getN(i-1)+1)*lambda*WeiID) - log((double)(cIDH->getN(i-1)- cIDH->getL(i) + 1)) - log(1-pow(1-rd, cIDH->getN(i-1))) + logRd + (cIDH->getL(i)-1) * logRd1;

        }else{                     // deletion - 2

	  if(difLen == cIDH->getL(i)){
	    
	    logProb += -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(cIDH->getN(i-1)- cIDH->getL(i) + 1)) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, cIDH->getN(i-1))) + logRd + (cIDH->getL(i)-1) * logRd1);

          }else{

	    logProb += -eta*(cIDH->getV(i) - cIDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(cIDH->getN(i-1)- cIDH->getL(i) + 1)) + log(1-ProbTargetFragD) - log(1-pow(1-rd, cIDH->getN(i-1))) + logRd + (cIDH->getL(i)-1) * logRd1;

          }
        }

      }

    }// end of for
    //--- v20 end ---//



    //cout << "A logProb " << logProb << endl;

    
    fD = fDel(cIDH->getN(numE),rd);
    eta = (cIDH->getN(numE)+1)*lambda + fD*mu;
    logprobNoE = -eta*(Time - cIDH->getV(numE))/C_noEvent; // No event from numE

    fD = fDel(cIDH->getN(numE1),rd);
    eta = (cIDH->getN(numE1)+1)*lambda + fD*mu; // eta(numE - 1)

    if(cIDH->getID(numE)==1){ // insertion

      if(cIDH->getL(numE) < LimI){

	logProbA = logProb - eta*(cIDH->getV(numE) - cIDH->getV(numE1)) + logLambda + log(1+WeiID) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (cIDH->getL(numE)-1) * logRi1);

      }else{

	logProbA = logProb - eta*(cIDH->getV(numE) - cIDH->getV(numE1)) + logLambda + log(1+WeiID) + logRi + (cIDH->getL(numE)-1) * logRi1;

      }

      logProbA += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);

      logProbB = logProb - eta*(Time - cIDH->getV(numE1)) - log(Time - cIDH->getV(numE1)) - log((double)cIDH->getN(numE1)+1); 

    }else{  // deletion

      if(cIDH->getL(numE) < LimD){

	logProbA = logProb - eta*(cIDH->getV(numE) - cIDH->getV(numE1)) + log(1+WeiID) + log(fD) + logMu - log((double)(cIDH->getN(numE1)- cIDH->getL(numE) + 1)) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, cIDH->getN(numE1))) + logRd + (cIDH->getL(numE)-1) * logRd1);

      }else{

	logProbA = logProb - eta*(cIDH->getV(numE) - cIDH->getV(numE1)) + log(1+WeiID) + log(fD) + logMu - log((double)(cIDH->getN(numE1)- cIDH->getL(numE) + 1)) - log(1-pow(1-rd, cIDH->getN(numE1))) + logRd + (cIDH->getL(numE)-1) * logRd1;
      }

      logProbA += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);

      logProbB = logProb - eta*(Time - cIDH->getV(numE1)) - log(Time - cIDH->getV(numE1)) - log((double)cIDH->getN(numE1) - cIDH->getL(numE)+1); 

    }

    res = LOG_SUM(logProbA, logProbB);
  }

  //cout << "res " << res << endl;

  return res;
}
//---- v20 end ----//


// propose History of runEdge2
double Edge::ProposHistory2(const Parameters &para)
{



  //cout << "In proposHistory !!! " << endl;

  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i;

  //cout << "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << endl;

  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  double logProb, logProb1, logProb2;
  double res, fD;

  int numE = IDH[current]->getNumE();

  //cout << "numE " << numE << endl;

  if(numE==0)                           // no event is proposed
    res = -((IDH[current]->getN(0)+1)*lambda + fDel(IDH[current]->getN(0),rd)*mu) * (IDH[current]->getV(numE+1));
  else{
    int numE1 = numE-1;

    logProb = 0.0;
    for( i=1; i<numE; i++){
      fD = fDel(IDH[current]->getN(i-1),rd);   
      logProb -= ((IDH[current]->getN(i-1)+1)*lambda + fD*mu) * (IDH[current]->getV(i) - IDH[current]->getV(i-1));
      if(IDH[current]->getID(i)==1)
	logProb += (logLambda + logRi + (IDH[current]->getL(i)-1) * logRi1);
      else
	logProb += (log(fD) + logMu - log((double)(IDH[current]->getN(i-1)-IDH[current]->getL(i)+1)) - log(1-pow(1-rd, IDH[current]->getN(i-1))) + logRd + (IDH[current]->getL(i)-1) * logRd1);
    }// end of for

    //cout << "A logProb " << logProb << endl;

    fD = fDel(IDH[current]->getN(numE1),rd); 
    logProb2 = logProb - ((IDH[current]->getN(numE1)+1)*lambda + fD*mu) * (IDH[current]->getV(numE) - IDH[current]->getV(numE1)) - ((IDH[current]->getN(numE)+1)*lambda + fDel(IDH[current]->getN(numE),rd)*mu) * (IDH[current]->getV(numE+1) - IDH[current]->getV(numE));

    if(IDH[current]->getID(numE)==1)
	logProb2 += (logLambda + logRi + (IDH[current]->getL(numE)-1) * logRi1);
    else
        logProb2 += (log(fD) + logMu - log((double)(IDH[current]->getN(numE-1) - IDH[current]->getL(numE)+1)) - log(1-pow(1-rd, IDH[current]->getN(numE-1))) + logRd + (IDH[current]->getL(numE)-1) * logRd1);


    res = logProb2;

  }

  //cout << "res " << res << endl;

  return res;
}




    
void Edge::generateSeqAtEndNode(Rand &rand, const Parameters &params){
   
  int i, h, seqLen, tmpint;
  int numLetters;
  vector<double> pi(0);
  vector<vector<double> > Q;

  Node* endNode;
  Node* stNode;
  
  endNode = getEnd();
  stNode = getStart();

  endNode->findRootSites();
  seqLen = endNode->getrootSitesSize();

  pi = params.getPi();
  Q = params.getQ();

  // generate letters at rooted sites.
  //cout << "endNode seqLen : " << seqLen << endl;
  endNode->resetSeq();
  for(i = 0; i < seqLen; i++){
    if(endNode->getrootSites(i)==1)
      endNode->setSeq(i, (int)pow((double)2, rand.rwunif(pi)));
  }

  // generate letters at not rooted sites
  seqLen = stNode->getSeqLen();
  numLetters = endNode->getNumLetters();

  //cout << "stNode seqLen : " << seqLen << endl;
  for(i = 0; i < seqLen; i++){
    tmpint = getHMG(i);
    //cout << "i : " << i << " HMG : " << tmpint << endl; 
    if(tmpint >= 0)
      endNode->setSeq(tmpint, generateLetter(stNode->getSeq(i), Q, getEdgeLen(), numLetters, rand));
  }

} 


int Edge::generateLetter(int stLetter, vector<vector<double> > Q, double len, int numLetters, Rand &rand){

  int stLetIndex, enLetIndex;
  vector<int> nextLet(0);
  vector<double> prob(0);


  incNumHMG();

  int i;
  double time = 0;
  double sum;
  for( i = 0; i < numLetters; i++){
    if(stLetter%2==1){
      stLetIndex = i; 
    }
    stLetter /= 2;
  }
  time += -log(1.0-rand.runif()) / (-Q[stLetIndex][stLetIndex]); 
  
  while(time < len){
    nextLet.resize(0);
    prob.resize(0);
    incNumSub();
    for( i = 0 ; i < numLetters; i++){
      if(i != stLetIndex){
	nextLet.push_back(i);
	prob.push_back(Q[stLetIndex][i]);
      }
    }
    if(prob.size()!=3){
      cout << "ERROR! At Edge::generateLetter" << endl;
    }
    sum = sum_vec(prob);
    for( i = 0; i < (numLetters - 1); i++)
      prob[i] = prob[i]/sum;
    stLetIndex = nextLet[rand.rwunif(prob)];
    time += -log(1.0-rand.runif()) / (-Q[stLetIndex][stLetIndex]);
  } 

  return (int)pow((double)2, stLetIndex);

}



  


void Edge::generateIDHandSeq(Rand &rand, const Parameters &params){

  Node* endNode;
  endNode = getEnd();

  runEdge2(rand,params);
  //printEdge();
  generateSeqAtEndNode(rand, params);

  if(!endNode->getLeaf()){
    for(int i = 0; i < endNode->getnumEdges(); i++){
      if(i!=endNode->getparentIndex())
	endNode->getEdge(i)->generateIDHandSeq(rand, params);
    }
  }

}





void Edge::generateIDH(Rand &rand, const Parameters &params){

  Node* endNode;
  endNode = getEnd();

  if(endNode->getLeaf()){
    runEdge(rand,params);
  }else{
    runEdge2(rand,params);
    for(int i = 0; i < endNode->getnumEdges(); i++){
      if(i!=endNode->getparentIndex())
	endNode->getEdge(i)->generateIDH(rand, params);
    }
  }

}





Tree::Tree(int n, Rand &rand, Parameters &params, double T, int N) : numLeaves(n), numNodes(2*n-2), numEdges(2*n-3) {

  //-- v29 start --//
  numLetters = 4;
  //-- v29 end --//

  current = 0;

  outGroupNode = numLeaves - 1;


  UpdatedNodeinRootSites.resize(2);
  for(int i=0;i<2;i++)
    UpdatedNodeinRootSites[i].resize(numNodes-1);

  //int shortLen, longLen, diffLen;



  nodes.resize(numNodes);
  edges.resize(numEdges);


  for(int i=0;i<numLeaves;i++) {
    if(numLeaves>1)
      nodes[i] = new Node(i,true,false,0, 1, 4);
    else
      nodes[i] = new Node(i,true,true,-1, 3, 4);
  }

 
  // Create internal nodes
  for(int i=numLeaves;i<(numNodes-1);i++) {
    nodes[i] = new Node(i,false,false,2, 3, 4);
  }


  double gamma = params.getGamma();


  vector<double> Elen(0);
  Elen.resize(0);
  for(int i=0;i<numEdges;i++)
    Elen.push_back(-log(1.0-rand.runif())/gamma);


  double Elensum = sum_vec(Elen);
  for(int i=0;i<numEdges;i++)
    Elen[i] = Elen[i]*T/Elensum;
 
  // Create edges
  for(int i=0;i<numEdges;i++)
    edges[i] = new Edge(i, Elen[i]);

  // Create root
  if(numNodes>3) {
    nodes[numNodes-1] = new Node(numNodes-1,false,true,-1, 3, 4);
  }  
  root = nodes[numNodes-1];


  // Build a random tree

  // Attach edges to all of the leaves
  if(numLeaves>=3) {

    for(int i=0;i<numLeaves;i++) {
      nodes[i]->setEdge(0,edges[i],0);
      edges[i]->setEnd(nodes[i],0);
    }

    // List of subtrees
    vector<int> v(numLeaves-1);
    for(int i=0;i<(numLeaves-1);i++)
      v[i] = i+1;


    // k is index of next internal node
    for(int k=numLeaves;k<(numNodes-1);k++) {
      // select two current subtree root nodes at random
      int i = (int)(rand.runif()*(v.size()));
      int j = (int)(rand.runif()*(v.size()-1));
      if(j>=i) j++;
      //  combine nodes v[i] and v[j], parent is k   
      Edge* e1 = nodes[v[i]]->getParentEdge();
      Edge* e2 = nodes[v[j]]->getParentEdge();
      nodes[k]->setEdge(0,e1,0);
      e1->setStart(nodes[k],0);
      nodes[k]->setEdge(1,e2,0);
      e2->setStart(nodes[k],0);
      nodes[k]->setEdge(2,edges[k],0);
      edges[k]->setEnd(nodes[k],0);

      if(i>j)
	swap(i,j);
      v[i] = k;
      v[j] = v[v.size()-1];
      v.resize(v.size()-1);
    }


    // attach root node to the tree
    Edge* e1 = nodes[v[0]]->getParentEdge();    
    Edge* e2 = nodes[v[1]]->getParentEdge();
    Edge* e3 = nodes[0]->getParentEdge();
    root->setEdge(0,e1,0);
    e1->setStart(root,0);
    root->setEdge(1,e2,0);
    e2->setStart(root,0);
    root->setEdge(2,e3,0);
    e3->setStart(root,0);


    // Generate sequence

    // 1. generate sequence length at root based on r
    double r = params.getR();
    //int seqLen = rand.rgeom0(r);
    int seqLen = N;
    root->setSeqLen(seqLen);
    // 2. generate letters at root from pi distribution
    vector<int> tmpint(0);
    vector<double> pi(0);
    pi = params.getPi();
    for(int i = 0; i < seqLen; i++)
      tmpint.push_back((int)pow((double)2, rand.rwunif(pi)));
    root->setSeq(tmpint);





    // Calculate Q
    vector<vector<double> > Q;
    Q.resize(0);
    vector<double> Q_in(0);
    // HKY substitution model
    // Q[i][j] = Pr(i->j)
    double mu, kappa, piA, piC, piG, piT, piR, piY, pi_j;


    piA = pi[0];
    piC = pi[1];
    piG = pi[2];
    piT = pi[3];
    piR=piA+piG;
    piY=piC+piT;
    
    kappa = params.getKappa();
    mu = (2*(kappa*(piA*piG + piC*piT) + piR*piY));

    // start from A
    Q_in.resize(4);
    Q_in[0] = -(kappa*piG + piY)/mu;
    Q_in[1] = piC/mu;
    Q_in[2] = kappa*piG/mu;
    Q_in[3] = piT/mu;
    Q.push_back(Q_in);
    Q_in.resize(0);

    // start from C
    Q_in.resize(4);
    Q_in[0] = piA/mu; 
    Q_in[1] = -(kappa*piT + piR)/mu;
    Q_in[2] = piG/mu;
    Q_in[3] = kappa*piT/mu;
    Q.push_back(Q_in);
    Q_in.resize(0);


    // start from G
    Q_in.resize(4);
    Q_in[0] = kappa*piA/mu; 
    Q_in[1] = piC/mu;
    Q_in[2] = -(kappa*piA + piY)/mu;
    Q_in[3] = piT/mu;
    Q.push_back(Q_in);
    Q_in.resize(0);

     // start from T
    Q_in.resize(4);
    Q_in[0] = piA/mu; 
    Q_in[1] = kappa*piC/mu;
    Q_in[2] = piG/mu; 
    Q_in[3] = -(kappa*piC + piR)/mu;
    Q.push_back(Q_in);
    Q_in.resize(0);   

    params.setQ(Q);
    Q.resize(0);
    
    // 3. Generate IDH and Sequeces.
    for(int i = 0; i < root->getnumEdges(); i++)
      root->getEdge(i)->generateIDHandSeq(rand,params);

    root->set0LinkedSites();
    root->findLinkedSites();

  }
         
  for(int i=0;i<numNodes;i++)
    nodes[i]->save();


  for(int i=0;i<numEdges;i++)
    edges[i]->save();


}




// Generate tree from uniform dist
// Genarate data from prior
Tree::Tree(int n, Rand &rand, RNG &rng, Parameters &params) : numLeaves(n), numNodes(2*n-2), numEdges(2*n-3) {

  //**************************************//
  //
  //   Generate parameters from prior
  //
  //**************************************//

  //-- v29 start --//
  numLetters = 4;
  //-- v29 end --//

  // 1. Get hyper parameters
  double r_alpha = params.getR_alpha();
  double r_beta = params.getR_beta();
  double rd_alpha = params.getRd_alpha();
  double rd_beta = params.getRd_beta();
  double lambda_epsilon = params.getLambda_epsilon(); 
  double kappa_epsilon = params.getKappa_epsilon(); 
  double gamma_alpha = params.getGamma_alpha();
  double gamma_beta = params.getGamma_beta();
  //double gamma_epsilon = params.getGamma_epsilon(); 
  vector<double> pi_alpha(0);
  vector<double> pi(0);
  pi_alpha = params.getPi_alpha();

  // 2. Generate parameters from prior
  double r = rng.beta(r_alpha, r_beta);
  //double r = 0.25;
  double rd = rng.beta(rd_alpha, rd_beta);
  //double rd = 1;
  //double lambda = rand.rRatioOfExps(lambda_epsilon);
  double lambda = -log(1.0-rand.runif())/lambda_epsilon;
  //double lambda = 0;
  double kappa = -log(1.0-rand.runif())/kappa_epsilon;
  //double kappa = rand.rRatioOfExps(kappa_epsilon);
  //double gamma = rand.rRatioOfExps(gamma_epsilon);
  double gamma = rng.gamma(gamma_alpha, gamma_beta);
  pi = rand.rDirichlet(pi_alpha, rng);


  // 3. Calculate all other parameters
  double ri = 1 - ((1-rd)*(1-r));
  //double ri = 1;
  //double mu = 0;
  double mu = lambda*ri*(1-rd)/(rd*(1-ri));

  // 4. Set all parameters
  params.setParameters(r, ri, rd, lambda, mu, gamma, pi);
  params.setKappa(kappa);



  //******* done ******************************//



  current = 0;
  int i, j, k;
  int newposi;

  outGroupNode = numLeaves - 1;

  UpdatedNodeinRootSites.resize(2);
  for(i=0;i<2;i++)
    UpdatedNodeinRootSites[i].resize(numNodes-1);


  nodes.resize(numNodes);
  edges.resize(numEdges);


  // Create leaves
  for(i=0;i<numLeaves;i++) {
    if(numLeaves>1)
      nodes[i] = new Node(i,true,false,0, 1, 4);
    else
      nodes[i] = new Node(i,true,true,-1, 3, 4);
  }

  // Create internal nodes
  for(i=numLeaves;i<(numNodes-1);i++) {
    nodes[i] = new Node(i,false,false,0, 3, 4);
  }

  gamma = params.getGamma();
  
  
  // Generate edge lengths
  vector<double> Elen(0);
  Elen.resize(0);
  for(int i=0;i<numEdges;i++)
    Elen.push_back(-log(1.0-rand.runif())/gamma);
  
  // Create edges
  for(i=0;i<numEdges;i++)
    edges[i] = new Edge(i, Elen[i]);

  Elen.resize(0);


  // Create root
  if(numNodes>3) {
    nodes[numNodes-1] = new Node(numNodes-1,false,true,-1, 3, 4);
  }

  root = nodes[numNodes-1];

  // Build a random tree from uniform dist
  // Attach edges to all of nodes except for root
  if(numLeaves>=3) {

    for(i=0;i<(numNodes-1);i++) {
      nodes[i]->setEdge(0,edges[i],0);
      edges[i]->setEnd(nodes[i],0);
    }
 
    // Set of edge numbers
    // Select edge number from this set and attach new edge here. 
    vector<int> setE(0);

    // Make an initial tree with four taxa
    for(i = 0; i < 3; i++){
      root->setEdge(i,edges[i],0);
      edges[i]->setStart(root,0);
      setE.push_back(i);
    }

    // Construct a tree
    int newSetIX;
    for(i = 3; i < numLeaves; i++){

      // get ready new edge
      newSetIX = numLeaves - 3 + i;
      edges[i]->setStart(nodes[newSetIX], 0);
      
      // select new edge where next node will be attached.
      newposi = setE[(int)(rand.runif() * setE.size())];

      // attach new edge into a tree at the selected position
      nodes[newSetIX]->setEdge(1, edges[i], 0);
      nodes[newSetIX]->setEdge(2, edges[newposi], 0);

      edges[newSetIX]->setStart(edges[newposi]->getStart(),0);
  
      edges[newposi]->getStart()->setEdge(edges[newposi], edges[newSetIX]);

      edges[newposi]->setStart(nodes[newSetIX]);

      // update setE
      setE.push_back(i);
      setE.push_back(newSetIX);

    }
    setE.resize(0);


    // Generate sequence

    // 1. generate sequence length at root based on r
    //double r = params.getR();
    r = params.getR();
    int seqLen = rand.rgeom0(r);
    root->setSeqLen(seqLen);
    // 2. generate letters at root from pi distribution
    vector<int> tmpint(0);
    //vector<double> pi(0);
    pi.resize(0);
    pi = params.getPi();
    for(i = 0; i < seqLen; i++)
      tmpint.push_back((int)pow((double)2, rand.rwunif(pi)));
    root->setSeq(tmpint);





    // Calculate Q
    vector<vector<double> > Q;
    Q.resize(0);
    vector<double> Q_in(0);
    // HKY substitution model
    // Q[i][j] = Pr(i->j)
    double piA, piC, piG, piT, piR, piY, pi_j;


    piA = pi[0];
    piC = pi[1];
    piG = pi[2];
    piT = pi[3];
    piR=piA+piG;
    piY=piC+piT;
    
    kappa = params.getKappa();
    mu = (2*(kappa*(piA*piG + piC*piT) + piR*piY));

    // start from A
    Q_in.resize(4);
    Q_in[0] = -(kappa*piG + piY)/mu;
    Q_in[1] = piC/mu;
    Q_in[2] = kappa*piG/mu;
    Q_in[3] = piT/mu;
    Q.push_back(Q_in);
    Q_in.resize(0);

    // start from C
    Q_in.resize(4);
    Q_in[0] = piA/mu; 
    Q_in[1] = -(kappa*piT + piR)/mu;
    Q_in[2] = piG/mu;
    Q_in[3] = kappa*piT/mu;
    Q.push_back(Q_in);
    Q_in.resize(0);


    // start from G
    Q_in.resize(4);
    Q_in[0] = kappa*piA/mu; 
    Q_in[1] = piC/mu;
    Q_in[2] = -(kappa*piA + piY)/mu;
    Q_in[3] = piT/mu;
    Q.push_back(Q_in);
    Q_in.resize(0);

     // start from T
    Q_in.resize(4);
    Q_in[0] = piA/mu; 
    Q_in[1] = kappa*piC/mu;
    Q_in[2] = piG/mu; 
    Q_in[3] = -(kappa*piC + piR)/mu;
    Q.push_back(Q_in);
    Q_in.resize(0);   

    params.setQ(Q);
    Q.resize(0);


    for(i=0;i<numEdges;i++){
      edges[i]->setNumHMG(0);
      edges[i]->setNumSub(0);
    }


    
    
    // 3. Generate IDH and Sequeces.
    for(i = 0; i < root->getnumEdges(); i++)
      root->getEdge(i)->generateIDHandSeq(rand,params);

    root->set0LinkedSites();
    root->findLinkedSites();

  }

  //printTree(0);
  calculateLogLikelihood(params);
         
  for(i=0;i<numNodes;i++)
    nodes[i]->save();


  for(i=0;i<numEdges;i++)
    edges[i]->save();



}




void Tree::printSeq(ofstream& c){

  int seqLen; 
  int letter; 
  for(int i = 0; i < numLeaves; i++){
    c << ">species" << (i+1) << endl;
    seqLen = nodes[i]->getSeqLen();
    for(int j = 0; j < seqLen; j++){
      letter = nodes[i]->getSeq(j);
      if(letter == 1){
	c << "A"; 
      }else if(letter == 2){
	c << "C";
      }else if(letter == 4){
	c << "G";
      }else if(letter == 8){
	c << "T";	
      }
    }
    c << endl;
  }
}










Tree::Tree(int n,Rand &rand,const Parameters &params,vector<vector<int> > seqData, double T) : numLeaves(n), numNodes(2*n-2), numEdges(2*n-3) {

  //-- v29 start --//
  numLetters = 4;
  //-- v29 end --//

  current = 0;

  outGroupNode = numLeaves - 1;


  UpdatedNodeinRootSites.resize(2);
  for(int i=0;i<2;i++)
    UpdatedNodeinRootSites[i].resize(numNodes-1);


  int shortLen, longLen, diffLen;



  nodes.resize(numNodes);
  edges.resize(numEdges);

  //cout << "Tree 3" << endl;
  // Create leaves
  for(int i=0;i<numLeaves;i++) {
    if(numLeaves>1)
      nodes[i] = new Node(i,seqData[i],true,false,0, 1, 4);
    else
      nodes[i] = new Node(i,seqData[i],true,true,-1, 3, 4);
  }

  //cout << "Tree 4" << endl;
  
  // Create internal nodes
  for(int i=numLeaves;i<(numNodes-1);i++) {
    nodes[i] = new Node(i,false,false,2, 3, 4);
  }

  //cout << "Tree 5" << endl;

  double gamma = params.getGamma();

  // new shim //
  vector<double> Elen(0);
  Elen.resize(0);
  for(int i=0;i<numEdges;i++)
    Elen.push_back(-log(1.0-rand.runif())/gamma);

  //cout << "Tree 6" << endl;

  double Elensum = sum_vec(Elen);
  for(int i=0;i<numEdges;i++)
    Elen[i] = Elen[i]*T/Elensum;
 
  //cout << "Tree 7" << endl;

  // Create edges
  for(int i=0;i<numEdges;i++)
    edges[i] = new Edge(i, Elen[i]);

  //cout << "Tree 8" << endl;

  // Create root
  if(numNodes>3) {
    nodes[numNodes-1] = new Node(numNodes-1,false,true,-1, 3, 4);
  }

  //cout << "Tree 9" << endl;
  
  root = nodes[numNodes-1];


  // Build a random tree

  // Attach edges to all of the leaves
  if(numLeaves>=3) {

    for(int i=0;i<numLeaves;i++) {
      nodes[i]->setEdge(0,edges[i],0);
      edges[i]->setEnd(nodes[i],0);
    }

    // List of subtrees
    vector<int> v(numLeaves-1);
    for(int i=0;i<(numLeaves-1);i++)
      v[i] = i+1;
    // k is index of next internal node
    for(int k=numLeaves;k<(numNodes-1);k++) {
      // select two current subtree root nodes at random
      int i = (int)(rand.runif()*(v.size()));
      int j = (int)(rand.runif()*(v.size()-1));
      if(j>=i) j++;
      //  combine nodes v[i] and v[j], parent is k   
      Edge* e1 = nodes[v[i]]->getParentEdge();
      Edge* e2 = nodes[v[j]]->getParentEdge();
      nodes[k]->setEdge(0,e1,0);
      e1->setStart(nodes[k],0);
      nodes[k]->setEdge(1,e2,0);
      e2->setStart(nodes[k],0);
      nodes[k]->setEdge(2,edges[k],0);
      edges[k]->setEnd(nodes[k],0);

      
      if(nodes[v[i]]->getSeqLen() > nodes[v[j]]->getSeqLen()){
	shortLen = nodes[v[j]]->getSeqLen();
	longLen  = nodes[v[i]]->getSeqLen();
      }else{
	shortLen = nodes[v[i]]->getSeqLen();
	longLen  = nodes[v[j]]->getSeqLen();
      }
      diffLen = longLen - shortLen;
      nodes[k]->setSeqLen((shortLen + (int)(rand.runif()*(diffLen + 1))));

      if(i>j)
	swap(i,j);
      v[i] = k;
      v[j] = v[v.size()-1];
      v.resize(v.size()-1);
    }

    //cout << "Tree 10" << endl;


    // attach root node to the tree
    Edge* e1 = nodes[v[0]]->getParentEdge();    
    Edge* e2 = nodes[v[1]]->getParentEdge();
    Edge* e3 = nodes[0]->getParentEdge();
    root->setEdge(0,e1,0);
    e1->setStart(root,0);
    root->setEdge(1,e2,0);
    e2->setStart(root,0);
    root->setEdge(2,e3,0);
    e3->setStart(root,0);

    shortLen = MIN(nodes[v[0]]->getSeqLen(), nodes[v[1]]->getSeqLen());
    shortLen = MIN(shortLen, nodes[0]->getSeqLen());
    
    longLen = MAX(nodes[v[0]]->getSeqLen(), nodes[v[1]]->getSeqLen());
    longLen = MAX(longLen, nodes[0]->getSeqLen());
    
    diffLen = longLen - shortLen;
    root->setSeqLen((shortLen + (int)(rand.runif()*(diffLen + 1))));
    //root->setSeqLen(3);

    //cout << "Tree 11" << endl;

 
    /*
  cout << "print out all Nodes" << endl << endl;
  for(int i=0; i < numNodes; i++){
    cout << "number " << nodes[i]->getnumber() << endl;
    cout << "leaf " << nodes[i]->getLeaf() << endl;
    cout << "root " << nodes[i]->getRoot() << endl;
    cout << "numEdges " << nodes[i]->getnumEdges() << endl;
    cout << "parentIndex " << nodes[i]->getparentIndex() << endl;
    for(int m=0; m < nodes[i]->getnumEdges(); m++)
      cout << "Edge number " << m << " Edge name " << nodes[i]->getEdge(m)->getnumber() << endl;
    cout << "seqLen " << nodes[i]->getSeqLen() << endl;
    if(nodes[i]->getLeaf()){
      for(int m = 0; m < nodes[i]->getSeqLen(); m++)
	cout << nodes[i]->getSeq(m) << " " ;
      cout << endl;
    }
    cout << endl;

  }
    
  cout << "print out all Edges" << endl << endl;
  for(int i=0; i < numEdges; i++){
    cout << "number " << edges[i]->getnumber() << endl;
    cout << "edgeLen " <<  edges[i]->getEdgeLen()  << endl;
    cout << "Start " << edges[i]->getStart()->getnumber() << endl;
    cout << "End " << edges[i]->getEnd()->getnumber() << endl;
    cout << endl;
  }
    */




    //cout << "Tree 12" << endl;


    //add IDH to the edges
    for(int i=0;i<numEdges;i++)
      edges[i]->runEdge(rand,params,0);

  }      

  //cout << "Tree 13" << endl;

  for(int i=0;i<numNodes;i++)
    nodes[i]->save();



  for(int i=0;i<numEdges;i++)
    edges[i]->save();


  /*
    cout << "################################" << endl;
    cout << "After saving nodes and edges!!! " << endl;
    cout << "################################" << endl;


    cout << "----- Old events ---------" << endl;
    printTree(1-current);
    cout << "----- New events ---------" << endl;
    printTree(current);
  */


  //cout << "Tree 14" << endl;

  // need to compute the log-likelihood of the tree and set it
  calculateLogLikelihood(params);

  //cout << "Tree 15" << endl;

}


/*
Tree::Tree(int n, Rand &rand,const Parameters &params,vector<vector<int> > seqData) : numLeaves(n), numNodes(2*n-2), numEdges(2*n-3) {


  int i, newposi;
  current = 0;

  outGroupNode = numLeaves - 1;


  UpdatedNodeinRootSites.resize(2);
  for(i=0;i<2;i++)
    UpdatedNodeinRootSites[i].resize(numNodes-1);


  nodes.resize(numNodes);
  edges.resize(numEdges);


  // Create leaves
  for(i=0;i<numLeaves;i++) {
    if(numLeaves>1)
      nodes[i] = new Node(i,seqData[i],true,false,0, 1, 4);
    else
      nodes[i] = new Node(i,seqData[i],true,true,-1, 3, 4);
  }


  // Create internal nodes
  for(i=numLeaves;i<(numNodes-1);i++) {
    nodes[i] = new Node(i,false,false, 0, 3, 4);
  }

  double gamma = params.getGamma();

  // Generate edge lengths
  vector<double> Elen(0);
  Elen.resize(0);
  for(i=0;i<numEdges;i++)
    Elen.push_back(-log(1.0-rand.runif())/gamma);


  // Create edges
  for(i=0;i<numEdges;i++)
    edges[i] = new Edge(i, Elen[i]);

  Elen.resize(0);


  // Create root
  if(numNodes>3) {
    nodes[numNodes-1] = new Node(numNodes-1,false,true,-1, 3, 4);
  }

  
  root = nodes[numNodes-1];


  // Build a random tree

  // Attach edges to all of the leaves
  if(numLeaves>=3) {

    for(i=0;i<(numNodes-1);i++) {
      nodes[i]->setEdge(0,edges[i],0);
      edges[i]->setEnd(nodes[i],0);
    }
 
    // Set of edge numbers
    // Select edge number from this set and attach new edge here. 
    vector<int> setE(0);

    // Make an initial tree with four taxa
    for(i = 0; i < 3; i++){
      root->setEdge(i,edges[i],0);
      edges[i]->setStart(root,0);
      setE.push_back(i);
    }

    // Construct a tree
    int newSetIX;
    for(i = 3; i < numLeaves; i++){

      // get ready new edge
      newSetIX = numLeaves - 3 + i;
      edges[i]->setStart(nodes[newSetIX], 0);
      
      // select new edge where next node will be attached.
      newposi = setE[(int)(rand.runif() * setE.size())];

      // attach new edge into a tree at the selected position
      nodes[newSetIX]->setEdge(1, edges[i], 0);
      nodes[newSetIX]->setEdge(2, edges[newposi], 0);

      edges[newSetIX]->setStart(edges[newposi]->getStart(),0);
  
      edges[newposi]->getStart()->setEdge(edges[newposi], edges[newSetIX]);

      edges[newposi]->setStart(nodes[newSetIX]);

      // update setE
      setE.push_back(i);
      setE.push_back(newSetIX);

    }
    setE.resize(0);


    // Generate IDH
    int shortLen, longLen, diffLen;
    shortLen = nodes[0]->getSeqLen();
    longLen = shortLen;
    for(i = 1; i < numLeaves; i++){
      shortLen = MIN(shortLen, nodes[i]->getSeqLen());
      longLen = MAX(longLen, nodes[i]->getSeqLen());
    }
    diffLen = longLen - shortLen;
    root->setSeqLen((shortLen + (int)(rand.runif()*(diffLen + 1))));
   

    for(i = 0; i < root->getnumEdges(); i++)
      root->getEdge(i)->generateIDH(rand,params);


    root->set0LinkedSites();
    root->findLinkedSites();
    calculateLogLikelihood(params);

  }

  for(int i=0;i<numNodes;i++)
    nodes[i]->save();

  for(int i=0;i<numEdges;i++)
    edges[i]->save();




}
*/




/*
 *  void convChar(string c) 
 *
 *  A is coded as 0001, G is coded as 0010, C is coded as 0100, 
 *  and T(U) is coded as 1000
 */

int Tree::convChar(char c)
{
  /* Returns the bit vector associated with the symbol. */

  /*
  switch (c) {
  case 'A' : case 'a' : 			return 0x1;
  case 'G' : case 'g' : 			return 0x2;
  case 'C' : case 'c' : 			return 0x4;
  case 'U' : case 'u' : case 'T' : case 't' :   return 0x8;
  case 'M' : case 'm' : 			return 0x1 | 0x4;
  case 'R' : case 'r' : 			return 0x1 | 0x2;
  case 'W' : case 'w' : 			return 0x1 | 0x8;
  case 'S' : case 's' : 			return 0x2 | 0x4;
  case 'Y' : case 'y' : 			return 0x4 | 0x8;
  case 'K' : case 'k' : 			return 0x2 | 0x8;
  case 'V' : case 'v' : 			return 0x1 | 0x2 | 0x4;
  case 'H' : case 'h' : 			return 0x1 | 0x4 | 0x8;
  case 'D' : case 'd' : 			return 0x1 | 0x2 | 0x8;
  case 'B' : case 'b' : 			return 0x2 | 0x4 | 0x8;
  case 'X' : case 'x' : case 'N' : case 'n' :   return 0x1 | 0x2 | 0x8 | 0x4;
  case '~' : case '-' : case '?' :		return 0x1 | 0x2 | 0x8 | 0x4;
  */
  switch (c) {
  case 'A' : case 'a' : 			return 0x1;
  case 'G' : case 'g' : 			return 0x4;
  case 'C' : case 'c' : 			return 0x2;
  case 'U' : case 'u' : case 'T' : case 't' :   return 0x8;
  case 'M' : case 'm' : 			return 0x1 | 0x2;
  case 'R' : case 'r' : 			return 0x1 | 0x4;
  case 'W' : case 'w' : 			return 0x1 | 0x8;
  case 'S' : case 's' : 			return 0x4 | 0x2;
  case 'Y' : case 'y' : 			return 0x2 | 0x8;
  case 'K' : case 'k' : 			return 0x4 | 0x8;
  case 'V' : case 'v' : 			return 0x1 | 0x4 | 0x2;
  case 'H' : case 'h' : 			return 0x1 | 0x2 | 0x8;
  case 'D' : case 'd' : 			return 0x1 | 0x4 | 0x8;
  case 'B' : case 'b' : 			return 0x4 | 0x2 | 0x8;
  case 'X' : case 'x' : case 'N' : case 'n' :   return 0x1 | 0x4 | 0x8 | 0x2;
  case '~' : case '-' : case '?' :		return 0x1 | 0x4 | 0x8 | 0x2;
    //  case '.' : 
    //   if(n==0) {
    //      error << "Error: Base '.' appears in the first taxon." << endError;
    //      quit(1);
    //    }
    //    return x;
  default:
    cout << "Warning: " << c << " unknown base. - used." << endl;
    return 0;
  }
}


/*
Tree::Tree(int n, Rand &rand, Parameters &params,vector<string> seqDataS) : numLeaves(n), numNodes(2*n-2), numEdges(2*n-3) {

  //-- v29 start --//
  numLetters = 4;
  //-- v29 end --//


  vector<vector<int> > seqData(0);
  int s, m;
  seqData.resize(seqDataS.size());
  for(s = 0; s < seqDataS.size(); s++){
    seqData[s].resize(0);
    for(m = 0; m < seqDataS[s].length(); m++){
      seqData[s].push_back(convChar(seqDataS[s][m]));
    }
  }



  int i, newposi;
  current = 0;

  outGroupNode = numLeaves - 1;


  UpdatedNodeinRootSites.resize(2);
  for(i=0;i<2;i++)
    UpdatedNodeinRootSites[i].resize(numNodes-1);


  nodes.resize(numNodes);
  edges.resize(numEdges);


  // Create leaves
  for(i=0;i<numLeaves;i++) {
    if(numLeaves>1)
      nodes[i] = new Node(i,seqData[i],true,false,0, 1, 4);
    else
      nodes[i] = new Node(i,seqData[i],true,true,-1, 3, 4);
  }


  // Create internal nodes
  for(i=numLeaves;i<(numNodes-1);i++) {
    nodes[i] = new Node(i,false,false, 0, 3, 4);
  }

  double gamma = params.getGamma();

  // Generate edge lengths
  vector<double> Elen(0);
  Elen.resize(0);
  for(i=0;i<numEdges;i++)
    Elen.push_back(-log(1.0-rand.runif())/gamma);


  // Create edges
  for(i=0;i<numEdges;i++)
    edges[i] = new Edge(i, Elen[i]);

  Elen.resize(0);


  // Create root
  if(numNodes>3) {
    nodes[numNodes-1] = new Node(numNodes-1,false,true,-1, 3, 4);
  }

  
  root = nodes[numNodes-1];


  // Build a random tree

  // Attach edges to all of the leaves
  if(numLeaves>=3) {

    for(i=0;i<(numNodes-1);i++) {
      nodes[i]->setEdge(0,edges[i],0);
      edges[i]->setEnd(nodes[i],0);
    }
 
    // Set of edge numbers
    // Select edge number from this set and attach new edge here. 
    vector<int> setE(0);

    // Make an initial tree with four taxa
    for(i = 0; i < 3; i++){
      root->setEdge(i,edges[i],0);
      edges[i]->setStart(root,0);
      setE.push_back(i);
    }

    // Construct a tree
    int newSetIX;
    for(i = 3; i < numLeaves; i++){

      // get ready new edge
      newSetIX = numLeaves - 3 + i;
      edges[i]->setStart(nodes[newSetIX], 0);
      
      // select new edge where next node will be attached.
      newposi = setE[(int)(rand.runif() * setE.size())];

      // attach new edge into a tree at the selected position
      nodes[newSetIX]->setEdge(1, edges[i], 0);
      nodes[newSetIX]->setEdge(2, edges[newposi], 0);

      edges[newSetIX]->setStart(edges[newposi]->getStart(),0);
  
      edges[newposi]->getStart()->setEdge(edges[newposi], edges[newSetIX]);

      edges[newposi]->setStart(nodes[newSetIX]);

      // update setE
      setE.push_back(i);
      setE.push_back(newSetIX);

    }
    setE.resize(0);


    // Generate IDH
    int shortLen, longLen, diffLen;
    shortLen = nodes[0]->getSeqLen();
    longLen = shortLen;
    for(i = 1; i < numLeaves; i++){
      shortLen = MIN(shortLen, nodes[i]->getSeqLen());
      longLen = MAX(longLen, nodes[i]->getSeqLen());
    }
    diffLen = longLen - shortLen;
    root->setSeqLen((shortLen + (int)(rand.runif()*(diffLen + 1))));
   

    for(i = 0; i < root->getnumEdges(); i++)
      root->getEdge(i)->generateIDH(rand,params);


    root->set0LinkedSites();
    root->findLinkedSites();
    calculateLogLikelihood(params);

  }

  for(int i=0;i<numNodes;i++)
    nodes[i]->save();

  for(int i=0;i<numEdges;i++)
    edges[i]->save();

  seqDataS.resize(0);
  seqData.resize(0);


}
*/


//-- v30 v31 start --//
Tree::Tree(int n, Rand &rand, Parameters &params,vector<string> seqDataS) : numLeaves(n), numNodes(2*n-2), numEdges(2*n-3) {





  //-- v29 start --//
  numLetters = 4;
  //-- v29 end --//



  vector<vector<int> > seqData(0);
  int s, m, k;
  seqData.resize(seqDataS.size());
  for(s = 0; s < seqDataS.size(); s++){
    seqData[s].resize(0);
    for(m = 0; m < seqDataS[s].length(); m++){
      seqData[s].push_back(convChar(seqDataS[s][m]));
    }
  }



  int i, j, newposi;
  current = 0;

  outGroupNode = numLeaves - 1;


  UpdatedNodeinRootSites.resize(2);
  for(i=0;i<2;i++)
    UpdatedNodeinRootSites[i].resize(numNodes-1);


  nodes.resize(numNodes);
  edges.resize(numEdges);


  // Create leaves
  for(i=0;i<numLeaves;i++) {
    if(numLeaves>1)
      nodes[i] = new Node(i,seqData[i],true,false,0, 1, 4);
    else
      nodes[i] = new Node(i,seqData[i],true,true,-1, 3, 4);
  }


  // Create internal nodes
  for(i=numLeaves;i<(numNodes-1);i++) {
    nodes[i] = new Node(i,false,false, 0, 3, 4);
  }


  // Create edges without edge length
  for(i=0;i<numEdges;i++)
    edges[i] = new Edge(i);
  
  // Create root
  if(numNodes>3) {
    nodes[numNodes-1] = new Node(numNodes-1,false,true,-1, 3, 4);
  }

  
  root = nodes[numNodes-1];

  // Attach edges to all of the nodes (except for root)

  for(i=0;i<(numNodes-1);i++) {
    nodes[i]->setEdge(0,edges[i],0);
    edges[i]->setEnd(nodes[i],0);
  }


  //-------------------------------//
  //
  //   Get all pairwise alignments
  //
  //--------------------------------//

  AlignDPTable *pVT;
  vector<vector<vector<vector<int > > > > AllpairAligns(0);
  vector<vector<vector<int > > > AllpairHMG(0);
  vector<vector<int> > Aligns(0);
  double temp;
  int intTemp, inttmp;
  double iDelta, iEpsilon, iTau;
  double lambda, mu, rd, ri, gamma, MedgeLen;
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<char> > seqDataCh(0);
  vector<char> chars(0);
  int Tnum, Dnum;
  vector<vector<double> > dist(0);
  vector<int> distIX(0);
  vector<double> U(0);
  vector<int> smallIJ(0);
  double smallval;
  int distSize, newSetIX;
  //, virtualLen;
  int HMGsize;
  int cherryIX; 
  vector<double> tempDB(0);
  vector<int> tempInt1(0);
  vector<int> tempInt2(0);
  vector<int> tempInt3(0);
  vector<int> tempInt4(0);
  vector<int> LeavesList(0);
  vector<vector<vector<int> > > Aligns2(0);
  vector<int> virtualLeaves(0);
  vector<int> virtualParentEdgeNum(0);
  vector<int> virtualLeavesT(0);
  vector<int> virtualParentEdgeNumT(0);  
  vector<vector<int> > cherries(0);
  vector<vector<int> > cherriesE(0);
  

  
  chars.resize(4);
  chars[0] = 'A';
  chars[1] = 'C';
  chars[2] = 'G';
  chars[3] = 'T';     


  tempInt2.resize(4);
  tempInt2[0] = 0;
  tempInt2[1] = 0;
  tempInt2[2] = 0;
  tempInt2[3] = 0;

  


  
  //tempInt1[0] = 1;
  //tempInt1[1] = 1;
  //tempInt1[2] = 1;
  //tempInt1[3] = 1;


  
  seqDataCh.resize(numNodes);
  for(s = 0; s < numLeaves; s++){
    intTemp = seqData[s].size();
    seqDataCh[s].resize(intTemp);
    for(m = 0; m < intTemp; m++){
      inttmp = seqData[s][m];
      //for( i = 0; i < numLetters; i++){
      //	if(inttmp%2==1){
      //	  seqDataCh[s][m] = chars[i];
      //	}
      //	inttmp /= 2;
      //}
      tempInt1.resize(0);
      tempInt1 = tempInt2;
      j = 0;
      k = -1;
      for( i = 0; i < numLetters; i++){
      	if(inttmp%2==1){
      	  tempInt1[i] = 1;
	  j++;
	  k = i;
      	}
      	inttmp /= 2;
      }
      if(j==1){
	//  Heejung is working on 
	//seqDataCh[s][m] = chars[rand.rwunif(tempInt1)];
	seqDataCh[s][m] = chars[k];
      }else
	seqDataCh[s][m] = chars[rand.rwunif(tempInt1)];
      
      //cout << "inttmp : " << inttmp << endl;
      //print_veci(tempInt1);
      //cout << "seqDataCh[s][m] : " << seqDataCh[s][m] << endl;
 



      //if(inttmp == 1){
      //	seqDataCh[s][m] = chars[0];
      //}else if(inttmp == 2){
      //	seqDataCh[s][m] = chars[1];
      //}else if(inttmp == 4){
      //	seqDataCh[s][m] = chars[2];
      //}else if(inttmp == 8){
      //	seqDataCh[s][m] = chars[3];
      //}else{
      //	seqDataCh[s][m] = chars[rand.rwunif(tempInt1)];
      //}
    }
  }
  tempInt1.resize(0);
  tempInt2.resize(0);


  for(s = 0; s < numLeaves; s++){
    intTemp = seqDataCh[s].size();
    for(m = 0; m < intTemp; m++){
      cout << seqDataCh[s][m] << " ";
    }
    cout << endl;
  }
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();
  gamma = params.getGamma();
  MedgeLen = (double)1/gamma;
  pi = params.getPi(); 

  nodes[0]->CalPt(MedgeLen,params);

  Pt = nodes[0]->getPt();
  nodes[0]->Ptreset();

  iDelta = (1 - exp(-(lambda + mu)*MedgeLen))/(double)2;
  iEpsilon = 1 - (rd + ri)/(double)2;
  iTau = 0.3;



  AllpairAligns.resize(numLeaves - 1);
  //cout << "numLeaves - 1 " << numLeaves - 1 << endl;
  for(i = 0; i < (numLeaves - 1); i++){
    //cout << " i " << i << endl;
    AllpairAligns[i].resize(0);
    for(j = (i+1); j < numLeaves; j++){
      Aligns.resize(0);
      Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, seqDataCh[i], seqDataCh[j]);
      Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, seqDataCh[i], seqDataCh[j], Aligns);
      
      Aligns.pop_back();
      intTemp = Aligns.size();
      Tnum = 0;
      Dnum = 0;
      for(s =0; s < intTemp; s++){
	if(Aligns[s][0] == 1)
	  Aligns[s][0] = Tnum++;
        else
	  Aligns[s][0] = -1;

	if(Aligns[s][1] == 1)
	  Aligns[s][1] = Dnum++;
        else
	  Aligns[s][1] = -1; 
      }

       
      cout << "i : " << i << " j : " << j << endl;
      cout << "Aligns1" << endl;
      for(s =0; s < Aligns.size(); s++){
      	for(m = 0; m < Aligns[s].size(); m++)
      	  cout << Aligns[s][m] << " ";
      	cout << endl;
      }



      AllpairAligns[i].push_back(Aligns);
      delete pVT;
    }
  }


  // Make an AllpairHMG
  AllpairHMG.resize(numLeaves);
  for(i = 0; i < numLeaves; i++)
    AllpairHMG[i].resize(numLeaves);

  for(i = 0; i < (numLeaves-1); i++){

    for(j = (i+1); j < numLeaves; j++){

      tempInt1.resize(0); // from i
      tempInt2.resize(0); // from j
      Aligns.resize(0);
      //cout << "i : " << i << " j " << j << endl;
      Aligns = AllpairAligns[i][j - i - 1];
      inttmp = Aligns.size();
      //cout << "inttmp : " << inttmp << endl;
      for(m = 0; m < inttmp; m++){
	if(Aligns[m][0] != -1)
	  tempInt1.push_back(Aligns[m][1]);
	if(Aligns[m][1] != -1)
	  tempInt2.push_back(Aligns[m][0]);
      }

      //cout << "CC" << endl;
      AllpairHMG[i][j] = tempInt1;
      AllpairHMG[j][i] = tempInt2;
      tempInt1.resize(0);
      tempInt2.resize(0);
      //cout << "DD" << endl;

    }
  }



  cout << "print AllpairHMG" << endl;
  for(i = 0; i < numLeaves; i++){
    for(j = 0; j < numLeaves; j++){
      cout << "i : " << i << " j : " << j << endl;
      cout << "HMG" << endl;
      for(s =0; s < AllpairHMG[i][j].size(); s++)
	cout << AllpairHMG[i][j][s] << " ";
      cout << endl;
    }
  }


  //-------------------------------//
  //
  //   Get all pairwise distance
  //
  //--------------------------------//


  cout << "Get all pairwise distance " << endl;

  dist.resize(numLeaves);
  distIX.resize(numLeaves);
  for(i = 0; i < numLeaves; i++){
    distIX[i] = i;
    dist[i].resize(numLeaves);
    for(j = 0; j < i; j++)
      dist[i][j] = dist[j][i];
    dist[i][i] = 0;
    for(j = (i+1); j < numLeaves; j++){
      cout << "i : " << i << " j : " << j << endl;
      Tnum = 0;
      Dnum = 0;
      Aligns.resize(0);
      Aligns = AllpairAligns[i][j - i - 1];
      inttmp = Aligns.size();
      for(m = 0; m < inttmp; m++){
	if((Aligns[m][0] != -1) &  (Aligns[m][1] != -1)){
	  Tnum++;
	  if(seqData[i][Aligns[m][0]] != seqData[j][Aligns[m][1]])
	    Dnum++;
        }
      }
      cout << "Tnum : " << Tnum << " Dnum : " << Dnum << endl; 
      smallval = (double)Dnum/Tnum;
      if(smallval > (double)3/4){
	dist[i][j] = -(double)3/4*log(1-(double)4/3*(2.9/4));
      }else{
	dist[i][j] = -(double)3/4*log(1-(double)4/3*smallval);
      }
      Aligns.resize(0);
    }
  }

  cout << "dist" << endl;
  for(s =0; s < dist.size(); s++){
    for(m = 0; m < dist[s].size(); m++)
      cout << dist[s][m] << " ";
    cout << endl;
  }


  //-------------------------------//
  //
  //   Nearest Neighbor-joining
  //
  //--------------------------------//
  

  distSize = dist.size();
  newSetIX = numLeaves;
  //cout << "numNodes : " << numNodes << endl;
  while(distSize > 2){
  
    cout << "distSize : " << distSize << endl;
    cout << "newSetIX :" << newSetIX << endl;
    // 1. Compute ui
    U.resize(distSize);
    for(i = 0; i < distSize; i++){
      U[i] = 0;
      for(j = 0; j < distSize; j++)
	U[i] += dist[i][j];
      U[i] /= (distSize - 2);
    }
    

    cout << "U " << endl;
    print_vecd(U);

    // 2. Choose the i and j for which Dij - ui - uj is smallest.

    smallIJ.resize(2);
    smallIJ[0] = 0;
    smallIJ[1] = 1;
    smallval = dist[0][1] - U[0] - U[1];

    cout << "smallval " << smallval << endl;

    for(i = 0; i < distSize; i++){
      for(j = (i+1); j < distSize; j++){
	cout << "i : " << i << " j : " << j << endl;
	cout << "dist[i][j] - U[i] - U[j]" << dist[i][j] - U[i] - U[j] << endl;
	if(smallval > dist[i][j] - U[i] - U[j]){
	  cout << "change " << endl;
	  smallval = dist[i][j] - U[i] - U[j];
	  smallIJ[0] = i;
	  smallIJ[1] = j;
	}
      }
    }

    cout << "smallest i and j " << smallIJ[0] << " " << smallIJ[1] << endl;


    // 3. Join items i and j. Compute the branch length from i to the new node(vi) and from j to the new node(vj) as.....
    
    i = smallIJ[0];
    j = smallIJ[1];
    edges[distIX[i]]->setStart(nodes[newSetIX], 0);
    edges[distIX[i]]->setEdgeLen((dist[i][j] + U[i] - U[j])/(double)2);
    edges[distIX[j]]->setStart(nodes[newSetIX], 0);
    edges[distIX[j]]->setEdgeLen((dist[i][j] + U[j] - U[i])/(double)2);


    cout << "real edge number distIX[i] " << distIX[i] << " distIX[j] " << distIX[j] << endl;
    cout << "edges[distIX[i]]->getEdgeLen() " << edges[distIX[i]]->getEdgeLen() << " edges[distIX[j]]->getEdgeLen() " << edges[distIX[j]]->getEdgeLen() << endl;
    cout << "nodes[newSetIX]->getnumber() " << nodes[newSetIX]->getnumber() << endl;


    nodes[newSetIX]->setEdge(1, edges[distIX[i]]);
    nodes[newSetIX]->setEdge(2, edges[distIX[j]]);
    
    // 4 and 5
    // Compute the distance between the new node(ij) and each of the remaining tips. 
    // Delete tips i and j from the tables and replace them by the new node(ij), which is now treated as a tip.

    tempDB.resize(0);
    for(m = 0; m < distSize; m++){
      if((m!=i) & (m!=j))
	tempDB.push_back((dist[i][m] + dist[j][m] - dist[i][j])/(double)2);
    }

    dist.erase(dist.begin() + j);
    dist.erase(dist.begin() + i);


    
    for(m = 0; m < (distSize - 2); m++){
      dist[m].erase(dist[m].begin() + j);
      dist[m].erase(dist[m].begin() + i);
      dist[m].push_back(tempDB[m]);
    }

    distIX.erase(distIX.begin() + j);
    distIX.erase(distIX.begin() + i);  


    tempDB.push_back(0);
    dist.push_back(tempDB);
    tempDB.resize(0);
    distSize = distSize - 1;


   
    distIX.push_back(newSetIX++);
   
    cout << "print distIX " << endl;
    print_veci(distIX);

    cout << "dist" << endl;
    for(s =0; s < dist.size(); s++){
      for(m = 0; m < dist[s].size(); m++)
	cout << dist[s][m] << " ";
      cout << endl;
    }



  }

  // 6. If more than two nodes remain, go back to step1.
  //    Otherwise, connect the two remaining nodes (say l and m) by a branch of length Dlm.


  if(distIX[1] != root->getnumber())
    cout << "ERROR! The last node should be root!" << endl;
 
 
  edges[distIX[0]]->setStart(root, 0);
  edges[distIX[0]]->setEdgeLen(dist[0][1]);
  root->setEdge(0, edges[distIX[0]]);


  printTree();



  //-------------------------------//
  //
  //   Generat alignment (IDH) and letters in internal nodes.
  //
  //--------------------------------//


  // 1. Work on all cherries
  //    Order : cherry containing real leaves
  //          : cherry with short distance


  virtualLeaves.resize(0);
  virtualParentEdgeNum.resize(0);
  int pairIX, stIX;
  //bool leftoverLeaf = false;
  int leftNnum, rightNnum;
  bool done;
  Node* leftN;
  Node* rightN;
  Node* centerN;
  Edge* leftE;
  Edge* rightE;
  

  // At the begining, put real leaves
  tempInt1.resize(1);
  tempInt2.resize(1);
  for(i = 0; i < numLeaves; i++){
    virtualLeaves.push_back(i);
    virtualParentEdgeNum.push_back(i);
    nodes[i]->leavesBelowReset();
    tempInt1[0] = i;
    nodes[i]->setleavesBelow(tempInt1); // Will be used later!
    nodes[i]->relatedLeavesReset();
    nodes[i]->relatedPosiReset();
    inttmp = nodes[i]->getSeqLen();
    for(j = 0; j < inttmp; j++){
      nodes[i]->RelatedLeaves_push_back(tempInt1);
      tempInt2[0] = j;
      nodes[i]->RelatedPosi_push_back(tempInt2);
    }
  }
  tempInt1.resize(0);
  tempInt2.resize(0);

  // Construct cherries
  
  smallIJ.resize(2);

  while(virtualLeaves.size() > 3){

    // From a given virtualLeves
    //virtualLen = virtualLeaves.size();
    virtualLeavesT.resize(0);
    virtualParentEdgeNumT.resize(0);
    cherries.resize(0);
    cherriesE.resize(0);
    tempDB.resize(0);
    stIX = 0;
    

    //while(virtualLen > 1){
    while(stIX < virtualLeaves.size()){

      cout << "In while and begining " << endl;
      cout << "virtualLeaves " << endl;
      print_veci(virtualLeaves);
      cout << "virtualParentEdgeNum " << endl;
      print_veci(virtualParentEdgeNum);
      



      // Finding cherry
      i = virtualLeaves[stIX];
      cout << "stIX : " << stIX << " i : " << i << endl;
      pairIX = getCloseNodeNumberInGivenSet(i, virtualLeaves, virtualParentEdgeNum[stIX]); 
      cout << "pairIX : " << pairIX << endl;
      if(pairIX < 0){
	stIX++;
	//break;
      }else{
	j = virtualLeaves[pairIX];
	smallIJ[0] = i;
	smallIJ[1] = j;
	cherries.push_back(smallIJ);
	smallIJ[0] = virtualParentEdgeNum[stIX];
	smallIJ[1] = virtualParentEdgeNum[pairIX];
	cherriesE.push_back(smallIJ);

	leftN = nodes[i];
	leftE = edges[virtualParentEdgeNum[stIX]];
	rightN = nodes[j];
	rightE = edges[virtualParentEdgeNum[pairIX]];

	tempDB.push_back(leftE->getEdgeLen() + rightE->getEdgeLen());

	intTemp = rightE->getOtherNode(rightN)->getnumber();
	virtualLeavesT.push_back(intTemp);
	centerN = nodes[intTemp];


	inttmp = centerN->getnumEdges();
	for(m=0; m < inttmp; m++){
	  k = centerN->getEdge(m)->getnumber();
	  if((k != virtualParentEdgeNum[stIX]) & (k != virtualParentEdgeNum[pairIX])){
	    virtualParentEdgeNumT.push_back(k);
	    break;
          }
        }


	if(virtualParentEdgeNumT.size()!=virtualLeavesT.size())
	  cout << "ERROR in Tree::Tree! Size should be same!" << endl;

	if(pairIX > stIX){
	  virtualLeaves.erase(virtualLeaves.begin() + pairIX);
	  virtualLeaves.erase(virtualLeaves.begin() + stIX);
	  virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + pairIX);
	  virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + stIX);
        }else{
	  virtualLeaves.erase(virtualLeaves.begin() + stIX);
	  virtualLeaves.erase(virtualLeaves.begin() + pairIX);
	  virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + stIX);
	  virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + pairIX);
        }
	//virtualLen -= 2;


      }


      cout << "In while and ending " << endl;
      cout << "virtualLeavesT " << endl;
      print_veci(virtualLeavesT);
      cout << "virtualParentEdgeNumT " << endl;
      print_veci(virtualParentEdgeNumT);
      cout << "cherries" << endl;
      for(m = 0; m < cherries.size(); m++)
	cout << cherries[m][0] << " " << cherries[m][1] << endl;
      cout << "cherriesE" << endl;
      for(m = 0; m < cherriesE.size(); m++)
	cout << cherriesE[m][0] << " " << cherriesE[m][1] << endl;

  
    }  // End of while(virtualLen > 1)  


    // Work on alignment and determine letters

    // pick the one with 

    cout << "tempDB " << endl;
    print_vecd(tempDB);


    //if(leftoverLeaf)
    //  cherryIX = 0;
    //else
    cherryIX = which_min_vec(tempDB);


    //cout << "leftoverLeaf " << leftoverLeaf << endl;
    cout << "cherryIX " << cherryIX << endl;
    //cout << "virtualLen " << virtualLen << endl;

    done = false;

    //if(virtualLen == 1)
    //  leftoverLeaf = true;
    //else
    //  leftoverLeaf = false;

      // order : by edge length
    while(!done){

      leftN = nodes[cherries[cherryIX][0]];
      leftE = edges[cherriesE[cherryIX][0]];
      rightN = nodes[cherries[cherryIX][1]];
      rightE = edges[cherriesE[cherryIX][1]];
      centerN = nodes[virtualLeavesT[cherryIX]];
      centerN->relatedLeavesReset();
      
      leftNnum = cherries[cherryIX][0];
      rightNnum = cherries[cherryIX][1];

      cout << "leftNnum " << leftNnum << endl;
      cout << "rightNnum " << rightNnum << endl;
      
      
      //if(rightNnum <= leftNnum)
      //	cout << "ERROR! It shouldn't be like that!" << endl;


      centerN->relatedLeavesReset();
      centerN->relatedPosiReset();
      
      
      centerN->leavesBelowReset();
      tempInt1.resize(0);
      tempInt1 = leftN->getleavesBelow();
      tempInt2.resize(0);
      tempInt2 = rightN->getleavesBelow();
      inttmp = tempInt2.size();
      for(i = 0; i < inttmp; i++)
	tempInt1.push_back(tempInt2[i]);
      centerN->setleavesBelow(tempInt1);
      tempInt2.resize(0);


      cout << "centerN setLeavesBelow" << endl;
      print_veci(tempInt1);

      
      for(i = 0; i < numLeaves; i++)
	tempInt2.push_back(0);
      
      inttmp = tempInt1.size();
      for(i = 0; i < inttmp; i++)
	tempInt2[tempInt1[i]] = 1;
      tempInt1.resize(0);
      
      LeavesList.resize(0);
      for(i = 0; i < numLeaves; i++){
	if(tempInt2[i] == 0)
	  LeavesList.push_back(i);
      }
      
      cout << "LeavesList" << endl;
      print_veci(LeavesList);

      
      stIX = centerN->getnumber();
      seqDataCh[stIX].resize(0);
      
      cout << "stIX " << stIX << endl;


      Aligns.resize(0);
      if((leftNnum < numLeaves) & (rightNnum < numLeaves))
	Aligns = AllpairAligns[leftNnum][rightNnum - leftNnum -1];
      else{
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, seqDataCh[leftNnum], seqDataCh[rightNnum]);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, seqDataCh[leftNnum], seqDataCh[rightNnum], Aligns);
	Aligns.pop_back();
	intTemp = Aligns.size();
	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;
	  
	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}       
	delete pVT;
      }



      cout << "Aligns" << endl;
      for(s =0; s < Aligns.size(); s++){
      	for(m = 0; m < Aligns[s].size(); m++)
      	  cout << Aligns[s][m] << " ";
      	cout << endl;
      }



      Aligns2.resize(2);
      smallIJ.resize(2);
      Aligns2[0].resize(0);
      Aligns2[1].resize(0);
      
      HMGsize = Aligns.size();
      for(i = 0; i < HMGsize; i++){

	cout << "***** " << i << " ******" << endl;

	
	if((Aligns[i][0] > -1) & (Aligns[i][1] > -1)){
	  
	  cout << "Aligns[i][0] : " << Aligns[i][0] << " Aligns[i][1] : " << Aligns[i][1] << endl;


	  // * - ? - *
	  
	  // determine alignment
	  smallIJ[0] = 1;
	  smallIJ[1] = 1;
	  Aligns2[0].push_back(smallIJ);
	  Aligns2[1].push_back(smallIJ);
	  
	  // determine letters
	  
	  tempInt1.resize(0); // Leaves number related to this site
	  tempInt1 = leftN->getRelatedLeaves(Aligns[i][0]);
	  tempInt2.resize(0); // Leaves number related to this site
	  tempInt2 = leftN->getRelatedPosi(Aligns[i][0]);
	  tempInt3.resize(0);
	  tempInt3 = rightN->getRelatedLeaves(Aligns[i][1]);
	  tempInt4.resize(0);
	  tempInt4 = rightN->getRelatedPosi(Aligns[i][1]);
	  
	  inttmp = tempInt3.size();
	  for(j = 0; j < inttmp; j++){
	    tempInt1.push_back(tempInt3[j]);
	    tempInt2.push_back(tempInt4[j]);
	  }


	  cout << "Leaves number related to this site" << endl;
	  print_veci(tempInt1);
	  cout << "position related to this site" << endl;
	  print_veci(tempInt2);

	  
	  tempInt3.resize(0);
	  tempInt4.resize(0);
	  
	  // search for leaves and positions aligned to this position
	  inttmp = LeavesList.size();
	  pairIX = tempInt1.size();
	  
	  for(j = 0; j < inttmp; j++){
	    Tnum = 0;  // number of position aligned to position in tempInt2 
	    for(k = 0; k < pairIX; k++){
	      if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != -1){
		if(Tnum == 0){
		  smallIJ[0] = LeavesList[j];
		  smallIJ[1] = AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]];
		  Tnum = 1;
		}else if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != smallIJ[1]){
		  Tnum = 2;
		  break;
		}
	      }
	    }		
	    
	    if(Tnum == 1){
	      tempInt3.push_back(smallIJ[0]); // Leaves number related to nodes in tempInt1
	      tempInt4.push_back(smallIJ[1]); // Posi number related to nodes in tempInt2
	    }
	    
	  }
	  

	  cout << "Leaves (other) number related to this site" << endl;
	  print_veci(tempInt3);
	  cout << "position (other) related to this site" << endl;
	  print_veci(tempInt4);
 


	  // determine letters
	  distIX.resize(0);
	  for(j = 0; j < numLetters; j++)
	    distIX.push_back(0);
	  
	  // count number of letters
	  intTemp = tempInt1.size();
	  for(j = 0; j < intTemp; j++){
	    inttmp = seqData[tempInt1[j]][tempInt2[j]];
	    for( k = 0; k < numLetters; k++){
	      if(inttmp%2==1)
		distIX[k]++;
	      inttmp /= 2;
	    }
	  }
	  
	  intTemp = tempInt3.size();
	  for(j = 0; j < intTemp; j++){
	    inttmp = seqData[tempInt3[j]][tempInt4[j]];
	    for( k = 0; k < numLetters; k++){
	      if(inttmp%2==1)
		distIX[k]++;
	      inttmp /= 2;
	    }
	  }
	  
	  tempInt3.resize(0);
	  which_max_vec(distIX, tempInt3);

	  cout << "distIX " << endl;
	  print_veci(distIX);
	  cout << "max char " << endl;
	  print_veci(tempInt3);

	  if(tempInt3.size() == 1){
	    cout << "only one " << endl;
	    cout << "tempInt3[0] " << tempInt3[0] << endl;
	    cout << "chars[tempInt3[0]] " << chars[tempInt3[0]] << endl;
	    cout << "stIX " << stIX << endl;
	    seqDataCh[stIX].push_back(chars[tempInt3[0]]);
	  }else{
	    cout << "more than one " << endl;
	    distIX.resize(0);
	    for(j = 0; j < tempInt3.size(); j++)
	      distIX.push_back(1);
	    seqDataCh[stIX].push_back(chars[tempInt3[rand.rwunif(distIX)]]);
	    cout << seqDataCh[stIX][seqDataCh[stIX].size()-1] << endl;
	  }
	  cout << "AA " << endl;
	  
	  centerN->RelatedLeaves_push_back(tempInt1);
	  centerN->RelatedPosi_push_back(tempInt2);
	  
	  tempInt1.resize(0);
	  tempInt2.resize(0);
	  tempInt3.resize(0);
	  tempInt4.resize(0);

	  cout << "BB" << endl;
	  
	}else if((Aligns[i][0] > -1) & (Aligns[i][1] == -1)){ 
	  // Else of if((Aligns[i][0] > -1) & (Aligns[i][1] > -1)){
	  
	  // * - ? - -1

	  cout << "Aligns[i][0] : " << Aligns[i][0] << " Aligns[i][1] : " << Aligns[i][1] << endl;
	  
	  
	  // search for leaves and positions aligned to this position
	  
	  tempInt1.resize(0); // Leaves number related to this site
	  tempInt1 = leftN->getRelatedLeaves(Aligns[i][0]);
	  tempInt2.resize(0); // Leaves number related to this site
	  tempInt2 = leftN->getRelatedPosi(Aligns[i][0]);
	  

	  cout << "Leaves number related to this site" << endl;
	  print_veci(tempInt1);
	  cout << "position related to this site" << endl;
	  print_veci(tempInt2);


	  tempInt3.resize(0);
	  tempInt4.resize(0);
	  
	  inttmp = LeavesList.size();
	  pairIX = tempInt1.size();
	  
	  for(j = 0; j < inttmp; j++){
	    Tnum = 0;  // number of position aligned to position in tempInt2 
	    for(k = 0; k < pairIX; k++){
	      if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != -1){
		if(Tnum == 0){
		  smallIJ[0] = LeavesList[j];
		  smallIJ[1] = AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]];
		  Tnum = 1;
		}else if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != smallIJ[1]){
		  Tnum = 2;
		  break;
		}
	      }
	    }		
	    
	    if(Tnum == 1){
	      tempInt3.push_back(smallIJ[0]); // Leaves number related to nodes in tempInt1
	      tempInt4.push_back(smallIJ[1]); // Posi number related to nodes in tempInt2
	    }
	    
	  }
	  
	  cout << "Leaves (other) number related to this site" << endl;
	  print_veci(tempInt3);
	  cout << "position (other) related to this site" << endl;
	  print_veci(tempInt4);
 	    
	  // determine alignment
	  
	  if(tempInt3.size() == 0){  // nothing is aligned to this position
	    
	    cout << "nothing is aligned!" << endl;

	    // asign gap
	    smallIJ[0] = 1;
	    smallIJ[1] = 0;
	    Aligns2[0].push_back(smallIJ);
	    smallIJ[0] = 0;
	    smallIJ[1] = 0;
	    Aligns2[1].push_back(smallIJ);
	    
	    // we don't need letter
	    
	  }else{                      // something is aligned to this position
	    

	    cout << "something is aligned" << endl;

	    // determine alignment
	    smallIJ[0] = 1;
	    smallIJ[1] = 1;
	    Aligns2[0].push_back(smallIJ);
	    smallIJ[0] = 1;
	    smallIJ[1] = 0;
	    Aligns2[1].push_back(smallIJ);	
	    
	    // determine letters
	    distIX.resize(0);
	    for(j = 0; j < numLetters; j++)
	      distIX.push_back(0);
	    
	    // count number of letters
	    intTemp = tempInt1.size();
	    for(j = 0; j < intTemp; j++){
	      inttmp = seqData[tempInt1[j]][tempInt2[j]];
	      for( k = 0; k < numLetters; k++){
		if(inttmp%2==1)
		  distIX[k]++;
		inttmp /= 2;
	      }
	    }
	    
	    intTemp = tempInt3.size();
	    for(j = 0; j < intTemp; j++){
	      inttmp = seqData[tempInt3[j]][tempInt4[j]];
	      for( k = 0; k < numLetters; k++){
		if(inttmp%2==1)
		  distIX[k]++;
		inttmp /= 2;
	      }
	    }
	    
	    tempInt3.resize(0);
	    which_max_vec(distIX, tempInt3);

	    cout << "distIX " << endl;
	    print_veci(distIX);
	    cout << "max char " << endl;
	    print_veci(tempInt3);



	    if(tempInt3.size() == 1)
	      seqDataCh[stIX].push_back(chars[tempInt3[0]]);
	    else{
	      distIX.resize(0);
	      for(j = 0; j < tempInt3.size(); j++)
		distIX.push_back(1);
	      seqDataCh[stIX].push_back(chars[tempInt3[rand.rwunif(distIX)]]);
	    }
	  }
	    
	  centerN->RelatedLeaves_push_back(tempInt1);
	  centerN->RelatedPosi_push_back(tempInt2);
	  
	  tempInt1.resize(0);
	  tempInt2.resize(0);
	  tempInt3.resize(0);
	  tempInt4.resize(0);
	  
	  
	}else if((Aligns[i][0] == -1) & (Aligns[i][1] >  -1)){ 
	  // Else of if((Aligns[i][0] > -1) & (Aligns[i][1] == -1)){

	  cout << "Aligns[i][0] : " << Aligns[i][0] << " Aligns[i][1] : " << Aligns[i][1] << endl;

	  
	  // -1 - ? - *
	  
	  // search for leaves and positions aligned to this position
	  tempInt1.resize(0); // Leaves number related to this site
	  tempInt1 = rightN->getRelatedLeaves(Aligns[i][1]);
	  tempInt2.resize(0); // Leaves number related to this site
	  tempInt2 = rightN->getRelatedPosi(Aligns[i][1]);

	  cout << "Leaves number related to this site" << endl;
	  print_veci(tempInt1);
	  cout << "position related to this site" << endl;
	  print_veci(tempInt2);
	  
	  tempInt3.resize(0);
	  tempInt4.resize(0);
	  
	  inttmp = LeavesList.size();
	  pairIX = tempInt1.size();
	  
	  for(j = 0; j < inttmp; j++){
	    Tnum = 0;  // number of position aligned to position in tempInt2 
	    for(k = 0; k < pairIX; k++){
	      if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != -1){
		if(Tnum == 0){
		  smallIJ[0] = LeavesList[j];
		  smallIJ[1] = AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]];
		  Tnum = 1;
		}else if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != smallIJ[1]){
		  Tnum = 2;
		  break;
		}
	      }
	    }		
	    
	    if(Tnum == 1){
	      tempInt3.push_back(smallIJ[0]); // Leaves number related to nodes in tempInt1
	      tempInt4.push_back(smallIJ[1]); // Posi number related to nodes in tempInt2
	    }
	    
	  }
	  
	  cout << "Leaves (other) number related to this site" << endl;
	  print_veci(tempInt3);
	  cout << "position (other) related to this site" << endl;
	  print_veci(tempInt4);
 	  


	  // determine alignment
	  
	  if(tempInt3.size() == 0){  // nothing is aligned to this position
	    
	    cout << "nothing is aligned" << endl;

	    // asign gap
	    smallIJ[0] = 0;
	    smallIJ[1] = 0;
	    Aligns2[0].push_back(smallIJ);
	    smallIJ[0] = 0;
	    smallIJ[1] = 1;
	    Aligns2[1].push_back(smallIJ);
	    
	    // we don't need letter
	    
	  }else{                      // something is aligned to this position

	    cout << "something is aligned" << endl;
	    
	    // determine alignment
	    smallIJ[0] = 0;
	    smallIJ[1] = 1;
	    Aligns2[0].push_back(smallIJ);
	    smallIJ[0] = 1;
	    smallIJ[1] = 1;
	    Aligns2[1].push_back(smallIJ);	
	    
	    // determine letters
	    distIX.resize(0);
	    for(j = 0; j < numLetters; j++)
	      distIX.push_back(0);
	    
	    // count number of letters
	    intTemp = tempInt1.size();
	    for(j = 0; j < intTemp; j++){
	      inttmp = seqData[tempInt1[j]][tempInt2[j]];
	      for( k = 0; k < numLetters; k++){
		if(inttmp%2==1)
		  distIX[k]++;
		inttmp /= 2;
	      }
	    }
	    
	    intTemp = tempInt3.size();
	    for(j = 0; j < intTemp; j++){
	      inttmp = seqData[tempInt3[j]][tempInt4[j]];
	      for( k = 0; k < numLetters; k++){
		if(inttmp%2==1)
		  distIX[k]++;
		inttmp /= 2;
	      }
	    }
	    
	    tempInt3.resize(0);
	    which_max_vec(distIX, tempInt3);

	    cout << "distIX " << endl;
	    print_veci(distIX);
	    cout << "max char " << endl;
	    print_veci(tempInt3);
	    

	    if(tempInt3.size() == 1)
	      seqDataCh[stIX].push_back(chars[tempInt3[0]]);
	    else{
	      distIX.resize(0);
	      for(j = 0; j < tempInt3.size(); j++)
		distIX.push_back(1);
	      seqDataCh[stIX].push_back(chars[tempInt3[rand.rwunif(distIX)]]);
	    }
	  }
	  
	  centerN->RelatedLeaves_push_back(tempInt1);
	  centerN->RelatedPosi_push_back(tempInt2);
	  
	  tempInt1.resize(0);
	  tempInt2.resize(0);
	  tempInt3.resize(0);
	  tempInt4.resize(0);
	  
	}else{ // Else of if (Aligns[i][0] == -1) & (Aligns[i][1] >  -1)){ 
	  //(Aligns[i][0] == -1) & (Aligns[i][1] == -1))
	  cout << "ERROR (Aligns[i][0] == -1) & (Aligns[i][1] == -1) never happen! " << endl;
	}
	
      }  // End of for(i = 0; i < intTemp; i++)
      

      cout << "setSeqLen" << endl;
      cout << "stIX " << stIX << endl;
      centerN->setSeqLen(seqDataCh[stIX].size());
      cout << "centerN->getnumber() : " << centerN->getnumber() << endl;
      cout << "centerN->getSeqLen() : " << centerN->getSeqLen() << endl;

      cout << "done! " << endl;
      cout << "seqDataCh[stIX] " << stIX << endl;
      for(i = 0; i < seqDataCh[stIX].size(); i++)
	cout << seqDataCh[stIX][i] << " "; 
      cout << endl;

      cout << "Aligns2[0]" << endl;
      for(s =0; s < Aligns2[0].size(); s++){
      	for(k = 0; k < Aligns2[0][s].size(); k++)
      	  cout << Aligns2[0][s][k] << " ";
      	cout << endl;
      }

      cout << "Aligns2[1]" << endl;
      for(s =0; s < Aligns2[1].size(); s++){
      	for(k = 0; k < Aligns2[1][s].size(); k++)
      	  cout << Aligns2[1][s][k] << " ";
      	cout << endl;
      }



      //---------------------------------
      // 
      // Generate IDH 
      //
      //---------------------------------

      generateNewIDHfromPairwiseAlignmentWOprobCal(Aligns2[0], leftE->getEdgeLen(), leftE->getIDH(), rand, params);
      generateNewIDHfromPairwiseAlignmentWOprobCal(Aligns2[1], rightE->getEdgeLen(), rightE->getIDH(), rand, params);

      if(leftE->getEnd()->getnumber() == leftN->getnumber())
	leftE->getIDH()->ReverseIDH();
      if(rightE->getStart()->getnumber() == rightN->getnumber())
	rightE->getIDH()->ReverseIDH();

      leftE->calHMG();
      rightE->calHMG();


      cout << "leftE->getnumber() : " << leftE->getnumber() << endl;
      leftE->printEdge();
      cout << "rightE->getnumber() : " << rightE->getnumber() << endl;
      rightE->printEdge();



      cout << "cherryIX " << cherryIX << endl;
      tempDB.erase(tempDB.begin() + cherryIX);
      cherries.erase(cherries.begin() + cherryIX);
      cherriesE.erase(cherriesE.begin() + cherryIX);
      virtualLeaves.push_back(virtualLeavesT[cherryIX]);
      virtualLeavesT.erase(virtualLeavesT.begin() + cherryIX);
      virtualParentEdgeNum.push_back(virtualParentEdgeNumT[cherryIX]);
      virtualParentEdgeNumT.erase(virtualParentEdgeNumT.begin() + cherryIX);


      cout << "After removing " << endl;
      cout << "virtualLeaves " << endl;
      print_veci(virtualLeaves);
      cout << "virtualParentEdgeNum " << endl;
      print_veci(virtualParentEdgeNum);
      cout << "virtualLeavesT " << endl;
      print_veci(virtualLeavesT);
      cout << "virtualParentEdgeNumT " << endl;
      print_veci(virtualParentEdgeNumT);
      cout << "cherries" << endl;
      for(m = 0; m < cherries.size(); m++)
	cout << cherries[m][0] << " " << cherries[m][1] << endl;
      cout << "cherriesE" << endl;
      for(m = 0; m < cherriesE.size(); m++)
	cout << cherriesE[m][0] << " " << cherriesE[m][1] << endl;
      cout << "tempDB" << endl;
      print_vecd(tempDB);



      if(tempDB.size() == 0)
	done = true;
      else
	cherryIX = which_min_vec(tempDB);
      
    }  // End of while(!done){
    
  } // End of while(virtualLeaves.size() > 3)



  // Now we have three or two virtualLeaves
  if(virtualLeaves.size() == 3){


    cout << "We have three leaves" << endl;

    /*
    if(leftoverLeaf){

      cout << "leftoverLeaf" << endl;

      if(edges[virtualParentEdgeNum[0]]->getEdgeLen() + edges[virtualParentEdgeNum[1]]->getEdgeLen() > edges[virtualParentEdgeNum[2]]->getEdgeLen() + edges[virtualParentEdgeNum[0]]->getEdgeLen()){

	leftN = nodes[virtualLeaves[0]];
	leftE = edges[virtualParentEdgeNum[0]];
	rightN = nodes[virtualLeaves[2]];
	rightE = edges[virtualParentEdgeNum[2]];
	centerN = nodes[rightE->getOtherNode(rightN)->getnumber()];
      
	virtualLeaves.erase(virtualLeaves.begin() + 2);
	virtualLeaves.erase(virtualLeaves.begin() + 0);
	virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 2);
	virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 0);

	virtualLeaves.push_back(centerN->getnumber());

      }else{    
	
	leftN = nodes[virtualLeaves[0]];
	leftE = edges[virtualParentEdgeNum[0]];
	rightN = nodes[virtualLeaves[1]];
	rightE = edges[virtualParentEdgeNum[1]];
	centerN = nodes[rightE->getOtherNode(rightN)->getnumber()];
      
	virtualLeaves.erase(virtualLeaves.begin() + 1);
	virtualLeaves.erase(virtualLeaves.begin() + 0);
	virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 1);
	virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 0);

	virtualLeaves.push_back(centerN->getnumber());

      }
  
    }else{  // there is no leftoverleaf

    */


    // find one combination with shortest sum of edge lengths
    tempDB.resize(3);
    tempDB[0] = edges[virtualParentEdgeNum[0]]->getEdgeLen() + edges[virtualParentEdgeNum[1]]->getEdgeLen();
    tempDB[1] = edges[virtualParentEdgeNum[1]]->getEdgeLen() + edges[virtualParentEdgeNum[2]]->getEdgeLen();
    tempDB[2] = edges[virtualParentEdgeNum[2]]->getEdgeLen() + edges[virtualParentEdgeNum[0]]->getEdgeLen();
    
    inttmp = which_min_vec(tempDB);
    
    if(inttmp == 0){
      
      leftN = nodes[virtualLeaves[0]];
      leftE = edges[virtualParentEdgeNum[0]];
      rightN = nodes[virtualLeaves[1]];
      rightE = edges[virtualParentEdgeNum[1]];
      centerN = nodes[rightE->getOtherNode(rightN)->getnumber()];
      
      virtualLeaves.erase(virtualLeaves.begin() + 1);
      virtualLeaves.erase(virtualLeaves.begin() + 0);
      virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 1);
      virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 0);
      
      virtualLeaves.push_back(centerN->getnumber());
      
    }else if(inttmp == 1){
      
      leftN = nodes[virtualLeaves[1]];
      leftE = edges[virtualParentEdgeNum[1]];
      rightN = nodes[virtualLeaves[2]];
      rightE = edges[virtualParentEdgeNum[2]];
      centerN = nodes[rightE->getOtherNode(rightN)->getnumber()];
      
      virtualLeaves.erase(virtualLeaves.begin() + 2);
      virtualLeaves.erase(virtualLeaves.begin() + 1);
      virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 2);
      virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 1);
      
      virtualLeaves.push_back(centerN->getnumber());
      
    }else{
      
      leftN = nodes[virtualLeaves[0]];
      leftE = edges[virtualParentEdgeNum[0]];
      rightN = nodes[virtualLeaves[2]];
      rightE = edges[virtualParentEdgeNum[2]];
      centerN = nodes[rightE->getOtherNode(rightN)->getnumber()];
      
      virtualLeaves.erase(virtualLeaves.begin() + 2);
      virtualLeaves.erase(virtualLeaves.begin() + 0);
      virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 2);
      virtualParentEdgeNum.erase(virtualParentEdgeNum.begin() + 0);
      
      virtualLeaves.push_back(centerN->getnumber());
      
    }
    


    cout << "virtualLeaves " << endl;
    print_veci(virtualLeaves);
    cout << "virtualParentEdgeNum " << endl;
    print_veci(virtualParentEdgeNum);
    
    
    leftNnum = leftN->getnumber();
    rightNnum = rightN->getnumber();


 
    cout << "leftNnum " << leftNnum << endl;
    cout << "rightNnum " << rightNnum << endl;
    cout << "leftE->getnumber() : " << leftE->getnumber() << endl;
    cout << "rightE->getnumber() : " << rightE->getnumber() << endl;
    cout << "centerN->getnumber() : " << centerN->getnumber() << endl;


    centerN->leavesBelowReset();
    tempInt1.resize(0);
    tempInt1 = leftN->getleavesBelow();
    tempInt2.resize(0);
    tempInt2 = rightN->getleavesBelow();
    inttmp = tempInt2.size();
    for(i = 0; i < inttmp; i++)
      tempInt1.push_back(tempInt2[i]);
    centerN->setleavesBelow(tempInt1);
    tempInt2.resize(0);
    
    cout << "centerN setLeavesBelow" << endl;
    print_veci(tempInt1);


    for(i = 0; i < numLeaves; i++)
      tempInt2.push_back(0);
    
    inttmp = tempInt1.size();
    for(i = 0; i < inttmp; i++)
      tempInt2[tempInt1[i]] = 1;
    tempInt1.resize(0);
      
    LeavesList.resize(0);
    for(i = 0; i < numLeaves; i++){
      if(tempInt2[i] == 0)
	LeavesList.push_back(i);
    }
    
    cout << "LeavesList" << endl;
    print_veci(LeavesList);


       
    stIX = centerN->getnumber();
    seqDataCh[stIX].resize(0);
    
    
    cout << "stIX " << stIX << endl;

    Aligns.resize(0);
    if((leftNnum < numLeaves) & (rightNnum < numLeaves))
      Aligns = AllpairAligns[leftNnum][rightNnum - leftNnum -1];
    else{
      Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, seqDataCh[leftNnum], seqDataCh[rightNnum]);
      Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, seqDataCh[leftNnum], seqDataCh[rightNnum], Aligns);
      Aligns.pop_back();
      intTemp = Aligns.size();
      Tnum = 0;
      Dnum = 0;
      for(s =0; s < intTemp; s++){
	if(Aligns[s][0] == 1)
	  Aligns[s][0] = Tnum++;
	else
	  Aligns[s][0] = -1;
	
	if(Aligns[s][1] == 1)
	  Aligns[s][1] = Dnum++;
	else
	  Aligns[s][1] = -1; 
      }       
      delete pVT;
    }
    

    cout << "Aligns" << endl;
    for(s =0; s < Aligns.size(); s++){
      for(m = 0; m < Aligns[s].size(); m++)
	cout << Aligns[s][m] << " ";
      cout << endl;
    }

    
    Aligns2.resize(2);
    smallIJ.resize(2);
    Aligns2[0].resize(0);
    Aligns2[1].resize(0);
    
    HMGsize = Aligns.size();
    for(i = 0; i < HMGsize; i++){
      

      cout << "***** " << i << " ******" << endl;

      if((Aligns[i][0] > -1) & (Aligns[i][1] > -1)){
	

	cout << "Aligns[i][0] : " << Aligns[i][0] << " Aligns[i][1] : " << Aligns[i][1] << endl;
	
	// * - ? - *
	
	// determine alignment
	smallIJ[0] = 1;
	smallIJ[1] = 1;
	Aligns2[0].push_back(smallIJ);
	Aligns2[1].push_back(smallIJ);
	
	// determine letters
	
	tempInt1.resize(0); // Leaves number related to this site
	tempInt1 = leftN->getRelatedLeaves(Aligns[i][0]);
	tempInt2.resize(0); // Leaves number related to this site
	tempInt2 = leftN->getRelatedPosi(Aligns[i][0]);
	tempInt3.resize(0);
	tempInt3 = rightN->getRelatedLeaves(Aligns[i][1]);
	tempInt4.resize(0);
	tempInt4 = rightN->getRelatedPosi(Aligns[i][1]);
	
	inttmp = tempInt3.size();
	for(j = 0; j < inttmp; j++){
	  tempInt1.push_back(tempInt3[j]);
	  tempInt2.push_back(tempInt4[j]);
	}

	cout << "Leaves number related to this site" << endl;
	print_veci(tempInt1);
	cout << "position related to this site" << endl;
	print_veci(tempInt2);
	

	
	tempInt3.resize(0);
	tempInt4.resize(0);
	
	// search for leaves and positions aligned to this position
	inttmp = LeavesList.size();
	pairIX = tempInt1.size();
	
	for(j = 0; j < inttmp; j++){
	  Tnum = 0;  // number of position aligned to position in tempInt2 
	  for(k = 0; k < pairIX; k++){
	    if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != -1){
	      if(Tnum == 0){
		smallIJ[0] = LeavesList[j];
		smallIJ[1] = AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]];
		Tnum = 1;
	      }else if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != smallIJ[1]){
		Tnum = 2;
		break;
	      }
	    }
	  }		
	  
	  if(Tnum == 1){
	    tempInt3.push_back(smallIJ[0]); // Leaves number related to nodes in tempInt1
	    tempInt4.push_back(smallIJ[1]); // Posi number related to nodes in tempInt2
	  }
	  
	}


	cout << "Leaves (other) number related to this site" << endl;
	print_veci(tempInt3);
	cout << "position (other) related to this site" << endl;
	print_veci(tempInt4);
	

	
	// determine letters
	distIX.resize(0);
	for(j = 0; j < numLetters; j++)
	  distIX.push_back(0);
	
	// count number of letters
	intTemp = tempInt1.size();
	for(j = 0; j < intTemp; j++){
	  inttmp = seqData[tempInt1[j]][tempInt2[j]];
	  for( k = 0; k < numLetters; k++){
	    if(inttmp%2==1)
	      distIX[k]++;
	    inttmp /= 2;
	  }
	}
	
	intTemp = tempInt3.size();
	for(j = 0; j < intTemp; j++){
	  inttmp = seqData[tempInt3[j]][tempInt4[j]];
	  for( k = 0; k < numLetters; k++){
	    if(inttmp%2==1)
	      distIX[k]++;
	    inttmp /= 2;
	  }
	}
	
	tempInt3.resize(0);
	which_max_vec(distIX, tempInt3);


	cout << "distIX " << endl;
	print_veci(distIX);
	cout << "max char " << endl;
	print_veci(tempInt3);
	
	if(tempInt3.size() == 1)
	  seqDataCh[stIX].push_back(chars[tempInt3[0]]);
	else{
	  distIX.resize(0);
	  for(j = 0; j < tempInt3.size(); j++)
	    distIX.push_back(1);
	  seqDataCh[stIX].push_back(chars[tempInt3[rand.rwunif(distIX)]]);
	}
	
	centerN->RelatedLeaves_push_back(tempInt1);
	centerN->RelatedPosi_push_back(tempInt2);
	
	tempInt1.resize(0);
	tempInt2.resize(0);
	tempInt3.resize(0);
	tempInt4.resize(0);
	
      }else if((Aligns[i][0] > -1) & (Aligns[i][1] == -1)){ 
	// Else of if((Aligns[i][0] > -1) & (Aligns[i][1] > -1)){
	
	// * - ? - -1
	
	// search for leaves and positions aligned to this position

	cout << "Aligns[i][0] : " << Aligns[i][0] << " Aligns[i][1] : " << Aligns[i][1] << endl;

	
	tempInt1.resize(0); // Leaves number related to this site
	tempInt1 = leftN->getRelatedLeaves(Aligns[i][0]);
	tempInt2.resize(0); // Leaves number related to this site
	tempInt2 = leftN->getRelatedPosi(Aligns[i][0]);
	

	cout << "Leaves number related to this site" << endl;
	print_veci(tempInt1);
	cout << "position related to this site" << endl;
	print_veci(tempInt2);

	tempInt3.resize(0);
	tempInt4.resize(0);
	
	inttmp = LeavesList.size();
	pairIX = tempInt1.size();
	
	for(j = 0; j < inttmp; j++){
	  Tnum = 0;  // number of position aligned to position in tempInt2 
	  for(k = 0; k < pairIX; k++){
	    if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != -1){
	      if(Tnum == 0){
		smallIJ[0] = LeavesList[j];
		smallIJ[1] = AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]];
		Tnum = 1;
	      }else if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != smallIJ[1]){
		Tnum = 2;
		break;
	      }
	    }
	  }		
	  
	  if(Tnum == 1){
	    tempInt3.push_back(smallIJ[0]); // Leaves number related to nodes in tempInt1
	    tempInt4.push_back(smallIJ[1]); // Posi number related to nodes in tempInt2
	  }
	  
	}
	
	
	cout << "Leaves (other) number related to this site" << endl;
	print_veci(tempInt3);
	cout << "position (other) related to this site" << endl;
	print_veci(tempInt4);	
	

	// determine alignment
	
	if(tempInt3.size() == 0){  // nothing is aligned to this position
	  
	
	  cout << "nothing is aligned!" << endl;
	  

	  // asign gap
	  smallIJ[0] = 1;
	  smallIJ[1] = 0;
	  Aligns2[0].push_back(smallIJ);
	  smallIJ[0] = 0;
	  smallIJ[1] = 0;
	  Aligns2[1].push_back(smallIJ);
	  
	  // we don't need letter
	  
	}else{                      // something is aligned to this position


	  cout << "something is aligned" << endl;
	  
	  // determine alignment
	  smallIJ[0] = 1;
	  smallIJ[1] = 1;
	  Aligns2[0].push_back(smallIJ);
	  smallIJ[0] = 1;
	  smallIJ[1] = 0;
	  Aligns2[1].push_back(smallIJ);	
	  
	  // determine letters
	  distIX.resize(0);
	  for(j = 0; j < numLetters; j++)
	    distIX.push_back(0);
	  
	  // count number of letters
	  intTemp = tempInt1.size();
	  for(j = 0; j < intTemp; j++){
	    inttmp = seqData[tempInt1[j]][tempInt2[j]];
	    for( k = 0; k < numLetters; k++){
	      if(inttmp%2==1)
		distIX[k]++;
	      inttmp /= 2;
	    }
	  }
	  
	  intTemp = tempInt3.size();
	  for(j = 0; j < intTemp; j++){
	    inttmp = seqData[tempInt3[j]][tempInt4[j]];
	    for( k = 0; k < numLetters; k++){
	      if(inttmp%2==1)
		distIX[k]++;
	      inttmp /= 2;
	    }
	  }
	  
	  tempInt3.resize(0);
	  which_max_vec(distIX, tempInt3);

	  cout << "distIX " << endl;
	  print_veci(distIX);
	  cout << "max char " << endl;
	  print_veci(tempInt3);
	  


	  if(tempInt3.size() == 1)
	    seqDataCh[stIX].push_back(chars[tempInt3[0]]);
	  else{
	    distIX.resize(0);
	    for(j = 0; j < tempInt3.size(); j++)
	      distIX.push_back(1);
	    seqDataCh[stIX].push_back(chars[tempInt3[rand.rwunif(distIX)]]);
	  }
	}
	
	centerN->RelatedLeaves_push_back(tempInt1);
	centerN->RelatedPosi_push_back(tempInt2);
	
	tempInt1.resize(0);
	tempInt2.resize(0);
	tempInt3.resize(0);
	tempInt4.resize(0);
	
	
      }else if((Aligns[i][0] == -1) & (Aligns[i][1] >  -1)){ 
	// Else of if((Aligns[i][0] > -1) & (Aligns[i][1] == -1)){
	
	cout << "Aligns[i][0] : " << Aligns[i][0] << " Aligns[i][1] : " << Aligns[i][1] << endl;


	// -1 - ? - *
	
	// search for leaves and positions aligned to this position
	tempInt1.resize(0); // Leaves number related to this site
	tempInt1 = rightN->getRelatedLeaves(Aligns[i][1]);
	tempInt2.resize(0); // Leaves number related to this site
	tempInt2 = rightN->getRelatedPosi(Aligns[i][1]);


	cout << "Leaves number related to this site" << endl;
	print_veci(tempInt1);
	cout << "position related to this site" << endl;
	print_veci(tempInt2);
	
	tempInt3.resize(0);
	tempInt4.resize(0);
	
	inttmp = LeavesList.size();
	pairIX = tempInt1.size();
	
	for(j = 0; j < inttmp; j++){
	  Tnum = 0;  // number of position aligned to position in tempInt2 
	  for(k = 0; k < pairIX; k++){
	    if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != -1){
	      if(Tnum == 0){
		smallIJ[0] = LeavesList[j];
		smallIJ[1] = AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]];
		Tnum = 1;
	      }else if(AllpairHMG[tempInt1[k]][LeavesList[j]][tempInt2[k]] != smallIJ[1]){
		Tnum = 2;
		break;
	      }
	    }
	  }		
	  
	  if(Tnum == 1){
	    tempInt3.push_back(smallIJ[0]); // Leaves number related to nodes in tempInt1
	    tempInt4.push_back(smallIJ[1]); // Posi number related to nodes in tempInt2
	  }
	  
	}
	
	cout << "Leaves (other) number related to this site" << endl;
	print_veci(tempInt3);
	cout << "position (other) related to this site" << endl;
	print_veci(tempInt4);
 	  	
	

	// determine alignment
	
	if(tempInt3.size() == 0){  // nothing is aligned to this position
	
	  cout << "nothing is aligned" << endl;
  
	  // asign gap
	  smallIJ[0] = 0;
	  smallIJ[1] = 0;
	  Aligns2[0].push_back(smallIJ);
	  smallIJ[0] = 0;
	  smallIJ[1] = 1;
	  Aligns2[1].push_back(smallIJ);
	    
	  // we don't need letter
	  
	}else{                      // something is aligned to this position
	  

	  cout << "something is aligned" << endl;

	  // determine alignment
	  smallIJ[0] = 0;
	  smallIJ[1] = 1;
	  Aligns2[0].push_back(smallIJ);
	  smallIJ[0] = 1;
	  smallIJ[1] = 1;
	  Aligns2[1].push_back(smallIJ);	
	  
	  // determine letters
	  distIX.resize(0);
	  for(j = 0; j < numLetters; j++)
	    distIX.push_back(0);
	  
	  // count number of letters
	  intTemp = tempInt1.size();
	  for(j = 0; j < intTemp; j++){
	    inttmp = seqData[tempInt1[j]][tempInt2[j]];
	    for( k = 0; k < numLetters; k++){
	      if(inttmp%2==1)
		distIX[k]++;
		inttmp /= 2;
	    }
	  }
	  
	  intTemp = tempInt3.size();
	  for(j = 0; j < intTemp; j++){
	    inttmp = seqData[tempInt3[j]][tempInt4[j]];
	    for( k = 0; k < numLetters; k++){
	      if(inttmp%2==1)
		distIX[k]++;
	      inttmp /= 2;
	    }
	  }
	  
	  tempInt3.resize(0);
	  which_max_vec(distIX, tempInt3);

	  cout << "distIX " << endl;
	  print_veci(distIX);
	  cout << "max char " << endl;
	  print_veci(tempInt3);
	  

	  if(tempInt3.size() == 1)
	    seqDataCh[stIX].push_back(chars[tempInt3[0]]);
	  else{
	    distIX.resize(0);
	    for(j = 0; j < tempInt3.size(); j++)
	      distIX.push_back(1);
	    seqDataCh[stIX].push_back(chars[tempInt3[rand.rwunif(distIX)]]);
	  }
	}
	
	centerN->RelatedLeaves_push_back(tempInt1);
	centerN->RelatedPosi_push_back(tempInt2);
	
	tempInt1.resize(0);
	tempInt2.resize(0);
	tempInt3.resize(0);
	tempInt4.resize(0);
	
      }else{ // Else of if (Aligns[i][0] == -1) & (Aligns[i][1] >  -1)){ 
	//(Aligns[i][0] == -1) & (Aligns[i][1] == -1))
	cout << "ERROR (Aligns[i][0] == -1) & (Aligns[i][1] == -1) never happen! " << endl;
      }
      
    }   // End of for(i = 0; i < intTemp; i++)


    centerN->setSeqLen(seqDataCh[stIX].size());
    
    cout << "done! " << endl;
    cout << "seqDataCh[stIX] " << stIX << endl;
    for(i = 0; i < seqDataCh[stIX].size(); i++)
      cout << seqDataCh[stIX][i] << " "; 
    cout << endl;
    
    cout << "Aligns2[0]" << endl;
    for(s =0; s < Aligns2[0].size(); s++){
      for(k = 0; k < Aligns2[0][s].size(); k++)
	cout << Aligns2[0][s][k] << " ";
      cout << endl;
    }
    
    cout << "Aligns2[1]" << endl;
    for(s =0; s < Aligns2[1].size(); s++){
      for(k = 0; k < Aligns2[1][s].size(); k++)
	cout << Aligns2[1][s][k] << " ";
      cout << endl;
    }
    


    //---------------------------------
    // 
    // Generate IDH 
    //
    //---------------------------------
    
    generateNewIDHfromPairwiseAlignmentWOprobCal(Aligns2[0], leftE->getEdgeLen(), leftE->getIDH(), rand, params);
    generateNewIDHfromPairwiseAlignmentWOprobCal(Aligns2[1], rightE->getEdgeLen(), rightE->getIDH(), rand, params);
    
    if(leftE->getEnd()->getnumber() == leftN->getnumber())
      leftE->getIDH()->ReverseIDH();
    if(rightE->getStart()->getnumber() == rightN->getnumber())
      rightE->getIDH()->ReverseIDH();
    
    
    leftE->calHMG();
    rightE->calHMG();

    cout << "leftE->getnumber() : " << leftE->getnumber() << endl;
    leftE->printEdge();
    cout << "rightE->getnumber() : " << rightE->getnumber() << endl;
    rightE->printEdge();
    



  } // End of if(virtualLeaves.size() == 3){



  cout << "Now we have two leaves!" << endl;

  // Now we have two virtualLeaves

  leftN = nodes[virtualLeaves[0]];
  leftE = edges[virtualParentEdgeNum[0]];
  rightN = nodes[virtualLeaves[1]];
  

  leftNnum = leftN->getnumber();
  rightNnum = rightN->getnumber();


  cout << "leftNnum " << leftNnum << endl;
  cout << "rightNnum " << rightNnum << endl;
  cout << "leftE->getnumber() : " << leftE->getnumber() << endl;


  Aligns.resize(0);
  if((leftNnum < numLeaves) & (rightNnum < numLeaves))
    cout << "ERROR! They should be internal nodes! " << endl;
  else{
    Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, seqDataCh[leftNnum], seqDataCh[rightNnum]);
    Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, seqDataCh[leftNnum], seqDataCh[rightNnum], Aligns);
    Aligns.pop_back();
    delete pVT;
  }


  //---------------------------------
  // 
  // Generate IDH 
  //
  //---------------------------------
  
  generateNewIDHfromPairwiseAlignmentWOprobCal(Aligns, leftE->getEdgeLen(), leftE->getIDH(), rand, params);
   


  if(leftE->getEnd()->getnumber() == leftN->getnumber())
    leftE->getIDH()->ReverseIDH();


  leftE->calHMG();
  

  cout << "leftE->getnumber() : " << leftE->getnumber() << endl;
  leftE->printEdge();


  // done!!!!!!!!!!!


  AllpairAligns.resize(0);
  AllpairHMG.resize(0);
  Aligns.resize(0);
  Pt.resize(0);
  pi.resize(0);
  seqDataCh.resize(0);
  chars.resize(0);
  dist.resize(0);
  distIX.resize(0);
  U.resize(0);
  smallIJ.resize(0);
  tempDB.resize(0);
  tempInt1.resize(0);
  tempInt2.resize(0);
  tempInt3.resize(0);
  tempInt4.resize(0);
  LeavesList.resize(0);
  Aligns2.resize(0);
  virtualLeaves.resize(0);
  virtualParentEdgeNum.resize(0);
  virtualLeavesT.resize(0);
  virtualParentEdgeNumT.resize(0);  
  cherries.resize(0);
  cherriesE.resize(0);

  for(i = 0; i < numNodes; i++){
    nodes[i]->relatedLeavesReset();
    nodes[i]->relatedPosiReset();
    nodes[i]->leavesBelowReset();
  }


  root->set0LinkedSites();
  root->findLinkedSites();
  calculateLogLikelihood(params);

 

  for(int i=0;i<numNodes;i++)
    nodes[i]->save();

  for(int i=0;i<numEdges;i++)
    edges[i]->save();

  seqDataS.resize(0);
  seqData.resize(0);


  cout << "done!!!!!!!!!!!" << endl;

}
//-- v30 v31 end --//


void Tree::printTree(int c){


  cout << endl << endl;
  cout << "####################################" << endl;
  cout << "#####       print Tree     #########" << endl;
  cout << "####################################" << endl;  
  
  cout << endl << endl << "print out all Nodes" << endl << endl;
  for(int i=0; i < numNodes; i++)
    nodes[i]->printNode(c);
  
  cout << endl << endl <<"print out all Edges" << endl << endl;
  for(int i=0; i < numEdges; i++)
    edges[i]->printEdge(c);

}



void Tree::printTree(ofstream& c){


  c << endl << endl;
  c << "####################################" << endl;
  c << "#####       print Tree     #########" << endl;
  c << "####################################" << endl;  
  
  c << endl << endl << "print out all Nodes" << endl << endl;
  for(int i=0; i < numNodes; i++)
    nodes[i]->printNode(c);
  
  c << endl << endl <<"print out all Edges" << endl << endl;
  for(int i=0; i < numEdges; i++)
    edges[i]->printEdge(c);

}




void Tree::printTree(){


  cout << endl << endl;
  cout << "####################################" << endl;
  cout << "#####       print Tree     #########" << endl;
  cout << "####################################" << endl;  
  
  cout << endl << endl << "print out all Nodes" << endl << endl;
  for(int i=0; i < numNodes; i++)
    nodes[i]->printNode();
  
  cout << endl << endl <<"print out all Edges" << endl << endl;
  for(int i=0; i < numEdges; i++)
    edges[i]->printEdge();

}


bool InDelHistory::checkCorrectIDH(){

  bool er = true;
  if(nume > 0){
    for(int i = 1; i <= nume ; i++){
      if(v[i] > v[i+1]){
	cout << "ERROR! V of " << i+1 << " is less than V of " << i << endl;
	er = false;
      }
    }  
  }
  return er; 
}


void Tree::checkTree(){
 

  //cout << "checkTree " << endl;

  Node* stNode;
  Node* enNode;
  InDelHistory* IDH;

  int i;

  for(i=0; i < numEdges; i++){
    IDH = edges[i]->getIDH();
    stNode = edges[i]->getStart();
    enNode = edges[i]->getEnd();
    if(stNode->getSeqLen()!= IDH->getN(0)){
      cout << "ERROR! Start node of Edge is different from N of first entry of IDH " << endl;
      cout << "edge number : " << i  << " Start node number : " << stNode->getnumber() << endl;
    }
    if(enNode->getSeqLen()!= IDH->getN(IDH->getNumE()+1)){
      cout << "ERROR! End node of Edge is different from N of the last entry of IDH " << endl;
      cout << "edge number : " << i  << " End node number : " << enNode->getnumber() << endl;
      edges[i]->printEdge(0);
      cout << "enNode->getSeqLen() : " << enNode->getSeqLen() << endl;
    }
    
    if(!equal(edges[i]->getEdgeLen(), IDH->getV(IDH->getNumE()+1))){
      cout << "ERROR! Edge length and last V of IDH are different. " << endl;
      cout << "edge number : " << i  << " Edge length : " << edges[i]->getEdgeLen() << " last V : " << IDH->getV(IDH->getNumE()+1) << endl;
    }
    if(!IDH->checkCorrectIDH()){
      cout << "ERROR in IDH! " << endl;
      edges[i]->printEdge();
    } 
  }

  /*** NNI start ***/
  for(i=0; i < numNodes; i++){
    if(!nodes[i]->checkNode()){
      cout << "ERROR in Node! " << endl;
      nodes[i]->printNode(current);
    }
  }
  /*** NNI end ***/

}

/*** NNI start ***/
bool Node::checkNode(){
  
  bool res = true;


  
  if(getRoot()){
    if((seqLen[current] != LinkedSites[current].size()) | (seqLen[current] != logLikelihood[current].size()))
      res = false;
  }else{
    if((seqLen[current] != rootSites[current].size()) | (seqLen[current] != logLikelihood[current].size()))
      res = false;
  }

  return res;
} 
/*** NNI end ***/	




void Tree::resetSubtreeprob(){
  for(int i = 0; i < numNodes ; i++){
    if(!nodes[i]->getRoot())
      nodes[i]->resetSubtreeprob();
  }
}

void Tree::resetSubtreeprob(int c){
  for(int i = 0; i < numNodes ; i++){
    if(!nodes[i]->getRoot())
      nodes[i]->resetSubtreeprob(c);
  }
}





double Tree::calPriorParas(const Parameters &params){

  double res = 0;

  // r
  double r = params.getR();
  double r_alpha = params.getR_alpha();
  double r_beta = params.getR_beta();  
  
  res += lgamma(r_alpha + r_beta) - lgamma(r_alpha) - lgamma(r_beta) + (r_alpha -1)*log(r) + (r_beta -1)*log(1-r);

  // rd
  double rd = params.getRd();
  double rd_epsilon = params.getRd_epsilon();  
  res += log(rd_epsilon) + rd_epsilon  -  rd_epsilon/rd - 2*log(rd);
  
  // Lambda
  double lambda = params.getLambda();
  double lambda_epsilon = params.getLambda_epsilon();
  res += log(lambda_epsilon) - 2*log(1+lambda_epsilon*lambda);

  // Kappa
  double kappa = params.getKappa();
  double kappa_epsilon = params.getKappa_epsilon();
  res += log(kappa_epsilon) - 2*log(1+kappa_epsilon*kappa); 

  // Gamma
  double gamma = params.getGamma();
  double gamma_epsilon = params.getGamma_epsilon();
  res += log(gamma_epsilon) - 2*log(1+gamma_epsilon*gamma);   

  // Pi
  vector<double> pi(0);
  vector<double> pi_alpha(0);

  pi = params.getPi();
  pi_alpha = params.getPi_alpha();
  res += lgamma(sum_vec(pi_alpha));
  for(int i = 0; i < 4; i++)
    res += (pi_alpha[i]-1)*log(pi[i]) - lgamma(pi_alpha[i]);
   



  return res;

}



void Tree::UpdateAllinfoToRoot(const Parameters &params, Node* Cnode){ 
  
  
  //cout << "In UpdateAllinfoToRoot !" << endl;

  if(Cnode->getRoot()){

    //cout << "AAA " << endl;
    Cnode->CalloglikeliofLinkedSites(params);
    
  }else{

    //cout << "BBB " << endl;
    Cnode->CalloglikeliofRootSites(params);
    Cnode->CalSubTreeProb(params);
    UpdatedNodeinRootSites[current][Cnode->getnumber()] = 1;
	  
    UpdateAllinfoToRoot(params, Cnode->getParent());

  }
	
}




void Tree::UpdateAllinfoToRootWithChangedHMG(const Parameters &params, Node* tempNode){ 
  

  
  
  Node* Cnode = tempNode->getParent();
  int edgeTnum = Cnode->getEdgeNum(tempNode->getParentEdge());

  //cout << "In UpdateAllinfoToRoot !" << endl;

  if(Cnode->getRoot()){

    //cout << "AAA " << endl;
    Cnode->CalloglikeliofLinkedSitesWithChangedG(params, edgeTnum);
    
  }else{

    //cout << "BBB " << endl;
    Cnode->CalloglikeliofRootSitesWithChangedG(params, edgeTnum);
    Cnode->CalSubTreeProbForSitesWithChangedG(params, edgeTnum);
    UpdatedNodeinRootSites[current][Cnode->getnumber()] = 1;
	  
    UpdateAllinfoToRootWithChangedHMG(params, Cnode);

  }
	
}








void Tree::UpdateAllinfoTogivenNode(const Parameters &params, Node* Cnode, Node* Tnode){ 
  
  
  if(Cnode != Tnode){

    Cnode->CalloglikeliofRootSites(params);
    Cnode->CalSubTreeProb(params);
    UpdatedNodeinRootSites[current][Cnode->getnumber()] = 1;
	  
    UpdateAllinfoTogivenNode(params, Cnode->getParent(), Tnode);

  }
	
}



double Tree::EdgeSum(){

  double result = 0;
  for(int i=0;i<numEdges;i++)
      result += edges[i]->getEdgeLen();

  return result;

}


double Tree::likeliHistory(const Parameters &params){

  double result = 0;
  double r = params.getR();
  result = log(r) + root->getSeqLen()*log(1-r);
  for(int i=0;i<numEdges;i++)
      result += edges[i]->likeliHistory(params);

  logLikeliIDH[current] = result;
  return result;

}


double Tree::CalculatelogLikeliEdges(const Parameters &params){

  double result = 0;
  for(int i=0;i<numEdges;i++)
      result += edges[i]->CalculatelogLikeliEdge(params);

  logLikeliEdges[current] = result;
  return result;

}




double Tree::likeliData(){


  //cout << "In Tree::likeliData() " << endl;

  double result = 0;
  int i, j;

  
  for(i = 0; i < root->getLinkedSitesSize(); i++){
    if(root->getLinkedSites(i)==1){
      result += root->getlogLikelihood(i);
      //cout << "i : " << i <<  " getlogLikelihood(i) : " << root->getlogLikelihood(i) << endl;
    }
  }

  //cout << " result " << result << endl; 


  for(i = 0; i < (numNodes-1); i++){
    for(j = 0; j < nodes[i]->getrootSitesSize(); j++){
      if(nodes[i]->getrootSites(j)==1)
	result += nodes[i]->getlogLikelihood(j);
    }
  }

  //cout << " result " << result << endl;


  logLikeliData[current] = result;

  return result;

}





void Tree::calculateLogLikelihood(const Parameters &params) {

  double result = 0;

  cout << "In calculateLogLikelihood 1" << endl;


  logLikeliIDH[current] = likeliHistory(params);

  cout << "logLikeliIDH[current] : " <<  logLikeliIDH[current]  << endl;


  cout << "In calculateLogLikelihood 2" << endl;

  logLikeliEdges[current] = CalculatelogLikeliEdges(params);

  cout << "logLikeliEdges[current] : " << logLikeliEdges[current] << endl;

  cout << "In calculateLogLikelihood 3" << endl;

  root->likeliDataR_v2(params);

  cout << "In calculateLogLikelihood 4" << endl;
  logLikeliData[current] = likeliData();

  cout << "In calculateLogLikelihood 5" << endl;

  /*
  cout << endl;
  cout << "likeliHistory(params) " << tmp1 << endl;
  cout << " likeliData(params) " << tmp2 << endl;   
  */

  //logLikelihood[current] = logLikeliIDH[current] + logLikeliData[current];

}


/*
// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTree(Rand &rand,const Parameters &params, int numZnode, int Edgenum) {

  cout << "In SPRonSingleEdgeAsPartOfSPRonSubTree " << endl;

  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  //cout << "nodeZ->getRoot() " << nodeZ->getRoot() << endl;

  // Select an adjacent edge e3 at random.
  Edge* edge3 = nodeZ->getEdge(Edgenum);

  //cout << "Edgenum " << Edgenum << endl;
  //cout << "edge3->getnumber() " << edge3->getnumber() << endl;

  O_IDHlike = edge3->likeliHistory(params);

  //cout << "O_IDHlike " << O_IDHlike << endl;

  O_psl= edge3->ProposHistory(params);

  //cout << "O_psl " << O_psl << endl;
  
  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge3->getOtherNode(nodeZ);

  //cout << "nodeC->getnumber() " << nodeC->getnumber() << endl;

  Edge* edges12[2];
  // The other two adjacent edges e1 and e2 connect Z to nodes A and B, respectively. 
  j = 0;
  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(Edgenum!=i){
      edges12[j] = nodeZ->getEdge(i);
      j++;
    }
  }

  cout << "edges12[0]->getnumber() " << edges12[0]->getnumber()  << endl;
  cout << "edges12[1]->getnumber() " << edges12[1]->getnumber()  << endl;

  Node* nodeA = edges12[0]->getOtherNode(nodeZ);
  Node* nodeB = edges12[1]->getOtherNode(nodeZ);
      
  cout << "nodeA->getnumber() " << nodeA->getnumber() << endl;
  cout << "nodeB->getnumber() " << nodeB->getnumber() << endl;

  // Pick a random location on the path from A to B and move Z to this new location.
  double X1andX2 = edges12[0]->getEdgeLen() + edges12[1]->getEdgeLen();
  // New edge length
  double newX1 = rand.runif()*(X1andX2);
  double newX2 = X1andX2 - newX1;
  double diffLen;
  int newN0, tmpNumE;

  cout << "X1andX2 " << X1andX2 << endl;
  cout << "newX1 " << newX1 << endl;
  cout << "newX2 " << newX2 << endl;

  InDelHistory* IDH1;
  InDelHistory* IDH2;

 vector<int> HMGin(0);

  HMGin.resize(0);

  IDH1 = edges12[0]->getIDH();
  IDH2 = edges12[1]->getIDH();


  //cout << "start " << endl;


  if((nodeZ->getRoot()) || (nodeZ->getparentIndex() == Edgenum)){  // Z is Root or Root is in a subtree which edge3 connects to Z.

    //cout << "case1234 " << endl;
    if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge1


      diffLen = edges12[0]->getEdgeLen() - newX1;
      // case 1 or case 1a
      if(IDH1->getV(1) > diffLen){  // All events will remain
 in the new edge1, but edge length should be changed.
	

	cout << "case1 " << endl;
	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) - diffLen, i);
 	edges12[0]->setEdgeLen(newX1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) + diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);


	// case 1a
	if(nodeZ->getRoot()){


	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);

	// case 1  

	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	   
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }
	
        }
	
	
      }else{


	cout << "case2 " << endl;
      // case 2 or case 2a
	i = 1;
	while(IDH1->getV(i) <= diffLen){
	  i++;
	}
	i--;


	newN0 = IDH1->getN(i);

	IDH1->eraseHistory(1, 0);
	IDH2->eraseHistory(1, 0);


	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){

	  j = i - m + 1;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(m-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->insertHistory(0, m, diffLen - IDH1->getV(j), -1, IDH1->getP(j), IDH1->getL(j), (IDH2->getN(m-1) - IDH1->getL(j)) , HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(m-1);
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->insertHistory(0, m, diffLen - IDH1->getV(j), 1, IDH1->getP(j), IDH1->getL(j), (IDH2->getN(m-1) + IDH1->getL(j)), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, j);

	} 

	for(j = 1; j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();



	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 2a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);

	// case 2  

	}else{               


	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    


	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	  

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }
	
        }	
      }

    }else{  // else if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge2

      diffLen = edges12[1]->getEdgeLen() - newX2;

      // case 3 or case 3a
      if(IDH2->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.

	cout << "case3 " << endl;
	
	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) - diffLen, i);
  	edges12[1]->setEdgeLen(newX2);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) + diffLen, i);
	edges12[0]->setEdgeLen(newX1);

	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 3a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);

	// case 3  

	}else{               


	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    
	  

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }
	
        }
		
      }else{


	cout << "case4 " << endl;

      // case 4
	i = 1;
	while(IDH2->getV(i) <= diffLen){
	  i++;
	}
	i--;

	cout << "i " << i << endl;

	newN0 = IDH2->getN(i);

	cout << "newN0 " << newN0 << endl;

	IDH2->eraseHistory(1, 0);
	IDH1->eraseHistory(1, 0);

      
	//cout << "AAAAA "  << endl; 

    
    //cout << endl << "#### FROM IDH1 ####" << endl;
    //cout << "numE " << IDH1->getNumE() << endl;
    //for(j =0; j< IDH1->getIDHsize(); j++){ 
    //  cout << "ID " << IDH1->getID(j) << endl;
    //  cout << "L " << IDH1->getL(j) << endl;
    //  cout << "P " << IDH1->getP(j) << endl;
    //  cout << "V " << IDH1->getV(j) << endl;
    //  cout << "N " << IDH1->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
 
    //cout << endl << "#### FROM IDH2 ####" << endl;
    //cout << "numE " << IDH2->getNumE() << endl;
    //for(j =0; j< IDH2->getIDHsize(); j++){  
    //  cout << "ID " << IDH2->getID(j) << endl;
    //  cout << "L " << IDH2->getL(j) << endl;
    //  cout << "P " << IDH2->getP(j) << endl;
    //  cout << "V " << IDH2->getV(j) << endl;
    //  cout << "N " << IDH2->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH2->getHMG(j).size(); m++){
//	cout << IDH2->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
      

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	


    
    //cout << "BBBBB "  << endl; 

    //cout << endl << "#### FROM IDH1 ####" << endl;
    //cout << "numE " << IDH1->getNumE() << endl;
    //for(j =0; j< IDH1->getIDHsize(); j++){ 
    //  cout << "ID " << IDH1->getID(j) << endl;
    //  cout << "L " << IDH1->getL(j) << endl;
    //  cout << "P " << IDH1->getP(j) << endl;
    //  cout << "V " << IDH1->getV(j) << endl;
    //  cout << "N " << IDH1->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
  //    }   
   //   cout << endl;
   // }
 
   // cout << endl << "#### FROM IDH2 ####" << endl;
   // cout << "numE " << IDH2->getNumE() << endl;
   // for(j =0; j< IDH2->getIDHsize(); j++){  
   //   cout << "ID " << IDH2->getID(j) << endl;
   //   cout << "L " << IDH2->getL(j) << endl;
    //  cout << "P " << IDH2->getP(j) << endl;
   //   cout << "V " << IDH2->getV(j) << endl;
   //   cout << "N " << IDH2->getN(j) << endl;
   //   cout << endl << "HMG "  << endl;
   //   for(m=0; m < IDH2->getHMG(j).size(); m++){
//	cout << IDH2->getHMG(j,m) << " ";
  //    }   
   //   cout << endl;
   // }
      
      

        tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){

	  j = i - m + 1;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(m-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->insertHistory(0, m, diffLen - IDH2->getV(j), -1, IDH2->getP(j), IDH2->getL(j), (IDH1->getN(m-1) - IDH2->getL(j)), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(m-1);
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->insertHistory(0, m, diffLen - IDH2->getV(j), 1, IDH2->getP(j), IDH2->getL(j), (IDH1->getN(m-1) + IDH2->getL(j)), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, j);

	} 

	for(j = 1; j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);



    
    //cout << "CCCCCCC "  << endl; 

    //cout << endl << "#### FROM IDH1 ####" << endl;
    //cout << "numE " << IDH1->getNumE() << endl;
    //for(j =0; j< IDH1->getIDHsize(); j++){ 
    //  cout << "ID " << IDH1->getID(j) << endl;
    //  cout << "L " << IDH1->getL(j) << endl;
    //  cout << "P " << IDH1->getP(j) << endl;
    //  cout << "V " << IDH1->getV(j) << endl;
    //  cout << "N " << IDH1->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
 
    //cout << endl << "#### FROM IDH2 ####" << endl;
    //cout << "numE " << IDH2->getNumE() << endl;
    //for(j =0; j< IDH2->getIDHsize(); j++){  
    //  cout << "ID " << IDH2->getID(j) << endl;
    //  cout << "L " << IDH2->getL(j) << endl;
    //  cout << "P " << IDH2->getP(j) << endl;
    //  cout << "V " << IDH2->getV(j) << endl;
    //  cout << "N " << IDH2->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH2->getHMG(j).size(); m++){
//	cout << IDH2->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
      
     



	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();



	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 4a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);

	// case 4  

	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	  

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }
	
        }

      }

    }

  }else if(nodeZ->getParentEdge()->getnumber() == edges12[0]->getnumber()){  // Root is in a subtree which edge1 connects to A.

    //cout << "case5678 " << endl;

    if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge1


      
      diffLen = edges12[0]->getEdgeLen() - newX1;
      // case 5
      if(edges12[0]->getEdgeLen() - IDH1->getV(IDH1->getNumE()) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.


	cout << "case5 " << endl;
 	edges12[0]->setEdgeLen(newX1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) + diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 5

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeA);
	
      }else{


	cout << "case6 " << endl;
      // case 6
	i = IDH1->getNumE();
	while(edges12[0]->getEdgeLen() - IDH1->getV(i) <= diffLen){
	  i--;
	}
	i++;


	newN0 = IDH1->getN(i-1);

	IDH2->eraseHistory(1, 0);


	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = IDH1->getNumE() - i + 1;

	for(m = 1; m <= tmpNumE; m++){

	  j = i;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(m-1);
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->insertHistory(0, m, diffLen - (edges12[0]->getEdgeLen() - IDH1->getV(j)), 1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(m-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->insertHistory(0, m, diffLen - (edges12[0]->getEdgeLen() - IDH1->getV(j)), -1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, i);
	}

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(j = (tmpNumE+1); j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();



	edge3->runEdge(rand,params);	
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 6

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);
	nodeB->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeA->getRoot()){
	  
	  nodeA->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeA->CalloglikeliofRootSites(params);
	  nodeA->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeA->getParent());
	    
	}

      }

    }else{  // else if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge2


      diffLen = edges12[1]->getEdgeLen() - newX2;
      // case 7
      if(IDH2->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.


	cout << "case7 " << endl;
 	edges12[0]->setEdgeLen(newX1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) - diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 7

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeA);
		

	
      }else{


	cout << "case8 " << endl;
      // case 8
	i = 1;
	while(IDH2->getV(i) <= diffLen){
	  i++;
	}
	i--;


	newN0 = IDH2->getN(i);

	IDH2->eraseHistory(1, 0);
	IDH1->eraseHistory(1);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){
	  j = 1;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(IDH1->getNumE());
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->addHistory(0, edges12[0]->getEdgeLen() + IDH2->getV(j), 1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(IDH1->getNumE());
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->addHistory(0, edges12[0]->getEdgeLen() + IDH2->getV(j), -1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, 1);
	}

	IDH1->addHistory(1, newX1, -2, 0, 0, IDH1->getN(IDH1->getNumE()), IDH1->getHMG(IDH1->getNumE()));


	for(j = 1; j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();



	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 8

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);
	nodeB->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeA->getRoot()){
	  
	  nodeA->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeA->CalloglikeliofRootSites(params);
	  nodeA->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeA->getParent());
	    
	}
	
      }

    }



  }else{  // Root is in a subtree which edge2 connects to B.

    //cout << "case9101112 AAAA" << endl;

    if(newX2 < edges12[1]->getEdgeLen()){  // Z will be moved in the direction of edge2


     
      diffLen = edges12[1]->getEdgeLen() - newX2;
      // case 9
      if(edges12[1]->getEdgeLen() - IDH2->getV(IDH2->getNumE()) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
	cout << "case9 " << endl;
 	edges12[1]->setEdgeLen(newX2);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) + diffLen, i);
 	edges12[0]->setEdgeLen(newX1);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 9

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeB);

	
      }else{

	//cout << "case10 " << endl;
      // case 10
	i = IDH2->getNumE();
	while(edges12[1]->getEdgeLen() - IDH2->getV(i) <= diffLen){
	  i--;
	}
	i++;

	//cout << "i " << i << endl;

	newN0 = IDH2->getN(i-1);

	//cout << "newN0 " << newN0 << endl;	

	IDH1->eraseHistory(1, 0);

    
    //cout << "AAAA "  << endl; 

    //cout << endl << "#### FROM IDH1 ####" << endl;
    //cout << "numE " << IDH1->getNumE() << endl;
    //for(j =0; j< IDH1->getIDHsize(); j++){ 
    //  cout << "ID " << IDH1->getID(j) << endl;
    //  cout << "L " << IDH1->getL(j) << endl;
    //  cout << "P " << IDH1->getP(j) << endl;
    //  cout << "V " << IDH1->getV(j) << endl;
    //  cout << "N " << IDH1->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
 
    //cout << endl << "#### FROM IDH2 ####" << endl;
    //cout << "numE " << IDH2->getNumE() << endl;
    //for(j =0; j< IDH2->getIDHsize(); j++){  
    //  cout << "ID " << IDH2->getID(j) << endl;
    //  cout << "L " << IDH2->getL(j) << endl;
    //  cout << "P " << IDH2->getP(j) << endl;
    //  cout << "V " << IDH2->getV(j) << endl;
    //  cout << "N " << IDH2->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH2->getHMG(j).size(); m++){
//	cout << IDH2->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
     

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	


     
    //cout << "BBBB "  << endl; 

    //cout << endl << "#### FROM IDH1 ####" << endl;
    //cout << "numE " << IDH1->getNumE() << endl;
    //for(j =0; j< IDH1->getIDHsize(); j++){ 
    //  cout << "ID " << IDH1->getID(j) << endl;
    //  cout << "L " << IDH1->getL(j) << endl;
    //  cout << "P " << IDH1->getP(j) << endl;
    //  cout << "V " << IDH1->getV(j) << endl;
    //  cout << "N " << IDH1->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
 
    //cout << endl << "#### FROM IDH2 ####" << endl;
    //cout << "numE " << IDH2->getNumE() << endl;
    //for(j =0; j< IDH2->getIDHsize(); j++){  
    //  cout << "ID " << IDH2->getID(j) << endl;
    //  cout << "L " << IDH2->getL(j) << endl;
    //  cout << "P " << IDH2->getP(j) << endl;
    //  cout << "V " << IDH2->getV(j) << endl;
    //  cout << "N " << IDH2->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH2->getHMG(j).size(); m++){
//	cout << IDH2->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
	

	tmpNumE = IDH2->getNumE() - i + 1;

	for(m = 1; m <= tmpNumE; m++){

	  j = i;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(m-1);
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->insertHistory(0, m, diffLen - (edges12[1]->getEdgeLen() - IDH2->getV(j)), 1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(m-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->insertHistory(0, m, diffLen - (edges12[1]->getEdgeLen() - IDH2->getV(j)), -1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, i);
	}



	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);
	IDH2->setN(newN0, IDH2->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

      
    //cout << "CCCCCCC "  << endl; 

    //cout << endl << "#### FROM IDH1 ####" << endl;
    //cout << "numE " << IDH1->getNumE() << endl;
    //for(j =0; j< IDH1->getIDHsize(); j++){ 
    //  cout << "ID " << IDH1->getID(j) << endl;
    //  cout << "L " << IDH1->getL(j) << endl;
    //  cout << "P " << IDH1->getP(j) << endl;
    //  cout << "V " << IDH1->getV(j) << endl;
    //  cout << "N " << IDH1->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
 
    //cout << endl << "#### FROM IDH2 ####" << endl;
    //cout << "numE " << IDH2->getNumE() << endl;
    //for(j =0; j< IDH2->getIDHsize(); j++){  
    //  cout << "ID " << IDH2->getID(j) << endl;
    //  cout << "L " << IDH2->getL(j) << endl;
    //  cout << "P " << IDH2->getP(j) << endl;
    //  cout << "V " << IDH2->getV(j) << endl;
    //  cout << "N " << IDH2->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH2->getHMG(j).size(); m++){
//	cout << IDH2->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
       

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	

	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 10

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);
	nodeA->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeB->getRoot()){
	  
	  nodeB->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeB->CalloglikeliofRootSites(params);
	  nodeB->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeB->getParent());
	    
	}
	
      }

    }else{  // else if(newX2 < edges12[1]->getEdgeLen()){  // Z will be moved in the direction of edge1


      diffLen = edges12[0]->getEdgeLen() - newX1;

      // case 11
      if(IDH1->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.


	cout << "case11 " << endl;
 	edges12[1]->setEdgeLen(newX2);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) - diffLen, i);
 	edges12[0]->setEdgeLen(newX1);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 11

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeB);

	
      }else{


	cout << "case12 " << endl;
      // case 12
	i = 1;
	while(IDH1->getV(i) <= diffLen){
	  i++;
	}
	i--;

	//cout << "i " << i << endl;

	newN0 = IDH1->getN(i);

	//cout << "newN0 " << newN0 << endl;

	IDH1->eraseHistory(1, 0);
	IDH2->eraseHistory(1);

      
    //cout << "AAAAA "  << endl; 

    //cout << endl << "#### FROM IDH1 ####" << endl;
    //cout << "numE " << IDH1->getNumE() << endl;
    //for(j =0; j< IDH1->getIDHsize(); j++){ 
    //  cout << "ID " << IDH1->getID(j) << endl;
    //  cout << "L " << IDH1->getL(j) << endl;
    //  cout << "P " << IDH1->getP(j) << endl;
    //  cout << "V " << IDH1->getV(j) << endl;
    //  cout << "N " << IDH1->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
 
    //cout << endl << "#### FROM IDH2 ####" << endl;
    //cout << "numE " << IDH2->getNumE() << endl;
    //for(j =0; j< IDH2->getIDHsize(); j++){  
    //  cout << "ID " << IDH2->getID(j) << endl;
    //  cout << "L " << IDH2->getL(j) << endl;
    //  cout << "P " << IDH2->getP(j) << endl;
    //  cout << "V " << IDH2->getV(j) << endl;
    //  cout << "N " << IDH2->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH2->getHMG(j).size(); m++){
//	cout << IDH2->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
      


	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

      
	//cout << "BBBBB "  << endl; 

    //cout << endl << "#### FROM IDH1 ####" << endl;
    //cout << "numE " << IDH1->getNumE() << endl;
    //for(j =0; j< IDH1->getIDHsize(); j++){  
    //  cout << "ID " << IDH1->getID(j) << endl;
    //  cout << "L " << IDH1->getL(j) << endl;
    //  cout << "P " << IDH1->getP(j) << endl;
    //  cout << "V " << IDH1->getV(j) << endl;
    //  cout << "N " << IDH1->getN(j) << endl;
    //  cout << endl << "HMG "  << endl;
    //  for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
  //    }   
    //  cout << endl;
    //}
      

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){
	  j = 1;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(IDH2->getNumE());
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->addHistory(0, edges12[1]->getEdgeLen() + IDH1->getV(j), 1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(IDH2->getNumE());
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->addHistory(0, edges12[1]->getEdgeLen() + IDH1->getV(j), -1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, 1);
	}

	IDH2->addHistory(1, newX2, -2, 0, 0, IDH2->getN(IDH2->getNumE()), IDH2->getHMG(IDH2->getNumE()));

      
      //  	cout << "CCCCC "  << endl; 
//	cout << endl << "#### FROM IDH2 ####" << endl;
  //  cout << "numE " << IDH2->getNumE() << endl;
  //  for(j =0; j< IDH2->getIDHsize(); j++){ 
  //    cout << "ID " << IDH2->getID(j) << endl;
  //    cout << "L " << IDH2->getL(j) << endl;
  //    cout << "P " << IDH2->getP(j) << endl;
  //    cout << "V " << IDH2->getV(j) << endl;
  //    cout << "N " << IDH2->getN(j) << endl;
  //    cout << endl << "HMG "  << endl;
  //    for(m=0; m < IDH2->getHMG(j).size(); m++){
//	cout << IDH2->getHMG(j,m) << " ";
  //    }   
  //    cout << endl;
  //  }
 
       
	for(j = 1; j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

    
//	cout << "DDDDD "  << endl; 
//	    cout << endl << "#### FROM IDH1 ####" << endl;
//    cout << "numE " << IDH1->getNumE() << endl;
//    for(j =0; j< IDH1->getIDHsize(); j++){ 
//      cout << "ID " << IDH1->getID(j) << endl;
//      cout << "L " << IDH1->getL(j) << endl;
//      cout << "P " << IDH1->getP(j) << endl;
//      cout << "V " << IDH1->getV(j) << endl;
//      cout << "N " << IDH1->getN(j) << endl;
//      cout << endl << "HMG "  << endl;
//      for(m=0; m < IDH1->getHMG(j).size(); m++){
//	cout << IDH1->getHMG(j,m) << " ";
 //     }   
//      cout << endl;
//    }
       
	nodeZ->setSeqLen(newN0);
	edges12[0]->setEdgeLen(newX1);
	//cout << "AAA" << endl;
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	//cout << "BBB" << endl;
	edges12[1]->calHMG();

	

	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);


	// case 12

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);
	nodeA->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeB->getRoot()){
	  
	  nodeB->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeB->CalloglikeliofRootSites(params);
	  nodeB->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeB->getParent());
	    
	}
	
      }

    }

  }
 
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];
  N_psl= edge3->ProposHistory(params);

  //double O_IDHslike, N_IDHslike;

  //O_IDHslike = logLikeliIDH[current];
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHslike = logLikeliIDH[current];


  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  edges12[0]->CalculatelogLikeliEdge(params);
  edges12[1]->CalculatelogLikeliEdge(params); 
  
  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  //AP = exp(N_datalike + N_IDHslike + O_psl - O_datalike - O_IDHslike - N_psl);

  
  //cout << endl << endl;
  //cout << "APAPAPAPAPAPAPAPAPAPAPAPAPAPAPAPAP" << endl << endl;
  //cout << "O_datalike " << O_datalike << endl;
  //cout << "N_datalike " << N_datalike << endl;
  //cout << "O_IDHlike " << O_IDHlike << endl;
  //cout << "N_IDHlike " << N_IDHlike << endl;
  //cout << "O_psl " << O_psl << endl;
  //cout << "N_psl " << N_psl << endl;
  //cout << "AP " << AP << endl;
  
  return AP;

}

*/




//Move node which connected two edges. 
//Edge length will be changed
double Tree::moveNodeOnTwoEdges(Edge* Pedge, Edge* Cedge, double newPedgeLen, double newCedgeLen){

  //cout << " In moveNodeOnTwoEdges " << endl;
 
  if(Pedge->getEnd()!=Cedge->getStart()){
    cout << "ERROR! Directions of Parent Edge or Child Edge is wrong!" << endl;
  }else{

    InDelHistory* pIDH;
    InDelHistory* cIDH;

    int numEofPedge, numEofCedge, newNumEofPedge, newNumEofCedge;
    
    vector<int> HMGin(0);
    vector<double> pV(0);
    vector<int> pID(0);
    vector<int> pP(0);
    vector<int> pL(0);
    vector<int> pN(0);
    vector<vector<int> > pHMG(0);

    vector<double> cV(0);
    vector<int> cID(0);
    vector<int> cP(0);
    vector<int> cL(0);
    vector<int> cN(0);
    vector<vector<int> > cHMG(0);


    int i, k, j;
    
    HMGin.resize(0);

    pIDH = Pedge->getIDH();
    cIDH = Cedge->getIDH();
    numEofPedge = pIDH->getNumE();
    numEofCedge = cIDH->getNumE();
    
    //double lastTimeIV = pIDH->getV(numEofPedge+1) - pIDH->getV(numEofPedge);
    double PedgeLen = pIDH->getV(numEofPedge+1);
    // Erase end of IDH on Pedge 

    if(PedgeLen < newPedgeLen){


      //cout << " if PedgeLen < newPedgeLen " << endl;

      HMGin.resize(0);
      pV.resize(0);
      pID.resize(0);
      pP.resize(0);
      pL.resize(0);
      pN.resize(0);
      pHMG.resize(0);

      
      // copy all IDH on Pedge
      for(i = 0; i <= numEofPedge; i++){
	pV.push_back(pIDH->getV(i));
	pID.push_back(pIDH->getID(i));
	pP.push_back(pIDH->getP(i));
	pL.push_back(pIDH->getL(i));
	pN.push_back(pIDH->getN(i));
	pHMG.push_back(pIDH->getHMG(i));
      }
      newNumEofPedge = numEofPedge;


      // copy IDH on Cedge in proper length
      i = 1;
      while(cIDH->getV(i) < (newPedgeLen - PedgeLen)){
	pV.push_back(cIDH->getV(i) + PedgeLen);
	pID.push_back(cIDH->getID(i));
	pP.push_back(cIDH->getP(i));
	pL.push_back(cIDH->getL(i));
	pN.push_back(cIDH->getN(i));
	HMGin = pHMG[newNumEofPedge];
	if(cIDH->getID(i)==1){
	  for( k = 0; k < cIDH->getL(i); k++)
	    HMGin.insert(HMGin.begin()+ cIDH->getP(i),-1);
	}else{
	  for( k = 0; k < cIDH->getL(i); k++)
	    HMGin.erase(HMGin.begin()+ cIDH->getP(i));
	}
	pHMG.push_back(HMGin);	
	HMGin.resize(0);
	i++;
	newNumEofPedge++;
      }

      // Add the last element
      pV.push_back(newPedgeLen);
      pID.push_back(-2);
      pP.push_back(0);
      pL.push_back(0);
      pN.push_back(pN[newNumEofPedge]);
      pHMG.push_back(pHMG[newNumEofPedge]);     




      HMGin.resize(0);
      cV.resize(0);
      cID.resize(0);
      cP.resize(0);
      cL.resize(0);
      cN.resize(0);
      cHMG.resize(0);


      // Add the first element
      cV.push_back(0);
      cID.push_back(-2);
      cP.push_back(0);
      cL.push_back(0);
      cN.push_back(pN[newNumEofPedge+1]);
      for( k = 0; k <= cN[0]; k++){
	HMGin.push_back(k);
      }     
      cHMG.push_back(HMGin);
      
      newNumEofCedge = 0;

      // copy the rest IDH on Cedge
      j = i;
      for(i = j ; i <= numEofCedge; i++){
	cV.push_back(cIDH->getV(i) + PedgeLen - newPedgeLen);
	cID.push_back(cIDH->getID(i));
	cP.push_back(cIDH->getP(i));
	cL.push_back(cIDH->getL(i));
	cN.push_back(cIDH->getN(i));
	HMGin = cHMG[newNumEofCedge];
	if(cIDH->getID(i)==1){
	  for( k = 0; k < cIDH->getL(i); k++)
	    HMGin.insert(HMGin.begin()+ cIDH->getP(i),-1);
	}else{
	  for( k = 0; k < cIDH->getL(i); k++)
	    HMGin.erase(HMGin.begin()+ cIDH->getP(i));
	}
	cHMG.push_back(HMGin);	
	HMGin.resize(0);
	newNumEofCedge++;
      }

      // Add the last element
      cV.push_back(newCedgeLen);
      cID.push_back(-2);
      cP.push_back(0);
      cL.push_back(0);
      cN.push_back(cN[newNumEofCedge]);
      cHMG.push_back(cHMG[newNumEofCedge]);     

      // Set new Cedge
      pIDH->setHistory(newNumEofPedge, pV, pID, pP, pL, pN, pHMG);
      cIDH->setHistory(newNumEofCedge, cV, cID, cP, cL, cN, cHMG);


      HMGin.resize(0);
      pV.resize(0);
      pID.resize(0);
      pP.resize(0);
      pL.resize(0);
      pN.resize(0);
      pHMG.resize(0);
      cV.resize(0);
      cID.resize(0);
      cP.resize(0);
      cL.resize(0);
      cN.resize(0);
      cHMG.resize(0);      


    }else{  // if(PedgeLen >= newPedgeLen)
      

      //      cout << " if PedgeLen > newPedgeLen " << endl;

      HMGin.resize(0);
      pV.resize(0);
      pID.resize(0);
      pP.resize(0);
      pL.resize(0);
      pN.resize(0);
      pHMG.resize(0);

      
      // copy IDH on Pedge in proper length
      i = 0;
      while(pIDH->getV(i) < newPedgeLen){
	pV.push_back(pIDH->getV(i));
	pID.push_back(pIDH->getID(i));
	pP.push_back(pIDH->getP(i));
	pL.push_back(pIDH->getL(i));
	pN.push_back(pIDH->getN(i));
	pHMG.push_back(pIDH->getHMG(i));
	i++;
      }
      newNumEofPedge = i-1 ; 

      //cout << " newNumEofPedge " << newNumEofPedge << endl;
      //cout << "AAAA pV " << endl;
      //print_vecd(pV);

      // Add the last element
      pV.push_back(newPedgeLen);
      pID.push_back(-2);
      pP.push_back(0);
      pL.push_back(0);
      pN.push_back(pN[newNumEofPedge]);
      pHMG.push_back(pHMG[newNumEofPedge]);     


      //cout << " pIDH doen " << endl;
      //print_vecd(pV);

      HMGin.resize(0);
      cV.resize(0);
      cID.resize(0);
      cP.resize(0);
      cL.resize(0);
      cN.resize(0);
      cHMG.resize(0);


      // Add the first element 
      cV.push_back(0);
      cID.push_back(-2);
      cP.push_back(0);
      cL.push_back(0);
      cN.push_back(pN[newNumEofPedge+1]);
      for( k = 0; k <= cN[0]; k++){
	HMGin.push_back(k);
      }     
      cHMG.push_back(HMGin);
      HMGin.resize(0);

      newNumEofCedge = 0;    


      //cout << "AAAA cV " << endl;
      //print_vecd(cV);
  
      //cout << " newNumEofCedge : " <<  newNumEofCedge << endl;

      // copy the rest IDH on Pedge
      j = i;
      //cout << " j : " << j << " numEofPedge : " << numEofPedge << endl;
      for(i = j; i <= numEofPedge; i++){
	//cout << " i : " << i << endl;
	cV.push_back(pIDH->getV(i) - newPedgeLen);
	cID.push_back(pIDH->getID(i));
	cP.push_back(pIDH->getP(i));
	cL.push_back(pIDH->getL(i));
	cN.push_back(pIDH->getN(i));
	HMGin = cHMG[newNumEofCedge];
	if(pIDH->getID(i)==1){
	  for( k = 0; k < pIDH->getL(i); k++)
	    HMGin.insert(HMGin.begin()+ pIDH->getP(i),-1);
	}else{
	  for( k = 0; k < pIDH->getL(i); k++)
	    HMGin.erase(HMGin.begin()+ pIDH->getP(i));
	}
	cHMG.push_back(HMGin);	
	HMGin.resize(0);
	newNumEofCedge++;
      }     

      
      //cout << "BBBB cV " << endl;
      //print_vecd(cV);


      // copy all IDH on Cedge
      for(i = 1; i <= numEofCedge; i++){
	cV.push_back(cIDH->getV(i) + PedgeLen - newPedgeLen);
	cID.push_back(cIDH->getID(i));
	cP.push_back(cIDH->getP(i));
	cL.push_back(cIDH->getL(i));
	cN.push_back(cIDH->getN(i));
	HMGin = cHMG[newNumEofCedge];
	if(cIDH->getID(i)==1){
	  for( k = 0; k < cIDH->getL(i); k++)
	    HMGin.insert(HMGin.begin()+ cIDH->getP(i),-1);
	}else{
	  for( k = 0; k < cIDH->getL(i); k++)
	    HMGin.erase(HMGin.begin()+ cIDH->getP(i));
	}
	cHMG.push_back(HMGin);	
	HMGin.resize(0);
	newNumEofCedge++;
      }

      //cout << "CCCC cV " << endl;
      //print_vecd(cV);      


      // Add the last element
      cV.push_back(newCedgeLen);
      cID.push_back(-2);
      cP.push_back(0);
      cL.push_back(0);
      cN.push_back(cN[newNumEofCedge]);
      cHMG.push_back(cHMG[newNumEofCedge]);     
      

      //cout << "DDDD cV " << endl;
      //print_vecd(cV);     

      // Set new Pedge and Cedge
      pIDH->setHistory(newNumEofPedge, pV, pID, pP, pL, pN, pHMG);
      cIDH->setHistory(newNumEofCedge, cV, cID, cP, cL, cN, cHMG);
      
      
      HMGin.resize(0);
      pV.resize(0);
      pID.resize(0);
      pP.resize(0);
      pL.resize(0);
      pN.resize(0);
      pHMG.resize(0);
      cV.resize(0);
      cID.resize(0);
      cP.resize(0);
      cL.resize(0);
      cN.resize(0);
      cHMG.resize(0);



    }

    Pedge->calHMG(); 
    Cedge->calHMG(); 

    Pedge->setEdgeLen(newPedgeLen);
    Cedge->setEdgeLen(newCedgeLen);



  }

}







// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithTargetWithinWindow(Rand &rand, const Parameters &params, int numZnode, int Edgenum, int baseNodenum, double templen, double N_psl_posi, double O_psl_posi, double posiM, ofstream& c, int start) {




  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum; 


  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);


  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    
    IDH = edge0->getIDH();
    endNum = IDH->getNumE()+1;
    endPosi = IDH->getNumE();
    for(i = 1; i <= endNum; i++){
      if(posiM < IDH->getV(i)){
	endPosi = i - 1;
	break;
      }
    }
    extractSubIDH(IDH, subIDH, endPosi, posiM);
    O_psl = ProposHistory(params, subIDH);

    edge0->ReverseEdge();
  }else{
      
    
    IDH = edge0->getIDH();
    endNum = IDH->getNumE()+1;
    endPosi = IDH->getNumE();
    for(i = 1; i <= endNum; i++){
      if(posiM < IDH->getV(i)){
	endPosi = i - 1;
	break;
      }
    }
    extractSubIDH(IDH, subIDH, endPosi, posiM);
    O_psl = ProposHistory(params, subIDH);
    
  }    


    

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	


    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
    //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	



    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
    //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	

           
    //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
    //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];



  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi - O_datalike - O_IDHlike - N_psl - N_psl_posi);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi  - N_psl - N_psl_posi) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << endl;




  delete subIDH;
 
  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 





// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithTargetWithinWindow(Rand &rand, const Parameters &params, int numZnode, int Edgenum, int baseNodenum, double templen, double N_psl_posi, double O_psl_posi, double posiM, ofstream& c) {




  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum; 


  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);


  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    
    IDH = edge0->getIDH();
    endPosi = IDH->getNumE();
    endNum = IDH->getNumE()+1;
    for(i = 1; i <= endNum; i++){
      if(posiM < IDH->getV(i)){
	endPosi = i - 1;
	break;
      }
    }
    extractSubIDH(IDH, subIDH, endPosi, posiM);
    O_psl = ProposHistory(params, subIDH);

    edge0->ReverseEdge();
  }else{
      
    
    IDH = edge0->getIDH();
    endPosi = IDH->getNumE();
    endNum = IDH->getNumE()+1;
    for(i = 1; i <= endNum; i++){
      if(posiM < IDH->getV(i)){
	endPosi = i - 1;
	break;
      }
    }
    extractSubIDH(IDH, subIDH, endPosi, posiM);
    O_psl = ProposHistory(params, subIDH);
    
  }    


    

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	


    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
    //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	



    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
    //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	

           
    //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
    //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];




  AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi - O_datalike - O_IDHlike - N_psl - N_psl_posi);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi  - N_psl - N_psl_posi) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << endl;




  delete subIDH;
 
  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 





// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithTarget(Rand &rand, const Parameters &params, int numZnode, int Edgenum, int baseNodenum, double templen, double N_psl_posi, double O_psl_posi, ofstream& c, int start) {




  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);

  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    O_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    O_psl= edge0->ProposHistory(params);
  }     

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
    
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
      
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
           
   //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    N_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    N_psl= edge0->ProposHistory(params);
  }           

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];



  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi - O_datalike - O_IDHlike - N_psl - N_psl_posi);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi  - N_psl - N_psl_posi) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << endl;




  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 






// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithTarget(Rand &rand, const Parameters &params, int numZnode, int Edgenum, int baseNodenum, double templen, double N_psl_posi, double O_psl_posi, ofstream& c) {




  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);

  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    O_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    O_psl= edge0->ProposHistory(params);
  }     

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
    
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
      
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    //templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
           
   //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    N_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    N_psl= edge0->ProposHistory(params);
  }           

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];




  AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi - O_datalike - O_IDHlike - N_psl - N_psl_posi);
 

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi  - N_psl - N_psl_posi) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << endl;




  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 








// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(Rand &rand, const Parameters &params, int numZnode, int Edgenum, int baseNodenum, double posiM, ofstream& c, int start) {


  //cout << "Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow " << endl;
  //printTree();


  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();
  //cout << "nodeZ : " << nodeZ->getnumber() << endl;

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum); 
  //cout << "edge0 : " << edge0->getnumber() << endl;
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum; 


  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);


  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    
    IDH = edge0->getIDH();
    endNum = IDH->getNumE()+1;
    endPosi = IDH->getNumE();
    for(i = 1; i <= endNum; i++){
      if(posiM < IDH->getV(i)){
	endPosi = i - 1;
	break;
      }
    }
    extractSubIDH(IDH, subIDH, endPosi, posiM);
    O_psl = ProposHistory(params, subIDH);

    edge0->ReverseEdge();
  }else{
      
    
    IDH = edge0->getIDH();
    endNum = IDH->getNumE()+1;
    endPosi = IDH->getNumE();
    for(i = 1; i <= endNum; i++){
      if(posiM < IDH->getV(i)){
	endPosi = i - 1;
	break;
      }
    }
    extractSubIDH(IDH, subIDH, endPosi, posiM);
    O_psl = ProposHistory(params, subIDH);
    
  }    


  //cout << "M1 " << endl;
  //checkTree();


  

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
  
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	

    //cout << "caseIIa " << endl;
    //checkTree();
    
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //cout << "edgeA " << edgeA->getnumber() << " newAlen "  << newAlen << endl;
    //cout << "edgeB " << edgeB->getnumber() << " newBlen "  << newBlen << endl;

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

 
    //cout << "edgeA" << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();    



   
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    //cout << "newnodeZ " << nodeZ->getSeqLen();


    //cout << "before " << endl;
    //checkTree();   
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();

      //cout << "reverse" << endl;
      IDH = edge0->getIDH();
      //cout << "P1 IDH" << endl;
      //IDH->printIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      //cout << "N0 " << IDH->getN(0) << " NsubEnd " << IDH->getN(endPosi) << " endPosi " << endPosi << " posiM " << posiM << endl;
      //cout << "P2 subIDH " << endl;
      //subIDH->printIDH();
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      //cout << "P3 IDH" << endl;
      //IDH->printIDH();
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      //cout << "not reverse" << endl;
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	


    //cout << "caseII " << endl;
    //checkTree();
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	
    //cout << "caseI " << endl;
    //checkTree();
           
   //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];

  delete subIDH;

  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl)  << endl;




  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 








// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(Rand &rand, const Parameters &params, int numZnode, int Edgenum, int baseNodenum, double posiM, ofstream& c) {


  //cout << "Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow " << endl;
  //printTree();


  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();
  //cout << "nodeZ : " << nodeZ->getnumber() << endl;

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum); 
  //cout << "edge0 : " << edge0->getnumber() << endl;
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum; 


  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);


  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    
    IDH = edge0->getIDH();
    endPosi = IDH->getNumE();
    endNum = IDH->getNumE()+1;
    for(i = 1; i <= endNum; i++){
      if(posiM < IDH->getV(i)){
	endPosi = i - 1;
	break;
      }
    }
    extractSubIDH(IDH, subIDH, endPosi, posiM);
    O_psl = ProposHistory(params, subIDH);

    edge0->ReverseEdge();
  }else{
      
    
    IDH = edge0->getIDH();
    endPosi = IDH->getNumE();
    endNum = IDH->getNumE()+1;
    for(i = 1; i <= endNum; i++){
      if(posiM < IDH->getV(i)){
	endPosi = i - 1;
	break;
      }
    }
    extractSubIDH(IDH, subIDH, endPosi, posiM);
    O_psl = ProposHistory(params, subIDH);
    
  }    


  //cout << "M1 " << endl;
  //checkTree();


  

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
  
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	

    //cout << "caseIIa " << endl;
    //checkTree();
    
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //cout << "edgeA " << edgeA->getnumber() << " newAlen "  << newAlen << endl;
    //cout << "edgeB " << edgeB->getnumber() << " newBlen "  << newBlen << endl;

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

 
    //cout << "edgeA" << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();    



   
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    //cout << "newnodeZ " << nodeZ->getSeqLen();


    //cout << "before " << endl;
    //checkTree();   
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();

      //cout << "reverse" << endl;
      IDH = edge0->getIDH();
      //cout << "P1 IDH" << endl;
      //IDH->printIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      //cout << "N0 " << IDH->getN(0) << " NsubEnd " << IDH->getN(endPosi) << " endPosi " << endPosi << " posiM " << posiM << endl;
      //cout << "P2 subIDH " << endl;
      //subIDH->printIDH();
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      //cout << "P3 IDH" << endl;
      //IDH->printIDH();
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      //cout << "not reverse" << endl;
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	


    //cout << "caseII " << endl;
    //checkTree();
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();     
      
      edge0->ReverseEdge();
    }else{
      
      IDH = edge0->getIDH();
      runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
      N_psl = ProposHistory(params, subIDH);
      insertSubIDH(IDH, subIDH, endPosi);
      edge0->calHMG();    
      
    }	
    //cout << "caseI " << endl;
    //checkTree();
           
   //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];

  delete subIDH;


  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
 
    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl)  << endl;




  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 







// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTree(Rand &rand, const Parameters &params, int numZnode, int Edgenum, int baseNodenum, ofstream& c, int start) {

  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);

  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    O_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    O_psl= edge0->ProposHistory(params);
  }     

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
    
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
      
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
           
   //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    N_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    N_psl= edge0->ProposHistory(params);
  }           

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];



  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);
  
  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl) << endl;

  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 







// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTree(Rand &rand, const Parameters &params, int numZnode, int Edgenum, int baseNodenum, ofstream& c) {

  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);

  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    O_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    O_psl= edge0->ProposHistory(params);
  }     

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
    
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
      
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
           
   //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    N_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    N_psl= edge0->ProposHistory(params);
  }           

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];




  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
 
  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl) << endl;

  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 




// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTree_v0(Rand &rand,const Parameters &params, int numZnode, int Edgenum, int baseNodenum) {

  //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTree " << endl;

  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  //cout << "nodeZ->getRoot() " << nodeZ->getRoot() << endl;

  // Select an adjacent edge e3 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  //cout << "Edgenum " << Edgenum << endl;
  //cout << "edge3->getnumber() " << edge3->getnumber() << endl;

  //O_IDHlike = edge0->likeliHistory(params);
  O_IDHlike = likeliHistory(params);


  //cout << "O_IDHlike " << O_IDHlike << endl;
  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    O_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    O_psl= edge0->ProposHistory(params);
  }     
  //cout << "O_psl " << O_psl << endl;
  
  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  //cout << "nodeC->getnumber() " << nodeC->getnumber() << endl;



  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  

  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //cout << "******** CASEIIA *****************" << endl;

      //----------------------//
      //                      //
      //       caseIIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      j = 0;
      for(i = 0; i < nodeZ->getnumEdges(); i++){
	if(Edgenum!=i){
	  if(j==0){
	    edgeA = nodeZ->getEdge(i);
	    nodeA = edgeA->getOtherNode(nodeZ);
	    j++;
	  }else{
	    edgeB = nodeZ->getEdge(i);
	    nodeB = edgeB->getOtherNode(nodeZ);	  
	  }
	}
      }

      //--- Assign new position --//
      lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
      templen = rand.runif()*(lenAandB);
      if(nodeA->getnumber() == baseNodenum){
	newAlen = templen;
	newBlen = lenAandB - newAlen;
      }else{
	newBlen = templen;
	newAlen = lenAandB - newBlen;	
      }


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeA
      edgeA->ReverseEdge();


      //      : Change IDH and edge length of edge A and edge B   
      moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);

      //      : Reverse IDH and change start and end nodes on edgeA
      edgeA->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeA->getIDH()->getN(0));


      //----- Reconstruct a tree --------------//

      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
      
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      /*
      nodeA->findRootSites();
      nodeB->findRootSites();
      nodeC->findRootSites();     

      // 1'
      nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeB->CalSubTreeProb(params);
      nodeB->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeZ); 

      
      //cout << endl << "~~~~~ After updating all information " << endl;
      //printTree(0);
     //checkTree();
	
      // Update IDHlikelihood
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

      */

  }else if(nodeZ->getParentEdge()==edge0){

    
    //cout << "******** CASEII *****************" << endl;
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    

    //cout << "nodeA : " << endl;
    //nodeA->printNode();
    //cout << "nodeB : " << endl;
    //nodeB->printNode();
    //cout << "edgeA " << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();


    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //cout << " templen : " << templen << " newAlen : " << newAlen << " newBlen : " << newBlen << endl;


    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
   
    //cout << " After reverse edgeA " << endl;
    //cout << "edgeA " << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();

    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //cout << " After move edge " << endl;
    //cout << "edgeA " << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();

  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    //cout << " After reverse edge A again " << endl;
    //cout << "edgeA " << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();


    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //

    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      edge0->ReverseEdge();
    }else{
      edge0->runEdge(rand,params);
      edge0->calHMG();
    }    
      
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    /*
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
    //cout << endl << "~~~~~ After updating all information " << endl;
    //printTree(0);
   //checkTree();
    
    // Update IDHlikelihood
    r = params.getR();
    
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
    
    */

  
  }else{

    //cout << "******** CASEI   *****************" << endl;

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//


     //checkTree();
      
      //----- Label nodes end edges ----//
      for(i = 0; i < nodeZ->getnumEdges(); i++){
	if(Edgenum!=i){
	  if(nodeZ->getparentIndex()==i){
	    edgeA = nodeZ->getEdge(i);
	    nodeA = edgeA->getOtherNode(nodeZ);
	  }else{
	    edgeB = nodeZ->getEdge(i);
	    nodeB = edgeB->getOtherNode(nodeZ);	  
	  }
	}
      }

      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB : " << endl;
      //nodeB->printNode();
      //cout << "edgeA " << endl;
      //edgeA->printEdge();
      //cout << "edgeB " << endl;
      //edgeB->printEdge();



      //--- Assign new position --//
      lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
      templen = rand.runif()*(lenAandB);
      if(nodeA->getnumber() == baseNodenum){
	newAlen = templen;
	newBlen = lenAandB - newAlen;
      }else{
	newBlen = templen;
	newAlen = lenAandB - newBlen;	
      }
    
      //cout << " templen : " << templen << " newAlen : " << newAlen << " newBlen : " << newBlen << endl;


      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge A and edge B   
      moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);

      //cout << " After move edge " << endl;
      //cout << "edgeA " << endl;
      //edgeA->printEdge();
      //cout << "edgeB " << endl;
      //edgeB->printEdge();
      

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeB->getIDH()->getN(0));


      //----- Reconstruct a tree --------------//

      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
           
      //printTree();
     //checkTree();


      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      /*
      //cout << "findRootSites nodeZ " << endl;
      //cout << "nodeZ : " << endl;
      //nodeZ->printNode();      
      nodeZ->findRootSites();
      //cout << "findRootSites nodeB " << endl;
      //cout << "nodeB : " << endl;
      //nodeB->printNode();        
      nodeB->findRootSites();
      //cout << "findRootSites nodeC " << endl;
      //cout << "nodeC : " << endl;
      //nodeC->printNode();  
      nodeC->findRootSites();     

      // 1'
      if(nodeA->getRoot())
	nodeA->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3      
      nodeB->CalSubTreeProb(params);
      nodeB->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeZ); 

      //cout << endl << "~~~~~ After updating all information " << endl;
      //printTree(0);
     //checkTree();
     
      // Update IDHlikelihood
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      */


  }
    
  O_datalike = logLikeliData[current];
  root->likeliDataR_v2(params);
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];
  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    N_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    N_psl= edge0->ProposHistory(params);
  }           





  //cout << "N_datalike : " << N_datalike << endl;
  //cout << "O_datalike : " << O_datalike << endl;
  //cout << "N_IDHlike : " << N_IDHlike << endl;
  //cout << "O_IDHlike : " << O_IDHlike << endl;


  logLikeliIDH[current] = likeliHistory(params);
  N_IDHlike = logLikeliIDH[current];



    //cout << "IDH diff : " << (logLikeliIDH[current] - logLikeliIDH[1-current]) << endl; 
    //double edgeS = 0;
    //for(int m = 0; m < numEdges; m++){ 
    //edgeS += getEdge(m)->getEdgeLen();
    //}
    //cout << "EdgeSum : " << edgeS << endl;



  logLikeliEdges[current] = CalculatelogLikeliEdges(params);






  //cout << "Updated information !!!!! " << endl;
  //cout << "N_datalike : " << N_datalike << endl;


  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
 
  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 







double Tree::SPRonSingleEdge(Rand &rand,const Parameters &params, ofstream& c, int start) {

  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e3 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge3 = nodeZ->getEdge(Edgenum);


  //Heejung
  O_IDHlike = edge3->likeliHistory(params);
  //O_IDHlike = logLikeliIDH[current];



  if(nodeZ == edge3->getEnd()){
    edge3->ReverseEdge();
    O_psl= edge3->ProposHistory(params);
    edge3->ReverseEdge();
  }else{
    O_psl= edge3->ProposHistory(params);
  }

  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge3->getOtherNode(nodeZ);

  Edge* edges12[2];
  // The other two adjacent edges e1 and e2 connect Z to nodes A and B, respectively. 
  j = 0;
  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(Edgenum!=i){
      edges12[j] = nodeZ->getEdge(i);
      j++;
    }
  }

  Node* nodeA = edges12[0]->getOtherNode(nodeZ);
  Node* nodeB = edges12[1]->getOtherNode(nodeZ);
      

  // Pick a random location on the path from A to B and move Z to this new location.
  double X1andX2 = edges12[0]->getEdgeLen() + edges12[1]->getEdgeLen();
  // New edge length
  double newX1 = rand.runif()*(X1andX2);
  double newX2 = X1andX2 - newX1;
  if(rand.runif() > 0.5){
    double newtmp = newX1;
    newX1 = newX2;
    newX2 = newtmp;
  }
  double diffLen;
  int newN0, tmpNumE;

  InDelHistory* IDH1;
  InDelHistory* IDH2;

  vector<int> HMGin(0);

  HMGin.resize(0);

  IDH1 = edges12[0]->getIDH();
  IDH2 = edges12[1]->getIDH();


  
  if((nodeZ->getRoot()) || (nodeZ->getparentIndex() == Edgenum)){  // Z is Root or Root is in a subtree which edge3 connects to Z.

    if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge1


      diffLen = edges12[0]->getEdgeLen() - newX1;
      // case 1 or case 1a
      if(IDH1->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
	
	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) - diffLen, i);
 	edges12[0]->setEdgeLen(newX1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) + diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);


	// case 1a
	if(nodeZ->getRoot()){


	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeC->UpdateRootSites(params);

	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;	  

	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);

	// case 1  
	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
       
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);
	  nodeZ->CalSubTreeProb(params);

	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;

	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	 
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);

	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    UpdateAllinfoToRoot(params, nodeC->getParent());

	  }
	
        }
	
	
      }else{


	// case 2 or case 2a
	i = 1;
	while(IDH1->getV(i) <= diffLen){
	  i++;
	}
	i--;

	newN0 = IDH1->getN(i);
	IDH1->eraseHistory(1, 0);
	IDH2->eraseHistory(1, 0);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);

	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){

	  j = i - m + 1;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(m-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->insertHistory(0, m, diffLen - IDH1->getV(j), -1, IDH1->getP(j), IDH1->getL(j), (IDH2->getN(m-1) - IDH1->getL(j)) , HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(m-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->insertHistory(0, m, diffLen - IDH1->getV(j), 1, IDH1->getP(j), IDH1->getL(j), (IDH2->getN(m-1) + IDH1->getL(j)), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, j);

	} 

	for(j = 1; j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(j = (tmpNumE+1); j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();

	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();


	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	// case 2a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();

	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);

	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);

	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeC->UpdateRootSites(params);

	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	 
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);


	// case 2  
	}else{               


	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	  

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }

        }	

      }

    }else{  // else if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge2

      diffLen = edges12[1]->getEdgeLen() - newX2;

      // case 3 or case 3a
      if(IDH2->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
	
	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) - diffLen, i);
  	edges12[1]->setEdgeLen(newX2);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) + diffLen, i);
	edges12[0]->setEdgeLen(newX1);

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	// case 3a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);
	 

	// case 3  
	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    
	 
	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }
	
        }
		
      }else{


	// case 4
	i = 1;
	while(IDH2->getV(i) <= diffLen){
	  i++;
	}
	i--;

	newN0 = IDH2->getN(i);

	IDH2->eraseHistory(1, 0);
	IDH1->eraseHistory(1, 0);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

        tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){

	  j = i - m + 1;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(m-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->insertHistory(0, m, diffLen - IDH2->getV(j), -1, IDH2->getP(j), IDH2->getL(j), (IDH1->getN(m-1) - IDH2->getL(j)), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(m-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->insertHistory(0, m, diffLen - IDH2->getV(j), 1, IDH2->getP(j), IDH2->getL(j), (IDH1->getN(m-1) + IDH2->getL(j)), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, j);

	} 

	for(j = 1; j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	// case 4a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);



	// case 4  
	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	  

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }

        }

      }

    }

  }else if(nodeZ->getParentEdge()->getnumber() == edges12[0]->getnumber()){  // Root is in a subtree which edge1 connects to A.


    if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge1
      
      diffLen = edges12[0]->getEdgeLen() - newX1;

      // case 5
      if(edges12[0]->getEdgeLen() - IDH1->getV(IDH1->getNumE()) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.

 	edges12[0]->setEdgeLen(newX1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) + diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeA);
	
      }else{

	// case 6
	i = IDH1->getNumE();
	while(edges12[0]->getEdgeLen() - IDH1->getV(i) <= diffLen){
	  i--;
	}
	i++;

	newN0 = IDH1->getN(i-1);

	IDH2->eraseHistory(1, 0);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = IDH1->getNumE() - i + 1;

	for(m = 1; m <= tmpNumE; m++){

	  j = i;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(m-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->insertHistory(0, m, diffLen - (edges12[0]->getEdgeLen() - IDH1->getV(j)), 1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(m-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->insertHistory(0, m, diffLen - (edges12[0]->getEdgeLen() - IDH1->getV(j)), -1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, i);
	}

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);
	IDH1->setN(newN0, IDH1->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);
	nodeB->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeA->getRoot()){
	  
	  nodeA->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeA->CalloglikeliofRootSites(params);
	  nodeA->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeA->getParent());
	    
	}
      }

    }else{  // else if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge2

      diffLen = edges12[1]->getEdgeLen() - newX2;

      // case 7
      if(IDH2->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.

 	edges12[0]->setEdgeLen(newX1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) - diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  
	UpdateAllinfoToRoot(params, nodeA);

      }else{

	// case 8
	i = 1;
	while(IDH2->getV(i) <= diffLen){
	  i++;
	}
	i--;


	newN0 = IDH2->getN(i);

	IDH2->eraseHistory(1, 0);
	IDH1->eraseHistory(1);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){
	  j = 1;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(IDH1->getNumE());
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->addHistory(0, edges12[0]->getEdgeLen() + IDH2->getV(j), 1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(IDH1->getNumE());
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->addHistory(0, edges12[0]->getEdgeLen() + IDH2->getV(j), -1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, 1);
	}

	IDH1->addHistory(1, newX1, -2, 0, 0, IDH1->getN(IDH1->getNumE()), IDH1->getHMG(IDH1->getNumE()));


	for(j = 1; j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);
	nodeB->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeA->getRoot()){
	  
	  nodeA->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeA->CalloglikeliofRootSites(params);
	  nodeA->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeA->getParent());
	    
	}
	
      }

    }

  }else{  // Root is in a subtree which edge2 connects to B.


    if(newX2 < edges12[1]->getEdgeLen()){  // Z will be moved in the direction of edge2
     
      diffLen = edges12[1]->getEdgeLen() - newX2;

      // case 9
      if(edges12[1]->getEdgeLen() - IDH2->getV(IDH2->getNumE()) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
  
 	edges12[1]->setEdgeLen(newX2);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) + diffLen, i);
 	edges12[0]->setEdgeLen(newX1);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  
	UpdateAllinfoToRoot(params, nodeB);

      }else{

 
	// case 10
	i = IDH2->getNumE();
	while(edges12[1]->getEdgeLen() - IDH2->getV(i) <= diffLen){
	  i--;
	}
	i++;

	newN0 = IDH2->getN(i-1);

	IDH1->eraseHistory(1, 0);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = IDH2->getNumE() - i + 1;

	for(m = 1; m <= tmpNumE; m++){

	  j = i;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(m-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->insertHistory(0, m, diffLen - (edges12[1]->getEdgeLen() - IDH2->getV(j)), 1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(m-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->insertHistory(0, m, diffLen - (edges12[1]->getEdgeLen() - IDH2->getV(j)), -1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, i);
	}

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);
	IDH2->setN(newN0, IDH2->getNumE() + 1);

	for(j = (tmpNumE+1); j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);
	nodeA->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeB->getRoot()){
	  
	  nodeB->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeB->CalloglikeliofRootSites(params);
	  nodeB->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeB->getParent());
	    
	}	
      }

    }else{  // else if(newX2 < edges12[1]->getEdgeLen()){  // Z will be moved in the direction of edge1


      diffLen = edges12[0]->getEdgeLen() - newX1;

      // case 11
      if(IDH1->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.

 	edges12[1]->setEdgeLen(newX2);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) - diffLen, i);
 	edges12[0]->setEdgeLen(newX1);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  
	UpdateAllinfoToRoot(params, nodeB);

      }else{

	// case 12
	i = 1;
	while(IDH1->getV(i) <= diffLen){
	  i++;
	}
	i--;

	newN0 = IDH1->getN(i);

	IDH1->eraseHistory(1, 0);
	IDH2->eraseHistory(1);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){
	  j = 1;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(IDH2->getNumE());
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->addHistory(0, edges12[1]->getEdgeLen() + IDH1->getV(j), 1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(IDH2->getNumE());
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->addHistory(0, edges12[1]->getEdgeLen() + IDH1->getV(j), -1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, 1);
	}

	IDH2->addHistory(1, newX2, -2, 0, 0, IDH2->getN(IDH2->getNumE()), IDH2->getHMG(IDH2->getNumE()));


	for(j = 1; j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	nodeZ->setSeqLen(newN0);
	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }
	
	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);
	nodeA->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeB->getRoot()){
	  
	  nodeB->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeB->CalloglikeliofRootSites(params);
	  nodeB->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeB->getParent());
	    
	}
	
      }

    }

  }
 


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];

  // IDH like
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];
  edges12[0]->likeliHistory(params);
  edges12[1]->likeliHistory(params);  
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  // Edge like
  edges12[0]->CalculatelogLikeliEdge(params);
  edges12[1]->CalculatelogLikeliEdge(params); 
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);



  //N_psl= edge3->ProposHistory(params);
  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<  exp(O_psl - N_psl) << endl;




  return AP;

} // end of SPRonSinglEdge









double Tree::SPRonSingleEdge(Rand &rand,const Parameters &params, ofstream& c) {

  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e3 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge3 = nodeZ->getEdge(Edgenum);


  //Heejung
  O_IDHlike = edge3->likeliHistory(params);
  //O_IDHlike = logLikeliIDH[current];



  if(nodeZ == edge3->getEnd()){
    edge3->ReverseEdge();
    O_psl= edge3->ProposHistory(params);
    edge3->ReverseEdge();
  }else{
    O_psl= edge3->ProposHistory(params);
  }

  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge3->getOtherNode(nodeZ);

  Edge* edges12[2];
  // The other two adjacent edges e1 and e2 connect Z to nodes A and B, respectively. 
  j = 0;
  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(Edgenum!=i){
      edges12[j] = nodeZ->getEdge(i);
      j++;
    }
  }

  Node* nodeA = edges12[0]->getOtherNode(nodeZ);
  Node* nodeB = edges12[1]->getOtherNode(nodeZ);
      

  // Pick a random location on the path from A to B and move Z to this new location.
  double X1andX2 = edges12[0]->getEdgeLen() + edges12[1]->getEdgeLen();
  // New edge length
  double newX1 = rand.runif()*(X1andX2);
  double newX2 = X1andX2 - newX1;
  if(rand.runif() > 0.5){
    double newtmp = newX1;
    newX1 = newX2;
    newX2 = newtmp;
  }
  double diffLen;
  int newN0, tmpNumE;

  InDelHistory* IDH1;
  InDelHistory* IDH2;

  vector<int> HMGin(0);

  HMGin.resize(0);

  IDH1 = edges12[0]->getIDH();
  IDH2 = edges12[1]->getIDH();


  
  if((nodeZ->getRoot()) || (nodeZ->getparentIndex() == Edgenum)){  // Z is Root or Root is in a subtree which edge3 connects to Z.

    if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge1


      diffLen = edges12[0]->getEdgeLen() - newX1;
      // case 1 or case 1a
      if(IDH1->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
	
	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) - diffLen, i);
 	edges12[0]->setEdgeLen(newX1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) + diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);


	// case 1a
	if(nodeZ->getRoot()){


	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeC->UpdateRootSites(params);

	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;	  

	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);

	// case 1  
	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
       
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);
	  nodeZ->CalSubTreeProb(params);

	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;

	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	 
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);

	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    UpdateAllinfoToRoot(params, nodeC->getParent());

	  }
	
        }
	
	
      }else{


	// case 2 or case 2a
	i = 1;
	while(IDH1->getV(i) <= diffLen){
	  i++;
	}
	i--;

	newN0 = IDH1->getN(i);
	IDH1->eraseHistory(1, 0);
	IDH2->eraseHistory(1, 0);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);

	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){

	  j = i - m + 1;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(m-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->insertHistory(0, m, diffLen - IDH1->getV(j), -1, IDH1->getP(j), IDH1->getL(j), (IDH2->getN(m-1) - IDH1->getL(j)) , HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(m-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->insertHistory(0, m, diffLen - IDH1->getV(j), 1, IDH1->getP(j), IDH1->getL(j), (IDH2->getN(m-1) + IDH1->getL(j)), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, j);

	} 

	for(j = 1; j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(j = (tmpNumE+1); j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();

	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();


	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	// case 2a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();

	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);

	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);

	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeC->UpdateRootSites(params);

	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	 
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);


	// case 2  
	}else{               


	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	  

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }

        }	

      }

    }else{  // else if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge2

      diffLen = edges12[1]->getEdgeLen() - newX2;

      // case 3 or case 3a
      if(IDH2->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
	
	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) - diffLen, i);
  	edges12[1]->setEdgeLen(newX2);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) + diffLen, i);
	edges12[0]->setEdgeLen(newX1);

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	// case 3a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);
	 

	// case 3  
	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    
	 
	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }
	
        }
		
      }else{


	// case 4
	i = 1;
	while(IDH2->getV(i) <= diffLen){
	  i++;
	}
	i--;

	newN0 = IDH2->getN(i);

	IDH2->eraseHistory(1, 0);
	IDH1->eraseHistory(1, 0);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

        tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){

	  j = i - m + 1;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(m-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->insertHistory(0, m, diffLen - IDH2->getV(j), -1, IDH2->getP(j), IDH2->getL(j), (IDH1->getN(m-1) - IDH2->getL(j)), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(m-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->insertHistory(0, m, diffLen - IDH2->getV(j), 1, IDH2->getP(j), IDH2->getL(j), (IDH1->getN(m-1) + IDH2->getL(j)), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, j);

	} 

	for(j = 1; j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	// case 4a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);



	// case 4  
	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	  

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }

        }

      }

    }

  }else if(nodeZ->getParentEdge()->getnumber() == edges12[0]->getnumber()){  // Root is in a subtree which edge1 connects to A.


    if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge1
      
      diffLen = edges12[0]->getEdgeLen() - newX1;

      // case 5
      if(edges12[0]->getEdgeLen() - IDH1->getV(IDH1->getNumE()) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.

 	edges12[0]->setEdgeLen(newX1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) + diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeA);
	
      }else{

	// case 6
	i = IDH1->getNumE();
	while(edges12[0]->getEdgeLen() - IDH1->getV(i) <= diffLen){
	  i--;
	}
	i++;

	newN0 = IDH1->getN(i-1);

	IDH2->eraseHistory(1, 0);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = IDH1->getNumE() - i + 1;

	for(m = 1; m <= tmpNumE; m++){

	  j = i;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(m-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->insertHistory(0, m, diffLen - (edges12[0]->getEdgeLen() - IDH1->getV(j)), 1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(m-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->insertHistory(0, m, diffLen - (edges12[0]->getEdgeLen() - IDH1->getV(j)), -1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, i);
	}

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);
	IDH1->setN(newN0, IDH1->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);
	nodeB->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeA->getRoot()){
	  
	  nodeA->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeA->CalloglikeliofRootSites(params);
	  nodeA->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeA->getParent());
	    
	}
      }

    }else{  // else if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge2

      diffLen = edges12[1]->getEdgeLen() - newX2;

      // case 7
      if(IDH2->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.

 	edges12[0]->setEdgeLen(newX1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) - diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  
	UpdateAllinfoToRoot(params, nodeA);

      }else{

	// case 8
	i = 1;
	while(IDH2->getV(i) <= diffLen){
	  i++;
	}
	i--;


	newN0 = IDH2->getN(i);

	IDH2->eraseHistory(1, 0);
	IDH1->eraseHistory(1);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){
	  j = 1;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(IDH1->getNumE());
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->addHistory(0, edges12[0]->getEdgeLen() + IDH2->getV(j), 1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(IDH1->getNumE());
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->addHistory(0, edges12[0]->getEdgeLen() + IDH2->getV(j), -1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, 1);
	}

	IDH1->addHistory(1, newX1, -2, 0, 0, IDH1->getN(IDH1->getNumE()), IDH1->getHMG(IDH1->getNumE()));


	for(j = 1; j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);
	nodeB->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeA->getRoot()){
	  
	  nodeA->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeA->CalloglikeliofRootSites(params);
	  nodeA->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeA->getParent());
	    
	}
	
      }

    }

  }else{  // Root is in a subtree which edge2 connects to B.


    if(newX2 < edges12[1]->getEdgeLen()){  // Z will be moved in the direction of edge2
     
      diffLen = edges12[1]->getEdgeLen() - newX2;

      // case 9
      if(edges12[1]->getEdgeLen() - IDH2->getV(IDH2->getNumE()) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
  
 	edges12[1]->setEdgeLen(newX2);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) + diffLen, i);
 	edges12[0]->setEdgeLen(newX1);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  
	UpdateAllinfoToRoot(params, nodeB);

      }else{

 
	// case 10
	i = IDH2->getNumE();
	while(edges12[1]->getEdgeLen() - IDH2->getV(i) <= diffLen){
	  i--;
	}
	i++;

	newN0 = IDH2->getN(i-1);

	IDH1->eraseHistory(1, 0);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = IDH2->getNumE() - i + 1;

	for(m = 1; m <= tmpNumE; m++){

	  j = i;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(m-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->insertHistory(0, m, diffLen - (edges12[1]->getEdgeLen() - IDH2->getV(j)), 1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(m-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->insertHistory(0, m, diffLen - (edges12[1]->getEdgeLen() - IDH2->getV(j)), -1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, i);
	}

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);
	IDH2->setN(newN0, IDH2->getNumE() + 1);

	for(j = (tmpNumE+1); j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);
	nodeA->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeB->getRoot()){
	  
	  nodeB->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeB->CalloglikeliofRootSites(params);
	  nodeB->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeB->getParent());
	    
	}	
      }

    }else{  // else if(newX2 < edges12[1]->getEdgeLen()){  // Z will be moved in the direction of edge1


      diffLen = edges12[0]->getEdgeLen() - newX1;

      // case 11
      if(IDH1->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.

 	edges12[1]->setEdgeLen(newX2);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) - diffLen, i);
 	edges12[0]->setEdgeLen(newX1);
	
	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }

	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  
	UpdateAllinfoToRoot(params, nodeB);

      }else{

	// case 12
	i = 1;
	while(IDH1->getV(i) <= diffLen){
	  i++;
	}
	i--;

	newN0 = IDH1->getN(i);

	IDH1->eraseHistory(1, 0);
	IDH2->eraseHistory(1);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){
	  j = 1;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(IDH2->getNumE());
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->addHistory(0, edges12[1]->getEdgeLen() + IDH1->getV(j), 1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(IDH2->getNumE());
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->addHistory(0, edges12[1]->getEdgeLen() + IDH1->getV(j), -1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, 1);
	}

	IDH2->addHistory(1, newX2, -2, 0, 0, IDH2->getN(IDH2->getNumE()), IDH2->getHMG(IDH2->getNumE()));


	for(j = 1; j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	nodeZ->setSeqLen(newN0);
	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	if(nodeZ == edge3->getEnd()){
	  edge3->ReverseEdge();
	  edge3->runEdge(rand,params);
	  edge3->calHMG();	
	  N_psl= edge3->ProposHistory(params);
	  edge3->ReverseEdge();
	}else{
	  edge3->runEdge(rand,params);
	  edge3->calHMG();
	  N_psl= edge3->ProposHistory(params);
        }
	
	N_IDHlike = edge3->likeliHistory(params);

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);
	nodeA->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeB->getRoot()){
	  
	  nodeB->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeB->CalloglikeliofRootSites(params);
	  nodeB->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeB->getParent());
	    
	}
	
      }

    }

  }
 


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];

  // IDH like
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];
  edges12[0]->likeliHistory(params);
  edges12[1]->likeliHistory(params);  
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  // Edge like
  edges12[0]->CalculatelogLikeliEdge(params);
  edges12[1]->CalculatelogLikeliEdge(params); 
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);



  //N_psl= edge3->ProposHistory(params);
  
  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<  exp(O_psl - N_psl) << endl;




  return AP;

} // end of SPRonSinglEdge










double Tree::SPRonSingleEdge_v0(Rand &rand,const Parameters &params) {

  int i, j, k, m, tmphmg;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_seqlenZ;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  O_seqlenZ = nodeZ->getSeqLen();
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  //cout << "nodeZ->getRoot() " << nodeZ->getRoot() << endl;

  // Select an adjacent edge e3 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge3 = nodeZ->getEdge(Edgenum);

  //cout << "Edgenum " << Edgenum << endl;
  //cout << "edge3->getnumber() " << edge3->getnumber() << endl;



  O_IDHlike = edge3->likeliHistory(params);
  //cout << "O_IDHlike " << O_IDHlike << endl;

  O_psl= edge3->ProposHistory(params);


  //cout << "O_psl " << O_psl << endl;
  
  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge3->getOtherNode(nodeZ);

  //cout << "nodeC->getnumber() " << nodeC->getnumber() << endl;

  Edge* edges12[2];
  // The other two adjacent edges e1 and e2 connect Z to nodes A and B, respectively. 
  j = 0;
  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(Edgenum!=i){
      edges12[j] = nodeZ->getEdge(i);
      j++;
    }
  }



  //cout << "edges12[0]->getnumber() " << edges12[0]->getnumber()  << endl;
  //cout << "edges12[1]->getnumber() " << edges12[1]->getnumber()  << endl;

  Node* nodeA = edges12[0]->getOtherNode(nodeZ);
  Node* nodeB = edges12[1]->getOtherNode(nodeZ);
      
  //cout << "nodeA->getnumber() " << nodeA->getnumber() << endl;
  //cout << "nodeB->getnumber() " << nodeB->getnumber() << endl;

  // Pick a random location on the path from A to B and move Z to this new location.
  double X1andX2 = edges12[0]->getEdgeLen() + edges12[1]->getEdgeLen();
  // New edge length
  double newX1 = rand.runif()*(X1andX2);
  double newX2 = X1andX2 - newX1;
  double diffLen;
  int newN0, tmpNumE;

  //cout << "X1andX2 " << X1andX2 << endl;
  //cout << "newX1 " << newX1 << endl;
  //cout << "newX2 " << newX2 << endl;


  InDelHistory* IDH1;
  InDelHistory* IDH2;

  vector<int> HMGin(0);

  HMGin.resize(0);

  IDH1 = edges12[0]->getIDH();
  IDH2 = edges12[1]->getIDH();


  

  //cout << "start " << endl;


  if((nodeZ->getRoot()) || (nodeZ->getparentIndex() == Edgenum)){  // Z is Root or Root is in a subtree which edge3 connects to Z.


    //cout << "case1234 " << endl;
    if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge1


      diffLen = edges12[0]->getEdgeLen() - newX1;
      // case 1 or case 1a
      if(IDH1->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
	

	//cout << "case1 " << endl;
	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) - diffLen, i);
 	edges12[0]->setEdgeLen(newX1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) + diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);



	//cout << "A " << endl;
	//checkTree();

	// case 1a
	if(nodeZ->getRoot()){


	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  //cout << "B " << endl;
	//checkTree();


	  nodeB->CalSubTreeProb(params);
	  //cout << "C " << endl;
	//checkTree();



	  nodeC->UpdateRootSites(params);
	  //cout << "D " << endl;
	//checkTree();


	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  //cout << "E " << endl;
	//checkTree();
	  


	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);

	  //cout << "F " << endl;
	//checkTree();


	// case 1  

	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    


	  //cout << "G " << endl;
	//checkTree();


	  set0UpdatedNodeinRootSites();
	
	  //cout << "H " << endl;
	//checkTree();



	  nodeA->CalSubTreeProb(params);

	  //cout << "I " << endl;
	//checkTree();


	  nodeB->CalSubTreeProb(params);


	  //cout << "J " << endl;
	//checkTree();


	  nodeZ->CalSubTreeProb(params);

	  //cout << "K " << endl;
	//checkTree();


	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;


	  //cout << "L " << endl;
	//checkTree();

	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  //cout << "M " << endl;
	//checkTree();



	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	   
	    //cout << "1 " << endl;
	//checkTree();



	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);

	    //cout << "2 " << endl;
	//checkTree();


	    nodeC->CalSubTreeProb(params);

	    //cout << "3 " << endl;
	//checkTree();



	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    //cout << "4 " << endl;
	//checkTree();



	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    

	    //cout << "5 " << endl;
	//checkTree();


	  }
	
        }
	
	
      }else{


	//cout << "case2 " << endl;
      // case 2 or case 2a
	i = 1;
	while(IDH1->getV(i) <= diffLen){
	  i++;
	}
	i--;


	//cout << "6 " << endl;
	//checkTree();


	newN0 = IDH1->getN(i);


	//cout << "7 " << endl;
	//checkTree();

	IDH1->eraseHistory(1, 0);

	//cout << "8 " << endl;
	//checkTree();



	IDH2->eraseHistory(1, 0);

	//cout << "9 " << endl;
	//checkTree();


	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	//cout << "10 " << endl;
	//checkTree();


	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);


	//cout << "11 " << endl;
	//checkTree();


	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);

	//cout << "12 " << endl;
	//checkTree();


	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){

	  j = i - m + 1;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(m-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->insertHistory(0, m, diffLen - IDH1->getV(j), -1, IDH1->getP(j), IDH1->getL(j), (IDH2->getN(m-1) - IDH1->getL(j)) , HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(m-1);
            /*** shim HMG ****/
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->insertHistory(0, m, diffLen - IDH1->getV(j), 1, IDH1->getP(j), IDH1->getL(j), (IDH2->getN(m-1) + IDH1->getL(j)), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, j);

	} 


	//cout << "13 " << endl;
	//checkTree();



	for(j = 1; j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
            /*** shim HMG ****/
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
	  }	    
        }

	//cout << "14 " << endl;
	//checkTree();
 

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);

	//cout << "15 " << endl;
	//checkTree();


	IDH1->setV(newX1, IDH1->getNumE() + 1);

	//cout << "16 " << endl;
	//checkTree();



	for(j = (tmpNumE+1); j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    /*** shim HMG ****/
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
	  }	    
        }

	//cout << "17 " << endl;
	//checkTree();


	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);


	//cout << "18 " << endl;
	//checkTree();


	IDH2->setV(newX2, IDH2->getNumE() + 1);

	//cout << "19 " << endl;
	//checkTree();

	nodeZ->setSeqLen(newN0);

	//cout << "20 " << endl;
	//checkTree();

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();

	//cout << "21 " << endl;
	//checkTree();


	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();


	//cout << "22 " << endl;
	//checkTree();


	edge3->runEdge(rand,params);
	edge3->calHMG();

	//cout << "23 " << endl;
	//checkTree();


	N_IDHlike = edge3->likeliHistory(params);

	//cout << "24 " << endl;
	//checkTree();


	// case 2a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	

	//cout << "25 " << endl;
	//checkTree();


	  nodeA->CalSubTreeProb(params);

	//cout << "26 " << endl;
	//checkTree();


	  nodeA->UpdateRootSites(params);

	//cout << "27 " << endl;
	//checkTree();


	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

	//cout << "28 " << endl;
	//checkTree();


	  nodeB->CalSubTreeProb(params);

	//cout << "29 " << endl;
	//checkTree();

	  nodeB->UpdateRootSites(params);

	//cout << "30 " << endl;
	//checkTree();


	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	//cout << "31 " << endl;
	//checkTree();



	  nodeC->UpdateRootSites(params);

	//cout << "32 " << endl;
	//checkTree();

	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  

	//cout << "33 " << endl;
	//checkTree();

	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);


	//cout << "34 " << endl;
	//checkTree();

	// case 2  

	}else{               


	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    


	  //cout << "35 " << endl;
	  //checkTree();



	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	  

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }


	//cout << "36 " << endl;
	//checkTree();	  
	
        }	
      }

    }else{  // else if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge2

      diffLen = edges12[1]->getEdgeLen() - newX2;

      // case 3 or case 3a
      if(IDH2->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.

	////cout << "case3 " << endl;

	//cout << "37 " << endl;
	//checkTree();

	
	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) - diffLen, i);
  	edges12[1]->setEdgeLen(newX2);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) + diffLen, i);
	edges12[0]->setEdgeLen(newX1);

	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 3a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);
	  
	  //cout << "38 " << endl;
	//checkTree();

	// case 3  

	}else{               


	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    
	  
	//cout << "39 " << endl;
	//checkTree();


	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeB->CalSubTreeProb(params);

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }

	//cout << "40 " << endl;
	//checkTree();

	
        }
		
      }else{


	////cout << "case4 " << endl;

      // case 4
	i = 1;
	while(IDH2->getV(i) <= diffLen){
	  i++;
	}
	i--;

	//cout << "41 " << endl;
	//checkTree();


	//cout << "i " << i << endl;

	newN0 = IDH2->getN(i);

	//cout << "newN0 " << newN0 << endl;

	IDH2->eraseHistory(1, 0);
	IDH1->eraseHistory(1, 0);

      
	//cout << "AAAAA "  << endl; 

	/*
    cout << endl << "#### FROM IDH1 ####" << endl;
    cout << "numE " << IDH1->getNumE() << endl;
    for(j =0; j< IDH1->getIDHsize(); j++){ 
      cout << "ID " << IDH1->getID(j) << endl;
      cout << "L " << IDH1->getL(j) << endl;
      cout << "P " << IDH1->getP(j) << endl;
      cout << "V " << IDH1->getV(j) << endl;
      cout << "N " << IDH1->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH1->getHMG(j).size(); m++){
	cout << IDH1->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
 
    cout << endl << "#### FROM IDH2 ####" << endl;
    cout << "numE " << IDH2->getNumE() << endl;
    for(j =0; j< IDH2->getIDHsize(); j++){  
      cout << "ID " << IDH2->getID(j) << endl;
      cout << "L " << IDH2->getL(j) << endl;
      cout << "P " << IDH2->getP(j) << endl;
      cout << "V " << IDH2->getV(j) << endl;
      cout << "N " << IDH2->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH2->getHMG(j).size(); m++){
	cout << IDH2->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
      
	*/

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	


	/*
    cout << "BBBBB "  << endl; 

    cout << endl << "#### FROM IDH1 ####" << endl;
    cout << "numE " << IDH1->getNumE() << endl;
    for(j =0; j< IDH1->getIDHsize(); j++){ 
      cout << "ID " << IDH1->getID(j) << endl;
      cout << "L " << IDH1->getL(j) << endl;
      cout << "P " << IDH1->getP(j) << endl;
      cout << "V " << IDH1->getV(j) << endl;
      cout << "N " << IDH1->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH1->getHMG(j).size(); m++){
	cout << IDH1->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
 
    cout << endl << "#### FROM IDH2 ####" << endl;
    cout << "numE " << IDH2->getNumE() << endl;
    for(j =0; j< IDH2->getIDHsize(); j++){  
      cout << "ID " << IDH2->getID(j) << endl;
      cout << "L " << IDH2->getL(j) << endl;
      cout << "P " << IDH2->getP(j) << endl;
      cout << "V " << IDH2->getV(j) << endl;
      cout << "N " << IDH2->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH2->getHMG(j).size(); m++){
	cout << IDH2->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
      
	*/


        tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){

	  j = i - m + 1;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(m-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->insertHistory(0, m, diffLen - IDH2->getV(j), -1, IDH2->getP(j), IDH2->getL(j), (IDH1->getN(m-1) - IDH2->getL(j)), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(m-1);
            /**** shim HMG ***/
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->insertHistory(0, m, diffLen - IDH2->getV(j), 1, IDH2->getP(j), IDH2->getL(j), (IDH1->getN(m-1) + IDH2->getL(j)), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, j);

	} 

	for(j = 1; j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
            /**** shim HMG ****/
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    /**** shim HMG ****/
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);



	/*
    cout << "CCCCCCC "  << endl; 

    cout << endl << "#### FROM IDH1 ####" << endl;
    cout << "numE " << IDH1->getNumE() << endl;
    for(j =0; j< IDH1->getIDHsize(); j++){ 
      cout << "ID " << IDH1->getID(j) << endl;
      cout << "L " << IDH1->getL(j) << endl;
      cout << "P " << IDH1->getP(j) << endl;
      cout << "V " << IDH1->getV(j) << endl;
      cout << "N " << IDH1->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH1->getHMG(j).size(); m++){
	cout << IDH1->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
 
    cout << endl << "#### FROM IDH2 ####" << endl;
    cout << "numE " << IDH2->getNumE() << endl;
    for(j =0; j< IDH2->getIDHsize(); j++){  
      cout << "ID " << IDH2->getID(j) << endl;
      cout << "L " << IDH2->getL(j) << endl;
      cout << "P " << IDH2->getP(j) << endl;
      cout << "V " << IDH2->getV(j) << endl;
      cout << "N " << IDH2->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH2->getHMG(j).size(); m++){
	cout << IDH2->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
      
	*/



	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();



	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 4a
	if(nodeZ->getRoot()){

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  

	  nodeC->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  nodeZ->CalloglikeliofUpdatedLinkedSites(params);


	//cout << "42 " << endl;
	//checkTree();

	// case 4  

	}else{               

	  r = params.getR();
	  O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
	  N_IDHlike +=  log(r) + O_seqlenZ*log(1-r);    

	  set0UpdatedNodeinRootSites();
	
	  nodeA->CalSubTreeProb(params);
	  nodeA->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	  

	  nodeB->CalSubTreeProb(params);
	  nodeB->UpdateRootSites(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

	  nodeZ->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  nodeZ->CalloglikeliofUpdatedRootSites(params);
	  
	  if(nodeC->getRoot()){
	    
	    nodeC->CalloglikeliofUpdatedLinkedSites(params);
	    
	  }else{
	    
	    nodeC->CalloglikeliofRootSites(params);
	    nodeC->CalSubTreeProb(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    UpdateAllinfoToRoot(params, nodeC->getParent());
	    
	  }


	//cout << "43 " << endl;
	//checkTree();

	
        }

      }

    }

  }else if(nodeZ->getParentEdge()->getnumber() == edges12[0]->getnumber()){  // Root is in a subtree which edge1 connects to A.

    //cout << "case5678 " << endl;

    if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge1


      
      diffLen = edges12[0]->getEdgeLen() - newX1;
      // case 5
      if(edges12[0]->getEdgeLen() - IDH1->getV(IDH1->getNumE()) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.


	//cout << "case5 " << endl;
 	edges12[0]->setEdgeLen(newX1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) + diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 5

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeA);

	//cout << "44 " << endl;
	//checkTree();

	
      }else{


	//cout << "case6 " << endl;
      // case 6
	i = IDH1->getNumE();
	while(edges12[0]->getEdgeLen() - IDH1->getV(i) <= diffLen){
	  i--;
	}
	i++;


	//cout << " i : " << i << endl;


	newN0 = IDH1->getN(i-1);


	//cout << " newN0 : " << newN0 << endl;


	IDH2->eraseHistory(1, 0);


	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = IDH1->getNumE() - i + 1;

	for(m = 1; m <= tmpNumE; m++){

	  j = i;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(m-1);
	    /*** shim HMG *****/
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->insertHistory(0, m, diffLen - (edges12[0]->getEdgeLen() - IDH1->getV(j)), 1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(m-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->insertHistory(0, m, diffLen - (edges12[0]->getEdgeLen() - IDH1->getV(j)), -1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, i);
	}

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);
	IDH1->setN(newN0, IDH1->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    /**** shim HMG *****/
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)+diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();



	edge3->runEdge(rand,params);	
	edge3->calHMG();


	//cout << "45.a" << endl;
	//checkTree();




	N_IDHlike = edge3->likeliHistory(params);

	// case 6

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);
	nodeB->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeA->getRoot()){
	  
	  nodeA->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeA->CalloglikeliofRootSites(params);
	  nodeA->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeA->getParent());
	    
	}

	//cout << "45 " << endl;
	//checkTree();


      }

    }else{  // else if(newX1 < edges12[0]->getEdgeLen()){  // Z will be moved in the direction of edge2


      diffLen = edges12[1]->getEdgeLen() - newX2;
      // case 7
      if(IDH2->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.


	//cout << "case7 " << endl;
 	edges12[0]->setEdgeLen(newX1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	for(i = 1; i <= (IDH2->getNumE() + 1); i++)
	  IDH2->setV(IDH2->getV(i) - diffLen, i);
 	edges12[1]->setEdgeLen(newX2);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 7

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeA);


	//cout << "46 " << endl;
	//checkTree();
		

	
      }else{


	//cout << "case8 " << endl;
      // case 8
	i = 1;
	while(IDH2->getV(i) <= diffLen){
	  i++;
	}
	i--;


	newN0 = IDH2->getN(i);

	IDH2->eraseHistory(1, 0);
	IDH1->eraseHistory(1);

	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH2->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){
	  j = 1;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(IDH1->getNumE());
	    /*** shim HMG ****/
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->addHistory(0, edges12[0]->getEdgeLen() + IDH2->getV(j), 1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(IDH1->getNumE());
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->addHistory(0, edges12[0]->getEdgeLen() + IDH2->getV(j), -1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, 1);
	}

	IDH1->addHistory(1, newX1, -2, 0, 0, IDH1->getN(IDH1->getNumE()), IDH1->getHMG(IDH1->getNumE()));


	for(j = 1; j <= IDH2->getNumE(); j++){
	  if(IDH2->getID(j)==1){
	    HMGin = IDH2->getHMG(j-1);
	    /**** shim HMG *****/
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH2->getHMG(j-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH2->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH2->setV(IDH2->getV(j)-diffLen, j);
	  }	    
        }

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();



	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 8

	set0UpdatedNodeinRootSites();
	
	nodeB->CalSubTreeProb(params);
	nodeB->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeA->getRoot()){
	  
	  nodeA->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeA->CalloglikeliofRootSites(params);
	  nodeA->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeA->getParent());
	    
	}

	//cout << "47 " << endl;
	//checkTree();

	
      }

    }



  }else{  // Root is in a subtree which edge2 connects to B.

    //cout << "case9101112 AAAA" << endl;

    if(newX2 < edges12[1]->getEdgeLen()){  // Z will be moved in the direction of edge2


     
      diffLen = edges12[1]->getEdgeLen() - newX2;
      // case 9
      if(edges12[1]->getEdgeLen() - IDH2->getV(IDH2->getNumE()) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.
	//cout << "case9 " << endl;
 	edges12[1]->setEdgeLen(newX2);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) + diffLen, i);
 	edges12[0]->setEdgeLen(newX1);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 9

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeB);


	//cout << "48 " << endl;
	//checkTree();
	
      }else{

	//cout << "case10 " << endl;
      // case 10
	i = IDH2->getNumE();
	while(edges12[1]->getEdgeLen() - IDH2->getV(i) <= diffLen){
	  i--;
	}
	i++;

	//cout << "i " << i << endl;

	newN0 = IDH2->getN(i-1);

	//cout << "newN0 " << newN0 << endl;	

	IDH1->eraseHistory(1, 0);


	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	tmpNumE = IDH2->getNumE() - i + 1;

	for(m = 1; m <= tmpNumE; m++){

	  j = i;
	  if(IDH2->getID(j)==1){
	    HMGin = IDH1->getHMG(m-1);
	    /**** shim HMG ****/
	    //tmphmg = HMGin[IDH2->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH2->getP(j),tmphmg);
	    IDH1->insertHistory(0, m, diffLen - (edges12[1]->getEdgeLen() - IDH2->getV(j)), 1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH1->getHMG(m-1);
	    for( k = 0; k < IDH2->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH2->getP(j));
	    IDH1->insertHistory(0, m, diffLen - (edges12[1]->getEdgeLen() - IDH2->getV(j)), -1, IDH2->getP(j), IDH2->getL(j), IDH2->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH2->eraseHistory(0, i);
	}

	IDH2->setHMG(IDH2->getHMG(IDH2->getNumE()), IDH2->getNumE() + 1);
	IDH2->setV(newX2, IDH2->getNumE() + 1);
	IDH2->setN(newN0, IDH2->getNumE() + 1);


	for(j = (tmpNumE+1); j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    /*** shim HMG ****/
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)+diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	nodeZ->setSeqLen(newN0);

	edges12[0]->setEdgeLen(newX1);
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	edges12[1]->calHMG();

	

	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 10

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);
	nodeA->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;


	//cout << "49 " << endl;
	//checkTree();

	  
	if(nodeB->getRoot()){
	  
	  nodeB->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeB->CalloglikeliofRootSites(params);
	  nodeB->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeB->getParent());
	    
	}


	//cout << "50 " << endl;
	//checkTree();
	
      }

    }else{  // else if(newX2 < edges12[1]->getEdgeLen()){  // Z will be moved in the direction of edge1


      diffLen = edges12[0]->getEdgeLen() - newX1;

      // case 11
      if(IDH1->getV(1) > diffLen){  // All events will remain in the new edge1, but edge length should be changed.


	//cout << "case11 " << endl;
 	edges12[1]->setEdgeLen(newX2);
	IDH2->setV(newX2, IDH2->getNumE() + 1);

	for(i = 1; i <= (IDH1->getNumE() + 1); i++)
	  IDH1->setV(IDH1->getV(i) - diffLen, i);
 	edges12[0]->setEdgeLen(newX1);
	
	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);

	// case 11

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);

	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	nodeZ->CalloglikeliofRootSites(params);
	  

	UpdateAllinfoToRoot(params, nodeB);


	//cout << "51 " << endl;
	//checkTree();


	
      }else{


	//cout << "case12 " << endl;
      // case 12
	i = 1;
	while(IDH1->getV(i) <= diffLen){
	  i++;
	}
	i--;

	//cout << "i " << i << endl;

	newN0 = IDH1->getN(i);

	//cout << "newN0 " << newN0 << endl;

	IDH1->eraseHistory(1, 0);
	IDH2->eraseHistory(1);

	/*
    cout << "AAAAA "  << endl; 

    cout << endl << "#### FROM IDH1 ####" << endl;
    cout << "numE " << IDH1->getNumE() << endl;
    for(j =0; j< IDH1->getIDHsize(); j++){ 
      cout << "ID " << IDH1->getID(j) << endl;
      cout << "L " << IDH1->getL(j) << endl;
      cout << "P " << IDH1->getP(j) << endl;
      cout << "V " << IDH1->getV(j) << endl;
      cout << "N " << IDH1->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH1->getHMG(j).size(); m++){
	cout << IDH1->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
 
    cout << endl << "#### FROM IDH2 ####" << endl;
    cout << "numE " << IDH2->getNumE() << endl;
    for(j =0; j< IDH2->getIDHsize(); j++){  
      cout << "ID " << IDH2->getID(j) << endl;
      cout << "L " << IDH2->getL(j) << endl;
      cout << "P " << IDH2->getP(j) << endl;
      cout << "V " << IDH2->getV(j) << endl;
      cout << "N " << IDH2->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH2->getHMG(j).size(); m++){
	cout << IDH2->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
	*/



	for( k = 0; k <= newN0; k++){
	  HMGin.push_back(k);
	}

	IDH1->insertHistory(1, 0, 0, -2, 0, 0, newN0, HMGin);
	HMGin.resize(0);	

	/*
	cout << "BBBBB "  << endl; 

    cout << endl << "#### FROM IDH1 ####" << endl;
    cout << "numE " << IDH1->getNumE() << endl;
    for(j =0; j< IDH1->getIDHsize(); j++){  
      cout << "ID " << IDH1->getID(j) << endl;
      cout << "L " << IDH1->getL(j) << endl;
      cout << "P " << IDH1->getP(j) << endl;
      cout << "V " << IDH1->getV(j) << endl;
      cout << "N " << IDH1->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH1->getHMG(j).size(); m++){
	cout << IDH1->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
	*/


	tmpNumE = i;

	for(m = 1; m <= tmpNumE; m++){
	  j = 1;
	  if(IDH1->getID(j)==1){
	    HMGin = IDH2->getHMG(IDH2->getNumE());
	    /*** shim HMG ****/
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH2->addHistory(0, edges12[1]->getEdgeLen() + IDH1->getV(j), 1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
          }else{
	    HMGin = IDH2->getHMG(IDH2->getNumE());
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH2->addHistory(0, edges12[1]->getEdgeLen() + IDH1->getV(j), -1, IDH1->getP(j), IDH1->getL(j), IDH1->getN(j), HMGin);
	    HMGin.resize(0); 
	  }
	  IDH1->eraseHistory(0, 1);
	}

	IDH2->addHistory(1, newX2, -2, 0, 0, IDH2->getN(IDH2->getNumE()), IDH2->getHMG(IDH2->getNumE()));

	/*
        	cout << "CCCCC "  << endl; 
	cout << endl << "#### FROM IDH2 ####" << endl;
    cout << "numE " << IDH2->getNumE() << endl;
    for(j =0; j< IDH2->getIDHsize(); j++){ 
      cout << "ID " << IDH2->getID(j) << endl;
      cout << "L " << IDH2->getL(j) << endl;
      cout << "P " << IDH2->getP(j) << endl;
      cout << "V " << IDH2->getV(j) << endl;
      cout << "N " << IDH2->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH2->getHMG(j).size(); m++){
	cout << IDH2->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
 
	*/

	for(j = 1; j <= IDH1->getNumE(); j++){
	  if(IDH1->getID(j)==1){
	    HMGin = IDH1->getHMG(j-1);
	    /*** shim HMG ****/
	    //tmphmg = HMGin[IDH1->getP(j)];
	    tmphmg = -1;
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.insert(HMGin.begin()+ IDH1->getP(j),tmphmg);
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
          }else{
	    HMGin = IDH1->getHMG(j-1);
	    for( k = 0; k < IDH1->getL(j); k++)
	      HMGin.erase(HMGin.begin()+ IDH1->getP(j));
	    IDH1->setHMG(HMGin, j);
	    HMGin.resize(0); 
	    IDH1->setV(IDH1->getV(j)-diffLen, j);
	  }	    
        }

	IDH1->setHMG(IDH1->getHMG(IDH1->getNumE()), IDH1->getNumE() + 1);
	IDH1->setV(newX1, IDH1->getNumE() + 1);

	/*
	cout << "DDDDD "  << endl; 
	    cout << endl << "#### FROM IDH1 ####" << endl;
    cout << "numE " << IDH1->getNumE() << endl;
    for(j =0; j< IDH1->getIDHsize(); j++){ 
      cout << "ID " << IDH1->getID(j) << endl;
      cout << "L " << IDH1->getL(j) << endl;
      cout << "P " << IDH1->getP(j) << endl;
      cout << "V " << IDH1->getV(j) << endl;
      cout << "N " << IDH1->getN(j) << endl;
      cout << endl << "HMG "  << endl;
      for(m=0; m < IDH1->getHMG(j).size(); m++){
	cout << IDH1->getHMG(j,m) << " ";
      }   
      cout << endl;
    }
	*/

	nodeZ->setSeqLen(newN0);
	edges12[0]->setEdgeLen(newX1);
	//cout << "AAA" << endl;
	edges12[0]->calHMG();
	edges12[1]->setEdgeLen(newX2);
	//cout << "BBB" << endl;
	edges12[1]->calHMG();

	

	edge3->runEdge(rand,params);
	edge3->calHMG();

	N_IDHlike = edge3->likeliHistory(params);


	// case 12

	set0UpdatedNodeinRootSites();
	
	nodeA->CalSubTreeProb(params);
	nodeA->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	  
	nodeC->UpdateRootSites(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	nodeZ->CalSubTreeProb(params);
	nodeZ->CalloglikeliofUpdatedRootSites(params);
	UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
	  
	if(nodeB->getRoot()){
	  
	  nodeB->CalloglikeliofUpdatedLinkedSites(params);
	  
	}else{
	  
	  nodeB->CalloglikeliofRootSites(params);
	  nodeB->CalSubTreeProb(params);
	  UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
	  
	  UpdateAllinfoToRoot(params, nodeB->getParent());
	    
	}


	//cout << "51 " << endl;
	//checkTree();

	
      }

    }

  }
 
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];
  N_psl= edge3->ProposHistory(params);

  //double O_IDHslike, N_IDHslike;

  //O_IDHslike = logLikeliIDH[current];
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHslike = logLikeliIDH[current];


  
  // find_bug3 //
  //logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  logLikeliIDH[current] = likeliHistory(params);
  edges12[0]->CalculatelogLikeliEdge(params);
  edges12[1]->CalculatelogLikeliEdge(params); 
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);

  
  
  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  //AP = exp(N_datalike + N_IDHslike + O_psl - O_datalike - O_IDHslike - N_psl);


	//cout << "52 " << endl;
	//checkTree();

  /*
  cout << endl << endl;
  cout << "APAPAPAPAPAPAPAPAPAPAPAPAPAPAPAPAP" << endl << endl;
  cout << "O_datalike " << O_datalike << endl;
  cout << "N_datalike " << N_datalike << endl;
  cout << "O_IDHlike " << O_IDHlike << endl;
  cout << "N_IDHlike " << N_IDHlike << endl;
  cout << "O_psl " << O_psl << endl;
  cout << "N_psl " << N_psl << endl;
  cout << "AP " << AP << endl;
  */

  return AP;

} // end of SPRonSinglEdge






// combine IDHs on Pedge(Parent Edge) and Cedge(Child Edge).
// Save result on Pedge.
// Pedge and Cedge share one node. 
// Pedge is parent edge of shared node.
// Edge length of Pedge will be changed.
void Tree::combineIDHonTwoEdges(Edge* Pedge, Edge* Cedge){

  if(Pedge->getEnd()!=Cedge->getStart()){
    cout << "ERROR! Directions of Parent Edge or Child Edge is wrong!" << endl;
  }else{

    InDelHistory* pIDH;
    InDelHistory* cIDH;
    int numEofPedge, numEofCedge;
    vector<int> HMGin(0);
    int i, k;
    
    HMGin.resize(0);
    pIDH = Pedge->getIDH();
    cIDH = Cedge->getIDH();
    numEofPedge = pIDH->getNumE();
    numEofCedge = cIDH->getNumE();
    
    //double lastTimeIV = pIDH->getV(numEofPedge+1) - pIDH->getV(numEofPedge);
    double PedgeLen = pIDH->getV(numEofPedge+1);
    // Erase end of IDH on Pedge 
    pIDH->eraseHistory(1);
    
    // Add IDH on Cedge to Pedge
    HMGin = pIDH->getHMG(numEofPedge);
    for(i = 1; i <= numEofCedge; i++){
      if(cIDH->getID(i)==1){
	for( k = 0; k < cIDH->getL(i); k++)
	  HMGin.insert(HMGin.begin()+ cIDH->getP(i),-1);
	pIDH->addHistory(0, PedgeLen + cIDH->getV(i), 1, cIDH->getP(i), cIDH->getL(i), cIDH->getN(i), HMGin);
      }else{
	for( k = 0; k < cIDH->getL(i); k++)
	  HMGin.erase(HMGin.begin()+ cIDH->getP(i));
	pIDH->addHistory(0, PedgeLen + cIDH->getV(i), -1, cIDH->getP(i), cIDH->getL(i), cIDH->getN(i), HMGin);
      }
    }
    HMGin.resize(0);
    
    // Change edge length of Pedge
    Pedge->setEdgeLen(Pedge->getEdgeLen() + Cedge->getEdgeLen());
    
    // Add end of IDH on Pedge
    pIDH->addHistory(1, Pedge->getEdgeLen(), -2, 0, 0, pIDH->getN(pIDH->getNumE()), pIDH->getHMG(pIDH->getNumE()));
    

    Pedge->calHMG(); 
  }
}

// Separate IDH on Pedge(Parent Edge) into Pedge(Parent Edge) and Cedge(Child Edge) at a cutTime.
// Save result on Pedge and Cedge.
// Pedge and Cedge share one node. 
// Time t should be less than edge length of Pedge.
// Pedge is parent edge of shared node.
// Edge length of Pedge and Cedge will be changed.
void Tree::separateIDHintoTwoEdges(Edge* Pedge, Edge* Cedge, double cutTime){


  //cout << "In separateIDHintoTwoEdges " << endl;

  if(Pedge->getEnd()!=Cedge->getStart()){
    cout << "ERROR! Directions of Parent Edge or Child Edge is wrong!" << endl;
  }else if(cutTime >= Pedge->getEdgeLen()){
    cout << "ERROR! Time for separation is longer than edge length of parent edge!" << endl;
  }else{

    InDelHistory* pIDH;
    InDelHistory* cIDH;
    int numEofPedge, numEofCedge, startIX;
    vector<int> HMGin(0);
    int i, k;
    
    HMGin.resize(0);
    pIDH = Pedge->getIDH();
    cIDH = Cedge->getIDH();
    numEofPedge = pIDH->getNumE();
    numEofCedge = cIDH->getNumE();

    //cout << "numEofPedge : " <<  numEofPedge << endl;
    //cout << "numEofCedge : " <<  numEofCedge << endl;
   

    // Find index of first indel event on Pedge which should be moved to Cedge.
    for( i = 1; i <= numEofPedge; i++){
      if(pIDH->getV(i) > cutTime){
	startIX = i;
	break;
      }
    }

    //cout << "startIX : " << startIX << " i : " << i << endl;   

    if(i > numEofPedge){  // no event to move

      // Erase all old events on cIDH
      if(numEofCedge > 0)
	cIDH->eraseHistory(0, 1, numEofCedge);

      Cedge->setEdgeLen(Pedge->getEdgeLen() - cutTime);
      Pedge->setEdgeLen(cutTime);
      cIDH->setV(Cedge->getEdgeLen(), 1);
      pIDH->setV(Pedge->getEdgeLen(), (pIDH->getNumE()+1));
      cIDH->setN(pIDH->getN(numEofPedge),0);
      cIDH->setN(pIDH->getN(numEofPedge),1);

      for( k = 0; k <= cIDH->getN(0); k++){
	HMGin.push_back(k);
      }
      cIDH->setHMG(HMGin,0);
      cIDH->setHMG(HMGin,1);
      HMGin.resize(0);
      //cout << "AAAA " << endl;
      Cedge->calHMG(); 


    }else{    // at least one event to move

      // Set the first part of cIDH
      cIDH->setN(pIDH->getN(startIX-1),0);      
      for( k = 0; k <= cIDH->getN(0); k++){
	HMGin.push_back(k);
      }
      cIDH->setHMG(HMGin,0);
      //cout << "Cedge first HMG " << endl;
      //print_veci(cIDH->getHMG(0));
      HMGin.resize(0);

      //cout << "numEofCedge : " << numEofCedge << endl; 
      // Erase all old events on cIDH
      if(numEofCedge > 0)
	cIDH->eraseHistory(1, 1, numEofCedge+1);
      else
	cIDH->eraseHistory(1);  
      
      //cout << "cIDH numE : " << cIDH->getNumE() << endl;
      //cout << "IDHsize : " << cIDH->getIDHsize() << endl;
    
      // Move events from Pedge to Cedge
      HMGin = cIDH->getHMG(0);
      for(i = startIX; i <= numEofPedge; i++){
	if(pIDH->getID(i)==1){
	  for( k = 0; k < pIDH->getL(i); k++)
	    HMGin.insert(HMGin.begin()+ pIDH->getP(i),-1);
	  cIDH->addHistory(0, pIDH->getV(i) - cutTime, 1, pIDH->getP(i), pIDH->getL(i), pIDH->getN(i), HMGin);
	}else{
	  for( k = 0; k < pIDH->getL(i); k++)
	    HMGin.erase(HMGin.begin()+ pIDH->getP(i));
	  cIDH->addHistory(0, pIDH->getV(i) - cutTime, -1, pIDH->getP(i), pIDH->getL(i), pIDH->getN(i), HMGin);
	}
      }
      HMGin.resize(0);

      // Erase all old events on pIDH
      pIDH->eraseHistory(1, startIX, numEofPedge+1);

      // Reset edge lengths of Pedge and Cedge
      Cedge->setEdgeLen(Pedge->getEdgeLen() - cutTime);
      Pedge->setEdgeLen(cutTime);          

      // Set the last parts of pIDH and cIDH
      pIDH->addHistory(1, Pedge->getEdgeLen(), -2, 0, 0, pIDH->getN(pIDH->getNumE()), pIDH->getHMG(pIDH->getNumE()));
      cIDH->addHistory(1, Cedge->getEdgeLen(), -2, 0, 0, cIDH->getN(cIDH->getNumE()), cIDH->getHMG(cIDH->getNumE()));    

      //cout << "BBB " << endl;
      Pedge->calHMG(); 
      Cedge->calHMG(); 
    }
    //cout << "CCCC " << endl;
  }
}


  


// find a set of edges in a given maximum step
// StNode : start node
// StEdge : To this direction from StNode
// depth  : start from 1
// MaximumStep should be greater than 2
// Set    : edge number at Set 
void Tree::ConstructSetofEdgesinMaximumStep(int MaximumStep, int depth, vector<int> &Set, Edge* StEdge, Node* StNode){
  
  //cout << "In ConstructSetofEdgesinMaximumStep " << endl;

  int i;
  Node* EnNode;
  Edge* EnEdge; 
  int StEdgeNum = StEdge->getnumber();
  //vector<int> Mset(0);

  Set.push_back(StEdgeNum);
  //cout << "Set size :" << Set.size() << endl;
  //print_veci(Set);
  EnNode = StEdge->getOtherNode(StNode);
  

  if((!EnNode->getLeaf()) && ( depth < MaximumStep)){
    
    for( i=0; i < EnNode->getnumEdges(); i++){
      EnEdge = EnNode->getEdge(i);
      if(EnEdge->getnumber()!= StEdgeNum){
	//cout << "EnEdge->getnumber() : " << EnEdge->getnumber() << endl;
	ConstructSetofEdgesinMaximumStep(MaximumStep, depth + 1, Set, EnEdge, EnNode);
      }
    }
  }
}





// Extract IDH on (0, posiM) from subIDH
// Ignore HMG
double Tree::extractSubIDH(InDelHistory* IDH, InDelHistory* subIDH, int endPosi, double posiM){

  int i;
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG(0);

  int numE = IDH->getNumE();
  //if(IDH->getV(numE + 1) < posiM){
  //  cout << "ERROR in Tree::extractSubIDH" << endl;
  //  cout << "posiM : " << posiM << " IDH->getV(numE + 1) : " << IDH->getV(numE + 1) << endl;
  //}else{

    for(i = 0; i <= endPosi; i++){
      if(IDH->getV(i) < posiM){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
      }
    }
    int subNumE = i-1;
    V.push_back(posiM);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N[subNumE]);
    subIDH->setHistory(subNumE, V, ID, P, L, N, HMG);
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
 
    //}
  
}




// insert subIDH to IDH and keep IDH from endPosi + 1
// with HMG
double Tree::insertSubIDH(InDelHistory* IDH, InDelHistory* subIDH, int endPosi){

  int i, j, k;
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  int tmphmg = -1;



  int knumE = subIDH->getNumE();
  int numE  = IDH->getNumE();

  for(i = 0; i <= knumE ; i++){
    V.push_back(subIDH->getV(i));
    ID.push_back(subIDH->getID(i));
    P.push_back(subIDH->getP(i));
    L.push_back(subIDH->getL(i));
    N.push_back(subIDH->getN(i));
    HMG.push_back(subIDH->getHMG(i));
  }
  
  if(endPosi < numE){

    for(i = (endPosi+1); i <= numE; i++){ 
      V.push_back(IDH->getV(i));
      ID.push_back(IDH->getID(i));
      P.push_back(IDH->getP(i));
      L.push_back(IDH->getL(i));
      N.push_back(IDH->getN(i));
      j = (ID.size()-1);
      HMGin.resize(0);
      if(ID[j]==1){
	HMGin = HMG[j-1];
	for( k = 0; k < L[j]; k++)
	  HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	HMG.push_back(HMGin);
	HMGin.resize(0);	 
      }else{
	HMGin = HMG[j-1];
	for( k = 0; k < L[j]; k++)
	  HMGin.erase(HMGin.begin()+ P[j]);
	HMG.push_back(HMGin);
	HMGin.resize(0);
      }
    }
  }

  

  V.push_back(IDH->getV(numE+1));
  numE = ID.size()-1;
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N[numE]);
  HMG.push_back(HMG[numE]);



  IDH->setHistory(numE, V, ID, P, L, N, HMG);

  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  
}




// Generate IDH given N0, Nend and time
// with HMG
//--- v20 start --//
/*
double Tree::runEdge(Rand &rand, const Parameters &params, InDelHistory* IDH, int N0, int Nend, double Time){


  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  


  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int i, k, d;
  int numE;
  double eta;
  double dt, tempTime;
  double prob1;   



  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



  // Generate Events
  while(1){
    eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   
    dt = -log(1.0-rand.runif()) / eta;  

    tempTime = tempTime+dt;
    if(tempTime<0){
      cerr << "Error: tempTime<0" << endl;
      exit(1);
    }
 
    if(tempTime - Time < 0){

      V.push_back(tempTime);
      prob1 = (N[i-1]+1)*lambda / eta;

      if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position
	
        P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	L.push_back(rand.rgeom(ri));
	ID.push_back(1);
	N.push_back(N[i-1]+L[i]);
        HMGin = HMG0[i-1];
	int tmphmg = -1;
        for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin()+ P[i],tmphmg);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);

      }else{   // propose a deletion, at a position with a length

        //propose length first
	//for( d = 1; d <= N[i-1] ; d++){
	//  Lwt.push_back( rd * pow(1-rd,d-1) * (N[i-1] - d + 1) );
        //}
	//L.push_back( (rand.rwunif(Lwt) + 1) );   
	//Lwt.resize(0);
        L.push_back(rand.rTRgeom(rd,N[i-1])); 
        P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
        ID.push_back(-1);
	N.push_back(N[i-1]-L[i]);
        HMGin = HMG0[i-1];
        for( k = 0; k<L[i]; k++){
	  HMGin.erase(HMGin.begin()+ P[i]);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);
      }  
      i++;
    }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
      if(N[i-1]<Nend){
	ID.push_back(1);
        L.push_back(Nend-N[i-1]);
        P.push_back((int)(rand.runif() * (N[i-1]+1)));
	V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	N.push_back(Nend);
        HMGin = HMG0[i-1];
	int tmphmg = -1;
        for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin() + P[i],tmphmg);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);
      }else if(N[i-1]>Nend){
	ID.push_back(-1);
	L.push_back(N[i-1]-Nend);
	P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
        V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	N.push_back(Nend);
        HMGin = HMG0[i-1];
        for( k = 0; k<L[i]; k++){
	  HMGin.erase(HMGin.begin()+ P[i]);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);

      }else{
	i--;
      }

      break;
    }// end of if(tempTime-Time<0)

  }// end of while(1).


  numE = i;
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
 

  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


}
*/
//--- v20 end ---//



// Generate IDH given N0, Nend and time
// with HMG
//--- v20 start --//
double Tree::runEdge(Rand &rand, const Parameters &params, InDelHistory* IDH, int N0, int Nend, double Time){


  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  


  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int i, k, d;
  int numE;
  double eta;
  double dt, tempTime;
  double prob1;   


  //-- v20 start --//
  double C_noEvent = params.getC_noEvent(); 
  double WeiID = params.getWeiID();
  double ImulFacSD = params.getImulFacSD();
  double DmulFacSD = params.getDmulFacSD();
  double ProbTargetFragI = params.getProbTargetFragI();
  double ProbTargetFragD = params.getProbTargetFragD();
  bool go = true;
  double probNoE;
  double LimI, LimD;
  int difLen;
  LimI = 1/ri + ImulFacSD*sqrt(1-ri)/ri;
  LimD = 1/rd + DmulFacSD*sqrt(1-rd)/rd;
  //-- v20 end --//



  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



  // Generate Events
  while(1){
    eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   

    //--- v20 start ---//
    probNoE = exp(-eta*(Time - V[i-1])/C_noEvent);


    go = true;
    if((N[i-1]==Nend) & (rand.runif()- probNoE < 0))
      go = false;

    if(go){     // Generate Events 
      //-- v20 end ---//
   

      dt = -log(1.0-rand.runif()) / eta;  

      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error: tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime - Time < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	

	//--- v20 start ---//
	if(N[i-1] < Nend)
	  prob1 *= (1 + WeiID);   // give up weight to insertion
	else if(N[i-1] > Nend)
	  prob1 = 1 - (1-prob1)*(1 + WeiID); // give up weight to deletion 
	//--- v20 end ---//
	

	if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position
	

	  ID.push_back(1);
	  //--- v20 start ---//
	  //L.push_back(rand.rgeom(ri));
	  difLen = Nend - N[i-1];
	  if((0 < difLen) & (difLen < LimI)){
	    if(rand.runif() - ProbTargetFragI < 0)
	      L.push_back(difLen);
	    else
	      L.push_back(rand.rgeom(ri));
	  }else{
	    L.push_back(rand.rgeom(ri));
          }
	  //--- v20 end ---//


	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  
	  N.push_back(N[i-1]+L[i]);
	  HMGin = HMG0[i-1];
	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(1-rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  ID.push_back(-1);

	  //--- v20 start ---//
	  //L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  difLen = N[i-1] - Nend;
	  if((0 < difLen) & (difLen < LimD)){
	    if(rand.runif() - ProbTargetFragD < 0)
	      L.push_back(difLen);
	    else
	      L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  }else{
	    L.push_back(rand.rTRgeom(rd,N[i-1])); 
          }
	  //--- v20 end ---//
 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	}  
	i++;
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<Nend){
	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG0[i-1];
	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>Nend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{
	  i--;
	}
	
	break;
      }// end of if(tempTime-Time<0)


      //-- v20 start --//
    }else{  // Else if(go) - don't generate Event
      i--;
      break; 
    }    
    //-- v20 end --//
    
  }// end of while(1).


  numE = i;
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
 

  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);


}
//--- v20 end ---//


double Tree::SPRonSubTreeWithTargetWithinWindowGivenWindowLen(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1, int start) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, O_psl_posi, N_psl_posi;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))]; 
  int O_seqlenZ = nodeZ->getSeqLen();



  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Pick M on edge0, which is the end point of window
  double posiM = MIN(params.getWindowLen_SPRonSubTreeWithTargetWithinWindow(), edge0->getEdgeLen());
  //cout << "posiM : " << posiM << " edge0->getEdgeLen() : " << edge0->getEdgeLen() << endl;
  //double posiM = rand.runif()*(edge0->getEdgeLen()); 
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum;




  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<Edge*> OtherE(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      OtherE.push_back(TempEdge);
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  int baseIX, baseIX0;
  if(rand.runif() > 0.5){
    baseNodenum = tempNodeNum[1];
    baseIX = 1;
  }else{
    baseNodenum = tempNodeNum[0];
    baseIX = 0;
  }
  baseIX0 = 1-baseIX;
  tempNodeNum.resize(0);



  // prepare to calculate old prob to pick up position
  vector<int> intN(0);
  vector<double> intvalL(0);
  int origIX, newIX;
  vector<bool> rev(2);
  rev[0] = false;
  rev[1] = false;
  int tmpNumE;
  if(baseNodenum == OtherE[baseIX]->getEnd()->getnumber()){
    OtherE[baseIX]->ReverseEdge();
    rev[baseIX] = true;
  }
  if(nodeZ == OtherE[baseIX0]->getEnd()){
    OtherE[baseIX0]->ReverseEdge();
    rev[baseIX0] = true;
  }
  
  
  //lenY1 = OtherE[0]->getIDH->getV(1) + OtherE[1]->getIDH->getV(1);
  //intN.push_back(nodeZ->getSeqLen());
  tmpNumE = OtherE[baseIX]->getIDH()->getNumE();
  for(i = 0; i <= tmpNumE; i++){
    intN.push_back(OtherE[baseIX]->getIDH()->getN(i));
    intvalL.push_back(OtherE[baseIX]->getIDH()->getV(i+1)-OtherE[baseIX]->getIDH()->getV(i));
  }
  origIX = tmpNumE;
  intvalL[tmpNumE] += OtherE[baseIX0]->getIDH()->getV(1);
  
  tmpNumE = OtherE[baseIX0]->getIDH()->getNumE();
  if(tmpNumE > 0){
    for(i = 1; i <= tmpNumE; i++){
      intN.push_back(OtherE[baseIX0]->getIDH()->getN(i));
      intvalL.push_back(OtherE[baseIX0]->getIDH()->getV(i+1)-OtherE[baseIX0]->getIDH()->getV(i));
    }
  }  

  vector<double> logwei(0);
  vector<double> wei(0);
  double SPRc = params.getSPRonSubTreeWithTarget_c();
  double maxV;
  double maxL; 
  int intvalZ;
  double intvallen;
  double posiNewZ;
  int seqLenZ;

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge


    // pick a new position and calculate proposal prob

    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size() - 1;
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = intvalL[intvalZ];
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }
    if(intvalZ > 0){
      for(i = 0; i < intvalZ; i++)
	posiNewZ += intvalL[i];
    }
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);



    // Calculate proposal prob 
    logwei.resize(0);
    wei.resize(0);

    tmpNumE = intN.size()-1;
    seqLenZ = intN[intvalZ];
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);

  
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithTargetWithinWindow(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiNewZ, N_psl_posi, O_psl_posi, posiM, c1, start);

  }else{                  // else if edge which is connected to Z is selected


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);
    



    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;


    // Get new posi for Z and get proposal prob
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = edgeT->getIDH()->getNumE();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - edgeT->getIDH()->getN(i)));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = (edgeT->getIDH()->getV(intvalZ+1) - edgeT->getIDH()->getV(intvalZ));
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }   
    posiNewZ = edgeT->getIDH()->getV(intvalZ) + posiNewZ;
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);
    

    O_IDHlike = edge0->likeliHistory(params);

    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();

      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

      edge0->ReverseEdge();
    }else{
      
      
      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

    }    




    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	

     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	



  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->ReverseEdge();
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();     
	  
	  edge0->ReverseEdge();
	}else{
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();    
	  
	}	



	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	



	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	


	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);


    // Calculate proposal prob to pick position
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size()-1;
    seqLenZ = nodeZ->getSeqLen();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   




    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    



    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];
    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - N_psl_posi - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi + log((double)N_sizeMset)  - N_psl - N_psl_posi - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;





  }
  
  Mset.resize(0);
 
  delete subIDH;
  return AP;  

} // SPRonSubTree




double Tree::SPRonSubTreeWithTargetWithinWindow(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1, int start) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, O_psl_posi, N_psl_posi;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))]; 
  int O_seqlenZ = nodeZ->getSeqLen();



  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Pick M on edge0, which is the end point of window
  //double posiM = MIN(params.getWindowLen_SPRonSubTreeWithTargetWithinWindow(), edge0->getEdgeLen());
  double posiM = rand.runif()*(edge0->getEdgeLen()); 
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum;




  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<Edge*> OtherE(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      OtherE.push_back(TempEdge);
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  int baseIX, baseIX0;
  if(rand.runif() > 0.5){
    baseNodenum = tempNodeNum[1];
    baseIX = 1;
  }else{
    baseNodenum = tempNodeNum[0];
    baseIX = 0;
  }
  baseIX0 = 1-baseIX;
  tempNodeNum.resize(0);



  // prepare to calculate old prob to pick up position
  vector<int> intN(0);
  vector<double> intvalL(0);
  int origIX, newIX;
  vector<bool> rev(2);
  rev[0] = false;
  rev[1] = false;
  int tmpNumE;
  if(baseNodenum == OtherE[baseIX]->getEnd()->getnumber()){
    OtherE[baseIX]->ReverseEdge();
    rev[baseIX] = true;
  }
  if(nodeZ == OtherE[baseIX0]->getEnd()){
    OtherE[baseIX0]->ReverseEdge();
    rev[baseIX0] = true;
  }
  
  
  //lenY1 = OtherE[0]->getIDH->getV(1) + OtherE[1]->getIDH->getV(1);
  //intN.push_back(nodeZ->getSeqLen());
  tmpNumE = OtherE[baseIX]->getIDH()->getNumE();
  for(i = 0; i <= tmpNumE; i++){
    intN.push_back(OtherE[baseIX]->getIDH()->getN(i));
    intvalL.push_back(OtherE[baseIX]->getIDH()->getV(i+1)-OtherE[baseIX]->getIDH()->getV(i));
  }
  origIX = tmpNumE;
  intvalL[tmpNumE] += OtherE[baseIX0]->getIDH()->getV(1);
  
  tmpNumE = OtherE[baseIX0]->getIDH()->getNumE();
  if(tmpNumE > 0){
    for(i = 1; i <= tmpNumE; i++){
      intN.push_back(OtherE[baseIX0]->getIDH()->getN(i));
      intvalL.push_back(OtherE[baseIX0]->getIDH()->getV(i+1)-OtherE[baseIX0]->getIDH()->getV(i));
    }
  }  

  vector<double> logwei(0);
  vector<double> wei(0);
  double SPRc = params.getSPRonSubTreeWithTarget_c();
  double maxV;
  double maxL; 
  int intvalZ;
  double intvallen;
  double posiNewZ;
  int seqLenZ;

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge


    // pick a new position and calculate proposal prob

    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size() - 1;
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = intvalL[intvalZ];
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }
    if(intvalZ > 0){
      for(i = 0; i < intvalZ; i++)
	posiNewZ += intvalL[i];
    }
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);



    // Calculate proposal prob 
    logwei.resize(0);
    wei.resize(0);

    tmpNumE = intN.size()-1;
    seqLenZ = intN[intvalZ];
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);

  
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithTargetWithinWindow(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiNewZ, N_psl_posi, O_psl_posi, posiM, c1, start);

  }else{                  // else if edge which is connected to Z is selected


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);
    



    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;


    // Get new posi for Z and get proposal prob
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = edgeT->getIDH()->getNumE();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - edgeT->getIDH()->getN(i)));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = (edgeT->getIDH()->getV(intvalZ+1) - edgeT->getIDH()->getV(intvalZ));
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }   
    posiNewZ = edgeT->getIDH()->getV(intvalZ) + posiNewZ;
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);
    

    O_IDHlike = edge0->likeliHistory(params);

    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();

      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

      edge0->ReverseEdge();
    }else{
      
      
      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

    }    




    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	

     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	



  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->ReverseEdge();
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();     
	  
	  edge0->ReverseEdge();
	}else{
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();    
	  
	}	



	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	



	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	


	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);


    // Calculate proposal prob to pick position
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size()-1;
    seqLenZ = nodeZ->getSeqLen();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   




    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    



    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];
    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - N_psl_posi - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi + log((double)N_sizeMset)  - N_psl - N_psl_posi - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;





  }
  
  Mset.resize(0);
 
  delete subIDH;
  return AP;  

} // SPRonSubTree








double Tree::SPRonSubTreeWithTargetWithinWindow(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, O_psl_posi, N_psl_posi;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))]; 
  int O_seqlenZ = nodeZ->getSeqLen();



  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Pick M on edge0, which is the end point of window
  double posiM = rand.runif()*(edge0->getEdgeLen()); 
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum;




  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<Edge*> OtherE(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      OtherE.push_back(TempEdge);
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  int baseIX, baseIX0;
  if(rand.runif() > 0.5){
    baseNodenum = tempNodeNum[1];
    baseIX = 1;
  }else{
    baseNodenum = tempNodeNum[0];
    baseIX = 0;
  }
  baseIX0 = 1-baseIX;
  tempNodeNum.resize(0);



  // prepare to calculate old prob to pick up position
  vector<int> intN(0);
  vector<double> intvalL(0);
  int origIX, newIX;
  vector<bool> rev(2);
  rev[0] = false;
  rev[1] = false;
  int tmpNumE;
  if(baseNodenum == OtherE[baseIX]->getEnd()->getnumber()){
    OtherE[baseIX]->ReverseEdge();
    rev[baseIX] = true;
  }
  if(nodeZ == OtherE[baseIX0]->getEnd()){
    OtherE[baseIX0]->ReverseEdge();
    rev[baseIX0] = true;
  }
  
  
  //lenY1 = OtherE[0]->getIDH->getV(1) + OtherE[1]->getIDH->getV(1);
  //intN.push_back(nodeZ->getSeqLen());
  tmpNumE = OtherE[baseIX]->getIDH()->getNumE();
  for(i = 0; i <= tmpNumE; i++){
    intN.push_back(OtherE[baseIX]->getIDH()->getN(i));
    intvalL.push_back(OtherE[baseIX]->getIDH()->getV(i+1)-OtherE[baseIX]->getIDH()->getV(i));
  }
  origIX = tmpNumE;
  intvalL[tmpNumE] += OtherE[baseIX0]->getIDH()->getV(1);
  
  tmpNumE = OtherE[baseIX0]->getIDH()->getNumE();
  if(tmpNumE > 0){
    for(i = 1; i <= tmpNumE; i++){
      intN.push_back(OtherE[baseIX0]->getIDH()->getN(i));
      intvalL.push_back(OtherE[baseIX0]->getIDH()->getV(i+1)-OtherE[baseIX0]->getIDH()->getV(i));
    }
  }  

  vector<double> logwei(0);
  vector<double> wei(0);
  double SPRc = params.getSPRonSubTreeWithTarget_c();
  double maxV;
  double maxL; 
  int intvalZ;
  double intvallen;
  double posiNewZ;
  int seqLenZ;

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge


    // pick a new position and calculate proposal prob

    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size() - 1;
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = intvalL[intvalZ];
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }
    if(intvalZ > 0){
      for(i = 0; i < intvalZ; i++)
	posiNewZ += intvalL[i];
    }
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);



    // Calculate proposal prob 
    logwei.resize(0);
    wei.resize(0);

    tmpNumE = intN.size()-1;
    seqLenZ = intN[intvalZ];
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);

  
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithTargetWithinWindow(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiNewZ, N_psl_posi, O_psl_posi, posiM, c1);

  }else{                  // else if edge which is connected to Z is selected


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);
    



    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;


    // Get new posi for Z and get proposal prob
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = edgeT->getIDH()->getNumE();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - edgeT->getIDH()->getN(i)));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = (edgeT->getIDH()->getV(intvalZ+1) - edgeT->getIDH()->getV(intvalZ));
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }   
    posiNewZ = edgeT->getIDH()->getV(intvalZ) + posiNewZ;
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);
    

    O_IDHlike = edge0->likeliHistory(params);

    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();

      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

      edge0->ReverseEdge();
    }else{
      
      
      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

    }    




    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	

     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	



  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->ReverseEdge();
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();     
	  
	  edge0->ReverseEdge();
	}else{
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();    
	  
	}	



	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	



	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	


	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);


    // Calculate proposal prob to pick position
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size()-1;
    seqLenZ = nodeZ->getSeqLen();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   




    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    



    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - N_psl_posi - log((double)O_sizeMset));

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi + log((double)N_sizeMset)  - N_psl - N_psl_posi - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;





  }
  
  Mset.resize(0);
 
  delete subIDH;
  return AP;  

} // SPRonSubTree




double Tree::SPRonSubTreeWithTarget(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1, int start) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, O_psl_posi, N_psl_posi;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))]; 
  int O_seqlenZ = nodeZ->getSeqLen();



  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<Edge*> OtherE(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      OtherE.push_back(TempEdge);
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  int baseIX, baseIX0;
  if(rand.runif() > 0.5){
    baseNodenum = tempNodeNum[1];
    baseIX = 1;
  }else{
    baseNodenum = tempNodeNum[0];
    baseIX = 0;
  }
  baseIX0 = 1-baseIX;
  tempNodeNum.resize(0);



  // prepare to calculate old prob to pick up position
  vector<int> intN(0);
  vector<double> intvalL(0);
  int origIX, newIX;
  vector<bool> rev(2);
  rev[0] = false;
  rev[1] = false;
  int tmpNumE;
  if(baseNodenum == OtherE[baseIX]->getEnd()->getnumber()){
    OtherE[baseIX]->ReverseEdge();
    rev[baseIX] = true;
  }
  if(nodeZ == OtherE[baseIX0]->getEnd()){
    OtherE[baseIX0]->ReverseEdge();
    rev[baseIX0] = true;
  }
  
  
  //lenY1 = OtherE[0]->getIDH->getV(1) + OtherE[1]->getIDH->getV(1);
  //intN.push_back(nodeZ->getSeqLen());
  tmpNumE = OtherE[baseIX]->getIDH()->getNumE();
  for(i = 0; i <= tmpNumE; i++){
    intN.push_back(OtherE[baseIX]->getIDH()->getN(i));
    intvalL.push_back(OtherE[baseIX]->getIDH()->getV(i+1)-OtherE[baseIX]->getIDH()->getV(i));
  }
  origIX = tmpNumE;
  intvalL[tmpNumE] += OtherE[baseIX0]->getIDH()->getV(1);
  
  tmpNumE = OtherE[baseIX0]->getIDH()->getNumE();
  if(tmpNumE > 0){
    for(i = 1; i <= tmpNumE; i++){
      intN.push_back(OtherE[baseIX0]->getIDH()->getN(i));
      intvalL.push_back(OtherE[baseIX0]->getIDH()->getV(i+1)-OtherE[baseIX0]->getIDH()->getV(i));
    }
  }  

  vector<double> logwei(0);
  vector<double> wei(0);
  double SPRc = params.getSPRonSubTreeWithTarget_c();
  double maxV;
  double maxL; 
  int intvalZ;
  double intvallen;
  double posiNewZ;
  int seqLenZ;

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge


    // pick a new position and calculate proposal prob

    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size() - 1;
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = intvalL[intvalZ];
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }
    if(intvalZ > 0){
      for(i = 0; i < intvalZ; i++)
	posiNewZ += intvalL[i];
    }
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);



    // Calculate proposal prob 
    logwei.resize(0);
    wei.resize(0);

    tmpNumE = intN.size()-1;
    seqLenZ = intN[intvalZ];
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);

  
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithTarget(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiNewZ, N_psl_posi, O_psl_posi, c1, start);

  }else{                  // else if edge which is connected to Z is selected


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);
    



    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;


    // Get new posi for Z and get proposal prob
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = edgeT->getIDH()->getNumE();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - edgeT->getIDH()->getN(i)));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = (edgeT->getIDH()->getV(intvalZ+1) - edgeT->getIDH()->getV(intvalZ));
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }   
    posiNewZ = edgeT->getIDH()->getV(intvalZ) + posiNewZ;
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);
    

    O_IDHlike = edge0->likeliHistory(params);



    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      O_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      O_psl= edge0->ProposHistory(params);
    }      

    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
      
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
     if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  edge0->runEdge(rand,params);
	  edge0->calHMG();     
	  edge0->ReverseEdge();
	}else{
	  edge0->runEdge(rand,params);
	  edge0->calHMG();
	}    
       

	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);


    // Calculate proposal prob to pick position
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size()-1;
    seqLenZ = nodeZ->getSeqLen();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   




    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      N_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      N_psl= edge0->ProposHistory(params);
    }     







    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];
    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - N_psl_posi - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi + log((double)N_sizeMset)  - N_psl - N_psl_posi - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;






  }
  
  Mset.resize(0);
 
  return AP;  

} // SPRonSubTree








double Tree::SPRonSubTreeWithTarget(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, O_psl_posi, N_psl_posi;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))]; 
  int O_seqlenZ = nodeZ->getSeqLen();



  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<Edge*> OtherE(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      OtherE.push_back(TempEdge);
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  int baseIX, baseIX0;
  if(rand.runif() > 0.5){
    baseNodenum = tempNodeNum[1];
    baseIX = 1;
  }else{
    baseNodenum = tempNodeNum[0];
    baseIX = 0;
  }
  baseIX0 = 1-baseIX;
  tempNodeNum.resize(0);



  // prepare to calculate old prob to pick up position
  vector<int> intN(0);
  vector<double> intvalL(0);
  int origIX, newIX;
  vector<bool> rev(2);
  rev[0] = false;
  rev[1] = false;
  int tmpNumE;
  if(baseNodenum == OtherE[baseIX]->getEnd()->getnumber()){
    OtherE[baseIX]->ReverseEdge();
    rev[baseIX] = true;
  }
  if(nodeZ == OtherE[baseIX0]->getEnd()){
    OtherE[baseIX0]->ReverseEdge();
    rev[baseIX0] = true;
  }
  
  
  //lenY1 = OtherE[0]->getIDH->getV(1) + OtherE[1]->getIDH->getV(1);
  //intN.push_back(nodeZ->getSeqLen());
  tmpNumE = OtherE[baseIX]->getIDH()->getNumE();
  for(i = 0; i <= tmpNumE; i++){
    intN.push_back(OtherE[baseIX]->getIDH()->getN(i));
    intvalL.push_back(OtherE[baseIX]->getIDH()->getV(i+1)-OtherE[baseIX]->getIDH()->getV(i));
  }
  origIX = tmpNumE;
  intvalL[tmpNumE] += OtherE[baseIX0]->getIDH()->getV(1);
  
  tmpNumE = OtherE[baseIX0]->getIDH()->getNumE();
  if(tmpNumE > 0){
    for(i = 1; i <= tmpNumE; i++){
      intN.push_back(OtherE[baseIX0]->getIDH()->getN(i));
      intvalL.push_back(OtherE[baseIX0]->getIDH()->getV(i+1)-OtherE[baseIX0]->getIDH()->getV(i));
    }
  }  

  vector<double> logwei(0);
  vector<double> wei(0);
  double SPRc = params.getSPRonSubTreeWithTarget_c();
  double maxV;
  double maxL; 
  int intvalZ;
  double intvallen;
  double posiNewZ;
  int seqLenZ;

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge


    // pick a new position and calculate proposal prob

    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size() - 1;
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = intvalL[intvalZ];
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }
    if(intvalZ > 0){
      for(i = 0; i < intvalZ; i++)
	posiNewZ += intvalL[i];
    }
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);



    // Calculate proposal prob 
    logwei.resize(0);
    wei.resize(0);

    tmpNumE = intN.size()-1;
    seqLenZ = intN[intvalZ];
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);

  
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithTarget(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiNewZ, N_psl_posi, O_psl_posi, c1);

  }else{                  // else if edge which is connected to Z is selected


    if(rev[0])
      OtherE[0]->ReverseEdge();
    if(rev[1])
      OtherE[1]->ReverseEdge();  
    OtherE.resize(0);
    



    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;


    // Get new posi for Z and get proposal prob
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = edgeT->getIDH()->getNumE();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(O_seqlenZ - edgeT->getIDH()->getN(i)));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    for(i = 0; i <= tmpNumE; i++)
      wei[i] = wei[i]/maxL;    
    intvalZ = rand.rwunif(wei);
    intvallen = (edgeT->getIDH()->getV(intvalZ+1) - edgeT->getIDH()->getV(intvalZ));
    posiNewZ = rand.runif()*(intvallen);
    if(rand.runif() > 0.5){
      posiNewZ = intvallen - posiNewZ;
    }   
    posiNewZ = edgeT->getIDH()->getV(intvalZ) + posiNewZ;
    N_psl_posi = log(wei[intvalZ]) - log(intvallen);
    

    O_IDHlike = edge0->likeliHistory(params);



    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      O_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      O_psl= edge0->ProposHistory(params);
    }      

    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
      
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
     if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  edge0->runEdge(rand,params);
	  edge0->calHMG();     
	  edge0->ReverseEdge();
	}else{
	  edge0->runEdge(rand,params);
	  edge0->calHMG();
	}    
       

	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);


    // Calculate proposal prob to pick position
    logwei.resize(0);
    wei.resize(0);
    tmpNumE = intN.size()-1;
    seqLenZ = nodeZ->getSeqLen();
    for(i = 0; i <= tmpNumE; i++)
      logwei.push_back((-1)*SPRc*abs(seqLenZ - intN[i]));
    maxV = max_vec(logwei);
    for(i = 0; i <= tmpNumE; i++)
      wei.push_back(exp(logwei[i]- maxV));
    maxL = sum_vec(wei);
    O_psl_posi = log(wei[origIX]) - log(maxL) - log(intvalL[origIX]);
    intN.resize(0);
    intvalL.resize(0);
    logwei.resize(0);
    wei.resize(0);   




    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      N_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      N_psl= edge0->ProposHistory(params);
    }     







    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_posi + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - N_psl_posi - log((double)O_sizeMset));

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + O_psl_posi + log((double)N_sizeMset)  - N_psl - N_psl_posi - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << exp(O_psl_posi - N_psl_posi) << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;






  }
  
  Mset.resize(0);
 
  return AP;  

} // SPRonSubTree





double Tree::SPRonSubTreeWithinWindowGivenWindowLen(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1, int start) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  
  // Pick M on edge0, which is the end point of window
  double posiM = MIN(params.getWindowLen_SPRonSubTreeWithinWindow(), edge0->getEdgeLen());
  //double posiM = rand.runif()*(edge0->getEdgeLen()); 
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum;


  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "single " << endl;
    params.setSPRonSingle(1);

    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiM, c1, start);
 


  }else{                  // else if edge which is connected to Z is selected


    //cout << "sub " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);


    Edge* edgeX;
    Edge* edgeY;

    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }
 
    lenXt = edgeT->getEdgeLen();
    // Heejung
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edge0->likeliHistory(params);
    //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
    //cout << "O_IDHlike " << O_IDHlike << endl;



    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();

      IDH = edge0->getIDH();
      endNum = IDH->getNumE()+1;
      endPosi = IDH->getNumE();
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

      edge0->ReverseEdge();
    }else{
      
      
      IDH = edge0->getIDH();
      endNum = IDH->getNumE()+1;
      endPosi = IDH->getNumE();
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

    }    


 

    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	


      
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      int O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	


  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->ReverseEdge();
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();     
	  
	  edge0->ReverseEdge();
	}else{
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();    
	  
	}	


	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	

	   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	


	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];
    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  
  Mset.resize(0);
 
  delete subIDH;
 
  return AP;  

} // SPRonSubTree






double Tree::SPRonSubTreeWithinWindow(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1, int start) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  
  // Pick M on edge0, which is the end point of window
  //double posiM = MIN(params.getWindowLen_SPRonSubTreeWithinWindow(), edge0->getEdgeLen());
  double posiM = rand.runif()*(edge0->getEdgeLen()); 
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum;


  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "single " << endl;
    params.setSPRonSingle(1);

    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiM, c1, start);
 


  }else{                  // else if edge which is connected to Z is selected


    //cout << "sub " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);


    Edge* edgeX;
    Edge* edgeY;

    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }
 
    lenXt = edgeT->getEdgeLen();
    // Heejung
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edge0->likeliHistory(params);
    //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
    //cout << "O_IDHlike " << O_IDHlike << endl;



    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();

      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

      edge0->ReverseEdge();
    }else{
      
      
      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

    }    


 

    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	


      
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      int O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	


  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->ReverseEdge();
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();     
	  
	  edge0->ReverseEdge();
	}else{
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();    
	  
	}	


	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	

	   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	


	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];
    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  
  Mset.resize(0);
 
  delete subIDH;
 
  return AP;  

} // SPRonSubTree





double Tree::SPRonSubTreeWithinWindow(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  
  // Pick M on edge0, which is the end point of window
  double posiM = rand.runif()*(edge0->getEdgeLen()); 
  InDelHistory* subIDH = new InDelHistory();  
  InDelHistory* IDH;
  int endPosi; 
  int endNum;


  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "single " << endl;
    params.setSPRonSingle(1);

    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiM, c1);
 


  }else{                  // else if edge which is connected to Z is selected


    //cout << "sub " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);


    Edge* edgeX;
    Edge* edgeY;

    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }
 
    lenXt = edgeT->getEdgeLen();
    // Heejung
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edge0->likeliHistory(params);
    //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
    //cout << "O_IDHlike " << O_IDHlike << endl;



    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();

      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

      edge0->ReverseEdge();
    }else{
      
      
      IDH = edge0->getIDH();
      endPosi = IDH->getNumE();
      endNum = IDH->getNumE()+1;
      for(i = 1; i <= endNum; i++){
	if(posiM < IDH->getV(i)){
	  endPosi = i - 1;
	  break;
	}
      }
      extractSubIDH(IDH, subIDH, endPosi, posiM);
      O_psl = ProposHistory(params, subIDH);

    }    


 

    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	


      
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      int O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->ReverseEdge();
	
	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();     
	
	edge0->ReverseEdge();
      }else{

	IDH = edge0->getIDH();
	runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	N_psl = ProposHistory(params, subIDH);
	insertSubIDH(IDH, subIDH, endPosi);
	edge0->calHMG();    
     
      }	


  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->ReverseEdge();
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();     
	  
	  edge0->ReverseEdge();
	}else{
	  
	  IDH = edge0->getIDH();
	  runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	  N_psl = ProposHistory(params, subIDH);
	  insertSubIDH(IDH, subIDH, endPosi);
	  edge0->calHMG();    
	  
	}	


	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	

	   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->ReverseEdge();
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();     
	    
	    edge0->ReverseEdge();
	  }else{
	    
	    IDH = edge0->getIDH();
	    runEdge(rand, params, subIDH, nodeZ->getSeqLen(), IDH->getN(endPosi), posiM);
	    N_psl = ProposHistory(params, subIDH);
	    insertSubIDH(IDH, subIDH, endPosi);
	    edge0->calHMG();    
	    
	  }	


	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  
  Mset.resize(0);
 
  delete subIDH;
 
  return AP;  

} // SPRonSubTree



//-- v24 start --//
/*
double Tree::generateNewIDHonEdgeWhileKeepingHMGandAdjust(Rand &rand,Parameters &params, vector<int> stSeqLen, vector<int> enSeqLen, vector<int> stPosi, double edge0len, InDelHistory* IDH, vector<vector<double> > &Pmat, vector<vector<double> > &Qmat,  vector<vector<double> > &DistT, vector<vector<double> > &Pt, vector<double> &pi, int Nst, int Nen){


  //cout << "generateNewIDHonEdgeWhileKeepingHMG without delBasePosi" << endl;

  double logProbs = 0;


  int ki, tmphmg, km, canN, st, en, m, stIX, enIX, upd_posi;
  double dist, maxL;
  int numLetters = Pt.size();
  int wingSize = 2;
  int MaxNumEvent = 2;
  double MaxCases = pow((double)(wingSize*2 + 1), (double)MaxNumEvent);
  int numPosi;
  vector<vector<int> > chain_v;
  vector<vector<int> > posi_v;
  vector<vector<vector<int> > > hmg_v;
  vector<double> lik_n;
  vector<double> lik_wei_n;
  

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  
  int numE;


  vector<InDelHistory*> listIDH(0);
  vector<double> timeS(0);
  int IX, i, j, k, eventIX, Nend, N0; 
  IX = stPosi.size();





  // 3. Generate new IDH on Edge0 while keeping the original HMG.
  //            - in separate regions.
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  for(i = 0; i < IX; i++){
    runEdge(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len);
    //cout << "IDH " << endl;
    //listIDH[i]->printIDHwoHMG();
    logProbs += ProposHistory(params, listIDH[i]);
    //cout << "logProbs : " << logProbs << endl;


    // Consider changing position of listIDH[i]

    numE = IDH->getNumE();


	
    if(numE > 0){

      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(IDH->getID(k) == 1) // if insertion
	  numPosi *= (IDH->getN(k-1) + 1);
	else
	  numPosi *= (IDH->getN(k-1) - IDH->getL(k) + 1);
      }
      

      if(numPosi > 1){




	if(numPosi <= MaxCases){

	  //------------------------------//
	  //                              //
	  // caseI : numPosi <= MaxCases  //
	  //                              //
          //------------------------------//


	  chain_v.resize(0);
	  posi_v.resize(0);
	  hmg_v.resize(0);
	  lik_n.resize(0);
	  lik_wei_n.resize(0);
      
	  chain_v.resize(numE+1);
	  posi_v.resize(numE+1);
	  hmg_v.resize(numE+1);

	  // Special setup for 0-th and 1-th position
	  chain_v[0].push_back(-1);
	  posi_v[0].push_back(-1);
	  hmg_v[0].push_back(IDH->getHMG(0));


	
	  if(IDH->getID(1) == 1){  // if insertion
	
	    for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	      
	      chain_v[1].push_back(-1);
	      posi_v[1].push_back(ki);
	    
	      HMGin = hmg_v[0][0];
	      tmphmg = -1;
	      for( km = 0; km < IDH->getL(1); km++){
		HMGin.insert(HMGin.begin()+ ki,tmphmg);
	      }
	      hmg_v[1].push_back(HMGin);
	      HMGin.resize(0);
	      
	    }
	    
	  }else{

	    for( ki = 0; ki < (hmg_v[0][0].size()-IDH->getL(1)); ki++){
	  
	      chain_v[1].push_back(-1);
	      posi_v[1].push_back(ki);
	  
	      HMGin = hmg_v[0][0];
	      for( km = 0; km < IDH->getL(1); km++){
		HMGin.erase(HMGin.begin()+ ki);
	      }
	      hmg_v[1].push_back(HMGin);
	      HMGin.resize(0);
	    
	    }
	  }


	  if(numE >= 2){
	
	    for( k = 2; k <= numE; k++){ 

	      if(IDH->getID(k) == 1){  // if insertion
	    
		for(j = 0; j < chain_v[k-1].size(); j++){ 

		  for( ki = 0; ki < hmg_v[k-1][j].size(); ki++){
		  
		    chain_v[k].push_back(j);
		    posi_v[k].push_back(ki);
		  
		    HMGin = hmg_v[k-1][j];
		    tmphmg = -1;
		    for( km = 0; km < IDH->getL(k); km++){
		      HMGin.insert(HMGin.begin()+ ki,tmphmg);
		    }
		    hmg_v[k].push_back(HMGin);
		    HMGin.resize(0);

		  }
		}

	      }else{

		for(j = 0; j < chain_v[k-1].size(); j++){ 
	      
		  for( ki = 0; ki < (hmg_v[k-1][j].size() - IDH->getL(k)); ki++){
		
		    chain_v[k].push_back(j);
		    posi_v[k].push_back(ki);
		  
		    HMGin = hmg_v[k-1][j];
		    for( km = 0; km < IDH->getL(k); km++){
		      HMGin.erase(HMGin.begin()+ ki);
		    }
		    hmg_v[k].push_back(HMGin);
		    HMGin.resize(0);
		  }
		}
	      }
	    }
	    
	  }  // End of if(numE >= 2)

	  
	  canN = chain_v[numE].size();

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  // Get all prob
	  for(ki = 0; ki < canN ; ki++){


	    
	    HMGin.resize(0);
	    HMGin = hmg_v[numE][ki];

	    Nend = enSeqLen[i];
	    lik_n[ki] = 0;
	    st = -1;
	    en = -1;
	    
	    for(m = 0; m < Nend; m++){

	      if(HMGin[m] == -1){
		
		stIX = Nst;
		enIX = stPosi[i] + m;
		if(DistT[stIX][enIX] == 0){
		  dist = 0;
		  for(k = 0; k < numLetters; k++)
		    dist += pi[k]*Qmat[enIX][k];
		  DistT[enIX][enIX] = log(dist);
                }

		lik_n[ki] += DistT[stIX][enIX];

	      }else{

		stIX = stPosi[i] + HMGin[m];
		enIX = stPosi[i] + m;
		if(DistT[stIX][enIX] == 0){
		  dist = 0;
		  for(k = 0; k < numLetters; k++){
		    for(j = 0; j < numLetters; j++)
		      dist += Pt[k][j]*Pmat[stIX][k]*Qmat[enIX][j];
		  }
		  DistT[stIX][enIX] = log(dist);
                }
		
		lik_n[ki] += DistT[stIX][enIX];
		
		en = HMGin[m];
		for(j = (st+1); j < en; j++){
		  stIX = stPosi[i] + j;
		  enIX = Nen;
		  if(DistT[stIX][enIX] == 0){
		    dist = 0;
		    for(k = 0; k < numLetters; k++)
		      dist += pi[k]*Pmat[stIX][k];
		    DistT[stIX][enIX] = log(dist);
		  }
		  lik_n[ki] += DistT[stIX][enIX];
                }

		st = en;

	      }

	    }


	    en = N0;
	    for(j = (st+1); j < en; j++){

	      stIX = stPosi[i] + j;
	      enIX = Nen;
	      if(DistT[stIX][enIX] == 0){
		dist = 0;
		for(k = 0; k < numLetters; k++)
		  dist += pi[k]*Pmat[stIX][k];
		DistT[stIX][enIX] = log(dist);
	      }
	      lik_n[ki] += DistT[stIX][enIX];
	    }

	  }  // End of for(ki = 0; ki < canN ; ki++)

	  


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));
	  
	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;

	  upd_posi = rand.rwunif(lik_wei_n); // Select new position based on prob


	  logProbs += log(lik_wei_n[upd_posi]) + log((double)numPosi);

	  if(canN != numPosi)
	    cout << "ERROR in generateNewIDHonEdgeWhileKeepingHMGandAdjust A" << endl;



	  P.resize(0);
	  HMG0.resize(0);
	  P.resize(numE+2);
	  P[0] = 0;
	  P[numE+1] = 0;
	  HMG0.resize(numE+2);
	  HMG0[0] = IDH->getHMG(0);
	  
	  for(ki = numE; ki > 0; ki--){
	    P[ki] =  posi_v[ki][upd_posi];
	    HMG0[ki] = hmg_v[ki][upd_posi];
	    upd_posi = chain_v[ki][upd_posi];
	  }
	  
	  HMG0[numE+1] = HMG0[numE];
	  
	  IDH->setP(P);
	  IDH->setHMG(HMG0);
	  P.resize(0);
	  HMG0.resize(0);
	  
	}else if(numE <= MaxNumEvent){

	  //------------------------------//
	  //                              //
	  // caseII : numE <= MaxNumEvent //
	  //                              //
          //------------------------------//

	  
	  chain_v.resize(0);
	  posi_v.resize(0);
	  hmg_v.resize(0);
	  lik_n.resize(0);
	  lik_wei_n.resize(0);
      
	  chain_v.resize(numE+1);
	  posi_v.resize(numE+1);
	  hmg_v.resize(numE+1);

	  // Special setup for 0-th and 1-th position
	  chain_v[0].push_back(-1);
	  posi_v[0].push_back(-1);
	  hmg_v[0].push_back(IDH->getHMG(0));


	
	  if(IDH->getID(1) == 1){  // if insertion


	    st = MAX(0, IDH->getP(1) - wingSize);
	    en = MIN(hmg_v[0][0].size() -1, IDH->getP(1) + wingSize);
	
	    for( ki = st; ki <= en; ki++){ // Go over all possible positions
	      
	      chain_v[1].push_back(-1);
	      posi_v[1].push_back(ki);
	    
	      HMGin = hmg_v[0][0];
	      tmphmg = -1;
	      for( km = 0; km < IDH->getL(1); km++){
		HMGin.insert(HMGin.begin()+ ki,tmphmg);
	      }
	      hmg_v[1].push_back(HMGin);
	      HMGin.resize(0);
	      
	    }
	    
	  }else{

	    st = MAX(0, IDH->getP(1) - wingSize);
	    en = MIN((hmg_v[0][0].size()-IDH->getL(1)) -1, IDH->getP(1) + wingSize);
	

	    for( ki = st; ki <= en; ki++){
	  
	      chain_v[1].push_back(-1);
	      posi_v[1].push_back(ki);
	  
	      HMGin = hmg_v[0][0];
	      for( km = 0; km < IDH->getL(1); km++){
		HMGin.erase(HMGin.begin()+ ki);
	      }
	      hmg_v[1].push_back(HMGin);
	      HMGin.resize(0);
	    
	    }
	  }


	  if(numE >= 2){
	
	    for( k = 2; k <= numE; k++){ 

	      if(IDH->getID(k) == 1){  // if insertion
	    
		for(j = 0; j < chain_v[k-1].size(); j++){ 

		  st = MAX(0, IDH->getP(k) - wingSize);
		  en = MIN(hmg_v[k-1][j].size() -1, IDH->getP(k) + wingSize);
	

		  for( ki = st; ki <= en; ki++){
		  
		    chain_v[k].push_back(j);
		    posi_v[k].push_back(ki);
		  
		    HMGin = hmg_v[k-1][j];
		    tmphmg = -1;
		    for( km = 0; km < IDH->getL(k); km++){
		      HMGin.insert(HMGin.begin()+ ki,tmphmg);
		    }
		    hmg_v[k].push_back(HMGin);
		    HMGin.resize(0);

		  }
		}

	      }else{

		for(j = 0; j < chain_v[k-1].size(); j++){ 


		  st = MAX(0, IDH->getP(k) - wingSize);
		  en = MIN((hmg_v[k-1][j].size() - IDH->getL(k)) -1, IDH->getP(k) + wingSize);

	      
		  for( ki = st; ki <= en; ki++){
		
		    chain_v[k].push_back(j);
		    posi_v[k].push_back(ki);
		  
		    HMGin = hmg_v[k-1][j];
		    for( km = 0; km < IDH->getL(k); km++){
		      HMGin.erase(HMGin.begin()+ ki);
		    }
		    hmg_v[k].push_back(HMGin);
		    HMGin.resize(0);
		  }
		}
	      }
	    }
	    
	  }  // End of if(numE >= 2)

	  
	  canN = chain_v[numE].size();

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  // Get all prob
	  for(ki = 0; ki < canN ; ki++){


	    
	    HMGin.resize(0);
	    HMGin = hmg_v[numE][ki];

	    Nend = enSeqLen[i];
	    N0 = stSeqLen[i];
	    lik_n[ki] = 0;
	    st = -1;
	    en = -1;
	    
	    for(m = 0; m < Nend; m++){

	      if(HMGin[m] == -1){
		
		stIX = Nst;
		enIX = stPosi[i] + m;
		if(DistT[stIX][enIX] == 0){
		  dist = 0;
		  for(k = 0; k < numLetters; k++)
		    dist += pi[k]*Qmat[enIX][k];
		  DistT[enIX][enIX] = log(dist);
                }

		lik_n[ki] += DistT[stIX][enIX];

	      }else{

		stIX = stPosi[i] + HMGin[m];
		enIX = stPosi[i] + m;
		if(DistT[stIX][enIX] == 0){
		  dist = 0;
		  for(k = 0; k < numLetters; k++){
		    for(j = 0; j < numLetters; j++)
		      dist += Pt[k][j]*Pmat[stIX][k]*Qmat[enIX][j];
		  }
		  DistT[stIX][enIX] = log(dist);
                }

		lik_n[ki] += DistT[stIX][enIX];

		en = HMGin[m];
		for(j = (st+1); j < en; j++){
		  stIX = stPosi[i] + j;
		  enIX = Nen;
		  if(DistT[stIX][enIX] == 0){
		    dist = 0;
		    for(k = 0; k < numLetters; k++)
		      dist += pi[k]*Pmat[stIX][k];
		    DistT[stIX][enIX] = log(dist);
		  }
		  lik_n[ki] += DistT[stIX][enIX];
                }

		st = en;

	      }

	    }


	    en = N0;
	    for(j = (st+1); j < en; j++){

	      stIX = stPosi[i] + j;
	      enIX = Nen;
	      if(DistT[stIX][enIX] == 0){
		dist = 0;
		for(k = 0; k < numLetters; k++)
		  dist += pi[k]*Pmat[stIX][k];
		DistT[stIX][enIX] = log(dist);
	      }
	      lik_n[ki] += DistT[stIX][enIX];
	    }

	  }  // End of for(ki = 0; ki < canN ; ki++)

	  


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));
	  
	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;

	  upd_posi = rand.rwunif(lik_wei_n); // Select new position based on prob


	  logProbs += log(lik_wei_n[upd_posi]) + log((double)canN);
     

	  P.resize(0);
	  HMG0.resize(0);
	  P.resize(numE+2);
	  P[0] = 0;
	  P[numE+1] = 0;
	  HMG0.resize(numE+2);
	  HMG0[0] = IDH->getHMG(0);
	  
	  for(ki = numE; ki > 0; ki--){
	    P[ki] =  posi_v[ki][upd_posi];
	    HMG0[ki] = hmg_v[ki][upd_posi];
	    upd_posi = chain_v[ki][upd_posi];
	  }
	  
	  HMG0[numE+1] = HMG0[numE];
	  
	  IDH->setP(P);
	  IDH->setHMG(HMG0);
	  P.resize(0);
	  HMG0.resize(0);
	  
	}

      } // End of if(numPosi > 1)

    } // End of if(numE > 0)

  } // End of for 


  //Nend = stPosi[IX-1] + enSeqLen[IX-1];
  eventIX = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(stPosi[IX-1] + stSeqLen[IX-1]);
  for(k = 0; k <= N[0]; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



 
  // 4. Need to combine all 
  int total;
  int selPosi = 0;  
  timeS.resize(IX);
  
  while(1){
    total = 0;
    for(j = 0; j < IX; j++){
      if(listIDH[j]->getNumE() > 0){
	timeS[j] = listIDH[j]->getV(1);
      }else{
	total++;
	timeS[j] = edge0len;
      }
    }
    if(total == IX)
      break;
    selPosi = which_min_vec(timeS);
    V.push_back(listIDH[selPosi]->getV(1));
    ID.push_back(listIDH[selPosi]->getID(1));
    L.push_back(listIDH[selPosi]->getL(1));
    P.push_back(listIDH[selPosi]->getP(1) + stPosi[selPosi]);
    if(ID[eventIX] == 1){
      N.push_back(N[eventIX-1]+L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.insert(HMGin.begin()+ P[eventIX],-1);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] + L[eventIX];
    }else{
      N.push_back(N[eventIX-1]-L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.erase(HMGin.begin()+ P[eventIX]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] - L[eventIX];
    }
    eventIX++;
    listIDH[selPosi]->eraseHistory(false, 1); 
  }

  numE = eventIX-1;
  V.push_back(edge0len);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N[numE]);    
  HMG0.push_back(HMG0[numE]);
  
  
  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 
  

  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  chain_v.resize(0);
  posi_v.resize(0);
  hmg_v.resize(0);
  lik_n.resize(0);
  lik_wei_n.resize(0);
  

  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  
  timeS.resize(0);
  listIDH.resize(0);
  
  return logProbs;
      
}
*/
//-- v24 end --//










//-- v24 start --//
double Tree::generateNewIDHonEdgeWhileKeepingHMGandAdjust(Rand &rand,Parameters &params, vector<int> stSeqLen, vector<int> enSeqLen, vector<int> stPosi, vector<int> enPosi, double edge0len, InDelHistory* IDH, vector<vector<double> > &Pmat, vector<vector<double> > &Qmat,  vector<vector<double> > &DistT, vector<vector<double> > &Pt, vector<double> &pi, int Nst, int Nen){


  //cout << "generateNewIDHonEdgeWhileKeepingHMGandAdjust" << endl;







  double logProbs = 0;



  int ki, tmphmg, km, canN, st, en, m, stIX, enIX, upd_posi;
  double dist, maxL;
  //int numLetters = Pt.size();
  //int wingSize = 2;
  //int MaxNumEvent = 2;
  int MaxCases = params.getMaxCases();

  //cout << "MaxCases : " << MaxCases << endl;
  //double MaxCases = pow((double)(wingSize*2 + 1), (double)MaxNumEvent);
  int numPosi;
  vector<vector<int> > chain_v;
  vector<vector<int> > posi_v;
  vector<vector<vector<int> > > hmg_v;
  vector<double> lik_n;
  vector<double> lik_wei_n;
  

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  
  int numE;


  vector<InDelHistory*> listIDH(0);
  vector<double> timeS(0);
  int IX, i, j, k, eventIX, Nend, N0; 
  IX = stPosi.size();



  //cout << " Nst : " << Nst << " Nen : " << Nen << endl; 

  //cout << "DistT " << endl;
  //for(i =0; i < DistT.size() ; i++){
  //  for(j=0; j < DistT[i].size(); j++)
  //    cout << DistT[i][j] << " ";
  //  cout << endl;
  // }
  //cout << endl;



  //cout << "stPosi " << endl;
  //print_veci(stPosi);
  //cout << "enPosi " << endl;
  //print_veci(enPosi);  
  //cout << "stSeqLen " << endl;
  //print_veci(stSeqLen); 
  //cout << "enSeqLen " << endl;
  //print_veci(enSeqLen); 
  //cout << "pi " << endl;
  //print_vecd(pi);
  //cout << "Pt " << endl;
  //for(i = 0; i<Pt.size(); i++){
  //  for(j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  // }



  // 3. Generate new IDH on Edge0 while keeping the original HMG.
  //            - in separate regions.
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  for(i = 0; i < IX; i++){
    runEdge(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len);
    //cout << "IDH " << i << endl;
    //listIDH[i]->printIDHwoHMG();
    logProbs += ProposHistory(params, listIDH[i]);
    //cout << "logProbs : " << logProbs << endl;


    // Consider changing position of listIDH[i]

    numE = listIDH[i]->getNumE();
    N0 = stSeqLen[i];

    //cout << "numE : " << numE << endl;
	
    if(numE > 0){

      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(listIDH[i]->getID(k) == 1) // if insertion
	  numPosi *= (listIDH[i]->getN(k-1) + 1);
	else
	  numPosi *= (listIDH[i]->getN(k-1) - listIDH[i]->getL(k) + 1);
      }
      


      //cout << "numPosi : " << numPosi << endl;

      if(numPosi > 1){




	if(numPosi <= MaxCases){

	  //------------------------------//
	  //                              //
	  // caseI : numPosi <= MaxCases  //
	  //                              //
          //------------------------------//


	  chain_v.resize(0);
	  posi_v.resize(0);
	  hmg_v.resize(0);
	  lik_n.resize(0);
	  lik_wei_n.resize(0);
      
	  chain_v.resize(numE+1);
	  posi_v.resize(numE+1);
	  hmg_v.resize(numE+1);

	  // Special setup for 0-th and 1-th position
	  chain_v[0].push_back(-1);
	  posi_v[0].push_back(-1);
	  hmg_v[0].push_back(listIDH[i]->getHMG(0));


	
	  if(listIDH[i]->getID(1) == 1){  // if insertion
	
	    for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	      
	      chain_v[1].push_back(-1);
	      posi_v[1].push_back(ki);
	    
	      HMGin = hmg_v[0][0];
	      tmphmg = -1;
	      for( km = 0; km < listIDH[i]->getL(1); km++){
		HMGin.insert(HMGin.begin()+ ki,tmphmg);
	      }
	      hmg_v[1].push_back(HMGin);
	      HMGin.resize(0);
	      
	    }
	    
	  }else{

	    for( ki = 0; ki < (hmg_v[0][0].size()-listIDH[i]->getL(1)); ki++){
	  
	      chain_v[1].push_back(-1);
	      posi_v[1].push_back(ki);
	  
	      HMGin = hmg_v[0][0];
	      for( km = 0; km < listIDH[i]->getL(1); km++){
		HMGin.erase(HMGin.begin()+ ki);
	      }
	      hmg_v[1].push_back(HMGin);
	      HMGin.resize(0);
	    
	    }
	  }



	  if(numE >= 2){
	
	    for( k = 2; k <= numE; k++){ 

	      if(listIDH[i]->getID(k) == 1){  // if insertion
	    
		for(j = 0; j < chain_v[k-1].size(); j++){ 

		  for( ki = 0; ki < hmg_v[k-1][j].size(); ki++){
		  
		    chain_v[k].push_back(j);
		    posi_v[k].push_back(ki);
		  
		    HMGin = hmg_v[k-1][j];
		    tmphmg = -1;
		    for( km = 0; km < listIDH[i]->getL(k); km++){
		      HMGin.insert(HMGin.begin()+ ki,tmphmg);
		    }
		    hmg_v[k].push_back(HMGin);
		    HMGin.resize(0);

		  }
		}

	      }else{

		for(j = 0; j < chain_v[k-1].size(); j++){ 
	      
		  for( ki = 0; ki < (hmg_v[k-1][j].size() - listIDH[i]->getL(k)); ki++){
		
		    chain_v[k].push_back(j);
		    posi_v[k].push_back(ki);
		  
		    HMGin = hmg_v[k-1][j];
		    for( km = 0; km < listIDH[i]->getL(k); km++){
		      HMGin.erase(HMGin.begin()+ ki);
		    }
		    hmg_v[k].push_back(HMGin);
		    HMGin.resize(0);
		  }
		}
	      }
	    }
	    
	  }  // End of if(numE >= 2)

	  
	  canN = chain_v[numE].size();

	  //cout << "canN " << canN << endl;

	  //cout << "posi_v" << endl;
	  //for(k = 0; k < posi_v.size(); k++){
	  //  for(j = 0; j < posi_v[k].size(); j++){
	  //    cout << posi_v[k][j] << " ";
	  //  }
	  //  cout << endl;
	  //}
	  //cout << endl;


	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  // Get all prob
	  for(ki = 0; ki < canN ; ki++){


	    //cout << "ki " << ki << endl;
	    HMGin.resize(0);
	    HMGin = hmg_v[numE][ki];

	    //cout << "HMGin " << endl;
	    //print_veci(HMGin);


	    Nend = enSeqLen[i];
	    lik_n[ki] = 0;
	    st = -1;
	    en = -1;
	    
	    for(m = 0; m < Nend; m++){


	      //cout << "m " << m << endl;
	      if(HMGin[m] == -1){
		

		//cout << "HMGin[m] == -1 " << endl;
		stIX = Nst;
		enIX = enPosi[i] + m;

		//cout << "stIX : " << stIX << " enIX : " << enIX << endl;
		//if((stIX > Nst) |  (enIX > Nen))
		//  cout << "ERROR in size " << endl;
		//cout << "DistT[stIX][enIX] : " << DistT[stIX][enIX] << endl;
		if(DistT[stIX][enIX] == 0){
		  //cout << "we don't have " << endl;
		  dist = 0;
		  for(k = 0; k < numLetters; k++)
		    dist += pi[k]*Qmat[enIX][k];
		  DistT[stIX][enIX] = log(dist);
                }


		lik_n[ki] += DistT[stIX][enIX];
		//cout << "DistT[stIX][enIX] " << DistT[stIX][enIX] << endl;

	      }else{


		//cout << "HMGin[m] != -1 " << endl;
		stIX = stPosi[i] + HMGin[m];
		enIX = enPosi[i] + m;

	    
		//cout << "stIX : " << stIX << " enIX : " << enIX << endl;

		//if((stIX > Nst) |  (enIX > Nen))
		//  cout << "ERROR in size " << endl;
		if(DistT[stIX][enIX] == 0){
		  //cout << "we don't have " << endl;
		  dist = 0;
		  for(k = 0; k < numLetters; k++){
		    for(j = 0; j < numLetters; j++)
		      dist += Pt[k][j]*Pmat[stIX][k]*Qmat[enIX][j];
		  }
		  DistT[stIX][enIX] = log(dist);
                }
		
		lik_n[ki] += DistT[stIX][enIX];
		//cout << "DistT[stIX][enIX] " << DistT[stIX][enIX] << endl;


		en = HMGin[m];
		
		for(j = (st+1); j < en; j++){
		  //cout << "left part j " << j << endl;
		  stIX = stPosi[i] + j;
		  enIX = Nen;

		  //cout << "stIX : " << stIX << " enIX : " << enIX << endl;
		  //if((stIX > Nst) |  (enIX > Nen))
		  // cout << "ERROR in size " << endl;
		  if(DistT[stIX][enIX] == 0){
		    //cout << "we don't have " << endl;
		    dist = 0;
		    for(k = 0; k < numLetters; k++){
		      //cout << "k : " << k << endl;
		      //cout << "pi[k] : " << pi[k] << endl;
		      //cout << "Pmat[stIX][k] : " << Pmat[stIX][k] << endl;
		      dist += pi[k]*Pmat[stIX][k];
                    }
		    DistT[stIX][enIX] = log(dist);
		  }
		  lik_n[ki] += DistT[stIX][enIX];
		  //cout << "DistT[stIX][enIX] " << DistT[stIX][enIX] << endl;
                }

		st = en;

	      }

	    }


	    en = N0;
	    //cout << "st : " << st << " en : " << en << endl; 
	    for(j = (st+1); j < en; j++){

	      //cout << "Last part j " << j << endl;
	      stIX = stPosi[i] + j;
	      enIX = Nen;
	      //cout << "stIX : " << stIX << " enIX : " << enIX << endl;
	      //if((stIX > Nst) |  (enIX > Nen))
	      //	cout << "ERROR in size " << endl;
	      if(DistT[stIX][enIX] == 0){
		//cout << "we don't have " << endl;
		dist = 0;
		for(k = 0; k < numLetters; k++){
		  //cout << "k : " << k << endl;
		  //cout << "pi[k] : " << pi[k] << endl;
		  //cout << "Pmat[stIX][k] : " << Pmat[stIX][k] << endl;
		  dist += pi[k]*Pmat[stIX][k];
		}
		DistT[stIX][enIX] = log(dist);
	      }
	      lik_n[ki] += DistT[stIX][enIX];
	      //cout << "DistT[stIX][enIX] " << DistT[stIX][enIX] << endl;
	    }

	  }  // End of for(ki = 0; ki < canN ; ki++)

	  


	  //cout << "lik_n" << endl;
	  //print_vecd(lik_n);

	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));
	  
	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;


	  //cout << "lik_wei_n" << endl;
	  //print_vecd(lik_wei_n);

	  upd_posi = rand.rwunif(lik_wei_n); // Select new position based on prob

	  //cout << "upd_posi " << upd_posi << endl;

	  logProbs += log(lik_wei_n[upd_posi]) + log((double)numPosi);

	  if(canN != numPosi)
	    cout << "ERROR in generateNewIDHonEdgeWhileKeepingHMGandAdjust A" << endl;



	  P.resize(0);
	  HMG0.resize(0);
	  P.resize(numE+2);
	  P[0] = 0;
	  P[numE+1] = 0;
	  HMG0.resize(numE+2);
	  HMG0[0] = listIDH[i]->getHMG(0);
	  
	  for(ki = numE; ki > 0; ki--){
	    P[ki] =  posi_v[ki][upd_posi];
	    HMG0[ki] = hmg_v[ki][upd_posi];
	    upd_posi = chain_v[ki][upd_posi];
	  }
	  
	  HMG0[numE+1] = HMG0[numE];
	  
	  listIDH[i]->setP(P);
	  listIDH[i]->setHMG(HMG0);
	  P.resize(0);
	  HMG0.resize(0);
	  
	}

      } // End of if(numPosi > 1)

    } // End of if(numE > 0)


    //cout << "after adjusting!!! " << endl;
    //cout << "IDH " << i << endl;
    //listIDH[i]->printIDHwoHMG();

  } // End of for 


  //Nend = stPosi[IX-1] + enSeqLen[IX-1];
  eventIX = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(stPosi[IX-1] + stSeqLen[IX-1]);
  for(k = 0; k <= N[0]; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



 
  // 4. Need to combine all 
  int total;
  int selPosi = 0;  
  timeS.resize(IX);
  
  while(1){
    total = 0;
    for(j = 0; j < IX; j++){
      if(listIDH[j]->getNumE() > 0){
	timeS[j] = listIDH[j]->getV(1);
      }else{
	total++;
	timeS[j] = edge0len;
      }
    }
    if(total == IX)
      break;
    selPosi = which_min_vec(timeS);
    V.push_back(listIDH[selPosi]->getV(1));
    ID.push_back(listIDH[selPosi]->getID(1));
    L.push_back(listIDH[selPosi]->getL(1));
    P.push_back(listIDH[selPosi]->getP(1) + stPosi[selPosi]);
    if(ID[eventIX] == 1){
      N.push_back(N[eventIX-1]+L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.insert(HMGin.begin()+ P[eventIX],-1);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] + L[eventIX];
    }else{
      N.push_back(N[eventIX-1]-L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.erase(HMGin.begin()+ P[eventIX]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] - L[eventIX];
    }
    eventIX++;
    listIDH[selPosi]->eraseHistory(false, 1); 
  }

  numE = eventIX-1;
  V.push_back(edge0len);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N[numE]);    
  HMG0.push_back(HMG0[numE]);
  
  
  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 
  
  //cout << "Done  " << endl;
  //IDH->printIDH();



  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);

  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  chain_v.resize(0);
  posi_v.resize(0);
  hmg_v.resize(0);
  lik_n.resize(0);
  lik_wei_n.resize(0);





  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  
  timeS.resize(0);
  listIDH.resize(0);
  
  return logProbs;
      
}
//-- v24 end --//













double Tree::generateNewIDHonEdgeWhileKeepingHMG(Rand &rand,Parameters &params, vector<int> stSeqLen, vector<int> enSeqLen, vector<int> stPosi, double edge0len, InDelHistory* IDH){


  //cout << "generateNewIDHonEdgeWhileKeepingHMG without delBasePosi" << endl;

  double logProbs = 0;

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  
  int numE;


  vector<InDelHistory*> listIDH(0);
  vector<double> timeS(0);
  int IX, i, j, k, eventIX, Nend; 
  IX = stPosi.size();


  //Nend = stPosi[IX-1] + enSeqLen[IX-1];
  eventIX = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(stPosi[IX-1] + stSeqLen[IX-1]);
  for(k = 0; k <= N[0]; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);





  // 3. Generate new IDH on Edge0 while keeping the original HMG.
  //            - in separate regions.
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  for(i = 0; i < IX; i++){
    runEdge(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len);
    //cout << "IDH " << endl;
    //listIDH[i]->printIDHwoHMG();
    logProbs += ProposHistory(params, listIDH[i]);
    //cout << "logProbs : " << logProbs << endl;
  }
 
 
  // 4. Need to combine all 
  int total;
  int selPosi = 0;  
  timeS.resize(IX);
  
  while(1){
    total = 0;
    for(j = 0; j < IX; j++){
      if(listIDH[j]->getNumE() > 0){
	timeS[j] = listIDH[j]->getV(1);
      }else{
	total++;
	timeS[j] = edge0len;
      }
    }
    if(total == IX)
      break;
    selPosi = which_min_vec(timeS);
    V.push_back(listIDH[selPosi]->getV(1));
    ID.push_back(listIDH[selPosi]->getID(1));
    L.push_back(listIDH[selPosi]->getL(1));
    P.push_back(listIDH[selPosi]->getP(1) + stPosi[selPosi]);
    if(ID[eventIX] == 1){
      N.push_back(N[eventIX-1]+L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.insert(HMGin.begin()+ P[eventIX],-1);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] + L[eventIX];
    }else{
      N.push_back(N[eventIX-1]-L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.erase(HMGin.begin()+ P[eventIX]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] - L[eventIX];
    }
    eventIX++;
    listIDH[selPosi]->eraseHistory(false, 1); 
  }

  numE = eventIX-1;
  V.push_back(edge0len);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N[numE]);    
  HMG0.push_back(HMG0[numE]);
  
  
  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 
  

  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  
  timeS.resize(0);
  listIDH.resize(0);
  
  return logProbs;
      
}




double Tree::generateNewIDHonEdgeWhileKeepingHMG(Rand &rand,Parameters &params, vector<int> stSeqLen, vector<int> enSeqLen, vector<int> stPosi, double edge0len, InDelHistory* IDH, vector<vector<int> > delBasePosi){


  //cout << "generateNewIDHonEdgeWhileKeepingHMG with delBasePosi" << endl;

  double logProbs = 0;

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  
  int numE;
  vector<vector<double> > delWeight(0);
  vector<int> delBasePosiIX(0);

  vector<InDelHistory*> listIDH(0);
  vector<double> timeS(0);
  int IX, i, j, k, eventIX, Nend; 
  IX = stPosi.size();


  //Nend = stPosi[IX-1] + enSeqLen[IX-1];
  eventIX = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(stPosi[IX-1] + stSeqLen[IX-1]);
  for(k = 0; k <= N[0]; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);





  // 3. Generate new IDH on Edge0 while keeping the original HMG.
  //            - in separate regions.
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  


  for(i = 0; i < IX; i++){
    if(delBasePosi[i].size() == 0){
      runEdge(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len);
      //cout << "IDH " << endl;
      //listIDH[i]->printIDHwoHMG();
      logProbs += ProposHistory(params, listIDH[i]);
      //cout << "logProbs : " << logProbs << endl;
    }else{
      delWeight.resize(0);
      delBasePosiIX.resize(0);
      for(j = 0; j <= stSeqLen[i] ; j++)
	delBasePosiIX.push_back(0);
      k = delBasePosi[i].size();
      for(j = 0; j < k; j++)
	delBasePosiIX[delBasePosi[i][j]] = 1;
      //cout << "before run Edge" << endl;
      //cout << "delBasePosiIX " << endl;
      //print_veci(delBasePosiIX);
      runEdgeWithDeletionConstraint(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len, delBasePosiIX, delWeight);
      //cout << "IDH B" << endl;
      //listIDH[i]->printIDHwoHMG();
      //logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX, delWeight);
      logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX);
      delWeight.resize(0);
      delBasePosiIX.resize(0);
      //cout << "logProbs B : " << logProbs << endl;
    }
  }
 
 
  // 4. Need to combine all 
  int total;
  int selPosi = 0;  
  timeS.resize(IX);
  
  while(1){
    total = 0;
    for(j = 0; j < IX; j++){
      if(listIDH[j]->getNumE() > 0){
	timeS[j] = listIDH[j]->getV(1);
      }else{
	total++;
	timeS[j] = edge0len;
      }
    }
    if(total == IX)
      break;
    selPosi = which_min_vec(timeS);
    V.push_back(listIDH[selPosi]->getV(1));
    ID.push_back(listIDH[selPosi]->getID(1));
    L.push_back(listIDH[selPosi]->getL(1));
    P.push_back(listIDH[selPosi]->getP(1) + stPosi[selPosi]);
    if(ID[eventIX] == 1){
      N.push_back(N[eventIX-1]+L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.insert(HMGin.begin()+ P[eventIX],-1);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] + L[eventIX];
    }else{
      N.push_back(N[eventIX-1]-L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.erase(HMGin.begin()+ P[eventIX]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] - L[eventIX];
    }
    eventIX++;
    listIDH[selPosi]->eraseHistory(false, 1); 
  }

  numE = eventIX-1;
  V.push_back(edge0len);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N[numE]);    
  HMG0.push_back(HMG0[numE]);
  
  
  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 
  

  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);
  delWeight.resize(0);
  delBasePosiIX.resize(0);
  delBasePosi.resize(0);

  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  
  timeS.resize(0);
  listIDH.resize(0);
  
  return logProbs;
      
}






double Tree::calProbIDHonEdgeWhileKeepingHMG(Parameters &params, vector<int> stSeqLen, vector<int> enSeqLen, vector<int> stPosi, double edge0len, InDelHistory* IDH){

  //cout << "calProbIDHonEdgeWhileKeepingHMG" << endl;

  //cout << "whole IDH " << endl;
  //IDH->printIDH();

  double logProbs = 0;

  //some vectors to generate events
  vector<vector<double> > V;
  vector<vector<int> > ID;
  vector<vector<int> > P;
  vector<vector<int> > L;
  vector<vector<int> > N;
  vector<vector<int> >  HMG0;
  vector<int> numEall(0);

  vector<InDelHistory*> listIDH(0);
  int IX, i, j, k, numE, tmpnumE, posi, selPosi;
  IX = stPosi.size();


  //cout << "cal 2" << endl;
  
  listIDH.resize(IX);
  numEall.resize(IX);
 
  V.resize(IX);
  ID.resize(IX);
  P.resize(IX);
  L.resize(IX);
  N.resize(IX);
 
  //cout << "cal 3" << endl;

  // First part
  for(i = 0; i < IX ; i++){
    numEall[i] = 1;
    V[i].push_back(0);
    ID[i].push_back(-2);
    P[i].push_back(0);
    L[i].push_back(0);
    N[i].push_back(stSeqLen[i]);
  }


  //cout << "cal 4" << endl;

  // Separate IDH into several blocks
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  
  //cout << "cal 5" << endl;

  numE = IDH->getNumE();
  if(numE > 0){
    //cout << "cal 6" << endl;
    for(i = 1; i <= numE; i++){
      //cout << "cal 7" << endl;
      posi = IDH->getP(i);
      for(j = 0; j < IX; j++){
	//cout << "cal 8" << endl;
	if(j == (IX -1)){
	  selPosi = IX -1;
	  break;
        }else if((stPosi[j] <= posi) & (posi < stPosi[j+1])){
	  selPosi = j;
          break;
        }
      }   
      V[selPosi].push_back(IDH->getV(i));
      ID[selPosi].push_back(IDH->getID(i));
      L[selPosi].push_back(IDH->getL(i));
      //P[selPosi].push_back(IDH->getP(i) + stPosi[selPosi]);
      P[selPosi].push_back(IDH->getP(i) - stPosi[selPosi]);
      tmpnumE = numEall[selPosi];
      if(ID[selPosi][tmpnumE] == 1){
	N[selPosi].push_back(N[selPosi][tmpnumE-1]+L[selPosi][tmpnumE]);      
	for(k = selPosi+1; k < IX; k++)
	  stPosi[k] = stPosi[k] + L[selPosi][tmpnumE];
      }else{
	N[selPosi].push_back(N[selPosi][tmpnumE-1]-L[selPosi][tmpnumE]); 
	for(k = selPosi+1; k < IX; k++)
	  stPosi[k] = stPosi[k] - L[selPosi][tmpnumE];
      }
      numEall[selPosi] = numEall[selPosi] + 1;
    }
  }

  
  //cout << "cal 9" << endl;

  for(i = 0; i < IX ; i++){
    numEall[i] =  numEall[i] - 1;
    V[i].push_back(edge0len);
    ID[i].push_back(-2);
    P[i].push_back(0);
    L[i].push_back(0);
    N[i].push_back(enSeqLen[i]);
    listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 
    //cout << "IDH " << endl;
    //listIDH[i]->printIDHwoHMG();
    logProbs += ProposHistory(params, listIDH[i]);
    //cout << "logProbs : " << logProbs << endl;
  }

  //cout << "cal 10" << endl;


  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  numEall.resize(0);

  //cout << "cal 11" << endl;
 
  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  

  //cout << "cal 12" << endl;


  listIDH.resize(0);
  
  return logProbs;
      
}


//-- v24 start --//
double Tree::calProbIDHonEdgeWhileKeepingHMGandAdjust(Parameters &params, vector<int> stSeqLen, vector<int> enSeqLen, vector<int> stPosi, vector<int> enPosi, double edge0len, InDelHistory* IDH, vector<vector<double> > &Pmat, vector<vector<double> > &Qmat,  vector<vector<double> > &DistT, vector<vector<double> > &Pt, vector<double> &pi, int Nst, int Nen){

  //cout << "calProbIDHonEdgeWhileKeepingHMGandAdjust" << endl;

  //cout << "whole IDH " << endl;
  //IDH->printIDH();

  double logProbs = 0;

  //some vectors to generate events
  vector<vector<double> > V;
  vector<vector<int> > ID;
  vector<vector<int> > P;
  vector<vector<int> > L;
  vector<vector<int> > N;
  vector<vector<int> >  HMG0;
  vector<int> numEall(0);

  vector<InDelHistory*> listIDH(0);
  int IX, i, j, k, numE, tmpnumE, posi, selPosi;
  IX = stPosi.size();


  int origIX;
  bool doneOrigIX;

  int ki, tmphmg, km, canN, st, en, m, stIX, enIX, upd_posi, N0, Nend;
  double dist, maxL;
  int MaxCases = params.getMaxCases();
  int numPosi;
  vector<vector<int> > chain_v;
  vector<vector<int> > posi_v;
  vector<vector<vector<int> > > hmg_v;
  vector<double> lik_n;
  vector<double> lik_wei_n;
  vector<int> HMGin(0);
  //int numLetters = Pt.size();


  //cout << "DistT " << endl;
  //for(i =0; i < DistT.size() ; i++){
  //  for(j=0; j < DistT[i].size(); j++)
  //    cout << DistT[i][j] << " ";
  //  cout << endl;
  //}
  //cout << endl;

  HMGin.resize(0);
  HMGin = stPosi;


  //cout << "cal 2" << endl;
  
  listIDH.resize(IX);
  numEall.resize(IX);
 
  V.resize(IX);
  ID.resize(IX);
  P.resize(IX);
  L.resize(IX);
  N.resize(IX);
 
  //cout << "cal 3" << endl;

  // First part
  for(i = 0; i < IX ; i++){
    numEall[i] = 1;
    V[i].push_back(0);
    ID[i].push_back(-2);
    P[i].push_back(0);
    L[i].push_back(0);
    N[i].push_back(stSeqLen[i]);
  }


  //cout << "cal 4" << endl;

  // Separate IDH into several blocks
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  
  //cout << "cal 5" << endl;

  numE = IDH->getNumE();
  if(numE > 0){
    //cout << "cal 6" << endl;
    for(i = 1; i <= numE; i++){
      //cout << "cal 7" << endl;
      posi = IDH->getP(i);
      for(j = 0; j < IX; j++){
	//cout << "cal 8" << endl;
	if(j == (IX -1)){
	  selPosi = IX -1;
	  break;
        }else if((stPosi[j] <= posi) & (posi < stPosi[j+1])){
	  selPosi = j;
          break;
        }
      }   
      V[selPosi].push_back(IDH->getV(i));
      ID[selPosi].push_back(IDH->getID(i));
      L[selPosi].push_back(IDH->getL(i));
      //P[selPosi].push_back(IDH->getP(i) + stPosi[selPosi]);
      P[selPosi].push_back(IDH->getP(i) - stPosi[selPosi]);
      tmpnumE = numEall[selPosi];
      if(ID[selPosi][tmpnumE] == 1){
	N[selPosi].push_back(N[selPosi][tmpnumE-1]+L[selPosi][tmpnumE]);      
	for(k = selPosi+1; k < IX; k++)
	  stPosi[k] = stPosi[k] + L[selPosi][tmpnumE];
      }else{
	N[selPosi].push_back(N[selPosi][tmpnumE-1]-L[selPosi][tmpnumE]); 
	for(k = selPosi+1; k < IX; k++)
	  stPosi[k] = stPosi[k] - L[selPosi][tmpnumE];
      }
      numEall[selPosi] = numEall[selPosi] + 1;
    }
  }


  stPosi.resize(0); 
  stPosi = HMGin;
  HMGin.resize(0);

  
  //cout << "cal 9" << endl;

  for(i = 0; i < IX ; i++){
    numEall[i] =  numEall[i] - 1;
    V[i].push_back(edge0len);
    ID[i].push_back(-2);
    P[i].push_back(0);
    L[i].push_back(0);
    N[i].push_back(enSeqLen[i]);
    listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 
    //cout << "IDH " << i << endl;
    //listIDH[i]->printIDHwoHMG();
    logProbs += ProposHistory(params, listIDH[i]);
    //cout << "logProbs : " << logProbs << endl;


    // Consider changing position of listIDH[i]

    numE = listIDH[i]->getNumE();
    N0 = stSeqLen[i];

	
    if(numE > 0){
      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(listIDH[i]->getID(k) == 1) // if insertion
	  numPosi *= (listIDH[i]->getN(k-1) + 1);
	else
	  numPosi *= (listIDH[i]->getN(k-1) - listIDH[i]->getL(k) + 1);
      }

      if(numPosi > 1){


	if(numPosi <= MaxCases){

	  //------------------------------//
	  //                              //
	  // caseI : numPosi <= MaxCases  //
	  //                              //
          //------------------------------//
	  

	  chain_v.resize(0);
	  posi_v.resize(0);
	  hmg_v.resize(0);
	  lik_n.resize(0);
	  lik_wei_n.resize(0);
      
	  chain_v.resize(numE+1);
	  posi_v.resize(numE+1);
	  hmg_v.resize(numE+1);
	  
	  // Special setup for 0-th and 1-th position
	  chain_v[0].push_back(-1);
	  posi_v[0].push_back(-1);

	  HMGin.resize(0);
	  for( k = 0; k<=stSeqLen[i]; k++){
	    HMGin.push_back(k);
	  }
	  hmg_v[0].push_back(HMGin);


	  if(listIDH[i]->getID(1) == 1){  // if insertion
	
	    for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	      
	      chain_v[1].push_back(-1);
	      posi_v[1].push_back(ki);

	    
	      HMGin = hmg_v[0][0];
	      tmphmg = -1;
	      for( km = 0; km < listIDH[i]->getL(1); km++){
		HMGin.insert(HMGin.begin()+ ki,tmphmg);
	      }
	      hmg_v[1].push_back(HMGin);
	      HMGin.resize(0);
	      
	    }
	    
	  }else{

	    for( ki = 0; ki < (hmg_v[0][0].size()-listIDH[i]->getL(1)); ki++){
	  
	      chain_v[1].push_back(-1);
	      posi_v[1].push_back(ki);
	  
	      HMGin = hmg_v[0][0];
	      for( km = 0; km < listIDH[i]->getL(1); km++){
		HMGin.erase(HMGin.begin()+ ki);
	      }
	      hmg_v[1].push_back(HMGin);
	      HMGin.resize(0);
	    
	    }
	  }


	  origIX  = listIDH[i]->getP(1);
	  //cout << "origIX A: " << origIX << endl;

	  if(numE >= 2){
	
	    for( k = 2; k <= numE; k++){ 

	      doneOrigIX = false;


	      if(listIDH[i]->getID(k) == 1){  // if insertion
	    
		for(j = 0; j < chain_v[k-1].size(); j++){ 

		  for( ki = 0; ki < hmg_v[k-1][j].size(); ki++){
		  
		    if(!doneOrigIX){
		      if((j == origIX) & (ki == listIDH[i]->getP(k))){
			origIX = posi_v[k].size();
			//cout << "k " << k << " j " << j << " ki " << ki << endl;
			//cout << "origIX : B" << origIX << endl;
			doneOrigIX = true;
		      }
		    }




		    chain_v[k].push_back(j);
		    posi_v[k].push_back(ki);
	
		    HMGin = hmg_v[k-1][j];
		    tmphmg = -1;
		    for( km = 0; km < listIDH[i]->getL(k); km++){
		      HMGin.insert(HMGin.begin()+ ki,tmphmg);
		    }
		    hmg_v[k].push_back(HMGin);
		    HMGin.resize(0);

		  }
		}

	      }else{

		for(j = 0; j < chain_v[k-1].size(); j++){ 
	      
		  for( ki = 0; ki < (hmg_v[k-1][j].size() - listIDH[i]->getL(k)); ki++){
		
		    if(!doneOrigIX){
		      if((j == origIX) & (ki == listIDH[i]->getP(k))){
			origIX = posi_v[k].size();
			//cout << "k " << k << " j " << j << " ki " << ki << endl;	      
			//cout << "origIX B: " << origIX << endl;
			doneOrigIX = true;
		      }
                    }

		    chain_v[k].push_back(j);
		    posi_v[k].push_back(ki);
		 
		    HMGin = hmg_v[k-1][j];
		    for( km = 0; km < listIDH[i]->getL(k); km++){
		      HMGin.erase(HMGin.begin()+ ki);
		    }
		    hmg_v[k].push_back(HMGin);
		    HMGin.resize(0);
		  }
		}
	      }
	    }
	    
	  }  // End of if(numE >= 2)

	  
	  canN = chain_v[numE].size();

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  // Get all prob
	  for(ki = 0; ki < canN ; ki++){


	    
	    HMGin.resize(0);
	    HMGin = hmg_v[numE][ki];

	    Nend = enSeqLen[i];
	    lik_n[ki] = 0;
	    st = -1;
	    en = -1;
	    
	    for(m = 0; m < Nend; m++){

	      if(HMGin[m] == -1){
		
		stIX = Nst;
		enIX = enPosi[i] + m;
		if(DistT[stIX][enIX] == 0){
		  dist = 0;
		  for(k = 0; k < numLetters; k++)
		    dist += pi[k]*Qmat[enIX][k];
		  DistT[stIX][enIX] = log(dist);
                }

		lik_n[ki] += DistT[stIX][enIX];

	      }else{

		stIX = stPosi[i] + HMGin[m];
		enIX = enPosi[i] + m;
		//cout << "stPosi[i] " << stPosi[i] << endl;
		//cout << "HMGin[m] " <<  HMGin[m] << endl;
		//cout << "m : " << m << endl;
		//cout << "stIX : " << stIX << " enIX : " << enIX << endl; 
		if(DistT[stIX][enIX] == 0){
		  dist = 0;
		  for(k = 0; k < numLetters; k++){
		    for(j = 0; j < numLetters; j++)
		      dist += Pt[k][j]*Pmat[stIX][k]*Qmat[enIX][j];
		  }
		  DistT[stIX][enIX] = log(dist);
                }
		
		lik_n[ki] += DistT[stIX][enIX];
		
		en = HMGin[m];
		for(j = (st+1); j < en; j++){
		  stIX = stPosi[i] + j;
		  enIX = Nen;
		  if(DistT[stIX][enIX] == 0){
		    dist = 0;
		    for(k = 0; k < numLetters; k++)
		      dist += pi[k]*Pmat[stIX][k];
		    DistT[stIX][enIX] = log(dist);
		  }
		  lik_n[ki] += DistT[stIX][enIX];
                }

		st = en;

	      }

	    }


	    en = N0;
	    for(j = (st+1); j < en; j++){

	      stIX = stPosi[i] + j;
	      enIX = Nen;
	      if(DistT[stIX][enIX] == 0){
		dist = 0;
		for(k = 0; k < numLetters; k++)
		  dist += pi[k]*Pmat[stIX][k];
		DistT[stIX][enIX] = log(dist);
	      }
	      lik_n[ki] += DistT[stIX][enIX];
	    }

	  }  // End of for(ki = 0; ki < canN ; ki++)

	  


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));
	  
	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;


	  //cout << "posi_v" << endl;
	  //for(k = 0; k < posi_v.size(); k++){
	  //  for(j = 0; j < posi_v[k].size(); j++){
	  //    cout << posi_v[k][j] << " ";
	  //  }
	  //  cout << endl;
	  //}
	  //cout << endl;




	  logProbs += log(lik_wei_n[origIX]) + log((double)numPosi);


	  upd_posi = origIX;
	  HMGin.resize(0);
	  HMGin.resize(numE+2);
	  HMGin[0] = 0;
	  HMGin[numE+1] = 0;
     

	  for(ki = numE; ki > 0; ki--){
	    HMGin[ki] =  posi_v[ki][upd_posi];
	    upd_posi = chain_v[ki][upd_posi];
	  }
	  

	  //cout << "HMGin " << endl;
	  //print_veci(HMGin);
	  //cout << "listIDH[i]->getP()" << endl;
	  //print_veci(listIDH[i]->getP());
	  if(!same_vec(HMGin, listIDH[i]->getP())){
	    cout << "ERROR in generateNewIDHonEdgeWhileKeepingHMGandAdjust. origIX is wrong" << endl;
	    //cout << "HMGin " << endl;
	    //print_veci(HMGin);
	    //cout << "listIDH[i]->getP()" << endl;
	    //print_veci(listIDH[i]->getP());

	    //cout << "posi_v" << endl;
	    //for(k = 0; k < posi_v.size(); k++){
	    //  for(j = 0; j < posi_v[k].size(); j++){
	    //	cout << posi_v[k][j] << " ";
	    // }
	    //  cout << endl;
	    //}
	    //cout << endl;

	    //cout << "origIX : " << origIX << endl;

	  }


	  if(canN != numPosi)
	    cout << "ERROR in generateNewIDHonEdgeWhileKeepingHMGandAdjust A" << endl;

	}

      } // End of if(numPosi > 1)

    } // End of if(numE > 0)

  } // End of for 


  //cout << "cal 10" << endl;


  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  numEall.resize(0);

  chain_v.resize(0);
  posi_v.resize(0);
  hmg_v.resize(0);
  lik_n.resize(0);
  lik_wei_n.resize(0);
  HMGin.resize(0);


  //cout << "cal 11" << endl;
 
  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  

  //cout << "cal 12" << endl;


  listIDH.resize(0);
  
  return logProbs;
      
}
//--- v24 end -//



double Tree::calProbIDHonEdgeWhileKeepingHMG(Parameters &params, vector<int> stSeqLen, vector<int> enSeqLen, vector<int> stPosi, double edge0len, InDelHistory* IDH, vector<vector<int> > delBasePosi){

  //cout << "calProbIDHonEdgeWhileKeepingHMG with delBasePosi" << endl;

  //cout << "whole IDH" << endl;
  //IDH->printIDH();

  double logProbs = 0;

  //some vectors to generate events
  vector<vector<double> > V;
  vector<vector<int> > ID;
  vector<vector<int> > P;
  vector<vector<int> > L;
  vector<vector<int> > N;
  vector<vector<int> >  HMG0;
  vector<int> HMGin(0);
  vector<int> numEall(0);
  vector<int> delBasePosiIX(0);


  vector<InDelHistory*> listIDH(0);
  int IX, i, j, k, numE, tmpnumE, posi, selPosi;
  IX = stPosi.size();


  //cout << "cal 2" << endl;
  
  listIDH.resize(IX);
  numEall.resize(IX);
 
  V.resize(IX);
  ID.resize(IX);
  P.resize(IX);
  L.resize(IX);
  N.resize(IX);
 
  //cout << "cal 3" << endl;

  // First part
  for(i = 0; i < IX ; i++){
    numEall[i] = 1;
    V[i].push_back(0);
    ID[i].push_back(-2);
    P[i].push_back(0);
    L[i].push_back(0);
    N[i].push_back(stSeqLen[i]);
  }


  //cout << "cal 4" << endl;

  // Separate IDH into several blocks
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  
  //cout << "cal 5" << endl;

  //cout << "whole IDH " << endl;
  //IDH->printIDH();
  

  numE = IDH->getNumE();
  if(numE > 0){
    //cout << "cal 6" << endl;
    for(i = 1; i <= numE; i++){
      //cout << "cal 7" << endl;
      posi = IDH->getP(i);
      for(j = 0; j < IX; j++){
	//cout << "cal 8" << endl;
	if(j == (IX -1)){
	  selPosi = IX -1;
	  break;
        }else if((stPosi[j] <= posi) & (posi < stPosi[j+1])){
	  selPosi = j;
          break;
        }
      }   
      V[selPosi].push_back(IDH->getV(i));
      ID[selPosi].push_back(IDH->getID(i));
      L[selPosi].push_back(IDH->getL(i));
      //P[selPosi].push_back(IDH->getP(i) + stPosi[selPosi]);
      P[selPosi].push_back(IDH->getP(i) - stPosi[selPosi]);
      tmpnumE = numEall[selPosi];
      if(ID[selPosi][tmpnumE] == 1){
	N[selPosi].push_back(N[selPosi][tmpnumE-1]+L[selPosi][tmpnumE]);      
	for(k = selPosi+1; k < IX; k++)
	  stPosi[k] = stPosi[k] + L[selPosi][tmpnumE];
      }else{
	N[selPosi].push_back(N[selPosi][tmpnumE-1]-L[selPosi][tmpnumE]); 
	for(k = selPosi+1; k < IX; k++)
	  stPosi[k] = stPosi[k] - L[selPosi][tmpnumE];
      }
      numEall[selPosi] = numEall[selPosi] + 1;
    }
  }

  
  //cout << "cal 9 IX :" << IX << endl;

  for(i = 0; i < IX ; i++){
    //cout << "i : " << i << endl;
    numEall[i] =  numEall[i] - 1;
    V[i].push_back(edge0len);
    ID[i].push_back(-2);
    P[i].push_back(0);
    L[i].push_back(0);
    N[i].push_back(enSeqLen[i]);
    if(delBasePosi[i].size()==0){
      //cout << "AA" << endl;
      listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 
      //cout << "IDH " << endl;
      //listIDH[i]->printIDHwoHMG();
      logProbs += ProposHistory(params, listIDH[i]);
      //cout << "logProbs : " << logProbs << endl;
    }else{
      // HMG calculation
      //cout << "BB" << endl;
      //listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 
      //cout << "IDH " << endl;
      //listIDH[i]->printIDHwoHMG();

      HMG0.resize(0);
      HMGin.resize(0);
      for(k = 0; k <= N[i][0]; k++){
	HMGin.push_back(k);
      }
      //cout << "BB1 numEall[i] " << numEall[i] << endl;
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(j = 1; j <= numEall[i]; j++){
	//cout << " j : " << j << endl; 
	HMGin = HMG0[j-1];
	if(ID[i][j]==1){
	  //cout << "Insertion st " << endl;
	  for(k = 0; k < L[i][j]; k++)
	    HMGin.insert(HMGin.begin()+ P[i][j],-1);
	  //cout << "Insertion en " << endl;
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
        }else{
	  //cout << "deletion st " << endl;
	  //cout << "L[i][j] " << L[i][j] << endl;
	  //cout << "P[i][j] " << P[i][j] << endl;
	  //cout << "HMGin " << endl;
	  //print_veci(HMGin);
	  for(k = 0; k< L[i][j]; k++)
	    HMGin.erase(HMGin.begin()+ P[i][j]);
	  //cout << "k : " << k << endl;
	  //cout << "deletion en " << endl;
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
        }
      }
      //cout << "BB2" << endl;
      HMG0.push_back(HMG0[numEall[i]]);
      listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 
      //cout << "IDH B" << endl;
      //listIDH[i]->printIDH();

      delBasePosiIX.resize(0);
      for(j = 0; j <= N[i][0] ; j++)
	delBasePosiIX.push_back(0);
      k = delBasePosi[i].size();
      for(j = 0; j < k; j++)
	delBasePosiIX[delBasePosi[i][j]] = 1;
      logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX);
      //cout << "logProbs B: " << logProbs << endl;
    }
  }

  //cout << "cal 10" << endl;


  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);
  numEall.resize(0);
  delBasePosiIX.resize(0);
  delBasePosi.resize(0);

  //cout << "cal 11" << endl;
 
  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  

  //cout << "cal 12" << endl;


  listIDH.resize(0);
  
  return logProbs;
      
}



// Generate IDH given N0, Nend, time, and position of bases to be deleted
// with HMG
//-- v21 start --//
/*
void Tree::runEdgeWithDeletionConstraint(Rand &rand, const Parameters &params, InDelHistory* IDH, int N0, int Nend, double Time, vector<int> delBasePosi, vector<vector<double> > &delWeight){



  //cout << "debug1 : delBasePosi " << endl;
  //print_veci(delBasePosi);

  double delProb = 4/(double)5;


  //--- v20 start ---//
  double InsertDownWei = params.getInsertDownWei();
  //--- v20 end ---//

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  


  vector<double> delWeight_in(0);
  delWeight.resize(0);
  delWeight.push_back(delWeight_in);
  vector<int> realDelPosi(0);

  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int i, k, d;
  int intTmp;
  int numE;
  double eta;
  double dt, tempTime;
  double prob1;   
  int st, en, stPosi, enPosi;
  bool done;
  int tmphmg;

  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



  // Generate Events
  while(1){

    //cout << " 1" << endl;
    eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   
    dt = -log(1.0-rand.runif()) / eta;  

    tempTime = tempTime+dt;
    if(tempTime<0){
      cerr << "Error: tempTime<0" << endl;
      exit(1);
    }
    delWeight_in.resize(0);

    if(tempTime - Time < 0){



      //cout << "AA " << endl;
      V.push_back(tempTime);
      prob1 = (N[i-1]+1)*lambda / eta;

      if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position


	//--- v20 start --//


       
	//P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	//L.push_back(rand.rgeom(ri));
	//ID.push_back(1);
	//N.push_back(N[i-1]+L[i]);
        //HMGin = HMG0[i-1];
	//tmphmg = -1;
        //for( k = 0; k<L[i]; k++){
	//  HMGin.insert(HMGin.begin()+ P[i],tmphmg);
        //}
        //HMG0.push_back(HMGin);
        //HMGin.resize(0);

	//cout << "Insertion " << endl;

	L.push_back(rand.rgeom(ri));
	ID.push_back(1);
	N.push_back(N[i-1]+L[i]);

	if(is_element(delBasePosi,1)){
	  delWeight_in.resize(0);

	  //cout << "HMG " << endl;
	  //print_veci(HMG0[i-1]);
	  calWeightIn(HMG0[i-1], delBasePosi, delWeight_in, InsertDownWei);
	  //print_vecd(delWeight_in);
	  P.push_back(rand.rwunif(delWeight_in));
	  delWeight_in.resize(0);
	  
	}else{
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
        }

        HMGin = HMG0[i-1];
	tmphmg = -1;
        for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin()+ P[i],tmphmg);
        }
        HMG0.push_back(HMGin);
        HMGin.resize(0);
	//--- v20 end ---//

      }else{   // propose a deletion, at a position with a length

	//cout << "AA2 " << endl;
	//print_veci(delBasePosi);
        //propose length first
	//for( d = 1; d <= N[i-1] ; d++){
	//  Lwt.push_back( rd * pow(1-rd,d-1) * (N[i-1] - d + 1) );
        //}
	//L.push_back( (rand.rwunif(Lwt) + 1) );   
	//Lwt.resize(0);
        L.push_back(rand.rTRgeom(rd,N[i-1]));
 
	if(is_element(delBasePosi,1)){

	  if(rand.runif()- delProb < 0){ // propose deletion in delBasePosi
	    delWeight_in.resize(0);
	    calWeight(HMG0[i-1], L[i], delBasePosi, delWeight_in);
	    //print_vecd(delWeight_in);
	    P.push_back(rand.rwunif(delWeight_in));
	    //if(sum_vec(delWeight_in)==0){
	    //  cout << "Size 0 : " << P[i] << endl;
	    //}
	    delWeight_in.resize(0);
	  }else{  // propose usual deletion
	    P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  }
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
	  
	  // Remove deleted positions from delBasePosi
	  for(k = 0; k < L[i]; k++){
	    if(HMG0[i-1][P[i]+k] >= 0)
	      delBasePosi[HMG0[i-1][P[i]+k]] = 0;
	  }

        }else{
	  delWeight_in.resize(0);
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
        }

      }  
      i++;

      delWeight.push_back(delWeight_in);
      delWeight_in.resize(0);
      
    }else{         // tempTime > Time, if bases to be deleted left, delete them or propose an event at any left time, at a position, with particular length 

      //cout << "BB " << endl;
      //cout << "delBasePosi " << endl;
      //print_veci(delBasePosi);

      if(is_element(delBasePosi, 1)){ // If based to be deleted left.

	//cout << "left over" << endl;
	done = false;
	//case1  Can we get there in one step deletion?

	  
	intTmp = delBasePosi.size();
	st = -1;
	en = -1;
	for(k = 0; k < intTmp; k++){
	  if(delBasePosi[k] == 1){
	      st = k;
	      break;
	  }
	}
	for(k = (intTmp-1); k >= 0; k--){
	  if(delBasePosi[k] == 1){
	    en = k;
	    break;
	  }
	}
	
	  // search position for st en
	intTmp = HMG0[i-1].size();
	for(k = 0; k < intTmp; k++){
	  if(HMG0[i-1][k] == st){
	    stPosi = k;
	    break;
	  }
	} 
	for(k = (intTmp-1); k >= 0; k--){
	  if(HMG0[i-1][k] == en){
	      enPosi = k;
	      break;
	  }
	}
		
	//cout << "stPosi " << stPosi << endl;
	//cout << "enPosi " << enPosi << endl;


	if(N[i-1] - Nend >= (enPosi - stPosi + 1)){  // We can go in one step
	    
	  //cout << "try one step " << endl;
	  ID.push_back(-1);
	  //cout << "N[i-1] " << N[i-1] << endl;
	  //cout << "Nend  " << Nend << endl;
	  L.push_back(N[i-1]-Nend);
	  //cout << "L " << L[i] << endl;
	  st = MAX(0, Nend - N[i-1] + enPosi + 1);
	  en = MIN(stPosi, N[i-1] - L[i]);
	  //cout << "st " << st << endl;
	  //cout << "stPosi - st +1 " << stPosi - st +1 << endl;
	  P.push_back(st + ((int)(rand.runif() * (en - st +1))));
	  //cout << "P " << P[i] << endl;
	  //V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  V.push_back(((rand.runif() * (Time-V[i-1]))+V[i-1]));
	  //cout << "V " << V[i] << endl;
	  N.push_back(Nend);

	  HMGin = HMG0[i-1];
	  //cout << "HMGin" << endl;
	  //print_veci(HMGin);
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  delWeight_in.resize(0);
	  delWeight.push_back(delWeight_in);
	  delWeight_in.resize(0);
	  done = true;
	}
	
	//Done of case1  we cannot get there in one step deletion?
      
	// case2 we cannot get there in one step deletion
	if(!done){
	
	  
	  //cout << "not one step " << endl;
	  // search position for deletion
	  realDelPosi.resize(0);
	  intTmp = HMG0[i-1].size();
	  realDelPosi.push_back(stPosi);
	  if(stPosi != enPosi){
	    for(k = (stPosi+1); k < enPosi; k++){
	      if(HMG0[i-1][k] >= 0){
		if(delBasePosi[HMG0[i-1][k]] == 1)
		  realDelPosi.push_back(k);
	      }
	    }
	    realDelPosi.push_back(enPosi);
          }
	  //cout << "realDelPosi " << endl;
	  //print_veci(realDelPosi);
	  
	  // how many?
	  //j = i;
	  
	  
	  st = 0;
	  
	  intTmp = realDelPosi.size();
	  //cout << "intTmp " << intTmp << endl;
	  while(intTmp > 1){
	    //cout << "realDelPosi " << endl;
	    //print_veci(realDelPosi);
	    //cout << "intTmp " << intTmp << endl;
	    ID.push_back(-1);
	    for(k = 0; k < (intTmp-1); k++){
	      if(realDelPosi[k]+1 < realDelPosi[k+1])
		break;
	    }
	    L.push_back(k+1);
	    //cout << "L " << L[i] << endl;
	    P.push_back(realDelPosi[0] - st);
	    //cout << "P " << P[i] << endl;
	    N.push_back(N[i-1]-L[i]);
	    //cout << "N " << N[i] << endl;
	    HMGin = HMG0[i-1];
	    for( k = 0; k < L[i]; k++){
	      HMGin.erase(HMGin.begin()+ P[i]);
	      realDelPosi.erase(realDelPosi.begin());
	    }
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);	    
	    st += L[i];
	    intTmp = realDelPosi.size();
	    i++;
	    delWeight_in.resize(0);
	    delWeight.push_back(delWeight_in);
	    delWeight_in.resize(0);
	  }
	  //cout << "####" << endl;
	  
	  if(intTmp == 1){
	    //cout << "intTmp : " << intTmp << endl;
	    ID.push_back(-1);
	    L.push_back(1);
	    P.push_back(realDelPosi[0] - st);
	    //cout << "1" << endl;
	    N.push_back(N[i-1]-L[i]);
	    HMGin = HMG0[i-1];
	    //cout << "2" << endl;
	    //print_veci(HMGin);
	    //cout << "L " << L[i] << endl;
	    //cout << "P " << P[i] << endl;
	    for( k = 0; k < L[i]; k++){
	      HMGin.erase(HMGin.begin()+ P[i]);
	      //realPosi.erase(realPosi.begin());
	    }
	    //cout << "3" << endl;
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);	    
	    st += L[i];
	    intTmp = realDelPosi.size();
	    i++;
	    delWeight_in.resize(0);
	    delWeight.push_back(delWeight_in);
	    delWeight_in.resize(0);
	    //cout << "4" << endl;
	  }
	  
	  //cout << "111" << endl;
	}
	
	//cout << "222" << endl;
      }
    
      //cout << "333" << endl;
      
      
      if(N[i-1]<Nend){
	//cout << "CC1 " << endl;
	ID.push_back(1);
	L.push_back(Nend-N[i-1]);
	P.push_back((int)(rand.runif() * (N[i-1]+1)));
	//V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	N.push_back(Nend);
	HMGin = HMG0[i-1];
	tmphmg = -1;
	for( k = 0; k<L[i]; k++){
	  HMGin.insert(HMGin.begin() + P[i],tmphmg);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);
	delWeight_in.resize(0);
	delWeight.push_back(delWeight_in);
	delWeight_in.resize(0);
	
      }else if(N[i-1]>Nend){
	//cout << "CC2 " << endl;
	ID.push_back(-1);
	L.push_back(N[i-1]-Nend);
	P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	//V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	N.push_back(Nend);
	HMGin = HMG0[i-1];
	for( k = 0; k<L[i]; k++){
	  HMGin.erase(HMGin.begin()+ P[i]);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);
	delWeight_in.resize(0);
	delWeight.push_back(delWeight_in);
	delWeight_in.resize(0);
	
      }else{
	//cout << "CC3 " << endl;
	i--;
      }

      intTmp = P.size() - V.size();
      st = V.size();
      delWeight_in.resize(intTmp);
      for(k = 0; k < intTmp; k++)
	delWeight_in[k] = (rand.runif() * (Time-V[st-1])) + V[st-1];

      for(k = 0; k < intTmp; k++){
	st = which_min_vec(delWeight_in);
	V.push_back(delWeight_in[st]);
	delWeight_in.erase(delWeight_in.begin()+ st);
      }  

      //cout << "HAHA " << endl;
      break;
    }
  }

  numE = i;
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
      
  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 



  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  delBasePosi.resize(0);
  delWeight_in.resize(0);
  realDelPosi.resize(0);


}
*/
//--- v21 end ---//



// Generate IDH given N0, Nend, time, and position of bases to be deleted
// with HMG
//-- v21 start --//
void Tree::runEdgeWithDeletionConstraint(Rand &rand, const Parameters &params, InDelHistory* IDH, int N0, int Nend, double Time, vector<int> delBasePosi, vector<vector<double> > &delWeight){



  //cout << "debug1 : delBasePosi " << endl;
  //print_veci(delBasePosi);


  //--- v20 start ---//
  double InsertDownWei = params.getInsertDownWei();
  //--- v20 end ---//

  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  


  vector<double> delWeight_in(0);
  delWeight.resize(0);
  delWeight.push_back(delWeight_in);
  vector<int> realDelPosi(0);

  double lambda = params.getLambda();
  double mu = params.getMu();
  double r = params.getR();
  double ri = params.getRi();
  double rd = params.getRd();
  int i, k, d;
  int intTmp;
  int numE;
  double eta;
  double dt, tempTime;
  double prob1;   
  int st, en, stPosi, enPosi;
  bool done;
  int tmphmg;


  //--- v21 start ---//
  double delProb = params.getDelProb();
  double C_noEvent = params.getC_noEvent(); 
  double WeiID = params.getWeiID();
  double ImulFacSD = params.getImulFacSD();
  double DmulFacSD = params.getDmulFacSD();
  double ProbTargetFragI = params.getProbTargetFragI();
  double ProbTargetFragD = params.getProbTargetFragD();
  bool go = true;
  double probNoE;
  double LimI, LimD;
  int difLen;
  LimI = 1/ri + ImulFacSD*sqrt(1-ri)/ri;
  LimD = 1/rd + DmulFacSD*sqrt(1-rd)/rd;
  int LenDel;
  //--- v21 end ---//



  tempTime = 0;
  i = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  // First part
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N0);
  for( k = 0; k<=N0; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);



  // Generate Events
  while(1){

    //cout << " 1" << endl;


    if(!is_element(delBasePosi,1)){ 

      //---------------------------//
      //                           //
      //  All bases are deleted    //
      //                           //
      //---------------------------//

      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;

      probNoE = exp(-eta*(Time - V[i-1])/C_noEvent);

      go = true;
      if((N[i-1]==Nend) & (rand.runif()- probNoE < 0))
	go = false;
      
      if(go){     // Generate Events 

	dt = -log(1.0-rand.runif()) / eta;  

	tempTime = tempTime+dt;
	if(tempTime<0){
	  cerr << "Error: tempTime<0" << endl;
	  exit(1);
	}
	delWeight_in.resize(0);
    
	if(tempTime - Time < 0){

	  V.push_back(tempTime);
	  prob1 = (N[i-1]+1)*lambda / eta;

	  if(N[i-1] < Nend)
	    prob1 *= (1 + WeiID);   // give up weight to insertion
	  else if(N[i-1] > Nend)
	    prob1 = 1 - (1-prob1)*(1 + WeiID); // give up weight to deletion 

	  if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position

	    ID.push_back(1);

	    difLen = Nend - N[i-1];
	    if((0 < difLen) & (difLen < LimI)){
	      if(rand.runif() - ProbTargetFragI < 0)
		L.push_back(difLen);
	      else
		L.push_back(rand.rgeom(ri));
	    }else{
	      L.push_back(rand.rgeom(ri));
	    }
	    //--- v20 end ---//
	    
	    N.push_back(N[i-1]+L[i]);
	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    HMGin = HMG0[i-1];
	    int tmphmg = -1;
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);
	    
	  }else{   // propose a deletion, at a position with a length
	  
	    ID.push_back(-1);
	    difLen = N[i-1] - Nend;
	    if((0 < difLen) & (difLen < LimD)){
	      if(rand.runif() - ProbTargetFragD < 0)
		L.push_back(difLen);
	      else
		L.push_back(rand.rTRgeom(rd,N[i-1])); 
	    }else{
	      L.push_back(rand.rTRgeom(rd,N[i-1])); 
	    }
    
	    P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  
	    N.push_back(N[i-1]-L[i]);
	    HMGin = HMG0[i-1];
	    for( k = 0; k<L[i]; k++){
	      HMGin.erase(HMGin.begin()+ P[i]);
	    }
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);
	  }  
	  i++;
	  
	}else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	  if(N[i-1]<Nend){
	    ID.push_back(1);
	    L.push_back(Nend-N[i-1]);
	    P.push_back((int)(rand.runif() * (N[i-1]+1)));
	    V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	    N.push_back(Nend);
	    HMGin = HMG0[i-1];
	    int tmphmg = -1;
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin() + P[i],tmphmg);
	    }
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);
	  }else if(N[i-1]>Nend){
	    ID.push_back(-1);
	    L.push_back(N[i-1]-Nend);
	    P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	    V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	    N.push_back(Nend);
	    HMGin = HMG0[i-1];
	    for( k = 0; k<L[i]; k++){
	      HMGin.erase(HMGin.begin()+ P[i]);
	    }
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);
	    
	  }else{
	    i--;
	  }
	  
	  break;
	}// end of if(tempTime-Time<0)
	
	//-- v20 start --//
      }else{  // Else if(go) - don't generate Event
	i--;
	break; 
      }    
  
    }else{

      //----------------------------------------------------//
      //                                                    //
      //  some bases are left over and should be deleted    //
      //                                                    //
      //----------------------------------------------------//

      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;   
      dt = -log(1.0-rand.runif()) / eta;  

      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error: tempTime<0" << endl;
	exit(1);
      }
      delWeight_in.resize(0);

      if(tempTime - Time < 0){

	// Calculate LenDel 

	intTmp = delBasePosi.size();
	st = -1;
	en = -1;
	for(k = 0; k < intTmp; k++){
	  if(delBasePosi[k] == 1){
	      st = k;
	      break;
	  }
	}
	for(k = (intTmp-1); k >= 0; k--){
	  if(delBasePosi[k] == 1){
	    en = k;
	    break;
	  }
	}
	
	// search position for st en
	intTmp = HMG0[i-1].size();
	for(k = 0; k < intTmp; k++){
	  if(HMG0[i-1][k] == st){
	    stPosi = k;
	    break;
	  }
	} 
	for(k = (intTmp-1); k >= 0; k--){
	  if(HMG0[i-1][k] == en){
	      enPosi = k;
	      break;
	  }
	}

	LenDel = enPosi - stPosi + 1;
		
      
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;


	if(N[i-1] - LenDel >= Nend)
	  prob1 = 1 - (1-prob1)*(1 + WeiID); // give up weight to deletion 
	


	if(rand.runif()-prob1 < 0){   // propose an insertion, which can be of any length, at any position

	  ID.push_back(1);

	  difLen = Nend - N[i-1] + LenDel; 
	  if((0 < difLen) & (difLen < LimI)){
	    if(rand.runif() - ProbTargetFragI < 0)
	      L.push_back(difLen);
	    else
	      L.push_back(rand.rgeom(ri));
	  }else{
	    L.push_back(rand.rgeom(ri));
          }
	  N.push_back(N[i-1]+L[i]);
	  
	  delWeight_in.resize(0);
	  calWeightIn(HMG0[i-1], delBasePosi, delWeight_in, InsertDownWei);
	  P.push_back(rand.rwunif(delWeight_in));
	  delWeight_in.resize(0);
	      
	  HMGin = HMG0[i-1];
	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
  
	}else{   // propose a deletion, at a position with a length
	  
	  ID.push_back(-1);
	  difLen = MAX(N[i-1] - Nend, LenDel);
	  if((0 < difLen) & (difLen < LimD)){
	    if(rand.runif() - ProbTargetFragD < 0)
	      L.push_back(difLen);
	    else
	      L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  }else{
	    L.push_back(rand.rTRgeom(rd,N[i-1])); 
          }
	  
	  if(rand.runif()- delProb < 0){ // propose deletion in delBasePosi
	    delWeight_in.resize(0);
	    calWeight(HMG0[i-1], L[i], delBasePosi, delWeight_in);
	    P.push_back(rand.rwunif(delWeight_in));
	    delWeight_in.resize(0);
	  }else{  // propose usual deletion
	    P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  }
	  
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  
	  
	  // Remove deleted positions from delBasePosi
	  for(k = 0; k < L[i]; k++){
	    if(HMG0[i-1][P[i]+k] >= 0)
	      delBasePosi[HMG0[i-1][P[i]+k]] = 0;
	  }

	}  
	i++;
	delWeight_in.resize(0);

      }else{         // tempTime > Time, if bases to be deleted left, delete them or propose an event at any left time, at a position, with particular length 

	//cout << "left over" << endl;
	done = false;
	//case1  Can we get there in one step deletion?
	
	  
	intTmp = delBasePosi.size();
	st = -1;
	en = -1;
	for(k = 0; k < intTmp; k++){
	  if(delBasePosi[k] == 1){
	    st = k;
	    break;
	  }
	}
	for(k = (intTmp-1); k >= 0; k--){
	  if(delBasePosi[k] == 1){
	    en = k;
	    break;
	  }
	}
	
	  // search position for st en
	intTmp = HMG0[i-1].size();
	for(k = 0; k < intTmp; k++){
	  if(HMG0[i-1][k] == st){
	    stPosi = k;
	    break;
	  }
	} 
	for(k = (intTmp-1); k >= 0; k--){
	  if(HMG0[i-1][k] == en){
	      enPosi = k;
	      break;
	  }
	}
		
	//cout << "stPosi " << stPosi << endl;
	//cout << "enPosi " << enPosi << endl;


	if(N[i-1] - Nend >= (enPosi - stPosi + 1)){  // We can go in one step
	  
	  //cout << "try one step " << endl;
	  ID.push_back(-1);
	  //cout << "N[i-1] " << N[i-1] << endl;
	  //cout << "Nend  " << Nend << endl;
	  L.push_back(N[i-1]-Nend);
	  //cout << "L " << L[i] << endl;
	  st = MAX(0, Nend - N[i-1] + enPosi + 1);
	  en = MIN(stPosi, N[i-1] - L[i]);
	  //cout << "st " << st << endl;
	  //cout << "stPosi - st +1 " << stPosi - st +1 << endl;
	  P.push_back(st + ((int)(rand.runif() * (en - st +1))));
	  //cout << "P " << P[i] << endl;
	  //V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  V.push_back(((rand.runif() * (Time-V[i-1]))+V[i-1]));
	  //cout << "V " << V[i] << endl;
	  N.push_back(Nend);

	  HMGin = HMG0[i-1];
	  //cout << "HMGin" << endl;
	  //print_veci(HMGin);
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  delWeight_in.resize(0);
	  delWeight.push_back(delWeight_in);
	  delWeight_in.resize(0);
	  done = true;
	}
	
	//Done of case1  we cannot get there in one step deletion?
      
	// case2 we cannot get there in one step deletion
	if(!done){
	
	  
	  //cout << "not one step " << endl;
	  // search position for deletion
	  realDelPosi.resize(0);
	  intTmp = HMG0[i-1].size();
	  realDelPosi.push_back(stPosi);
	  if(stPosi != enPosi){
	    for(k = (stPosi+1); k < enPosi; k++){
	      if(HMG0[i-1][k] >= 0){
		if(delBasePosi[HMG0[i-1][k]] == 1)
		  realDelPosi.push_back(k);
	      }
	    }
	    realDelPosi.push_back(enPosi);
          }
	  //cout << "realDelPosi " << endl;
	  //print_veci(realDelPosi);
	  
	  // how many?
	  //j = i;
	  
	  
	  st = 0;
	  
	  intTmp = realDelPosi.size();
	  //cout << "intTmp " << intTmp << endl;
	  while(intTmp > 1){
	    //cout << "realDelPosi " << endl;
	    //print_veci(realDelPosi);
	    //cout << "intTmp " << intTmp << endl;
	    ID.push_back(-1);
	    for(k = 0; k < (intTmp-1); k++){
	      if(realDelPosi[k]+1 < realDelPosi[k+1])
		break;
	    }
	    L.push_back(k+1);
	    //cout << "L " << L[i] << endl;
	    P.push_back(realDelPosi[0] - st);
	    //cout << "P " << P[i] << endl;
	    N.push_back(N[i-1]-L[i]);
	    //cout << "N " << N[i] << endl;
	    HMGin = HMG0[i-1];
	    for( k = 0; k < L[i]; k++){
	      HMGin.erase(HMGin.begin()+ P[i]);
	      realDelPosi.erase(realDelPosi.begin());
	    }
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);	    
	    st += L[i];
	    intTmp = realDelPosi.size();
	    i++;
	    delWeight_in.resize(0);
	    delWeight.push_back(delWeight_in);
	    delWeight_in.resize(0);
	  }
	  //cout << "####" << endl;
	  
	  if(intTmp == 1){
	    //cout << "intTmp : " << intTmp << endl;
	    ID.push_back(-1);
	    L.push_back(1);
	    P.push_back(realDelPosi[0] - st);
	    //cout << "1" << endl;
	    N.push_back(N[i-1]-L[i]);
	    HMGin = HMG0[i-1];
	    //cout << "2" << endl;
	    //print_veci(HMGin);
	    //cout << "L " << L[i] << endl;
	    //cout << "P " << P[i] << endl;
	    for( k = 0; k < L[i]; k++){
	      HMGin.erase(HMGin.begin()+ P[i]);
	      //realPosi.erase(realPosi.begin());
	    }
	    //cout << "3" << endl;
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);	    
	    st += L[i];
	    intTmp = realDelPosi.size();
	    i++;
	    delWeight_in.resize(0);
	    delWeight.push_back(delWeight_in);
	    delWeight_in.resize(0);
	    //cout << "4" << endl;
	  }
	  
	  //cout << "111" << endl;
	}
	
      
	if(N[i-1]<Nend){
	  //cout << "CC1 " << endl;
	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  //V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG0[i-1];
	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  delWeight_in.resize(0);
	  delWeight.push_back(delWeight_in);
	  delWeight_in.resize(0);
	  
	}else if(N[i-1]>Nend){
	  //cout << "CC2 " << endl;
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  //V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG0[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	  delWeight_in.resize(0);
	  delWeight.push_back(delWeight_in);
	  delWeight_in.resize(0);
	  
	}else{
	  //cout << "CC3 " << endl;
	  i--;
	}

	intTmp = P.size() - V.size();
	st = V.size();
	delWeight_in.resize(intTmp);
	for(k = 0; k < intTmp; k++)
	  delWeight_in[k] = (rand.runif() * (Time-V[st-1])) + V[st-1];
	
	for(k = 0; k < intTmp; k++){
	  st = which_min_vec(delWeight_in);
	  V.push_back(delWeight_in[st]);
	  delWeight_in.erase(delWeight_in.begin()+ st);
	}  
	
	//cout << "HAHA " << endl;
	break;
      }

    }
  }

  numE = i;
  V.push_back(Time);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(Nend);    
  HMG0.push_back(HMG0[numE]);
      
  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 



  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);

  delBasePosi.resize(0);
  delWeight_in.resize(0);
  realDelPosi.resize(0);


}
//--- v21 end ---//


/*
double Tree::ProposHistoryWithDeletionConstraint(const Parameters &para, InDelHistory* IDH, vector<int> delBasePosi, vector<vector<double> > delWeight){


  //cout << "In proposHistoryWithDeletionConstraint without delWeight!!! " << endl;

  //IDH->printIDH();
  





  double delProb = 4/(double)5;
  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i, j, k;

  //cout << "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << " delProb : " << delProb << endl;
  //cout << "delBasePosi " << endl;
  //print_veci(delBasePosi);
  


  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  double logProb, logProb1, logProb2;
  double res, fD;

  int numE = IDH->getNumE();
  int Nend = IDH->getN(numE);
  int numEndPosi;
  vector<double> logProbV(0);
  double logProbT; 
  int EndPosi;
  //vector<vector<double> > delWeight(0);
  vector<double> delWeight_in(0);

  int st, en, stPosi, enPosi, intTmp;

  //vector<int> delBasePosiT(0);
  //vector<int> visit(0);

  //delWeight.resize(numE+1);
  //for(i = 0; i <= numE; i++){
  //  delWeight_in.resize(0);
  //  delWeight[i] = delWeight_in;
  //}

  //delBasePosiT = delBasePosi;
  delWeight.resize(0);
  delWeight.resize(numE+1);
  delWeight_in.resize(0);
  delWeight[0] = delWeight_in;
  for(i = 1; i <= numE; i++){
    delWeight_in.resize(0);
    if(IDH->getID(i) == -1){
      calWeight(IDH->getHMG(i-1), IDH->getL(i), delBasePosi, delWeight_in);
      delWeight[i] = delWeight_in;
    
      // Remove deleted positions from delBasePosi
      //for(k = 0; k < IDH->getL(i); k++){
      //	if(IDH->getHMG(i-1, (IDH->getP(i) + k)) >= 0)
      //	  delBasePosi[IDH->getHMG(i-1, (IDH->getP(i) + k))] = 0;
      // }

    }else{
      delWeight[i] = delWeight_in;
    }

  }
  //delBasePosiT.resize(0);

  // Calculate delWeight first!!
  

  double weight;
  int tmpInt;
  double tuning;
  //delWeight.resize(0);
  delWeight_in.resize(0);
  
  //cout << "numE " << numE << endl;

  if(numE==0)                           // no event is proposed
    res = -((IDH->getN(0)+1)*lambda + fDel(IDH->getN(0),rd)*mu) * (IDH->getV(numE+1));
  else{
    int numE1 = numE-1;

    logProb = 0.0;

    if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 0){  
      // deletion containing bases only in delBasePosi
      
      //cout << "deletion containing bases only in delBasePosi " << endl;
      // Get possible number of ending positions
      numEndPosi = 1;
      if(numE > 1){
	for(i = numE1 ; i >= 1; i--){
	  if((IDH->IsDelEventContainingOnlyBases(i, delBasePosi) == 0) & (IDH->getHMG(i,IDH->getP(i+1)) >  IDH->getHMG(i-1,IDH->getP(i))) & (IDH->getP(i+1) > IDH->getP(i))){
	    numEndPosi++;
          }else{
	    break;
          }
	}
      }
      
      logProbV.resize(numEndPosi+1);

      // Find EndPosi
      EndPosi = numE - numEndPosi;

      //if(EndPosi > 1){

      for(i = 1; i <= EndPosi; i++){
	fD = fDel(IDH->getN(i-1),rd);   
	logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	if(IDH->getID(i)==1)
	  logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	else{
	  
	  if(IDH->IsDelEventContainingOnlyBases(i, delBasePosi)==2){ // not contain bases in delBasePosi
	    logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	  }else{
	    // get weight function
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];

	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	 
	    logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

          }
	}
      }// end of for
      

      for(j = 1; j <= numEndPosi; j++){
	
	logProbT = 0;

	for(i = (EndPosi + 1); i < EndPosi + j; i++){

	  //cout << "Here!!! " << endl;
	  fD = fDel(IDH->getN(i-1),rd);   
	  logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];

	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
          
	  logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);


	}
	
	tmpInt = EndPosi + j - 1;
	logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));

	logProbT -= (numE - EndPosi - j + 1)*log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
	logProbV[j-1] = logProb + logProbT;
      }


      logProbT = 0;
      
      for(i = (EndPosi + 1); i <= numE; i++){

 
	fD = fDel(IDH->getN(i-1),rd);   
	logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

 
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];

	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);
	
	logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

      }

      logProbT -= ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));
      
      logProbV[numEndPosi] = logProb + logProbT;
      

    }else if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 2){ 

      //cout << "insertion or deletion not containing delBasePosi " << endl;
      // Get possible number of ending positions
      numEndPosi = 1;
      if(numE > 1){
	if(IDH->IsDelEventContainingOnlyBases(numE-1, delBasePosi) == 0){
	  numEndPosi++;
	  if(numE > 2){
	    for(i = (numE1-1) ; i >= 1; i--){
	      if((IDH->IsDelEventContainingOnlyBases(i, delBasePosi) == 0) & (IDH->getHMG(i,IDH->getP(i+1)) >  IDH->getHMG(i-1,IDH->getP(i))) & (IDH->getP(i+1) > IDH->getP(i))){
		numEndPosi++;
	      }else{
		break;
	      }
	    }
          }
        }
      }
      
      logProbV.resize(numEndPosi+1);

      //cout << "numEndPosi " << numEndPosi << endl;

      // Find EndPosi
      EndPosi = numE - numEndPosi;

      //cout << "EndPosi : " << EndPosi << endl;
      //cout << "logProb : " << logProb << endl;


      if(numEndPosi > 1){

	for(i = 1; i <= EndPosi; i++){
	  fD = fDel(IDH->getN(i-1),rd);   
	  logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	  if(IDH->getID(i)==1)
	    logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	  else{
	    
	    if(IDH->IsDelEventContainingOnlyBases(i, delBasePosi)==2){ // not contain bases in delBasePosi
	      logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	    }else{
	      
	      delWeight_in.resize(0);
	      delWeight_in = delWeight[i];

	      weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	      delWeight_in.resize(0);
	      
	      logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	      
	    }
	  }
	}
	
	for(j = 1; j <= (numEndPosi-1); j++){
	  
	  
	  logProbT = 0;
	  
	  bool pass = false;
	  int ix = EndPosi + j - 1;
	  if(IDH->getN(ix) >  Nend){
	    

	    // search position for st en
	    intTmp = (IDH->getHMG(ix)).size();
	    for(k = 0; k < (intTmp-1); k++){
	      if(IDH->getHMG(ix, k) >= 0){
		if(delBasePosi[IDH->getHMG(ix, k)]==1){
		  stPosi = k;
		  break;
		}
	      } 
	    }
	    for(k = (intTmp-2); k >= 0; k--){
	      if( IDH->getHMG(ix, k) >= 0){
		if(delBasePosi[IDH->getHMG(ix, k)]==1){
		  enPosi = k;
		  break;
		}
	      }  
	    }
	    
	    if(IDH->getN(ix) - Nend >= (enPosi - stPosi + 1))
	      pass = true;
	    else
	      pass = false;
	    
	  }
	  
	if(!pass){
  
	  for(i = (EndPosi + 1); i < EndPosi + j; i++){
	
	    //cout << "Here!!! " << endl;  
	    fD = fDel(IDH->getN(i-1),rd);   
	    logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	    
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];

	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	    
	    logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	    
	  }

       
	  tmpInt = EndPosi + j - 1;
	  logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));
	//cout << " tmpInt : " << tmpInt << " logProbT B after: " << logProbT << endl;

	  logProbT -= (numE - EndPosi - j + 1)*log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
	  i = numE;
	  if(IDH->getID(numE)==1)
	    logProbT -= log((double)IDH->getN(i-1)+1); 
	  else
	    logProbT -= log((double)IDH->getN(i-1)+1 - IDH->getL(numE));
	  
	  logProbV[j-1] = logProb + logProbT;

	}else{
	  logProbV[j-1] = 0;
	}

      }

      logProbT = 0;

      j = numEndPosi;

      for(i = (EndPosi + 1); i < EndPosi + j; i++){
	
	//cout << "Here!!! " << endl;  
	fD = fDel(IDH->getN(i-1),rd);   
	logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];

	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);
	
	logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	    
      }

       
      tmpInt = EndPosi + j - 1;
      logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));
      //cout << " tmpInt : " << tmpInt << " logProbT B after: " << logProbT << endl;

      logProbT -= (numE - EndPosi - j + 1)*log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
      i = numE;
      if(IDH->getID(numE)==1)
	logProbT -= log((double)IDH->getN(i-1)+1); 
      else
	logProbT -= log((double)IDH->getN(i-1)+1 - IDH->getL(numE));
      
      logProbV[j-1] = logProb + logProbT;
      

      logProbT = 0;

      for(i = (EndPosi + 1); i <= (numE-1); i++){
	
	fD = fDel(IDH->getN(i-1),rd);   
	logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

 
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];

	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);

	logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);


      }


      i = numE;
      fD = fDel(IDH->getN(i-1),rd);   
      logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

      if(IDH->getID(i)==1)
	logProbT += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
      else
	logProbT += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);


      // v8
      //logProbT += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

      logProbT -= ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));
      
      logProbV[numEndPosi] = logProb + logProbT;
      

      }else{  // numEndPosi == 1

	for(i = 1; i <= EndPosi; i++){
	  fD = fDel(IDH->getN(i-1),rd);   
	  logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	  if(IDH->getID(i)==1)
	    logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	  else{
	  
	    if(IDH->IsDelEventContainingOnlyBases(i, delBasePosi)==2){ // not contain bases in delBasePosi
	      delWeight_in.resize(0);
	      delWeight_in = delWeight[i];
	      if(sum_vec(delWeight_in)==0){
		logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	      }else{
		logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	      }
	      delWeight_in.resize(0);
	    }else{
	  
	      delWeight_in.resize(0);
	      delWeight_in = delWeight[i];

	      weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	      delWeight_in.resize(0);
	      
	      logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	      
	    }
	  }
	}

	logProbT = 0;
	
	tmpInt = numE - 1;
	logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));
      //cout << " tmpInt : " << tmpInt << " logProbT B after: " << logProbT << endl;

	logProbT -= log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
	i = numE;
	if(IDH->getID(numE)==1)
	  logProbT -= log((double)IDH->getN(i-1)+1); 
	else
	  logProbT -= log((double)IDH->getN(i-1)+1 - IDH->getL(numE));
      
	logProbV[numEndPosi-1] = logProb + logProbT;
      

	logProbT = 0;
	i = numE;
	fD = fDel(IDH->getN(i-1),rd);   
	logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

	if(IDH->getID(i)==1)
	  logProbT += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	else
	  logProbT += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	logProbT -= ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));
      
	logProbV[numEndPosi] = logProb + logProbT;
      

      }



    }else if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 1){

      logProbV.resize(2);

      for(i = 1; i <= (numE-1); i++){
	fD = fDel(IDH->getN(i-1),rd);   
	logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	if(IDH->getID(i)==1)
	  logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	else{
	  
	  if(IDH->IsDelEventContainingOnlyBases(i, delBasePosi)==2){ // not contain bases in delBasePosi
	    logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	  }else{
	  
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];

	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	    
	    logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	    
          }
	}
      }

      logProbT = 0;
      
      tmpInt = numE - 1;
      logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));

      logProbT -= log(IDH->getV(numE+1) - IDH->getV(tmpInt));

      numE1 = numE-1;
      intTmp = (IDH->getHMG(numE1)).size();
      for(k = 0; k < (intTmp-1); k++){
	if(IDH->getHMG(numE1, k) >= 0){
	  if(delBasePosi[IDH->getHMG(numE1, k)]==1){
	    stPosi = k;
	    break;
	  }
	} 
      }
      for(k = (intTmp-2); k >= 0; k--){
	if( IDH->getHMG(numE1, k) >= 0){
	  if(delBasePosi[IDH->getHMG(numE1, k)]==1){
	    enPosi = k;
	    break;
	  }
	}  
      }
      
      st = MAX(0, Nend - IDH->getN(numE1) + enPosi + 1);
      en = MIN(stPosi, IDH->getN(numE1) - IDH->getL(numE));

      logProbT -= log((double)(en - st +1));
      
      logProbV[0] = logProb + logProbT;
      

      logProbT = 0;

      i = numE;
      fD = fDel(IDH->getN(i-1),rd);   
      logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
      
      delWeight_in.resize(0);
      delWeight_in = delWeight[i];
 
      weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
      delWeight_in.resize(0);
	 
      logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
      
      logProbT -= ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));
      
      logProbV[1] = logProb + logProbT;
      
    }

    logProb1 = logProbV[0];
    intTmp = logProbV.size();
    for(i = 1; i < intTmp; i++){
      logProb2 = logProbV[i];
      tuning = (logProb1>logProb2 ? logProb1 : logProb2);
      logProb1 -= tuning;
      logProb2 -= tuning;
      res = log(exp(logProb1) + exp(logProb2)) + tuning;
      logProb1 = res;
    }
    
    //cout << "logProbV " << endl;
    //print_vecd(logProbV);

  }

  logProbV.resize(0);
  delWeight.resize(0);
  delWeight_in.resize(0);
  delBasePosi.resize(0);
  //cout << "res " << res << endl;

  return res;
}
*/




//-- v21 start --//
/*
double Tree::ProposHistoryWithDeletionConstraint(const Parameters &para, InDelHistory* IDH, vector<int> delBasePosi){



  //cout << "In proposHistoryWithDeletionConstraint without delWeight!!! " << endl;

  //IDH->printIDH();
  






  double delProb = 4/(double)5;
  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i, j, k;

  //cout << "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << " delProb : " << delProb << endl;
  //cout << "delBasePosi " << endl;
  //print_veci(delBasePosi);
  


  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  double logProb, logProb1, logProb2;
  double res, fD;

  int numE = IDH->getNumE();
  int Nend = IDH->getN(numE);
  int numEndPosi;
  vector<double> logProbV(0);
  //-- v20 start --//
  vector<int> logProbVIX(0);
  logProbVIX.resize(0);
  double InsertDownWei = para.getInsertDownWei();
  //-- v20 end --//
  double logProbT; 
  int EndPosi;
  vector<vector<double> > delWeight(0);
  vector<double> delWeight_in(0);

  int st, en, stPosi, enPosi, intTmp;

  //vector<int> delBasePosiT(0);
  //vector<int> visit(0);

  //delWeight.resize(numE+1);
  //for(i = 0; i <= numE; i++){
  //  delWeight_in.resize(0);
  //  delWeight[i] = delWeight_in;
  //}

  //delBasePosiT = delBasePosi;
  delWeight.resize(numE+1);
  delWeight_in.resize(0);
  delWeight[0] = delWeight_in;
  for(i = 1; i <= numE; i++){
    delWeight_in.resize(0);
    if(IDH->getID(i) == -1){
      calWeight(IDH->getHMG(i-1), IDH->getL(i), delBasePosi, delWeight_in);
      delWeight[i] = delWeight_in;
    
      // Remove deleted positions from delBasePosi
      //for(k = 0; k < IDH->getL(i); k++){
      //	if(IDH->getHMG(i-1, (IDH->getP(i) + k)) >= 0)
      //	  delBasePosi[IDH->getHMG(i-1, (IDH->getP(i) + k))] = 0;
      // }

    }else{
      //-- v20 start ---//
      calWeightIn(IDH->getHMG(i-1), delBasePosi, delWeight_in, InsertDownWei);
      //-- v20 end ---//
      delWeight[i] = delWeight_in;
    }

  }
  //delBasePosiT.resize(0);

  // Calculate delWeight first!!
  

  double weight;
  int tmpInt;
  double tuning;
  //delWeight.resize(0);
  delWeight_in.resize(0);
  
  //cout << "numE " << numE << endl;

  if(numE==0)                           // no event is proposed
    res = -((IDH->getN(0)+1)*lambda + fDel(IDH->getN(0),rd)*mu) * (IDH->getV(numE+1));
  else{
    int numE1 = numE-1;

    logProb = 0.0;


    if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 0){  
      // deletion containing bases only in delBasePosi
      
      //cout << "deletion containing bases only in delBasePosi " << endl;
      // Get possible number of ending positions
      numEndPosi = 1;
      if(numE > 1){
	for(i = numE1 ; i >= 1; i--){
	  if((IDH->IsDelEventContainingOnlyBases(i, delBasePosi) == 0) & (IDH->getHMG(i,IDH->getP(i+1)) >  IDH->getHMG(i-1,IDH->getP(i))) & (IDH->getP(i+1) > IDH->getP(i))){
	    numEndPosi++;
          }else{
	    break;
          }
	}
      }
      
      logProbV.resize(numEndPosi+1);

      // Find EndPosi
      EndPosi = numE - numEndPosi;

      //if(EndPosi > 1){

      for(i = 1; i <= EndPosi; i++){
	fD = fDel(IDH->getN(i-1),rd);   
	logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	if(IDH->getID(i)==1){
	  //-- v20 start --//
	  //logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];
	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
	  logProb += (logLambda + log((double)(IDH->getN(i-1)+1)) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1);
          //-- v20 end --//
	}else{
	  
	  if(IDH->IsDelEventContainingOnlyBases(i, delBasePosi)==2){ // not contain bases in delBasePosi
	    logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	  }else{
	    // get weight function
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];

	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	 
	    logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

          }
	}
      }// end of for
      

      for(j = 1; j <= numEndPosi; j++){
	
	logProbT = 0;

	for(i = (EndPosi + 1); i < EndPosi + j; i++){

	  //cout << "Here!!! " << endl;
	  fD = fDel(IDH->getN(i-1),rd);   
	  logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];

	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
          
	  logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);


	}
	
	tmpInt = EndPosi + j - 1;
	logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));

	logProbT -= (numE - EndPosi - j + 1)*log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
	logProbV[j-1] = logProb + logProbT;
      }


      logProbT = 0;
      
      for(i = (EndPosi + 1); i <= numE; i++){

 
	fD = fDel(IDH->getN(i-1),rd);   
	logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

 
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];

	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);
	
	logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

      }

      logProbT -= ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));
      
      logProbV[numEndPosi] = logProb + logProbT;
      

    }else if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 2){ 

      //cout << "insertion or deletion not containing delBasePosi " << endl;
      // Get possible number of ending positions
      numEndPosi = 1;
      if(numE > 1){
	if(IDH->IsDelEventContainingOnlyBases(numE-1, delBasePosi) == 0){
	  numEndPosi++;
	  if(numE > 2){
	    for(i = (numE1-1) ; i >= 1; i--){
	      if((IDH->IsDelEventContainingOnlyBases(i, delBasePosi) == 0) & (IDH->getHMG(i,IDH->getP(i+1)) >  IDH->getHMG(i-1,IDH->getP(i))) & (IDH->getP(i+1) > IDH->getP(i))){
		numEndPosi++;
	      }else{
		break;
	      }
	    }
          }
        }
      }
      
      logProbV.resize(numEndPosi+1);

      //-- v20 start --//
      logProbVIX.resize(numEndPosi+1);
      for(i = 0; i <= numEndPosi; i++)
	logProbVIX[i] = 0;
      //-- v20 end --//
      //cout << "numEndPosi " << numEndPosi << endl;

      // Find EndPosi
      EndPosi = numE - numEndPosi;

      //cout << "EndPosi : " << EndPosi << endl;
      //cout << "logProb : " << logProb << endl;

      if(numEndPosi > 1){

      for(i = 1; i <= EndPosi; i++){
	fD = fDel(IDH->getN(i-1),rd);   
	logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	if(IDH->getID(i)==1){
	  //-- v20 start --//
	  //logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];
	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
	  logProb += (logLambda + log((double)(IDH->getN(i-1)+1)) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1);
	  //-- v20 end --//
	}else{
	  
	  if(IDH->IsDelEventContainingOnlyBases(i, delBasePosi)==2){ // not contain bases in delBasePosi
	    logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	  }else{
	  
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];

	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	    
	    logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	    
          }
	}
      }

      for(j = 1; j <= (numEndPosi-1); j++){
	
    
	logProbT = 0;

	bool pass = false;
	int ix = EndPosi + j - 1;
	if(IDH->getN(ix) >  Nend){
	 

	  // search position for st en
	  //cout << "HMG ix " << ix << endl;
	  //print_veci(IDH->getHMG(ix));
	  //cout << "delBasePosi " << endl;
	  //print_veci(delBasePosi);
	  intTmp = (IDH->getHMG(ix)).size();
 	  for(k = 0; k < (intTmp-1); k++){
	    if(IDH->getHMG(ix, k) >= 0){
	      if(delBasePosi[IDH->getHMG(ix, k)]==1){
		stPosi = k;
		break;
	      }
	    } 
          }
	  for(k = (intTmp-2); k >= 0; k--){
	    if( IDH->getHMG(ix, k) >= 0){
	      if(delBasePosi[IDH->getHMG(ix, k)]==1){
		enPosi = k;
		break;
	      }
	    }  
          }

	  //cout << "stPosi : " << stPosi << endl;
	  //cout << "enPosi : " << enPosi << endl;
	  if(IDH->getN(ix) - Nend >= (enPosi - stPosi + 1))
	    pass = true;
	  else
	    pass = false;

        }
	    
	if(!pass){
  
	  for(i = (EndPosi + 1); i < EndPosi + j; i++){
	
	    //cout << "Here!!! " << endl;  
	    fD = fDel(IDH->getN(i-1),rd);   
	    logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	    
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];

	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	    
	    logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	    
	  }

       
	  tmpInt = EndPosi + j - 1;
	  logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));
	//cout << " tmpInt : " << tmpInt << " logProbT B after: " << logProbT << endl;

	  logProbT -= (numE - EndPosi - j + 1)*log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
	  i = numE;
	  if(IDH->getID(numE)==1)
	    logProbT -= log((double)IDH->getN(i-1)+1); 
	  else
	    logProbT -= log((double)IDH->getN(i-1)+1 - IDH->getL(numE));
	  
	  logProbV[j-1] = logProb + logProbT;

	}else{
	  logProbV[j-1] = 0;
	  //-- v20 start --//
	  logProbVIX[j-1] = 1;
	  //-- v20 end --//
	}

      }

      logProbT = 0;

      j = numEndPosi;

      for(i = (EndPosi + 1); i < EndPosi + j; i++){
	
	//cout << "Here!!! " << endl;  
	fD = fDel(IDH->getN(i-1),rd);   
	logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	    
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];

	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);
	
	logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	    
      }

       
      tmpInt = EndPosi + j - 1;
      logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));
      //cout << " tmpInt : " << tmpInt << " logProbT B after: " << logProbT << endl;

      logProbT -= (numE - EndPosi - j + 1)*log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
      i = numE;
      if(IDH->getID(numE)==1)
	logProbT -= log((double)IDH->getN(i-1)+1); 
      else
	logProbT -= log((double)IDH->getN(i-1)+1 - IDH->getL(numE));
      
      logProbV[j-1] = logProb + logProbT;
      

      logProbT = 0;

      for(i = (EndPosi + 1); i <= (numE-1); i++){
	
	fD = fDel(IDH->getN(i-1),rd);   
	logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

 
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];

	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);

	logProbT += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);


      }


      i = numE;
      fD = fDel(IDH->getN(i-1),rd);   
      logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

      if(IDH->getID(i)==1){
	//-- v20 start --//
	//logProbT += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];
	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);
	logProbT += (logLambda + log((double)(IDH->getN(i-1)+1)) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1);
	//-- v20 end --//
      }else
	logProbT += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1))  - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
      
      // v8
	//logProbT += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

      logProbT -= ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));
      
      logProbV[numEndPosi] = logProb + logProbT;

    }else{  // numEndPosi == 1

	for(i = 1; i <= EndPosi; i++){
	  fD = fDel(IDH->getN(i-1),rd);   
	  logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	  if(IDH->getID(i)==1){
	    //-- v20 start --//
	    //logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];
	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	    logProb += (logLambda + log((double)(IDH->getN(i-1)+1)) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1);
	    //-- v20 end --//
	  }else{
	  
	    if(IDH->IsDelEventContainingOnlyBases(i, delBasePosi)==2){ // not contain bases in delBasePosi
	      delWeight_in.resize(0);
	      delWeight_in = delWeight[i];
	      if(sum_vec(delWeight_in)==0){
		logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	      }else{
		logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	      }
	      delWeight_in.resize(0);
	    }else{
	  
	      delWeight_in.resize(0);
	      delWeight_in = delWeight[i];

	      weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	      delWeight_in.resize(0);
	      
	      logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	      
	    }
	  }
	}

	logProbT = 0;
	
	tmpInt = numE - 1;
	logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));
      //cout << " tmpInt : " << tmpInt << " logProbT B after: " << logProbT << endl;

	logProbT -= log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
	i = numE;
	if(IDH->getID(numE)==1)
	  logProbT -= log((double)IDH->getN(i-1)+1); 
	else
	  logProbT -= log((double)IDH->getN(i-1)+1 - IDH->getL(numE));
      
	logProbV[numEndPosi-1] = logProb + logProbT;
      

	logProbT = 0;
	i = numE;
	fD = fDel(IDH->getN(i-1),rd);   
	logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));

	if(IDH->getID(i)==1){
	  //-- v20 start --//
	  //logProbT += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];
	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
	  logProbT += (logLambda + log((double)(IDH->getN(i-1)+1)) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1);
	  //-- v20 end --//
	}else
	  logProbT += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	logProbT -= ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));
      
	logProbV[numEndPosi] = logProb + logProbT;
      

      }



      
    }else if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 1){

      logProbV.resize(2);

      for(i = 1; i <= (numE-1); i++){
	fD = fDel(IDH->getN(i-1),rd);   
	logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	if(IDH->getID(i)==1){
	  //-- v20 start --//
	  //logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];
	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
	  logProb += (logLambda + log((double)(IDH->getN(i-1)+1)) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1);
	  //-- v20 end --//
	}else{
	  
	  if(IDH->IsDelEventContainingOnlyBases(i, delBasePosi)==2){ // not contain bases in delBasePosi
	    logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) + log(1-delProb) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	  }else{
	  
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];

	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	    
	    logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
	    
          }
	}
      }

      logProbT = 0;
      
      tmpInt = numE - 1;
      logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));

      logProbT -= log(IDH->getV(numE+1) - IDH->getV(tmpInt));

      numE1 = numE-1;
      intTmp = (IDH->getHMG(numE1)).size();
      for(k = 0; k < (intTmp-1); k++){
	if(IDH->getHMG(numE1, k) >= 0){
	  if(delBasePosi[IDH->getHMG(numE1, k)]==1){
	    stPosi = k;
	    break;
	  }
	} 
      }
      for(k = (intTmp-2); k >= 0; k--){
	if( IDH->getHMG(numE1, k) >= 0){
	  if(delBasePosi[IDH->getHMG(numE1, k)]==1){
	    enPosi = k;
	    break;
	  }
	}  
      }
      
      st = MAX(0, Nend - IDH->getN(numE1) + enPosi + 1);
      en = MIN(stPosi, IDH->getN(numE1) - IDH->getL(numE));
	     
      logProbT -= log((double)(en - st +1));
      
      logProbV[0] = logProb + logProbT;
      

      logProbT = 0;

      i = numE;
      fD = fDel(IDH->getN(i-1),rd);   
      logProbT -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
      
      delWeight_in.resize(0);
      delWeight_in = delWeight[i];
 
      weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
      delWeight_in.resize(0);
	 
      logProb += (log(fD) + logMu  + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
      
      logProbT -= ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));
      
      logProbV[1] = logProb + logProbT;
      
    }


    //-- v20 start --//
    if(logProbVIX.size() == 0){
      logProb1 = logProbV[0];
      intTmp = logProbV.size();
      for(i = 1; i < intTmp; i++){
	logProb2 = logProbV[i];
	tuning = (logProb1>logProb2 ? logProb1 : logProb2);
	logProb1 -= tuning;
	logProb2 -= tuning;
	res = log(exp(logProb1) + exp(logProb2)) + tuning;
	logProb1 = res;
      }
    }else{
      intTmp = logProbV.size();
      logProb1 = logProbV[intTmp-1];
      for(i = 0; i < (intTmp-1); i++){
	if(logProbVIX[i] == 0){
	  logProb2 = logProbV[i];
	  tuning = (logProb1>logProb2 ? logProb1 : logProb2);
	  logProb1 -= tuning;
	  logProb2 -= tuning;
	  res = log(exp(logProb1) + exp(logProb2)) + tuning;
	  logProb1 = res;
	}
      }
    }
    //-- v20 end --//
    //cout << "logProbV " << endl;
    //print_vecd(logProbV);

  }

  //-- v20 start --//
  logProbVIX.resize(0);
  //-- v20 start --//

  logProbV.resize(0);
  delWeight.resize(0);
  delWeight_in.resize(0);
  delBasePosi.resize(0);
  //cout << "res " << res << endl;

  return res;
}
*/
//--- v21 end ---//



//-- v21 start --//
double Tree::ProposHistoryWithDeletionConstraint(const Parameters &para, InDelHistory* IDH, vector<int> delBasePosi){



  //cout << "In proposHistoryWithDeletionConstraint without delWeight!!! " << endl;

  //IDH->printIDH();
  






  double delProb = para.getDelProb();
  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i, j, k;


  //-- v20 start --//
  double logProbA, logProbB;
  double C_noEvent = para.getC_noEvent(); 
  double WeiID = para.getWeiID();
  double ImulFacSD = para.getImulFacSD();
  double DmulFacSD = para.getDmulFacSD();
  double ProbTargetFragI = para.getProbTargetFragI();
  double ProbTargetFragD = para.getProbTargetFragD();
  double logprobNoE;
  double eta;
  double LimI, LimD;
  int difLen;
  int numE = IDH->getNumE();
  int Nend = IDH->getN(numE+1);
  double Time = IDH->getV(numE+1);
  LimI = 1/ri + ImulFacSD*sqrt(1-ri)/ri;
  LimD = 1/rd + DmulFacSD*sqrt(1-rd)/rd;
  vector<int> tHMG(0);
  bool noDelBasePosi;
  int LenDel;
  double tmpDouble; 
  //-- v20 end --//




  //cout << "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << " delProb : " << delProb << endl;
  //cout << "delBasePosi " << endl;
  //print_veci(delBasePosi);
  


  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  double logProb, logProb1, logProb2;
  double res, fD;


  int numEndPosi;
  vector<double> logProbV(0);
  //-- v20 start --//
  vector<int> logProbVIX(0);
  logProbVIX.resize(0);
  double InsertDownWei = para.getInsertDownWei();
  //-- v20 end --//
  double logProbT; 
  int EndPosi;
  vector<vector<double> > delWeight(0);
  vector<double> delWeight_in(0);

  int st, en, stPosi, enPosi, intTmp;

  //vector<int> delBasePosiT(0);
  //vector<int> visit(0);

  //delWeight.resize(numE+1);
  //for(i = 0; i <= numE; i++){
  //  delWeight_in.resize(0);
  //  delWeight[i] = delWeight_in;
  //}

  //delBasePosiT = delBasePosi;
  delWeight.resize(numE+1);
  delWeight_in.resize(0);
  delWeight[0] = delWeight_in;
  for(i = 1; i <= numE; i++){
    delWeight_in.resize(0);
    if(IDH->getID(i) == -1){
      calWeight(IDH->getHMG(i-1), IDH->getL(i), delBasePosi, delWeight_in);
      delWeight[i] = delWeight_in;
    
      // Remove deleted positions from delBasePosi
      //for(k = 0; k < IDH->getL(i); k++){
      //	if(IDH->getHMG(i-1, (IDH->getP(i) + k)) >= 0)
      //	  delBasePosi[IDH->getHMG(i-1, (IDH->getP(i) + k))] = 0;
      // }

    }else{
      //-- v20 start ---//
      calWeightIn(IDH->getHMG(i-1), delBasePosi, delWeight_in, InsertDownWei);
      //-- v20 end ---//
      delWeight[i] = delWeight_in;
    }

  }
  //delBasePosiT.resize(0);

  // Calculate delWeight first!!
  

  double weight;
  int tmpInt;
  double tuning;
  //delWeight.resize(0);
  delWeight_in.resize(0);
  
  //cout << "numE " << numE << endl;

  if(numE==0){
    // no event is proposed
    eta = (IDH->getN(0)+1)*lambda + fDel(IDH->getN(0),rd)*mu;
    logprobNoE = -eta*Time/C_noEvent;
    res = LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - eta*Time);
  }else{
    int numE1 = numE-1;

    logProb = 0.0;


    if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 0){  
   
      //-------------------------------------------------------------//
      //                                                             //
      // case III :  deletion containing bases only in delBasePosi   //
      //                                                             //
      //-------------------------------------------------------------//

      
      //cout << "deletion containing bases only in delBasePosi " << endl;
      // Get possible number of ending positions
      numEndPosi = 1;
      if(numE > 1){
	for(i = numE1 ; i >= 1; i--){
	  if((IDH->IsDelEventContainingOnlyBases(i, delBasePosi) == 0) & (IDH->getHMG(i,IDH->getP(i+1)) >  IDH->getHMG(i-1,IDH->getP(i))) & (IDH->getP(i+1) > IDH->getP(i))){
	    numEndPosi++;
          }else{
	    break;
          }
	}
      }
      
      logProbV.resize(numEndPosi+1);

      // Find EndPosi
      EndPosi = numE - numEndPosi;


      for(i = 1; i <= EndPosi; i++){

       
	tHMG = IDH->getHMG(i-1);
	stPosi = -1;
	enPosi = -1;

	intTmp = tHMG.size();
	for(k = 0; k < (intTmp-1); k++){
	  if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		stPosi = k;
		break;
	      }
	  } 
	}
	for(k = (intTmp-2); k >= 0; k--){
	  if(tHMG[k] >= 0){
	    if(delBasePosi[tHMG[k]]==1){
	      enPosi = k;
	      break;
	    }
	  }  
	}
	
	if((stPosi == -1) | (enPosi == -1))
	  cout << "ERROR in ProposHistoryWithDeletionConstraint A! No bases in delBasePosi." << endl;
	

	LenDel = enPosi - stPosi + 1;

	if(LenDel <= 0)
	  cout << "ERROR in ProposHistoryWithDeletionConstraint A! LenDel should be positive." << endl;


	fD = fDel(IDH->getN(i-1),rd);   
	eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];
	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);
	
	//logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
	if(IDH->getID(i)==1){  // insertion

	  difLen = Nend - IDH->getN(i-1) + LenDel;

	  if(difLen <= 0){            // insertion - 1

	    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((IDH->getN(i-1)+1)*lambda - fD*mu*WeiID) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1;

	  }else if(difLen >= LimI){   // insertion - 3

	    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + logRi + (IDH->getL(i)-1) * logRi1;

	  }else{                      // insertion - 2

	    if(difLen == IDH->getL(i)){

	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1);

	    }else{

	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1;
	    
	    }
	  }

	}else{   // deletion 

	  if(IDH->getN(i-1) - LenDel < Nend){

	    difLen = LenDel;

	    if(difLen >= LimD){    // Deletion - 2
	      
	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu +  log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	    }else{                 // Deletion - 1

	      if(difLen == IDH->getL(i)){

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	      }else{

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight)+ log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

              }
            }

	  }else{   // means IDH->getN(i-1) - LenDel >= Nend
		
	    difLen = IDH->getN(i-1) - Nend;

	    if(difLen >= LimD){    // Deletion - 4
	      
	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	    }else{                 // Deletion - 3

	      if(difLen == IDH->getL(i)){

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	      }else{

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

              }
            }
	  }  // Done of if(IDH->getN(i-1) - LenDel < Nend){

	} // Done of deletion

      }// end of for
      

      for(j = 1; j <= numEndPosi; j++){
	
	logProbT = 0;

	for(i = (EndPosi + 1); i < EndPosi + j; i++){


	  tHMG = IDH->getHMG(i-1);
	  stPosi = -1;
	  enPosi = -1;
	  
	  intTmp = tHMG.size();
	  for(k = 0; k < (intTmp-1); k++){
	    if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		stPosi = k;
		break;
	      }
	    } 
	  }
	  for(k = (intTmp-2); k >= 0; k--){
	    if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		enPosi = k;
		break;
	      }
	    }  
	  }
	  
	  if((stPosi == -1) | (enPosi == -1))
	    cout << "ERROR in ProposHistoryWithDeletionConstraint B! No bases in delBasePosi." << endl;
	  

	  LenDel = enPosi - stPosi + 1;
	  
	  if(LenDel <= 0)
	    cout << "ERROR in ProposHistoryWithDeletionConstraint B! LenDel should be positive." << endl;


	  //cout << "Here!!! " << endl;
	  fD = fDel(IDH->getN(i-1),rd);   
	  eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];
	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
	  

	  // All deletion
	  
	  if(IDH->getN(i-1) - LenDel < Nend){
	    
	    difLen = LenDel;
	    
	    if(difLen >= LimD){    // Deletion - 2
	      
	      logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu +  log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
	      
	    }else{                 // Deletion - 1
	      
	      if(difLen == IDH->getL(i)){

		logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
		
	      }else{
		
		logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight)+ log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		
              }
            }

	  }else{   // means IDH->getN(i-1) - LenDel >= Nend
	    
	    difLen = IDH->getN(i-1) - Nend;
	    
	    if(difLen >= LimD){    // Deletion - 4
	      
	      logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
	      
	    }else{                 // Deletion - 3
	      
	      if(difLen == IDH->getL(i)){
		
		logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
		
	      }else{
		
		logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		
              }
            }
	  }  // Done of if(IDH->getN(i-1) - LenDel < Nend){
	} // End for loop for i
	

	tmpInt = EndPosi + j - 1;
	logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));

	logProbT -= (numE - EndPosi - j + 1)*log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
	logProbV[j-1] = logProb + logProbT;
      }  // End for loop for j




      logProbT = 0;
      
      for(i = (EndPosi + 1); i <= numE; i++){


	tHMG = IDH->getHMG(i-1);
	stPosi = -1;
	enPosi = -1;
	
	intTmp = tHMG.size();
	for(k = 0; k < (intTmp-1); k++){
	  if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		stPosi = k;
		break;
	      }
	  } 
	}
	for(k = (intTmp-2); k >= 0; k--){
	  if(tHMG[k] >= 0){
	    if(delBasePosi[tHMG[k]]==1){
	      enPosi = k;
	      break;
	    }
	  }  
	}
	
	if((stPosi == -1) | (enPosi == -1))
	  cout << "ERROR in ProposHistoryWithDeletionConstraint C! No bases in delBasePosi." << endl;
	
	
	LenDel = enPosi - stPosi + 1;

	if(LenDel <= 0)
	  cout << "ERROR in ProposHistoryWithDeletionConstraint C! LenDel should be positive." << endl;

 
	fD = fDel(IDH->getN(i-1),rd);
	eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];
	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);

   
	if(IDH->getN(i-1) - LenDel < Nend){

	  difLen = LenDel;
	  
	  if(difLen >= LimD){    // Deletion - 2
	    
	    logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu +  log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	  }else{                 // Deletion - 1

	    if(difLen == IDH->getL(i)){

	      logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	    }else{

	      logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight)+ log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	    }
	  }

	}else{   // means IDH->getN(i-1) - LenDel >= Nend
		
	  difLen = IDH->getN(i-1) - Nend;
	  
	  if(difLen >= LimD){    // Deletion - 4
	    
	    logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	  }else{                 // Deletion - 3

	    if(difLen == IDH->getL(i)){
	      
	      logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	    }else{
	      
	      logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	    }
	  }
	}  // Done of if(IDH->getN(i-1) - LenDel < Nend){

      } // End for loop


      fD = fDel(IDH->getN(numE),rd);
      eta = (IDH->getN(numE)+1)*lambda + fD*mu;
      logprobNoE = -eta*(IDH->getV(numE+1) - IDH->getV(numE))/C_noEvent; // No event from numE

      logProbT += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);
      
      logProbV[numEndPosi] = logProb + logProbT;
      
      
    }else if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 2){ 

      //-------------------------------------------------------------//
      //                                                             //
      // case II : insertion or deletion not containing delBasePosi  //
      //                                                             //
      //-------------------------------------------------------------//

      //cout << "insertion or deletion not containing delBasePosi " << endl;
      // Get possible number of ending positions
      numEndPosi = 1;
      if(numE > 1){
	if(IDH->IsDelEventContainingOnlyBases(numE-1, delBasePosi) == 0){
	  numEndPosi++;
	  if(numE > 2){
	    for(i = (numE1-1) ; i >= 1; i--){
	      if((IDH->IsDelEventContainingOnlyBases(i, delBasePosi) == 0) & (IDH->getHMG(i,IDH->getP(i+1)) >  IDH->getHMG(i-1,IDH->getP(i))) & (IDH->getP(i+1) > IDH->getP(i))){
		numEndPosi++;
	      }else{
		break;
	      }
	    }
          }
        }
      }
      
      logProbV.resize(numEndPosi+1);

      //-- v20 start --//
      logProbVIX.resize(numEndPosi+1);
      for(i = 0; i <= numEndPosi; i++)
	logProbVIX[i] = 0;
      //-- v20 end --//
      //cout << "numEndPosi " << numEndPosi << endl;

      // Find EndPosi
      EndPosi = numE - numEndPosi;

      //cout << "EndPosi : " << EndPosi << endl;
      //cout << "logProb : " << logProb << endl;

      if(numEndPosi > 1){

	// We have deletion!!!!

	for(i = 1; i <= EndPosi; i++){
	  
	  tHMG = IDH->getHMG(i-1);
	  stPosi = -1;
	  enPosi = -1;
	  
	  intTmp = tHMG.size();
	  for(k = 0; k < (intTmp-1); k++){
	    if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		stPosi = k;
		break;
	      }
	    } 
	  }
	  for(k = (intTmp-2); k >= 0; k--){
	    if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		enPosi = k;
		break;
	      }
	    }  
	  }
	  
	  if((stPosi == -1) | (enPosi == -1))
	    cout << "ERROR in ProposHistoryWithDeletionConstraint D! No bases in delBasePosi." << endl;
	

	  
	  LenDel = enPosi - stPosi + 1;

	  if(LenDel <= 0)
	    cout << "ERROR in ProposHistoryWithDeletionConstraint A! LenDel should be positive." << endl;

	  
	  fD = fDel(IDH->getN(i-1),rd);   
	  eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];
	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
	  

	  if(IDH->getID(i)==1){  // insertion

	    difLen = Nend - IDH->getN(i-1) + LenDel;

	    if(difLen <= 0){            // insertion - 1

	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((IDH->getN(i-1)+1)*lambda - fD*mu*WeiID) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1;
	      
	    }else if(difLen >= LimI){   // insertion - 3
	    
	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + logRi + (IDH->getL(i)-1) * logRi1;

	    }else{                      // insertion - 2

	      if(difLen == IDH->getL(i)){

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1);

	      }else{

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1;
	    
	      }
	    }
	    
	  }else{   // deletion 

	    if(IDH->getN(i-1) - LenDel < Nend){

	      difLen = LenDel;

	      if(difLen >= LimD){    // Deletion - 2
	      
		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu +  log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	      }else{                 // Deletion - 1

		if(difLen == IDH->getL(i)){

		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

		}else{

		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight)+ log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

		}
	      }

	    }else{   // means IDH->getN(i-1) - LenDel >= Nend
		
	      difLen = IDH->getN(i-1) - Nend;

	      if(difLen >= LimD){    // Deletion - 4
	      
		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	      }else{                 // Deletion - 3

		if(difLen == IDH->getL(i)){

		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

		}else{

		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

		}
	      }
	    }  // Done of if(IDH->getN(i-1) - LenDel < Nend){
	    
	  } // Done of deletion

	}// end of for
      

	for(j = 1; j <= (numEndPosi-1); j++){
	  
	  
	  logProbT = 0;

	  bool pass = false;
	  int ix = EndPosi + j - 1;
	  if(IDH->getN(ix) >  Nend){
	 
	    stPosi = -1;
	    enPosi = -1;
	    intTmp = (IDH->getHMG(ix)).size();
	    for(k = 0; k < (intTmp-1); k++){
	      if(IDH->getHMG(ix, k) >= 0){
		if(delBasePosi[IDH->getHMG(ix, k)]==1){
		  stPosi = k;
		  break;
		}
	      } 
	    }
	    for(k = (intTmp-2); k >= 0; k--){
	      if( IDH->getHMG(ix, k) >= 0){
		if(delBasePosi[IDH->getHMG(ix, k)]==1){
		  enPosi = k;
		  break;
		}
	      }  
	    }

	    if((stPosi == -1) | (enPosi == -1))
	    cout << "ERROR in ProposHistoryWithDeletionConstraint E! No bases in delBasePosi." << endl;


	    //cout << "stPosi : " << stPosi << endl;
	    //cout << "enPosi : " << enPosi << endl;
	    if(IDH->getN(ix) - Nend >= (enPosi - stPosi + 1))
	      pass = true;
	    else
	      pass = false;
	    
	  }
	    
	  if(!pass){
  
	    for(i = (EndPosi + 1); i < EndPosi + j; i++){
	
	      //cout << "Here!!! " << endl;  


	      tHMG = IDH->getHMG(i-1);
	      stPosi = -1;
	      enPosi = -1;
	      
	      intTmp = tHMG.size();
	      for(k = 0; k < (intTmp-1); k++){
		if(tHMG[k] >= 0){
		  if(delBasePosi[tHMG[k]]==1){
		    stPosi = k;
		    break;
		  }
		} 
	      }
	      for(k = (intTmp-2); k >= 0; k--){
		if(tHMG[k] >= 0){
		  if(delBasePosi[tHMG[k]]==1){
		    enPosi = k;
		    break;
		  }
		}  
	      }
	      
	      if((stPosi == -1) | (enPosi == -1))
		cout << "ERROR in ProposHistoryWithDeletionConstraint F! No bases in delBasePosi." << endl;
	      
	      
	      LenDel = enPosi - stPosi + 1;
	      
	      if(LenDel <= 0)
		cout << "ERROR in ProposHistoryWithDeletionConstraint F! LenDel should be positive." << endl;
	      


	      fD = fDel(IDH->getN(i-1),rd);   
	      eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
	      delWeight_in.resize(0);
	      delWeight_in = delWeight[i];
	      weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	      delWeight_in.resize(0);
	    

	      // All deletion
	  
	      if(IDH->getN(i-1) - LenDel < Nend){
	    
		difLen = LenDel;
	    
		if(difLen >= LimD){    // Deletion - 2
	      
		  logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu +  log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
	      
		}else{                 // Deletion - 1
	      
		  if(difLen == IDH->getL(i)){

		    logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
		
		  }else{
		
		    logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight)+ log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		
		  }
		}
		
	      }else{   // means IDH->getN(i-1) - LenDel >= Nend
		
		difLen = IDH->getN(i-1) - Nend;
		
		if(difLen >= LimD){    // Deletion - 4
		  
		  logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		  
		}else{                 // Deletion - 3
		  
		  if(difLen == IDH->getL(i)){
		    
		    logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
		    
		  }else{
		    
		    logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		    
		  }
		}
	      }  // Done of if(IDH->getN(i-1) - LenDel < Nend){
	       
	    }  // End for loop
	    
       
	    tmpInt = EndPosi + j - 1;
	    logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));
	    //cout << " tmpInt : " << tmpInt << " logProbT B after: " << logProbT << endl;

	    logProbT -= (numE - EndPosi - j + 1)*log(IDH->getV(numE+1) - IDH->getV(tmpInt));
 
	    i = numE;
	    if(IDH->getID(numE)==1)
	      logProbT -= log((double)IDH->getN(i-1)+1); 
	    else
	      logProbT -= log((double)IDH->getN(i-1)+1 - IDH->getL(numE));
	    
	    logProbV[j-1] = logProb + logProbT;
	    
	  }else{
	    logProbV[j-1] = 0;
	    //-- v20 start --//
	    logProbVIX[j-1] = 1;
	    //-- v20 end --//
	  }
	  
	}
	
	// End and End+1 cases
	
	logProbT = 0;
	
	for(i = (EndPosi + 1); i <= (numE-1); i++){
	
	  tHMG = IDH->getHMG(i-1);
	  stPosi = -1;
	  enPosi = -1;
	  
	  intTmp = tHMG.size();
	  for(k = 0; k < (intTmp-1); k++){
	    if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		stPosi = k;
		break;
	      }
	    } 
	  }
	  for(k = (intTmp-2); k >= 0; k--){
	    if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		enPosi = k;
		break;
	      }
	    }  
	  }
	  
	  if((stPosi == -1) | (enPosi == -1))
	    cout << "ERROR in ProposHistoryWithDeletionConstraint G! No bases in delBasePosi." << endl;
	
	
	  LenDel = enPosi - stPosi + 1;

	  if(LenDel <= 0)
	    cout << "ERROR in ProposHistoryWithDeletionConstraint G! LenDel should be positive." << endl;
	  


	  fD = fDel(IDH->getN(i-1),rd);
	  eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
	  delWeight_in.resize(0);
	  delWeight_in = delWeight[i];
	  weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	  delWeight_in.resize(0);
	  
	  
	  if(IDH->getN(i-1) - LenDel < Nend){
	    
	    difLen = LenDel;
	    
	    if(difLen >= LimD){    // Deletion - 2
	      
	      logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu +  log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
	      
	    }else{                 // Deletion - 1
	      
	      if(difLen == IDH->getL(i)){
		
		logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
		
	      }else{
		
		logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight)+ log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		
	      }
	    }
	    
	  }else{   // means IDH->getN(i-1) - LenDel >= Nend
	    
	    difLen = IDH->getN(i-1) - Nend;
	    
	    if(difLen >= LimD){    // Deletion - 4
	      
	      logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
	      
	    }else{                 // Deletion - 3
	      
	      if(difLen == IDH->getL(i)){
		
		logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
		
	      }else{
		
		logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		
	      }
	    }
	  }  // Done of if(IDH->getN(i-1) - LenDel < Nend){
	  
	} // End for loop


	tmpDouble = 0;
	tmpDouble -= ((IDH->getN(numE1)+1)*lambda + fDel(IDH->getN(numE1),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE1));
	
	tmpDouble -= log(IDH->getV(numE+1) - IDH->getV(numE1));
 
	i = numE;
	if(IDH->getID(numE)==1)
	  tmpDouble -= log((double)IDH->getN(i-1)+1); 
	else
	  tmpDouble -= log((double)IDH->getN(i-1)+1 - IDH->getL(numE));
	
	logProbV[numEndPosi-1] = logProb + logProbT + tmpDouble;
	

	i = numE;
	fD = fDel(IDH->getN(numE),rd);
	eta = (IDH->getN(numE)+1)*lambda + fD*mu;
	logprobNoE = -eta*(IDH->getV(numE+1) - IDH->getV(numE))/C_noEvent; // No event from numE
	
	fD = fDel(IDH->getN(numE1),rd);
	eta = (IDH->getN(numE1)+1)*lambda + fD*mu; // eta(numE - 1)
	
	if(IDH->getID(numE)==1){ // insertion
	  
	  if(IDH->getL(numE) < LimI){

	    logProbT += - eta*(IDH->getV(numE) - IDH->getV(numE1)) + logLambda + log(1+WeiID) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(numE)-1) * logRi1);
	    
	  }else{
	    
	    logProbT += - eta*(IDH->getV(numE) - IDH->getV(numE1)) + logLambda + log(1+WeiID) + logRi + (IDH->getL(numE)-1) * logRi1;
	  }

	  logProbT += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);

	}else{  // deletion

	  if(IDH->getL(numE) < LimD){

	    logProbT += - eta*(IDH->getV(numE) - IDH->getV(numE1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(numE1)- IDH->getL(numE) + 1)) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(numE1))) + logRd + (IDH->getL(numE)-1) * logRd1);

	  }else{
	    
	    logProbT += - eta*(IDH->getV(numE) - IDH->getV(numE1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(numE1)- IDH->getL(numE) + 1)) - log(1-pow(1-rd, IDH->getN(numE1))) + logRd + (IDH->getL(numE)-1) * logRd1;
	  }

	  logProbT += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);

	}

      
	logProbV[numEndPosi] = logProb + logProbT;


      }else{  // numEndPosi == 1 It could happen we don't have DelBasePosi


	for(i = 1; i <= EndPosi; i++){

	  tHMG = IDH->getHMG(i-1);
	  stPosi = -1;
	  enPosi = -1;
	  
	  intTmp = tHMG.size();
	  for(k = 0; k < (intTmp-1); k++){
	    if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		stPosi = k;
		break;
	      }
	    } 
	  }
	  for(k = (intTmp-2); k >= 0; k--){
	    if(tHMG[k] >= 0){
	      if(delBasePosi[tHMG[k]]==1){
		enPosi = k;
		break;
	      }
	    }  
	  }
	

  
	  if((stPosi == -1) | (enPosi == -1))
	    noDelBasePosi = true;
	  else
	    noDelBasePosi = false;


	  if(!noDelBasePosi){

	    // We have delBasePosi

	    LenDel = enPosi - stPosi + 1;

	    if(LenDel <= 0)
	      cout << "ERROR in ProposHistoryWithDeletionConstraint H! LenDel should be positive." << endl;

	  
	    fD = fDel(IDH->getN(i-1),rd);   
	    eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
	    delWeight_in.resize(0);
	    delWeight_in = delWeight[i];
	    weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	    delWeight_in.resize(0);
	    
	    
	    if(IDH->getID(i)==1){  // insertion

	      difLen = Nend - IDH->getN(i-1) + LenDel;

	      if(difLen <= 0){            // insertion - 1

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((IDH->getN(i-1)+1)*lambda - fD*mu*WeiID) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1;
	      
	      }else if(difLen >= LimI){   // insertion - 3
	    
		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + logRi + (IDH->getL(i)-1) * logRi1;

	      }else{                      // insertion - 2

		if(difLen == IDH->getL(i)){

		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1);

		}else{

		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1;
	    
		}
	      }
	    
	    }else{   // deletion 

	      if(IDH->getN(i-1) - LenDel < Nend){

		difLen = LenDel;

		if(difLen >= LimD){    // Deletion - 2
	      
		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu +  log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

		}else{                 // Deletion - 1

		  if(difLen == IDH->getL(i)){

		    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

		  }else{

		    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight)+ log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

		  }
		}

	      }else{   // means IDH->getN(i-1) - LenDel >= Nend
		
		difLen = IDH->getN(i-1) - Nend;

		if(difLen >= LimD){    // Deletion - 4
	      
		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

		}else{                 // Deletion - 3

		  if(difLen == IDH->getL(i)){

		    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
		    
		  }else{
		    
		    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		    
		  }
		}
	      }  // Done of if(IDH->getN(i-1) - LenDel < Nend){
	      
	    } // Done of deletion

          }else{

	    // noDelBasePosi
	    fD = fDel(IDH->getN(i-1),rd);   
	    eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
      
	    if(IDH->getID(i)==1){ // insertion

	      difLen = Nend - IDH->getN(i-1);;
	      if(difLen == 0){          // insertion - 1

		logprobNoE = -eta*(Time - IDH->getV(i-1))/C_noEvent;
		logProb += log(1 - exp(logprobNoE)) -eta*(IDH->getV(i) - IDH->getV(i-1)) + logLambda + logRi + (IDH->getL(i)-1) * logRi1;

	      }else if(difLen >= LimI){ // insertion - 3

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + logLambda + log(1+WeiID) + logRi + (IDH->getL(i)-1) * logRi1;

	      }else if(difLen < 0){     // insertion - 4

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((IDH->getN(i-1)+1)*lambda - fD*mu*WeiID) - log((double)IDH->getN(i-1)+1) + logRi + (IDH->getL(i)-1) * logRi1;

	      }else{                     // insertion - 2

		if(difLen == IDH->getL(i)){
	    
		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + logLambda + log(1+WeiID) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1);

		}else{

		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + logLambda + log(1+WeiID) + log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1;

		}
	      }

	    }else{     // deletion
	
	      difLen = IDH->getN(i-1); - Nend;

	      if(difLen == 0){          // deletion - 1
		
		logprobNoE = -eta*(Time - IDH->getV(i-1))/C_noEvent;
		logProb += log(1 - exp(logprobNoE)) -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		
	      }else if(difLen >= LimD){ // deletion - 3
		
		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		
	      }else if(difLen < 0){     // deletion - 4
		
		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD*mu - (IDH->getN(i-1)+1)*lambda*WeiID) - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		
	      }else{                     // deletion - 2
		
		if(difLen == IDH->getL(i)){
		  
		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
		  
		}else{
		  
		  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;
		  
		}
	      }
	      
	    }

	  }  // End of noDelBasePosi
 
	}  // End for loop



	// The last event : we know it doesn't contain any delBasePosi

	logProbT = 0;


	fD = fDel(IDH->getN(numE),rd);
	eta = (IDH->getN(numE)+1)*lambda + fD*mu;
	logprobNoE = -eta*(Time - IDH->getV(numE))/C_noEvent; // No event from numE
	
	fD = fDel(IDH->getN(numE1),rd);
	eta = (IDH->getN(numE1)+1)*lambda + fD*mu; // eta(numE - 1)
	
	
	if(IDH->getID(numE)==1){ // insertion
	  
	  if(IDH->getL(numE) < LimI){
	    
	    logProbT += - eta*(IDH->getV(numE) - IDH->getV(numE1)) + logLambda + log(1+WeiID) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(numE)-1) * logRi1);
	    
	  }else{
	    
	    logProbT += logProb - eta*(IDH->getV(numE) - IDH->getV(numE1)) + logLambda + log(1+WeiID) + logRi + (IDH->getL(numE)-1) * logRi1;
	    
	  }
	  
	  logProbT += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);
	  
	  logProbV[numEndPosi] = logProb + logProbT;
	  
	  logProbV[numEndPosi-1] = logProb - eta*(Time - IDH->getV(numE1)) - log(Time - IDH->getV(numE1)) - log((double)IDH->getN(numE1)+1); 
	  
	}else{  // deletion
	  
	  if(IDH->getL(numE) < LimD){
	    
	    logProbT += - eta*(IDH->getV(numE) - IDH->getV(numE1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(numE1)- IDH->getL(numE) + 1)) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(numE1))) + logRd + (IDH->getL(numE)-1) * logRd1);
	    
	  }else{
	    
	    logProbT += - eta*(IDH->getV(numE) - IDH->getV(numE1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(numE1)- IDH->getL(numE) + 1)) - log(1-pow(1-rd, IDH->getN(numE1))) + logRd + (IDH->getL(numE)-1) * logRd1;
	  }
	  
	  logProbT += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);
	  
	  logProbV[numEndPosi] = logProb + logProbT;
	  
	  logProbV[numEndPosi-1] = logProb - eta*(Time - IDH->getV(numE1)) - log(Time - IDH->getV(numE1)) - log((double)IDH->getN(numE1) - IDH->getL(numE)+1); 
	  
	}	
	
      }

      
    }else if(IDH->IsDelEventContainingOnlyBases(numE, delBasePosi) == 1){



      //-------------------------------------------------------------//
      //                                                             //
      // case III : deletion containing delBasePosi with others      //
      //                                                             //
      //-------------------------------------------------------------//


      // We always have delBasePosi


      logProbV.resize(2);

      for(i = 1; i <= (numE-1); i++){

	tHMG = IDH->getHMG(i-1);
	stPosi = -1;
	enPosi = -1;

	intTmp = tHMG.size();
	for(k = 0; k < (intTmp-1); k++){
	  if(tHMG[k] >= 0){
	    if(delBasePosi[tHMG[k]]==1){
	      stPosi = k;
	      break;
	      }
	  } 
	}
	for(k = (intTmp-2); k >= 0; k--){
	  if(tHMG[k] >= 0){
	    if(delBasePosi[tHMG[k]]==1){
	      enPosi = k;
	      break;
	    }
	  }  
	}
	
	if((stPosi == -1) | (enPosi == -1))
	  cout << "ERROR in ProposHistoryWithDeletionConstraint I! No bases in delBasePosi." << endl;
	
	
	LenDel = enPosi - stPosi + 1;
	
	if(LenDel <= 0)
	  cout << "ERROR in ProposHistoryWithDeletionConstraint I! LenDel should be positive." << endl;
	
	
	fD = fDel(IDH->getN(i-1),rd);   
	eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
	delWeight_in.resize(0);
	delWeight_in = delWeight[i];
	weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
	delWeight_in.resize(0);
	
	if(IDH->getID(i)==1){  // insertion

	  difLen = Nend - IDH->getN(i-1) + LenDel;

	  if(difLen <= 0){            // insertion - 1

	    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((IDH->getN(i-1)+1)*lambda - fD*mu*WeiID) + log(weight) + logRi + (IDH->getL(i)-1) * logRi1;

	  }else if(difLen >= LimI){   // insertion - 3

	    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + logRi + (IDH->getL(i)-1) * logRi1;

	  }else{                      // insertion - 2

	    if(difLen == IDH->getL(i)){

	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1);

	    }else{

	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((double)(IDH->getN(i-1)+1)) + logLambda + log(weight) + log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1;
	    
	    }
	  }

	}else{   // deletion 

	  if(IDH->getN(i-1) - LenDel < Nend){

	    difLen = LenDel;

	    if(difLen >= LimD){    // Deletion - 2
	      
	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu +  log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	    }else{                 // Deletion - 1

	      if(difLen == IDH->getL(i)){

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	      }else{

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight)+ log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

              }
            }

	  }else{   // means IDH->getN(i-1) - LenDel >= Nend
		
	    difLen = IDH->getN(i-1) - Nend;

	    if(difLen >= LimD){    // Deletion - 4
	      
	      logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	    }else{                 // Deletion - 3

	      if(difLen == IDH->getL(i)){

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	      }else{

		logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

              }
            }
	  }  // Done of if(IDH->getN(i-1) - LenDel < Nend){

	} // Done of deletion

      } // End of for loop


      logProbT = 0;
      
      tmpInt = numE - 1;
      logProbT -= ((IDH->getN(tmpInt)+1)*lambda + fDel(IDH->getN(tmpInt),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(tmpInt));

      logProbT -= log(IDH->getV(numE+1) - IDH->getV(tmpInt));

      numE1 = numE-1;
      intTmp = (IDH->getHMG(numE1)).size();
      for(k = 0; k < (intTmp-1); k++){
	if(IDH->getHMG(numE1, k) >= 0){
	  if(delBasePosi[IDH->getHMG(numE1, k)]==1){
	    stPosi = k;
	    break;
	  }
	} 
      }
      for(k = (intTmp-2); k >= 0; k--){
	if( IDH->getHMG(numE1, k) >= 0){
	  if(delBasePosi[IDH->getHMG(numE1, k)]==1){
	    enPosi = k;
	    break;
	  }
	}  
      }
      
      st = MAX(0, Nend - IDH->getN(numE1) + enPosi + 1);
      en = MIN(stPosi, IDH->getN(numE1) - IDH->getL(numE));
	     
      logProbT -= log((double)(en - st +1));
      
      logProbV[0] = logProb + logProbT;
      


      logProbT = 0;

      i = numE;
      tHMG = IDH->getHMG(i-1);
      stPosi = -1;
      enPosi = -1;
	
      intTmp = tHMG.size();
      for(k = 0; k < (intTmp-1); k++){
	if(tHMG[k] >= 0){
	  if(delBasePosi[tHMG[k]]==1){
	    stPosi = k;
	    break;
	  }
	} 
      }
      for(k = (intTmp-2); k >= 0; k--){
	if(tHMG[k] >= 0){
	  if(delBasePosi[tHMG[k]]==1){
	    enPosi = k;
	    break;
	  }
	}  
      }
      
      if((stPosi == -1) | (enPosi == -1))
	cout << "ERROR in ProposHistoryWithDeletionConstraint J! No bases in delBasePosi." << endl;
      
      
      LenDel = enPosi - stPosi + 1;
      
      if(LenDel <= 0)
	cout << "ERROR in ProposHistoryWithDeletionConstraint J! LenDel should be positive." << endl;
      
      
      fD = fDel(IDH->getN(i-1),rd);
      eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
      delWeight_in.resize(0);
      delWeight_in = delWeight[i];
      weight = delWeight_in[IDH->getP(i)]/sum_vec(delWeight_in);
      delWeight_in.resize(0);
      

      if(IDH->getN(i-1) - LenDel < Nend){

	cout << "ERROR in ProposHistoryWithDeletionConstraint K! Not reasonable size for LenDel" << endl;

      }else{   // means IDH->getN(i-1) - LenDel >= Nend
		
	difLen = IDH->getN(i-1) - Nend;
	  
	if(difLen >= LimD){    // Deletion - 4
	    
	  logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	}else{                 // Deletion - 3
	      
	  logProbT += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu + log(1+WeiID) + log( ((1-delProb)/(double)(IDH->getN(i-1)-IDH->getL(i)+1)) + delProb*weight) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

	}
      }  // Done of if(IDH->getN(i-1) - LenDel < Nend){


      fD = fDel(IDH->getN(numE),rd);
      eta = (IDH->getN(numE)+1)*lambda + fD*mu;
      logprobNoE = -eta*(IDH->getV(numE+1) - IDH->getV(numE))/C_noEvent; // No event from numE

      logProbT += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);
      
      logProbV[1] = logProb + logProbT;
      
    }      

    //-- v20 start --//
    if(logProbVIX.size() == 0){
      logProb1 = logProbV[0];
      intTmp = logProbV.size();
      for(i = 1; i < intTmp; i++){
	logProb2 = logProbV[i];
	tuning = (logProb1>logProb2 ? logProb1 : logProb2);
	logProb1 -= tuning;
	logProb2 -= tuning;
	res = log(exp(logProb1) + exp(logProb2)) + tuning;
	logProb1 = res;
      }
    }else{
      intTmp = logProbV.size();
      logProb1 = logProbV[intTmp-1];
      for(i = 0; i < (intTmp-1); i++){
	if(logProbVIX[i] == 0){
	  logProb2 = logProbV[i];
	  tuning = (logProb1>logProb2 ? logProb1 : logProb2);
	  logProb1 -= tuning;
	  logProb2 -= tuning;
	  res = log(exp(logProb1) + exp(logProb2)) + tuning;
	  logProb1 = res;
	}
      }
    }
  }

  //-- v20 start --//
  logProbVIX.resize(0);
  //-- v20 start --//

  logProbV.resize(0);
  delWeight.resize(0);
  delWeight_in.resize(0);
  delBasePosi.resize(0);
  //cout << "res " << res << endl;

  return res;
}
//--- v21 end ---//





// 0 only bases in the list
// 1 with other bases 
// 2 not contain or insertion
int InDelHistory::IsDelEventContainingOnlyBases(int i, vector<int> delBasePosi){

  int res = 2;
  int num;
  if(id[i] == -1){
    num = 0;
    for(int k = 0; k < l[i]; k++){
      if(hmg[i-1][p[i]+k] >= 0){
	if(delBasePosi[hmg[i-1][p[i]+k]] == 1)
	  num++;
      }
    }
    if(num==0){
      res = 2;
    }else if(num == l[i]){
      res = 0;
    }else
      res = 1;
  }

  return res;
}




void Tree::calWeight(vector<int> HMG, int L, vector<int> delBasePosi, vector<double> &delWeight){


  //cout << "In calWeight" << endl;
  //cout << "HMG" << endl;
  //print_veci(HMG);
  //cout << "delBasePosi " << endl;
  //print_veci(delBasePosi);
  //cout << "L : " << L << endl;

  int Len = HMG.size();
  int delNum = 0;
  int i, j;
  delWeight.resize(Len - L);
  for(i = 0; i <= (Len - L - 1); i++){
    delNum = 0;
    for(j = 0; j < L; j++){
      if(HMG[i+j] >= 0){
	if(delBasePosi[HMG[i+j]] == 1)
	  delNum++;
      }
    }
    delWeight[i] = (double)delNum;
  }

  //cout << "delWeight" << endl;
  //print_vecd(delWeight);
}



//--- v20 start -----//
void Tree::calWeightIn(vector<int> HMG, vector<int> delBasePosi, vector<double> &delWeight, double c){

  int Len = HMG.size();
  int delNum = 0;
  int i, j;
  int st, en;
  int diff;
  double tmp;
  bool go = false;
  bool goout = false;
  delWeight.resize(Len);
  i = 0;
  //cout << "In calWeight" << endl;
  //cout << "HMG" << endl;
  //print_veci(HMG);
  //cout << "delBasePosi " << endl;
  //print_veci(delBasePosi);



  while(i < Len){
    //cout << "i : " << i << " HMG[i] : " <<  HMG[i] << " delBasePosi[HMG[i]] " << delBasePosi[HMG[i]] << endl;
    go = false;
    if(HMG[i] >= 0){
      if(delBasePosi[HMG[i]] == 1)
    	go = true;
    }

    //cout << "i : " << i << " go" << go << endl;
    if(go){


    //if((HMG[i] >= 0) & (delBasePosi[HMG[i]] == 1)){
      st = i;
      i++;
      while(i < Len){
	goout = false;
	if(HMG[i] < 0){
	  goout = true;
        }else if(delBasePosi[HMG[i]] != 1){
	  //if(HMG[i] >= delBasePosi.size()){
	  //  cout << "ERROR calWeightIn i " << i << " HMG[i] " << HMG[i] << endl;
	  //}
	  goout = true;
        }
        if(goout)
	  break;
	//if((HMG[i] < 0) | (delBasePosi[HMG[i]] != 1))
	//  break;
	i++;
      }
      en = i;
      diff = en - st - 1;
      //cout << "st : " << st << " en : " << en << " diff : " << diff << endl;
      if(diff > 0){
	delWeight[st] = (1-c)/(double)2;
	delWeight[en] = delWeight[st];
	tmp = c/(double)diff;
	
	for(j = 1; j <= diff; j++)
	  delWeight[st + j] = tmp;
      }else{
	delWeight[st] = 1/(double)2;
	delWeight[en] = delWeight[st];
      }
	
    }else{
      delWeight[i] = 1;
    }
    i++;
  }

  //cout << "delWeight" << endl;
  //print_vecd(delWeight);


}
//--- v20 end -----//

  


double Tree::UpIDHonEdgeWithFixedHMG(Rand &rand, Parameters &params, ofstream& c, int start) {

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory();

  //vector<double> V(0);
  //vector<int> ID(0);
  //vector<int> P(0);
  //vector<int> L(0);
  //vector<int> N(0);
  //vector<vector<int> > HMG;
  vector<int> HMGin(0);
  //vector<double> Lwt(0);


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  double fixProb = 0.85;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  int IX;

  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  //w = params.getWindowLen();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();


  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  //if(Time <= w){ // Propose new history in a whole sequence

  O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
  O_IDHlike = edgeT->getlogLikeliIDH();

   
  if(baseNode != nodeP){
    N0 = Nend;
    Nend = nodeP->getSeqLen();
    IDH->ReverseIDH();
    (*oldIDH) = (*IDH);
    //O_psl = ProposHistory(params, IDH);
  }else{
    (*oldIDH) = (*IDH);
    //O_psl= edgeT->ProposHistory(params);
  }
  
  
  // decide what homologies would be fixed
  // get  vector<int> stSeqLen(0);
  //      vector<int> enSeqLen(0);
  //      vector<int> stPosi(0);
  //      vector<int> enPosi(0);

  N_psl = 0;
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  stPosi.push_back(0);
  enPosi.push_back(0);
  IX=1;
  HMGin.resize(0);
  HMGin = IDH->getHMG(IDH->getNumE());
  for(i = 0; i < Nend; i++){
    if(HMGin[i] != -1){
      if(rand.runif()- fixProb < 0){
	stPosi.push_back(HMGin[i]+1);
	enPosi.push_back(i+1);	    
	stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	IX++;
	N_psl += logfixProb;
      }else{
	N_psl += logNfixProb;
      }
    }
  }
  stSeqLen.push_back(N0 -stPosi[IX-1]);
  enSeqLen.push_back(Nend-enPosi[IX-1]);
  
  enPosi.resize(0);
  
  N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, Time, IDH);
  
  
  O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, Time, oldIDH);
  
  
  int total = 0;
  HMGin.resize(0);
  HMGin = IDH->getHMG(IDH->getNumE());
  for(i = 0; i < Nend; i++){
    if(HMGin[i] != -1)
      total++;
  }
  O_psl += (stPosi.size() - 1) * logfixProb  + (total - stPosi.size() + 1) * logNfixProb; 
   


  if(baseNode != nodeP)
    IDH->ReverseIDH();
  
  edgeT->calHMG();
  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      
      
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //tempB = logLikeliIDH[current];
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  
  //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;
  if(start)     
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;


  //V.resize(0);
  //ID.resize(0);
  //P.resize(0);
  //L.resize(0);
  //N.resize(0);
  //HMG.resize(0);
  HMGin.resize(0);
  //Lwt.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);



  delete oldIDH;

  return AP;

} // End of UpIDHonEdge



double Tree::UpIDHonEdgeWithFixedHMG(Rand &rand, Parameters &params, ofstream& c) {

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory();

  //vector<double> V(0);
  //vector<int> ID(0);
  //vector<int> P(0);
  //vector<int> L(0);
  //vector<int> N(0);
  //vector<vector<int> > HMG;
  vector<int> HMGin(0);
  //vector<double> Lwt(0);


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  double fixProb = 0.85;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  int IX;

  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  //w = params.getWindowLen();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();


  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  //if(Time <= w){ // Propose new history in a whole sequence

  O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
  O_IDHlike = edgeT->getlogLikeliIDH();

   
  if(baseNode != nodeP){
    N0 = Nend;
    Nend = nodeP->getSeqLen();
    IDH->ReverseIDH();
    (*oldIDH) = (*IDH);
    //O_psl = ProposHistory(params, IDH);
  }else{
    (*oldIDH) = (*IDH);
    //O_psl= edgeT->ProposHistory(params);
  }
  
  
  // decide what homologies would be fixed
  // get  vector<int> stSeqLen(0);
  //      vector<int> enSeqLen(0);
  //      vector<int> stPosi(0);
  //      vector<int> enPosi(0);

  N_psl = 0;
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  stPosi.push_back(0);
  enPosi.push_back(0);
  IX=1;
  HMGin.resize(0);
  HMGin = IDH->getHMG(IDH->getNumE());
  for(i = 0; i < Nend; i++){
    if(HMGin[i] != -1){
      if(rand.runif()- fixProb < 0){
	stPosi.push_back(HMGin[i]+1);
	enPosi.push_back(i+1);	    
	stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	IX++;
	N_psl += logfixProb;
      }else{
	N_psl += logNfixProb;
      }
    }
  }
  stSeqLen.push_back(N0 -stPosi[IX-1]);
  enSeqLen.push_back(Nend-enPosi[IX-1]);
  
  enPosi.resize(0);
  
  N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, Time, IDH);
  
  
  O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, Time, oldIDH);
  
  
  int total = 0;
  HMGin.resize(0);
  HMGin = IDH->getHMG(IDH->getNumE());
  for(i = 0; i < Nend; i++){
    if(HMGin[i] != -1)
      total++;
  }
  O_psl += (stPosi.size() - 1) * logfixProb  + (total - stPosi.size() + 1) * logNfixProb; 
   


  if(baseNode != nodeP)
    IDH->ReverseIDH();
  
  edgeT->calHMG();
  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      
      
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //tempB = logLikeliIDH[current];
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  
  //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;
      
  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

      

  //V.resize(0);
  //ID.resize(0);
  //P.resize(0);
  //L.resize(0);
  //N.resize(0);
  //HMG.resize(0);
  HMGin.resize(0);
  //Lwt.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);



  delete oldIDH;

  return AP;

} // End of UpIDHonEdge




//-- v24 start --//
double Tree::UpIDHonEdgeWithFixedHMGbyDistanceAndAdjust(Rand &rand, Parameters &params, ofstream& c) {


  //cout << "start UpIDHonEdgeWithFixedHMGbyDistanceAndAdjust" << endl;


  double powWei = params.getPowWei();

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory();

  //vector<double> V(0);
  //vector<int> ID(0);
  //vector<int> P(0);
  //vector<int> L(0);
  //vector<int> N(0);
  //vector<vector<int> > HMG;
  vector<int> HMGin(0);
  //vector<double> Lwt(0);


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  //double fixProb = 0.9;
  //double logfixProb = log(fixProb);
  //double logNfixProb = log(1-fixProb);
  int IX;

  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  //w = params.getWindowLen();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();



  //cout << "edgeT : " << edgeT->getnumber() << endl;
  //cout << "nodeP : " << nodeP->getnumber() << endl;
  //cout << "nodeC : " << nodeC->getnumber() << endl;

  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  //if(Time <= w){ // Propose new history in a whole sequence

  O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
  O_IDHlike = edgeT->getlogLikeliIDH();

   
  //if(baseNode != nodeP){
  //  N0 = Nend;
  //  Nend = nodeP->getSeqLen();
  //  IDH->ReverseIDH();
  //  (*oldIDH) = (*IDH);
  //  //O_psl = ProposHistory(params, IDH);
  //}else{
  //  (*oldIDH) = (*IDH);
  //  //O_psl= edgeT->ProposHistory(params);
  //}
  
  
  // decide what homologies would be fixed
  // get  vector<int> stSeqLen(0);
  //      vector<int> enSeqLen(0);
  //      vector<int> stPosi(0);
  //      vector<int> enPosi(0);

  // Ready for HMG selection
  nodeP->ReadyForCalSubTreeProbHere(edgeT->getnumber(), Time,params);
  nodeP->CalSubTreeProbHere();

  vector<int> oldHMG(0);
  vector<double> oldFixProb(0);
  double dist;
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<int> fixedHMGIX(0);
  vector<double> P(0);
  vector<double> Q(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  Pt = nodeP->getPt();
  pi = params.getPi();  


  //cout << "pi" << endl;
  //print_vecd(pi);
  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  // }


  //int numLetters = Pt.size();
  double MaxT = 0;
  for(i = 0; i < numLetters; i++){
    for(j = 0; j < numLetters; j++){
      Pt[i][j] *= pi[i];
      MaxT = MAX(MaxT, Pt[i][j]);
    }
  }

  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  // }



  //cout << "MaxT : " << MaxT << endl;




  // Make hash table
  // Will be set up later from parents to child
  vector<vector<double> > DistT(0);
  




  if(baseNode != nodeP){

    //cout << "reverse " << endl;

    N0 = Nend;
    Nend = nodeP->getSeqLen();
    IDH->ReverseIDH();
    (*oldIDH) = (*IDH);


    DistT.resize(N0 + 1);
    for(i = 0; i <= N0; i++)
      DistT[i].resize(Nend+1);


    N_psl = 0;
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    oldHMG = HMGin;
    oldFixProb.resize(oldHMG.size());



    Pmat.resize(0);
    nodeC->getProbFromSubTreeProb(Pmat);
    Qmat.resize(0);
    nodeP->getProbFromSubTreeProb(Qmat);
        

    //cout << "N0 : " << N0 << " Nend : " << Nend << endl;
    //cout << "HMGin " << endl;
    //print_veci(HMGin);

    //cout << "Pmat " << endl;
    //for(i =0; i < Pmat.size() ; i++){
    //  for(j=0; j < Pmat[i].size(); j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;


    //cout << "Qmat " << endl;
    //for(i =0; i < Qmat.size() ; i++){
    //  for(j=0; j < Qmat[i].size(); j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;




    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	


	
	// Calculate distance from HMGin[i] to i;

	//P.resize(0);
	//Q.resize(0);
	//nodeC->getProbFromSubTreeProb(P, HMGin[i]);
	//nodeP->getProbFromSubTreeProb(Q, i);
	//dist = 0;
	//for(k = 0; k < numLetters; k++){
	//  for(j = 0; j < numLetters; j++)
	//    dist += Pt[k][j]*P[k]*Q[j];
	//}

	dist = 0;
	for(k = 0; k < numLetters; k++){
	  for(j = 0; j < numLetters; j++)
	    dist += Pt[k][j]*Pmat[HMGin[i]][k]*Qmat[i][j];
	}

	
	DistT[HMGin[i]][i] = log(dist);


	dist = pow(dist/MaxT, powWei);
	oldFixProb[i] = dist;
	



	if(rand.runif()- dist < 0){
	  stPosi.push_back(HMGin[i]+1);
	  enPosi.push_back(i+1);	    
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  IX++;
	  N_psl += log(dist);
	  fixedHMGIX.push_back(1);
	}else{
	  N_psl += log(1-dist);
	  fixedHMGIX.push_back(0);
	}
      }else{
	fixedHMGIX.push_back(-1);
      }
    }
    stSeqLen.push_back(N0 -stPosi[IX-1]);
    enSeqLen.push_back(Nend-enPosi[IX-1]);
    

    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);   
    //cout << "fixedHMGIX" << endl;
    //print_veci(fixedHMGIX);  
    //cout << "oldFixProb " << endl;
    //print_vecd(oldFixProb);

    //cout << "N_psl " << N_psl << endl;


    //cout << "DistT " << endl;
    //for(i =0; i < DistT.size() ; i++){
    //  for(j=0; j < DistT[i].size(); j++)
    //	cout << DistT[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;

  
    N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, Time, IDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  
  
    O_psl = calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, Time, oldIDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  

    //cout << "O_psl " << O_psl << endl;
  
  
    //int total = 0;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    //cout << "HMGin " << endl;
    //print_veci(HMGin);
    
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	//cout << "A : " << i << endl;
	if(fixedHMGIX[i] == 1){
	  //cout << "B " << endl;
	  if(oldFixProb[i]==0)
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	  O_psl += log(oldFixProb[i]);
	}else if(HMGin[i] == oldHMG[i]){
	  //cout << "C " << endl;
	  if(fixedHMGIX[i] != 0){
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This case cannot happen! " << endl;
	  }else{

	    if(oldFixProb[i]==0)
	      cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	    O_psl += log(1-oldFixProb[i]);
	  }
	}else{
	  //cout << "D " << endl;
	  // need to calculate!

	  //P.resize(0);
	  //Q.resize(0);
	  //nodeC->getProbFromSubTreeProb(P, HMGin[i]);
	  //nodeP->getProbFromSubTreeProb(Q, i);

	  //dist = 0;
	  //for(k = 0; k < numLetters; k++){
	  //  for(j = 0; j < numLetters; j++)
	  //    dist += Pt[k][j]*P[k]*Q[j];
	  //}

	  dist = 0;
	  for(k = 0; k < numLetters; k++){
	    for(j = 0; j < numLetters; j++)
	      dist += Pt[k][j]*Pmat[HMGin[i]][k]*Qmat[i][j];
	  }
	  
	  dist = pow(dist/MaxT, powWei);
	  O_psl += log(1-dist);
	}
      }
    }


    //cout << "O_psl " << O_psl << endl;

    IDH->ReverseIDH();


  }else{   // baseNode == nodeP

    //cout << "Not reverse" << endl;

    (*oldIDH) = (*IDH);


    DistT.resize(N0 + 1);
    for(i = 0; i <= N0; i++)
      DistT[i].resize(Nend+1);


    N_psl = 0;
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    oldHMG = HMGin;
    oldFixProb.resize(oldHMG.size());

    Pmat.resize(0);
    nodeP->getProbFromSubTreeProb(Pmat);
    Qmat.resize(0);
    nodeC->getProbFromSubTreeProb(Qmat);
        


    //cout << "N0 : " << N0 << " Nend : " << Nend << endl;
    //cout << "HMGin " << endl;
    //print_veci(HMGin);

    //cout << "Pmat " << endl;
    //for(i =0; i < Pmat.size() ; i++){
    //  for(j=0; j < Pmat[i].size(); j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;


    //cout << "Qmat " << endl;
    //for(i =0; i < Qmat.size() ; i++){
    //  for(j=0; j < Qmat[i].size(); j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;




    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	
	
	// Calculate distance from HMGin[i] to i;

	//P.resize(0);
	//Q.resize(0);
	//nodeP->getProbFromSubTreeProb(P, HMGin[i]);
	//nodeC->getProbFromSubTreeProb(Q, i);
	
	//dist = 0;
	//for(k = 0; k < numLetters; k++){
	//  for(j = 0; j < numLetters; j++)
	//    dist += Pt[k][j]*P[k]*Q[j];
	//}

	dist = 0;
	for(k = 0; k < numLetters; k++){
	  for(j = 0; j < numLetters; j++)
	    dist += Pt[k][j]*Pmat[HMGin[i]][k]*Qmat[i][j];
	}



	DistT[HMGin[i]][i] = log(dist);
	
	dist = pow(dist/MaxT, powWei);
	oldFixProb[i] = dist;
      
	if(rand.runif()- dist < 0){
	  stPosi.push_back(HMGin[i]+1);
	  enPosi.push_back(i+1);	    
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  IX++;
	  N_psl += log(dist);
	  fixedHMGIX.push_back(1);
	}else{
	  N_psl += log(1-dist);
	  fixedHMGIX.push_back(0);
	}
      }else{
	fixedHMGIX.push_back(-1);
      }
    }
    stSeqLen.push_back(N0 -stPosi[IX-1]);
    enSeqLen.push_back(Nend-enPosi[IX-1]);
    
    //enPosi.resize(0);
    

    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);   
    //cout << "fixedHMGIX" << endl;
    //print_veci(fixedHMGIX);  
    //cout << "oldFixProb " << endl;
    //print_vecd(oldFixProb);


  
    N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, Time, IDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  
  
    O_psl = calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, Time, oldIDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  

  
  
    //int total = 0;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	if(fixedHMGIX[i] == 1){
	  if(oldFixProb[i]==0)
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	  O_psl += log(oldFixProb[i]);
	}else if(HMGin[i] == oldHMG[i]){
	  if(fixedHMGIX[i] != 0){
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This case cannot happen! " << endl;
	  }else{
	    if(oldFixProb[i]==0)
	      cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	    O_psl += log(1-oldFixProb[i]);
	  }
	}else{
	  // need to calculate!

	  //P.resize(0);
	  //Q.resize(0);
	  //nodeP->getProbFromSubTreeProb(P, HMGin[i]);
	  //nodeC->getProbFromSubTreeProb(Q, i);

	  //dist = 0;
	  //for(k = 0; k < numLetters; k++){
	  //  for(j = 0; j < numLetters; j++)
	  //    dist += Pt[k][j]*P[k]*Q[j];
	  //}
	  
	  dist = 0;
	  for(k = 0; k < numLetters; k++){
	    for(j = 0; j < numLetters; j++)
	      dist += Pt[k][j]*Pmat[HMGin[i]][k]*Qmat[i][j];
	  }




	  dist = pow(dist/MaxT, powWei);
	  O_psl += log(1-dist);
	}
      }
    }
  
  }
   





  //if(baseNode != nodeP)
  //  IDH->ReverseIDH();
  
  
  nodeP->FinishForCalSubTreeProbHere();

  edgeT->calHMG();
  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      
      
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //tempB = logLikeliIDH[current];
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  
  //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;
      
  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

      

  //V.resize(0);
  //ID.resize(0);
  //P.resize(0);
  //L.resize(0);
  //N.resize(0);
  //HMG.resize(0);
  HMGin.resize(0);
  //Lwt.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  oldHMG.resize(0);
  oldFixProb.resize(0);
  Pt.resize(0);
  pi.resize(0);
  fixedHMGIX.resize(0);
  P.resize(0);
  Q.resize(0);
  DistT.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  delete oldIDH;

  return AP;

} // End of UpIDHonEdge
//-- v24 end --//




//-- v24 start --//
double Tree::UpIDHonEdgeWithFixedHMGbyDistanceAndAdjust(Rand &rand, Parameters &params, ofstream& c, int start) {


  //cout << "start UpIDHonEdgeWithFixedHMGbyDistanceAndAdjust" << endl;


  double powWei = params.getPowWei();
  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory();

  //vector<double> V(0);
  //vector<int> ID(0);
  //vector<int> P(0);
  //vector<int> L(0);
  //vector<int> N(0);
  //vector<vector<int> > HMG;
  vector<int> HMGin(0);
  //vector<double> Lwt(0);


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  //double fixProb = 0.85;
  //double logfixProb = log(fixProb);
  //double logNfixProb = log(1-fixProb);
  int IX;

  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  //w = params.getWindowLen();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();



  //cout << "edgeT : " << edgeT->getnumber() << endl;
  //cout << "nodeP : " << nodeP->getnumber() << endl;
  //cout << "nodeC : " << nodeC->getnumber() << endl;

  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  //if(Time <= w){ // Propose new history in a whole sequence

  O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
  O_IDHlike = edgeT->getlogLikeliIDH();

   
  //if(baseNode != nodeP){
  //  N0 = Nend;
  //  Nend = nodeP->getSeqLen();
  //  IDH->ReverseIDH();
  //  (*oldIDH) = (*IDH);
  //  //O_psl = ProposHistory(params, IDH);
  //}else{
  //  (*oldIDH) = (*IDH);
  //  //O_psl= edgeT->ProposHistory(params);
  //}
  
  
  // decide what homologies would be fixed
  // get  vector<int> stSeqLen(0);
  //      vector<int> enSeqLen(0);
  //      vector<int> stPosi(0);
  //      vector<int> enPosi(0);

  // Ready for HMG selection
  nodeP->ReadyForCalSubTreeProbHere(edgeT->getnumber(), Time,params);
  nodeP->CalSubTreeProbHere();

  vector<int> oldHMG(0);
  vector<double> oldFixProb(0);
  double dist;
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<int> fixedHMGIX(0);
  vector<double> P(0);
  vector<double> Q(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  Pt = nodeP->getPt();
  pi = params.getPi();  


  //cout << "pi" << endl;
  //print_vecd(pi);
  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  // }


  //int numLetters = Pt.size();
  double MaxT = 0;
  for(i = 0; i < numLetters; i++){
    for(j = 0; j < numLetters; j++){
      Pt[i][j] *= pi[i];
      MaxT = MAX(MaxT, Pt[i][j]);
    }
  }

  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  // }



  //cout << "MaxT : " << MaxT << endl;




  // Make hash table
  // Will be set up later from parents to child
  vector<vector<double> > DistT(0);
  




  if(baseNode != nodeP){

    //cout << "reverse " << endl;

    N0 = Nend;
    Nend = nodeP->getSeqLen();
    IDH->ReverseIDH();
    (*oldIDH) = (*IDH);


    DistT.resize(N0 + 1);
    for(i = 0; i <= N0; i++)
      DistT[i].resize(Nend+1);


    N_psl = 0;
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    oldHMG = HMGin;
    oldFixProb.resize(oldHMG.size());



    Pmat.resize(0);
    nodeC->getProbFromSubTreeProb(Pmat);
    Qmat.resize(0);
    nodeP->getProbFromSubTreeProb(Qmat);
        

    //cout << "N0 : " << N0 << " Nend : " << Nend << endl;
    //cout << "HMGin " << endl;
    //print_veci(HMGin);

    //cout << "Pmat " << endl;
    //for(i =0; i < Pmat.size() ; i++){
    //  for(j=0; j < Pmat[i].size(); j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;


    //cout << "Qmat " << endl;
    //for(i =0; i < Qmat.size() ; i++){
    //  for(j=0; j < Qmat[i].size(); j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;




    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	


	
	// Calculate distance from HMGin[i] to i;

	//P.resize(0);
	//Q.resize(0);
	//nodeC->getProbFromSubTreeProb(P, HMGin[i]);
	//nodeP->getProbFromSubTreeProb(Q, i);
	//dist = 0;
	//for(k = 0; k < numLetters; k++){
	//  for(j = 0; j < numLetters; j++)
	//    dist += Pt[k][j]*P[k]*Q[j];
	//}

	dist = 0;
	for(k = 0; k < numLetters; k++){
	  for(j = 0; j < numLetters; j++)
	    dist += Pt[k][j]*Pmat[HMGin[i]][k]*Qmat[i][j];
	}

	
	DistT[HMGin[i]][i] = log(dist);


	dist = pow(dist/MaxT, powWei);
	oldFixProb[i] = dist;
	



	if(rand.runif()- dist < 0){
	  stPosi.push_back(HMGin[i]+1);
	  enPosi.push_back(i+1);	    
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  IX++;
	  N_psl += log(dist);
	  fixedHMGIX.push_back(1);
	}else{
	  N_psl += log(1-dist);
	  fixedHMGIX.push_back(0);
	}
      }else{
	fixedHMGIX.push_back(-1);
      }
    }
    stSeqLen.push_back(N0 -stPosi[IX-1]);
    enSeqLen.push_back(Nend-enPosi[IX-1]);
    

    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);   
    //cout << "fixedHMGIX" << endl;
    //print_veci(fixedHMGIX);  
    //cout << "oldFixProb " << endl;
    //print_vecd(oldFixProb);

    //cout << "N_psl " << N_psl << endl;


    //cout << "DistT " << endl;
    //for(i =0; i < DistT.size() ; i++){
    //  for(j=0; j < DistT[i].size(); j++)
    //	cout << DistT[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;

  
    N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, Time, IDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  
  
    O_psl = calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, Time, oldIDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  

    //cout << "O_psl " << O_psl << endl;
  
  
    //int total = 0;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    //cout << "HMGin " << endl;
    //print_veci(HMGin);
    
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	//cout << "A : " << i << endl;
	if(fixedHMGIX[i] == 1){
	  //cout << "B " << endl;
	  if(oldFixProb[i]==0)
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	  O_psl += log(oldFixProb[i]);
	}else if(HMGin[i] == oldHMG[i]){
	  //cout << "C " << endl;
	  if(fixedHMGIX[i] != 0){
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This case cannot happen! " << endl;
	  }else{

	    if(oldFixProb[i]==0)
	      cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	    O_psl += log(1-oldFixProb[i]);
	  }
	}else{
	  //cout << "D " << endl;
	  // need to calculate!

	  //P.resize(0);
	  //Q.resize(0);
	  //nodeC->getProbFromSubTreeProb(P, HMGin[i]);
	  //nodeP->getProbFromSubTreeProb(Q, i);

	  //dist = 0;
	  //for(k = 0; k < numLetters; k++){
	  //  for(j = 0; j < numLetters; j++)
	  //    dist += Pt[k][j]*P[k]*Q[j];
	  //}

	  dist = 0;
	  for(k = 0; k < numLetters; k++){
	    for(j = 0; j < numLetters; j++)
	      dist += Pt[k][j]*Pmat[HMGin[i]][k]*Qmat[i][j];
	  }
	  
	  dist = pow(dist/MaxT, powWei);
	  O_psl += log(1-dist);
	}
      }
    }


    //cout << "O_psl " << O_psl << endl;

    IDH->ReverseIDH();


  }else{   // baseNode == nodeP

    //cout << "Not reverse" << endl;

    (*oldIDH) = (*IDH);


    DistT.resize(N0 + 1);
    for(i = 0; i <= N0; i++)
      DistT[i].resize(Nend+1);


    N_psl = 0;
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    oldHMG = HMGin;
    oldFixProb.resize(oldHMG.size());

    Pmat.resize(0);
    nodeP->getProbFromSubTreeProb(Pmat);
    Qmat.resize(0);
    nodeC->getProbFromSubTreeProb(Qmat);
        


    //cout << "N0 : " << N0 << " Nend : " << Nend << endl;
    //cout << "HMGin " << endl;
    //print_veci(HMGin);

    //cout << "Pmat " << endl;
    //for(i =0; i < Pmat.size() ; i++){
    //  for(j=0; j < Pmat[i].size(); j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;


    //cout << "Qmat " << endl;
    //for(i =0; i < Qmat.size() ; i++){
    //  for(j=0; j < Qmat[i].size(); j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}
    //cout << endl;




    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	
	
	// Calculate distance from HMGin[i] to i;

	//P.resize(0);
	//Q.resize(0);
	//nodeP->getProbFromSubTreeProb(P, HMGin[i]);
	//nodeC->getProbFromSubTreeProb(Q, i);
	
	//dist = 0;
	//for(k = 0; k < numLetters; k++){
	//  for(j = 0; j < numLetters; j++)
	//    dist += Pt[k][j]*P[k]*Q[j];
	//}

	dist = 0;
	for(k = 0; k < numLetters; k++){
	  for(j = 0; j < numLetters; j++)
	    dist += Pt[k][j]*Pmat[HMGin[i]][k]*Qmat[i][j];
	}



	DistT[HMGin[i]][i] = log(dist);
	
	dist = pow(dist/MaxT, powWei);
	oldFixProb[i] = dist;
      
	if(rand.runif()- dist < 0){
	  stPosi.push_back(HMGin[i]+1);
	  enPosi.push_back(i+1);	    
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  IX++;
	  N_psl += log(dist);
	  fixedHMGIX.push_back(1);
	}else{
	  N_psl += log(1-dist);
	  fixedHMGIX.push_back(0);
	}
      }else{
	fixedHMGIX.push_back(-1);
      }
    }
    stSeqLen.push_back(N0 -stPosi[IX-1]);
    enSeqLen.push_back(Nend-enPosi[IX-1]);
    
    //enPosi.resize(0);
    

    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);   
    //cout << "fixedHMGIX" << endl;
    //print_veci(fixedHMGIX);  
    //cout << "oldFixProb " << endl;
    //print_vecd(oldFixProb);


  
    N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, Time, IDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  
  
    O_psl = calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, Time, oldIDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  

  
  
    //int total = 0;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	if(fixedHMGIX[i] == 1){
	  if(oldFixProb[i]==0)
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	  O_psl += log(oldFixProb[i]);
	}else if(HMGin[i] == oldHMG[i]){
	  if(fixedHMGIX[i] != 0){
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This case cannot happen! " << endl;
	  }else{
	    if(oldFixProb[i]==0)
	      cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	    O_psl += log(1-oldFixProb[i]);
	  }
	}else{
	  // need to calculate!

	  //P.resize(0);
	  //Q.resize(0);
	  //nodeP->getProbFromSubTreeProb(P, HMGin[i]);
	  //nodeC->getProbFromSubTreeProb(Q, i);

	  //dist = 0;
	  //for(k = 0; k < numLetters; k++){
	  //  for(j = 0; j < numLetters; j++)
	  //    dist += Pt[k][j]*P[k]*Q[j];
	  //}
	  
	  dist = 0;
	  for(k = 0; k < numLetters; k++){
	    for(j = 0; j < numLetters; j++)
	      dist += Pt[k][j]*Pmat[HMGin[i]][k]*Qmat[i][j];
	  }




	  dist = pow(dist/MaxT, powWei);
	  O_psl += log(1-dist);
	}
      }
    }
  
  }
   





  //if(baseNode != nodeP)
  //  IDH->ReverseIDH();
  
  
  nodeP->FinishForCalSubTreeProbHere();

  edgeT->calHMG();
  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      
      
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //tempB = logLikeliIDH[current];
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  
  //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;
      
  if(start)     
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

      

  //V.resize(0);
  //ID.resize(0);
  //P.resize(0);
  //L.resize(0);
  //N.resize(0);
  //HMG.resize(0);
  HMGin.resize(0);
  //Lwt.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  oldHMG.resize(0);
  oldFixProb.resize(0);
  Pt.resize(0);
  pi.resize(0);
  fixedHMGIX.resize(0);
  P.resize(0);
  Q.resize(0);
  DistT.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  delete oldIDH;

  return AP;

} // End of UpIDHonEdge
//-- v24 end --//



//-- v35 start --//
double Tree::UpIDHonEdgeWithFixedHMGbyDP(Rand &rand, Parameters &params, ofstream& c, int start) {


  //cout << "start UpIDHonEdgebyDPWithFixedHMGbyDistanceAndAdjust" << endl;


  double powWei = params.getPowWei();
  int i, k, j, N0, Nend, numE, h, inttmp, intTemp, seqLen, s;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;



  // Select an edge T at random.
  Node* nodeC;
  Node* nodeP;
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();


  if((nodeC->getSeqLen() == 0) | (nodeP->getSeqLen() == 0)){

    AP = 0;

  }else{



    int tmphmg = -1;

    InDelHistory* IDH;
    InDelHistory* oldIDH = new InDelHistory();

    AlignDPTable *pVT;
    vector<char> SeqP(0);
    vector<char> SeqQ(0);
    vector<vector<int> > Aligns(0);
    vector<char> chars(0);
    vector<int> tempI(0);
    vector<int> tempI2(0);
    double iDelta;
    double iEpsilon;
    double iTau;
    chars.resize(4);
    chars[0] = 'A';
    chars[1] = 'C';
    chars[2] = 'G';
    chars[3] = 'T'; 
    vector<vector<double> > Pmat(0);
    vector<vector<double> > Qmat(0);
    
    //vector<double> V(0);
    //vector<int> ID(0);
    //vector<int> P(0);
    //vector<int> L(0);
    //vector<int> N(0);
    //vector<vector<int> > HMG;
    //vector<int> HMGin(0);
    //vector<double> Lwt(0);
    
    
    vector<int> stSeqLen(0);
    vector<int> enSeqLen(0);
    vector<int> stPosi(0);
    vector<int> enPosi(0);
    vector<int> oldHMG(0);
    vector<int> HMG(0);
    double fixProb = 0.8;
    double logfixProb = log(fixProb);
    double logNfixProb = log(1-fixProb);
    int oldNum, newNum;
    int IX, Tnum, Dnum;


    //cout << "A" << endl;
    
    //Node* nodeC;
    //Node* nodeP;
    Node* tempNode;
    Node* baseNode;
    
    //w = params.getWindowLen();
    lambda = params.getLambda();
    mu = params.getMu();
    ri = params.getRi();
    rd = params.getRd();
    
    

    if(rand.runif() < 0.5)
      baseNode = nodeC;
    else
      baseNode = nodeP;
 



    //cout << "edgeT : " << edgeT->getnumber() << endl;
    //cout << "nodeP : " << nodeP->getnumber() << endl;
    //cout << "nodeC : " << nodeC->getnumber() << endl;
    
    Time = edgeT->getEdgeLen();
    N0 = nodeP->getSeqLen();
    Nend = nodeC->getSeqLen();
    
    
    iDelta = (1 - exp(-(lambda + mu)*Time))/(double)2;
    iEpsilon = 1 - (rd + ri)/(double)2;
    iTau = 0.3;
    
    O_datalike = getLogLikeliData();
    O_IDHlike = edgeT->getlogLikeliIDH();
  
   

    nodeP->ReadyForCalSubTreeProbHere(edgeT->getnumber(), Time,params);
    nodeP->CalSubTreeProbHere();
    
    //vector<int> oldHMG(0);
    //vector<double> oldFixProb(0);
    //double dist;
    vector<vector<double> > Pt(0);
    vector<double> pi(0);
    //vector<int> fixedHMGIX(0);
    //vector<double> P(0);
    //vector<double> Q(0);
    //vector<vector<double> > Pmat(0);
    //vector<vector<double> > Qmat(0);
    Pt = nodeP->getPt();
    pi = params.getPi();  
    
    
    //cout << "pi" << endl;
    //print_vecd(pi);
    //cout << "Pt " << endl;
    //for(int i = 0; i<Pt.size(); i++){
    //  for(int j=0; j<Pt[i].size(); j++)
    //    cout << Pt[i][j] << " " ;
    //  cout << endl;
    // }
    

    //int numLetters = Pt.size();
    //double MaxT = 0;
    //for(i = 0; i < numLetters; i++){
    //  for(j = 0; j < numLetters; j++){
    //	Pt[i][j] *= pi[i];
    //	MaxT = MAX(MaxT, Pt[i][j]);
    //  }
    //}
    
    //cout << "Pt " << endl;
    //for(int i = 0; i<Pt.size(); i++){
    //  for(int j=0; j<Pt[i].size(); j++)
    //    cout << Pt[i][j] << " " ;
    //  cout << endl;
    // }
    


    //cout << "MaxT : " << MaxT << endl;




    // Make hash table
    // Will be set up later from parents to child
    //vector<vector<double> > DistT(0);
    




    if(baseNode != nodeP){

      //cout << "reverse " << endl;
      
      N0 = Nend;
      Nend = nodeP->getSeqLen();
      edgeT->ReverseEdge();
      IDH =  edgeT->getIDH();
      (*oldIDH) = (*IDH);
 
      
            
 
      //oldHMG = HMGin;
      //oldFixProb.resize(oldHMG.size());
      
      
      Qmat.resize(0);
      nodeP->getProbFromSubTreeProb(Qmat);
      
      //cout << "Qmat " << endl;
      //for(i = 0; i < Qmat.size(); i++){
      //  for(j = 0; j < 4; j++)
      // 	cout << Qmat[i][j] << " ";
      //  cout << endl;
      //}
      
      seqLen = Qmat.size();
      SeqQ.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqQ[i] = chars[rand.rwunif(Qmat[i])];
      
      
      //cout << "SeqQ " << endl;
      //for(i = 0; i < SeqQ.size(); i++)
      //  cout << SeqQ[i] << " ";
      //cout << endl;
      
 

      if(nodeC->getnumber() >= numLeaves){
	
	Pmat.resize(0);
	nodeC->getProbFromSubTreeProb(Pmat);
	
	
	//cout << "Pmat " << endl;
	//for(i = 0; i < Pmat.size(); i++){
	// 	for(j = 0; j < 4; j++)
	// 	  cout << Pmat[i][j] << " ";
	//	cout << endl;
	//}
	
	
	
	//-------------------------------------------//
	//
	// Sampling letters which will be cancelled and cal BackWard
	//
	//--------------------------------------------//
	
	seqLen = Pmat.size();
	SeqP.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
	
	
	
      }else{
	
	//cout << "nodeC->getnumber() : " << nodeC->getnumber() << endl;
	
	seqLen = nodeC->getSeqLen();
	SeqP.resize(seqLen);
	//-- v31 start --//
	//for(h = 0; h < seqLen; h++){
	//	inttmp = nodeC->getSeq(h);
	//	for( i = 0; i < numLetters; i++){
	//	  if(inttmp%2==1){
	//	    SeqP[h] = chars[i];
	//   }
	//	  inttmp /= 2;
	//   }
	//}
	
	
	tempI2.resize(numLetters);
	
	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
	
	

	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on
	    //SeqP[h] = chars[rand.rwunif(tempI)];
	    SeqP[h] = chars[k];
	  }else{
	    SeqP[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }

 


      //cout << "SeqP " << endl;
      //for(i = 0; i < SeqP.size(); i++)
      //  cout << SeqP[i] << " ";
      //cout << endl;


      N_psl = 0;
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldHMG.resize(0);
      oldHMG = IDH->getHMG(IDH->getNumE());
      
      Aligns.resize(0);
      Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
      Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

      delete pVT;
      Aligns.pop_back();
      intTemp = Aligns.size();

      Tnum = 0;
      Dnum = 0;
      for(s =0; s < intTemp; s++){
	if(Aligns[s][0] == 1)
	  Aligns[s][0] = Tnum++;
        else
	  Aligns[s][0] = -1;

	if(Aligns[s][1] == 1)
	  Aligns[s][1] = Dnum++;
        else
	  Aligns[s][1] = -1; 
      }
      
       

      for(i = 0; i < intTemp; i++){

	if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){

	  if(rand.runif()- fixProb < 0){
	    stPosi.push_back(Aligns[i][0]+1);
	    enPosi.push_back(Aligns[i][1]+1);	    
	    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	    IX++;
	  }

        }

      }

      stSeqLen.push_back(N0 -stPosi[IX-1]);
      enSeqLen.push_back(Nend-enPosi[IX-1]);
    

      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);   

      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, Time, IDH);

      //N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, Time, IDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  
      HMG.resize(0);
      HMG = IDH->getHMG(IDH->getNumE());


      O_psl = 0;
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for N_psl
      oldNum = 0; // for O_psl

      for(i = 0; i < intTemp; i++){

	if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){

	  // N_psl 
	  if(HMG[Aligns[i][1]] == Aligns[i][0])
	    newNum++;

	  if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	    oldNum++;
	    
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	  
	  }
	
	}
      
      }
      stSeqLen.push_back(N0 -stPosi[IX-1]);
      enSeqLen.push_back(Nend-enPosi[IX-1]);
   
   
      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, Time, oldIDH);
      
      //O_psl = calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, Time, oldIDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
  
      
      N_psl += oldNum*logNfixProb;
      O_psl += newNum*logNfixProb;

      //cout << "O_psl " << O_psl << endl;
  
  
      edgeT->ReverseEdge();
   


  }else{   // baseNode == nodeP
 
    //cout << "Not reverse" << endl;

    IDH =  edgeT->getIDH();
    (*oldIDH) = (*IDH);
    
    //cout << "1" << endl;

      Pmat.resize(0);

      //cout << "2" << endl;

      nodeP->getProbFromSubTreeProb(Pmat);

      //cout << "3" << endl;
      //cout << "Pmat " << endl;
      //for(i = 0; i < Pmat.size(); i++){
      //  for(j = 0; j < 4; j++)
      //	cout << Pmat[i][j] << " ";
      //  cout << endl;
      //}


      seqLen = Pmat.size();

      //cout << "4" << endl;
      SeqP.resize(seqLen);
      //cout << "5" << endl;
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];
      


      //cout << "SeqP " << endl;
      //for(i = 0; i < SeqP.size(); i++)
      // cout << SeqP[i] << " ";
      //cout << endl;
      
      
      
      if(nodeC->getnumber() >= numLeaves){
	

	Qmat.resize(0);
	nodeC->getProbFromSubTreeProb(Qmat);
	
	//cout << "Qmat " << endl;
	//for(i = 0; i < Qmat.size(); i++){
	//for(j = 0; j < 4; j++)
	//  cout << Qmat[i][j] << " ";
	//	cout << endl;
	//}
	
	
	//-------------------------------------------//
	//
	// Sampling letters which will be cancelled and cal BackWard
	//
	//--------------------------------------------//
	


	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{
	
	
	
	//cout << "nodeC->getnumber() : " << nodeC->getnumber() << endl;
	
	

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);
	
	//-- v31 start --//
	//for(h = 0; h < seqLen; h++){
	//	inttmp = nodeC->getSeq(h);
	//	for( i = 0; i < numLetters; i++){
	//	  if(inttmp%2==1){
	//	    SeqQ[h] = chars[i];
	//    }
	//	  inttmp /= 2;
	// }
	//}
	

	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      
	
	
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//

      
      }
    
      //       cout << "SeqQ " << endl;
      //for(i = 0; i < SeqQ.size(); i++)
      //  cout << SeqQ[i] << " ";
      //cout << endl;
      
      N_psl = 0;
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldHMG.resize(0);
      oldHMG = IDH->getHMG(IDH->getNumE());
      
      
      Aligns.resize(0);
      Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
      Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

      delete pVT;
      Aligns.pop_back();
      intTemp = Aligns.size();
      


      Tnum = 0;
      Dnum = 0;
      for(s =0; s < intTemp; s++){
	if(Aligns[s][0] == 1)
	  Aligns[s][0] = Tnum++;
	else
	  Aligns[s][0] = -1;
	
	if(Aligns[s][1] == 1)
	  Aligns[s][1] = Dnum++;
	else
	  Aligns[s][1] = -1; 
      }
      
      
      
      //      cout << "BBB" << endl;

      
      for(i = 0; i < intTemp; i++){
	
	if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	  
	  if(rand.runif()- fixProb < 0){
	    stPosi.push_back(Aligns[i][0]+1);
	    enPosi.push_back(Aligns[i][1]+1);	    
	    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	    IX++;
	  }
	  
	}
	
      }
      
      stSeqLen.push_back(N0 -stPosi[IX-1]);
      enSeqLen.push_back(Nend-enPosi[IX-1]);
      
      
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);   
      
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, Time, IDH);
      
      //N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, Time, IDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
      
      HMG.resize(0);
      HMG = IDH->getHMG(IDH->getNumE());
      
      
      O_psl = 0;
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for N_psl
      oldNum = 0; // for O_psl
      
      for(i = 0; i < intTemp; i++){
	
	if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	  
	  // N_psl 
	  if(HMG[Aligns[i][1]] == Aligns[i][0])
	    newNum++;
	  
	  if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	    
	    oldNum++;
	    
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	
      }
      stSeqLen.push_back(N0 -stPosi[IX-1]);
      enSeqLen.push_back(Nend-enPosi[IX-1]);
      
   
      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, Time, oldIDH);
      
      //O_psl = calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, Time, oldIDH, Pmat, Qmat, DistT, Pt, pi, N0, Nend);
      
      
      N_psl += oldNum*logNfixProb;
      O_psl += newNum*logNfixProb;
      
      //cout << "O_psl " << O_psl << endl;
      
      
    }

   
    nodeP->FinishForCalSubTreeProbHere();

    edgeT->calHMG();
    N_IDHlike = edgeT->likeliHistory(params);
  
  
  
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
  
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }
    
      
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();
    
      
 
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  
    //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;
      
    if(start)     
      AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);
    
    
    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;
    
  
    
    
    //V.resize(0);
    //ID.resize(0);
    //P.resize(0);
    //L.resize(0);
    //N.resize(0);
    //HMG.resize(0);
    //HMGin.resize(0);
    //Lwt.resize(0);
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    oldHMG.resize(0);
    HMG.resize(0);
    Pt.resize(0);
    pi.resize(0);
    Pmat.resize(0);
    Qmat.resize(0);
  
    SeqP.resize(0);
    SeqQ.resize(0);
    Aligns.resize(0);
    chars.resize(0);
    tempI.resize(0);
    tempI2.resize(0);
    chars.resize(0); 
    Pmat.resize(0);
    Qmat.resize(0);

    delete oldIDH;

  }





  
  return AP;
  
} // End of UpIDHonEdge
//-- v35 end --//






//-- v23 start --//
double Tree::UpIDHonEdgeWithFixedHMGbyDistance(Rand &rand, Parameters &params, ofstream& c) {



  double powWei = params.getPowWei();

  //cout << "start UpIDHonEdgeWithFixedHMGbyDistance" << endl;

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory();

  //vector<double> V(0);
  //vector<int> ID(0);
  //vector<int> P(0);
  //vector<int> L(0);
  //vector<int> N(0);
  //vector<vector<int> > HMG;
  vector<int> HMGin(0);
  //vector<double> Lwt(0);


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  //double fixProb = 0.85;
  //double logfixProb = log(fixProb);
  //double logNfixProb = log(1-fixProb);
  int IX;

  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  //w = params.getWindowLen();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();



  //cout << "edgeT : " << edgeT->getnumber() << endl;
  //cout << "nodeP : " << nodeP->getnumber() << endl;
  //cout << "nodeC : " << nodeC->getnumber() << endl;

  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  //if(Time <= w){ // Propose new history in a whole sequence

  O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
  O_IDHlike = edgeT->getlogLikeliIDH();

   
  //if(baseNode != nodeP){
  //  N0 = Nend;
  //  Nend = nodeP->getSeqLen();
  //  IDH->ReverseIDH();
  //  (*oldIDH) = (*IDH);
  //  //O_psl = ProposHistory(params, IDH);
  //}else{
  //  (*oldIDH) = (*IDH);
  //  //O_psl= edgeT->ProposHistory(params);
  //}
  
  
  // decide what homologies would be fixed
  // get  vector<int> stSeqLen(0);
  //      vector<int> enSeqLen(0);
  //      vector<int> stPosi(0);
  //      vector<int> enPosi(0);

  // Ready for HMG selection
  nodeP->ReadyForCalSubTreeProbHere(edgeT->getnumber(), Time,params);
  nodeP->CalSubTreeProbHere();
  vector<int> oldHMG(0);
  vector<double> oldFixProb(0);
  double dist;
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<int> fixedHMGIX(0);
  vector<double> P(0);
  vector<double> Q(0);
  Pt = nodeP->getPt();
  pi = params.getPi();  


  //cout << "pi" << endl;
  //print_vecd(pi);
  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}


  //int numLetters = Pt.size();
  double MaxT = 0;
  for(i = 0; i < numLetters; i++){
    for(j = 0; j < numLetters; j++){
      Pt[i][j] *= pi[i];
      MaxT = MAX(MaxT, Pt[i][j]);
    }
  }

  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}



  //cout << "MaxT : " << MaxT << endl;





  if(baseNode != nodeP){

    //cout << "reverse " << endl;

    N0 = Nend;
    Nend = nodeP->getSeqLen();
    IDH->ReverseIDH();
    (*oldIDH) = (*IDH);

    N_psl = 0;
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    oldHMG = HMGin;
    oldFixProb.resize(oldHMG.size());

    //cout << "Nend : " << Nend << endl;
    //cout << "HMGin " << endl;
    //print_veci(HMGin);

    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	
	
	// Calculate distance from HMGin[i] to i;

	P.resize(0);
	Q.resize(0);
	nodeC->getProbFromSubTreeProb(P, HMGin[i]);
	nodeP->getProbFromSubTreeProb(Q, i);
	dist = 0;
	for(k = 0; k < numLetters; k++){
	  for(j = 0; j < numLetters; j++)
	    dist += Pt[k][j]*P[k]*Q[j];
	}
	
	dist = pow(dist/MaxT, powWei);
	oldFixProb[i] = dist;
      
	if(rand.runif()- dist < 0){
	  stPosi.push_back(HMGin[i]+1);
	  enPosi.push_back(i+1);	    
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  IX++;
	  N_psl += log(dist);
	  fixedHMGIX.push_back(1);
	}else{
	  N_psl += log(1-dist);
	  fixedHMGIX.push_back(0);
	}
      }else{
	fixedHMGIX.push_back(-1);
      }
    }
    stSeqLen.push_back(N0 -stPosi[IX-1]);
    enSeqLen.push_back(Nend-enPosi[IX-1]);
    
    enPosi.resize(0);
    
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);   
    //cout << "fixedHMGIX" << endl;
    //print_veci(fixedHMGIX);  
    //cout << "oldFixProb " << endl;
    //print_vecd(oldFixProb);

    //cout << "N_psl " << N_psl << endl;

  
    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, Time, IDH);
  
  
    O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, Time, oldIDH);
  

    //cout << "O_psl " << O_psl << endl;
  
  
    //int total = 0;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    //cout << "HMGin " << endl;
    //print_veci(HMGin);
    
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	//cout << "A : " << i << endl;
	if(fixedHMGIX[i] == 1){
	  //cout << "B " << endl;
	  if(oldFixProb[i]==0)
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	  O_psl += log(oldFixProb[i]);
	}else if(HMGin[i] == oldHMG[i]){
	  //cout << "C " << endl;
	  if(fixedHMGIX[i] != 0){
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This case cannot happen! " << endl;
	  }else{

	    if(oldFixProb[i]==0)
	      cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	    O_psl += log(1-oldFixProb[i]);
	  }
	}else{
	  //cout << "D " << endl;
	  // need to calculate!

	  P.resize(0);
	  Q.resize(0);
	  nodeC->getProbFromSubTreeProb(P, HMGin[i]);
	  nodeP->getProbFromSubTreeProb(Q, i);

	  dist = 0;
	  for(k = 0; k < numLetters; k++){
	    for(j = 0; j < numLetters; j++)
	      dist += Pt[k][j]*P[k]*Q[j];
	  }
	  
	  dist = pow(dist/MaxT, powWei);
	  O_psl += log(1-dist);
	}
      }
    }


    //cout << "O_psl " << O_psl << endl;

    IDH->ReverseIDH();


  }else{   // baseNode == nodeP

    //cout << "Not " << endl;

    (*oldIDH) = (*IDH);

    N_psl = 0;
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    oldHMG = HMGin;
    oldFixProb.resize(oldHMG.size());
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	
	
	// Calculate distance from HMGin[i] to i;

	P.resize(0);
	Q.resize(0);
	nodeP->getProbFromSubTreeProb(P, HMGin[i]);
	nodeC->getProbFromSubTreeProb(Q, i);
	
	dist = 0;
	for(k = 0; k < numLetters; k++){
	  for(j = 0; j < numLetters; j++)
	    dist += Pt[k][j]*P[k]*Q[j];
	}
	
	dist = pow(dist/MaxT, powWei);
	oldFixProb[i] = dist;
      
	if(rand.runif()- dist < 0){
	  stPosi.push_back(HMGin[i]+1);
	  enPosi.push_back(i+1);	    
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  IX++;
	  N_psl += log(dist);
	  fixedHMGIX.push_back(1);
	}else{
	  N_psl += log(1-dist);
	  fixedHMGIX.push_back(0);
	}
      }else{
	fixedHMGIX.push_back(-1);
      }
    }
    stSeqLen.push_back(N0 -stPosi[IX-1]);
    enSeqLen.push_back(Nend-enPosi[IX-1]);
    
    enPosi.resize(0);
    


  
    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, Time, IDH);
  
  
    O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, Time, oldIDH);
  

  
  
    //int total = 0;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	if(fixedHMGIX[i] == 1){
	  if(oldFixProb[i]==0)
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	  O_psl += log(oldFixProb[i]);
	}else if(HMGin[i] == oldHMG[i]){
	  if(fixedHMGIX[i] != 0){
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This case cannot happen! " << endl;
	  }else{
	    if(oldFixProb[i]==0)
	      cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	    O_psl += log(1-oldFixProb[i]);
	  }
	}else{
	  // need to calculate!

	  P.resize(0);
	  Q.resize(0);
	  nodeP->getProbFromSubTreeProb(P, HMGin[i]);
	  nodeC->getProbFromSubTreeProb(Q, i);

	  dist = 0;
	  for(k = 0; k < numLetters; k++){
	    for(j = 0; j < numLetters; j++)
	      dist += Pt[k][j]*P[k]*Q[j];
	  }
	  
	  dist = pow(dist/MaxT, powWei);
	  O_psl += log(1-dist);
	}
      }
    }
  
  }
   





  //if(baseNode != nodeP)
  //  IDH->ReverseIDH();
  
  
  nodeP->FinishForCalSubTreeProbHere();

  edgeT->calHMG();
  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      
      
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //tempB = logLikeliIDH[current];
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  
  //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;
      
  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

      

  //V.resize(0);
  //ID.resize(0);
  //P.resize(0);
  //L.resize(0);
  //N.resize(0);
  //HMG.resize(0);
  HMGin.resize(0);
  //Lwt.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  oldHMG.resize(0);
  oldFixProb.resize(0);
  Pt.resize(0);
  pi.resize(0);
  fixedHMGIX.resize(0);
  P.resize(0);
  Q.resize(0);

  delete oldIDH;

  return AP;

} // End of UpIDHonEdge
//-- v23 end --//







//-- v23 start --//
double Tree::UpIDHonEdgeWithFixedHMGbyDistance(Rand &rand, Parameters &params, ofstream& c, int start) {



  double powWei = params.getPowWei();

  //cout << "start UpIDHonEdgeWithFixedHMGbyDistance" << endl;

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory();

  //vector<double> V(0);
  //vector<int> ID(0);
  //vector<int> P(0);
  //vector<int> L(0);
  //vector<int> N(0);
  //vector<vector<int> > HMG;
  vector<int> HMGin(0);
  //vector<double> Lwt(0);


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  //double fixProb = 0.85;
  //double logfixProb = log(fixProb);
  //double logNfixProb = log(1-fixProb);
  int IX;

  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  //w = params.getWindowLen();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();



  //cout << "edgeT : " << edgeT->getnumber() << endl;
  //cout << "nodeP : " << nodeP->getnumber() << endl;
  //cout << "nodeC : " << nodeC->getnumber() << endl;

  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  //if(Time <= w){ // Propose new history in a whole sequence

  O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
  O_IDHlike = edgeT->getlogLikeliIDH();

   
  //if(baseNode != nodeP){
  //  N0 = Nend;
  //  Nend = nodeP->getSeqLen();
  //  IDH->ReverseIDH();
  //  (*oldIDH) = (*IDH);
  //  //O_psl = ProposHistory(params, IDH);
  //}else{
  //  (*oldIDH) = (*IDH);
  //  //O_psl= edgeT->ProposHistory(params);
  //}
  
  
  // decide what homologies would be fixed
  // get  vector<int> stSeqLen(0);
  //      vector<int> enSeqLen(0);
  //      vector<int> stPosi(0);
  //      vector<int> enPosi(0);

  // Ready for HMG selection
  nodeP->ReadyForCalSubTreeProbHere(edgeT->getnumber(), Time,params);
  nodeP->CalSubTreeProbHere();
  vector<int> oldHMG(0);
  vector<double> oldFixProb(0);
  double dist;
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<int> fixedHMGIX(0);
  vector<double> P(0);
  vector<double> Q(0);
  Pt = nodeP->getPt();
  pi = params.getPi();  


  //cout << "pi" << endl;
  //print_vecd(pi);
  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}


  //int numLetters = Pt.size();
  double MaxT = 0;
  for(i = 0; i < numLetters; i++){
    for(j = 0; j < numLetters; j++){
      Pt[i][j] *= pi[i];
      MaxT = MAX(MaxT, Pt[i][j]);
    }
  }

  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}



  //cout << "MaxT : " << MaxT << endl;





  if(baseNode != nodeP){

    //cout << "reverse " << endl;

    N0 = Nend;
    Nend = nodeP->getSeqLen();
    IDH->ReverseIDH();
    (*oldIDH) = (*IDH);

    N_psl = 0;
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    oldHMG = HMGin;
    oldFixProb.resize(oldHMG.size());

    //cout << "Nend : " << Nend << endl;
    //cout << "HMGin " << endl;
    //print_veci(HMGin);

    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	
	
	// Calculate distance from HMGin[i] to i;

	P.resize(0);
	Q.resize(0);
	nodeC->getProbFromSubTreeProb(P, HMGin[i]);
	nodeP->getProbFromSubTreeProb(Q, i);
	dist = 0;
	for(k = 0; k < numLetters; k++){
	  for(j = 0; j < numLetters; j++)
	    dist += Pt[k][j]*P[k]*Q[j];
	}
	
	dist = pow(dist/MaxT, powWei);
	oldFixProb[i] = dist;
      
	if(rand.runif()- dist < 0){
	  stPosi.push_back(HMGin[i]+1);
	  enPosi.push_back(i+1);	    
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  IX++;
	  N_psl += log(dist);
	  fixedHMGIX.push_back(1);
	}else{
	  N_psl += log(1-dist);
	  fixedHMGIX.push_back(0);
	}
      }else{
	fixedHMGIX.push_back(-1);
      }
    }
    stSeqLen.push_back(N0 -stPosi[IX-1]);
    enSeqLen.push_back(Nend-enPosi[IX-1]);
    
    enPosi.resize(0);
    
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);   
    //cout << "fixedHMGIX" << endl;
    //print_veci(fixedHMGIX);  
    //cout << "oldFixProb " << endl;
    //print_vecd(oldFixProb);

    //cout << "N_psl " << N_psl << endl;

  
    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, Time, IDH);
  
  
    O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, Time, oldIDH);
  

    //cout << "O_psl " << O_psl << endl;
  
  
    //int total = 0;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    //cout << "HMGin " << endl;
    //print_veci(HMGin);
    
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	//cout << "A : " << i << endl;
	if(fixedHMGIX[i] == 1){
	  //cout << "B " << endl;
	  if(oldFixProb[i]==0)
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	  O_psl += log(oldFixProb[i]);
	}else if(HMGin[i] == oldHMG[i]){
	  //cout << "C " << endl;
	  if(fixedHMGIX[i] != 0){
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This case cannot happen! " << endl;
	  }else{

	    if(oldFixProb[i]==0)
	      cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	    O_psl += log(1-oldFixProb[i]);
	  }
	}else{
	  //cout << "D " << endl;
	  // need to calculate!

	  P.resize(0);
	  Q.resize(0);
	  nodeC->getProbFromSubTreeProb(P, HMGin[i]);
	  nodeP->getProbFromSubTreeProb(Q, i);

	  dist = 0;
	  for(k = 0; k < numLetters; k++){
	    for(j = 0; j < numLetters; j++)
	      dist += Pt[k][j]*P[k]*Q[j];
	  }
	  
	  dist = pow(dist/MaxT, powWei);
	  O_psl += log(1-dist);
	}
      }
    }


    //cout << "O_psl " << O_psl << endl;

    IDH->ReverseIDH();


  }else{   // baseNode == nodeP

    //cout << "Not " << endl;

    (*oldIDH) = (*IDH);

    N_psl = 0;
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    oldHMG = HMGin;
    oldFixProb.resize(oldHMG.size());
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	
	
	// Calculate distance from HMGin[i] to i;

	P.resize(0);
	Q.resize(0);
	nodeP->getProbFromSubTreeProb(P, HMGin[i]);
	nodeC->getProbFromSubTreeProb(Q, i);
	
	dist = 0;
	for(k = 0; k < numLetters; k++){
	  for(j = 0; j < numLetters; j++)
	    dist += Pt[k][j]*P[k]*Q[j];
	}
	
	dist = pow(dist/MaxT, powWei);
	oldFixProb[i] = dist;
      
	if(rand.runif()- dist < 0){
	  stPosi.push_back(HMGin[i]+1);
	  enPosi.push_back(i+1);	    
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  IX++;
	  N_psl += log(dist);
	  fixedHMGIX.push_back(1);
	}else{
	  N_psl += log(1-dist);
	  fixedHMGIX.push_back(0);
	}
      }else{
	fixedHMGIX.push_back(-1);
      }
    }
    stSeqLen.push_back(N0 -stPosi[IX-1]);
    enSeqLen.push_back(Nend-enPosi[IX-1]);
    
    enPosi.resize(0);
    


  
    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, Time, IDH);
  
  
    O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, Time, oldIDH);
  

  
  
    //int total = 0;
    HMGin.resize(0);
    HMGin = IDH->getHMG(IDH->getNumE());
    
    for(i = 0; i < Nend; i++){
      if(HMGin[i] != -1){
	if(fixedHMGIX[i] == 1){
	  if(oldFixProb[i]==0)
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	  O_psl += log(oldFixProb[i]);
	}else if(HMGin[i] == oldHMG[i]){
	  if(fixedHMGIX[i] != 0){
	    cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This case cannot happen! " << endl;
	  }else{
	    if(oldFixProb[i]==0)
	      cout << "ERROR in UpIDHonEdgeWithFixedHMGbyDistance! This cannot be zero! " << endl;
	    O_psl += log(1-oldFixProb[i]);
	  }
	}else{
	  // need to calculate!

	  P.resize(0);
	  Q.resize(0);
	  nodeP->getProbFromSubTreeProb(P, HMGin[i]);
	  nodeC->getProbFromSubTreeProb(Q, i);

	  dist = 0;
	  for(k = 0; k < numLetters; k++){
	    for(j = 0; j < numLetters; j++)
	      dist += Pt[k][j]*P[k]*Q[j];
	  }
	  
	  dist = pow(dist/MaxT, powWei);
	  O_psl += log(1-dist);
	}
      }
    }
  
  }
   





  //if(baseNode != nodeP)
  //  IDH->ReverseIDH();
  
  
  nodeP->FinishForCalSubTreeProbHere();

  edgeT->calHMG();
  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      
      
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //tempB = logLikeliIDH[current];
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  
  //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;
      
  if(start) 
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

      

  //V.resize(0);
  //ID.resize(0);
  //P.resize(0);
  //L.resize(0);
  //N.resize(0);
  //HMG.resize(0);
  HMGin.resize(0);
  //Lwt.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  oldHMG.resize(0);
  oldFixProb.resize(0);
  Pt.resize(0);
  pi.resize(0);
  fixedHMGIX.resize(0);
  P.resize(0);
  Q.resize(0);

  delete oldIDH;

  return AP;

} // End of UpIDHonEdge
//-- v23 end --//





//-- v27 start v29 start--//
double Tree::UpIDHonEdgebyDP(Rand &rand, Parameters &params, ofstream& c) {


  //double powWei = 0.7;

  //cout << "start UpIDHonEdgebyDP" << endl;

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;




  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();



  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();


  if((nodeC->getSeqLen() == 0) | (nodeP->getSeqLen() == 0)){

    AP = 0;

  }else{


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory(); 


  AlignDPTable *pBW;
  vector<char> SeqP(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  chars.resize(4);
  chars[0] = 'A';
  chars[1] = 'C';
  chars[2] = 'G';
  chars[3] = 'T'; 
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  int seqLen;
  int inttmp, h;
  int IX;





  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();



  //cout << "edgeT : " << edgeT->getnumber() << endl;
  //cout << "nodeP : " << nodeP->getnumber() << endl;
  //cout << "nodeC : " << nodeC->getnumber() << endl;

  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();



  iDelta = (1 - exp(-(lambda + mu)*Time))/(double)2;
  iEpsilon = 1 - (rd + ri)/(double)2;
  iTau = 0.3;
		   


  O_datalike = getLogLikeliData();
  O_IDHlike = edgeT->getlogLikeliIDH();

   

  // Ready for HMG selection
  nodeP->ReadyForCalSubTreeProbHere(edgeT->getnumber(), Time,params);
  nodeP->CalSubTreeProbHere();
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  Pt = nodeP->getPt();
  pi = params.getPi();  


  //cout << "pi" << endl;
  //print_vecd(pi);
  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}


  if(baseNode != nodeP){

    //cout << "reverse " << endl;

    N0 = Nend;
    Nend = nodeP->getSeqLen();
    edgeT->ReverseEdge();
    IDH =  edgeT->getIDH();
    (*oldIDH) = (*IDH);


    Qmat.resize(0);
    nodeP->getProbFromSubTreeProb(Qmat);

    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}

    seqLen = Qmat.size();
    SeqQ.resize(seqLen);
    for(i = 0; i < seqLen; i++)
      SeqQ[i] = chars[rand.rwunif(Qmat[i])];


    // cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;


    if(nodeC->getnumber() >= numLeaves){

      Pmat.resize(0);
      nodeC->getProbFromSubTreeProb(Pmat);

   
      //cout << "Pmat " << endl;
      //for(i = 0; i < Pmat.size(); i++){
      //	for(j = 0; j < 4; j++)
      //	  cout << Pmat[i][j] << " ";
      //	cout << endl;
      //}
      


      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled and cal BackWard
      //
      //--------------------------------------------//
      
      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];
      
      

    }else{

      //cout << "nodeC->getnumber() : " << nodeC->getnumber() << endl;

      seqLen = nodeC->getSeqLen();
      SeqP.resize(seqLen);
      //-- v31 start --//
      //for(h = 0; h < seqLen; h++){
      //	inttmp = nodeC->getSeq(h);
      //	for( i = 0; i < numLetters; i++){
      //	  if(inttmp%2==1){
      //	    SeqP[h] = chars[i];
      //   }
      //	  inttmp /= 2;
      //   }
      //}
      
      
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j =0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqP[h] = chars[rand.rwunif(tempI)];
	    SeqP[h] = chars[k];
	  }else{
	    SeqP[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//





    }

 


    // cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;
    

    Backward(&pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

    O_psl = 0;

    // Get Alignment
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edgeT->getHMG(), N0, Nend, Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);

    //cout << "O_psl " << endl;
    //cout << "Aligns1" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}


    O_psl = CalProbSample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);
    



    //cout << "O_psl 1 : " << O_psl << endl;
    Aligns.pop_back();

    //cout << "Aligns2" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}


    O_psl += calProbIDHfromPairwiseAlignment(Aligns, Time, oldIDH, params);

    //cout << "O_psl 2 : " << O_psl << endl;

    //---------------------------------------------//
    //
    //  N_psl first!
    //
    //----------------------------------------------//

    N_psl = 0;

    Aligns.resize(0);



    N_psl = Sample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);


    //cout << "N_psl " << endl;
    //cout << "Aligns" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}



    delete pBW;

    Aligns.pop_back();
    N_psl += generateNewIDHfromPairwiseAlignment(Aligns, Time, IDH, rand, params);

    //IDH->printIDH();

    edgeT->ReverseEdge();

  }else{   // baseNode == nodeP

    //cout << "Not " << endl;

    (*oldIDH) = (*IDH);

    Pmat.resize(0);
    nodeP->getProbFromSubTreeProb(Pmat);

    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    seqLen = Pmat.size();
    SeqP.resize(seqLen);
    for(i = 0; i < seqLen; i++)
      SeqP[i] = chars[rand.rwunif(Pmat[i])];


    //  cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;



    if(nodeC->getnumber() >= numLeaves){
    

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);

      //cout << "Qmat " << endl;
      //for(i = 0; i < Qmat.size(); i++){
      //for(j = 0; j < 4; j++)
      //  cout << Qmat[i][j] << " ";
      //	cout << endl;
      //}


      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled and cal BackWard
      //
      //--------------------------------------------//
      


      seqLen = Qmat.size();
      SeqQ.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqQ[i] = chars[rand.rwunif(Qmat[i])];
      
    }else{

      
 
      //cout << "nodeC->getnumber() : " << nodeC->getnumber() << endl;
      


      seqLen = nodeC->getSeqLen();
      SeqQ.resize(seqLen);

      //-- v31 start --//
      //for(h = 0; h < seqLen; h++){
      //	inttmp = nodeC->getSeq(h);
      //	for( i = 0; i < numLetters; i++){
      //	  if(inttmp%2==1){
      //	    SeqQ[h] = chars[i];
      //    }
      //	  inttmp /= 2;
      // }
      //}


	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      
    }
    
    //    cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    Backward(&pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

    O_psl = 0;


    // Get Alignment
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edgeT->getHMG(), N0, Nend, Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);

    O_psl = CalProbSample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

    //cout << "O_psl " << endl;
    //cout << "Aligns1" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}

    //cout << "O_psl 1 : " << O_psl << endl;

    Aligns.pop_back();

    //cout << "Aligns2" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}

    O_psl += calProbIDHfromPairwiseAlignment(Aligns, Time, oldIDH, params);

    //cout << "O_psl 2 : " << O_psl << endl;

    //---------------------------------------------//
    //
    //  N_psl first!
    //
    //----------------------------------------------//

    N_psl = 0;

    Aligns.resize(0);

    N_psl = Sample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);


    //cout << "N_psl " << endl;
    //cout << "Aligns" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}




    delete pBW;

    Aligns.pop_back();
    N_psl += generateNewIDHfromPairwiseAlignment(Aligns, Time, IDH, rand, params);

    //IDH->printIDH();

    edgeT->calHMG();

  }
   

  nodeP->FinishForCalSubTreeProbHere();


  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      
      

  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  

  //cout << "AP : " << AP << " O_psl : " << O_psl << " N_psl : " << N_psl << endl;



  //if(start)     
  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
    //else
    //AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

      

  Pt.resize(0);
  pi.resize(0);

  SeqP.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0); 
  Pmat.resize(0);
  Qmat.resize(0);

  delete oldIDH;

  }

  return AP;

} // End of UpIDHonEdge
//-- v27 end and v29 end --//









//-- v27 start v29 start--//
double Tree::UpIDHonEdgebyDP(Rand &rand, Parameters &params, ofstream& c, int start) {


  //double powWei = 0.7;

  //cout << "start UpIDHonEdgebyDP" << endl;

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;




  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();



  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();


  if((nodeC->getSeqLen() == 0) | (nodeP->getSeqLen() == 0)){

    AP = 0;

  }else{


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory(); 


  AlignDPTable *pBW;
  vector<char> SeqP(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  chars.resize(4);
  chars[0] = 'A';
  chars[1] = 'C';
  chars[2] = 'G';
  chars[3] = 'T'; 
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  int seqLen;
  int inttmp, h;
  int IX;





  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();



  //cout << "edgeT : " << edgeT->getnumber() << endl;
  //cout << "nodeP : " << nodeP->getnumber() << endl;
  //cout << "nodeC : " << nodeC->getnumber() << endl;

  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();



  iDelta = (1 - exp(-(lambda + mu)*Time))/(double)2;
  iEpsilon = 1 - (rd + ri)/(double)2;
  iTau = 0.3;
		   


  O_datalike = getLogLikeliData();
  O_IDHlike = edgeT->getlogLikeliIDH();

   

  // Ready for HMG selection
  nodeP->ReadyForCalSubTreeProbHere(edgeT->getnumber(), Time,params);
  nodeP->CalSubTreeProbHere();
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  Pt = nodeP->getPt();
  pi = params.getPi();  


  //cout << "pi" << endl;
  //print_vecd(pi);
  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}


  if(baseNode != nodeP){

    //cout << "reverse " << endl;

    N0 = Nend;
    Nend = nodeP->getSeqLen();
    edgeT->ReverseEdge();
    IDH =  edgeT->getIDH();
    (*oldIDH) = (*IDH);


    Qmat.resize(0);
    nodeP->getProbFromSubTreeProb(Qmat);

    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}

    seqLen = Qmat.size();
    SeqQ.resize(seqLen);
    for(i = 0; i < seqLen; i++)
      SeqQ[i] = chars[rand.rwunif(Qmat[i])];


    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;


    if(nodeC->getnumber() >= numLeaves){

      Pmat.resize(0);
      nodeC->getProbFromSubTreeProb(Pmat);

   
      //cout << "Pmat " << endl;
      //for(i = 0; i < Pmat.size(); i++){
      // 	for(j = 0; j < 4; j++)
      // 	  cout << Pmat[i][j] << " ";
      //	cout << endl;
      //}
      


      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled and cal BackWard
      //
      //--------------------------------------------//
      
      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];
      
      

    }else{

      //cout << "nodeC->getnumber() : " << nodeC->getnumber() << endl;

      seqLen = nodeC->getSeqLen();
      SeqP.resize(seqLen);
      //-- v31 start --//
      //for(h = 0; h < seqLen; h++){
      //	inttmp = nodeC->getSeq(h);
      //	for( i = 0; i < numLetters; i++){
      //	  if(inttmp%2==1){
      //	    SeqP[h] = chars[i];
      //   }
      //	  inttmp /= 2;
      //   }
      //}
      
      
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on
	    //SeqP[h] = chars[rand.rwunif(tempI)];
	    SeqP[h] = chars[k];
	  }else{
	    SeqP[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




    }

 


    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;
    

    Backward(&pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

    O_psl = 0;

    // Get Alignment
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edgeT->getHMG(), N0, Nend, Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);

    //cout << "O_psl " << endl;
    //cout << "Aligns1" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}


    O_psl = CalProbSample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);
    



    //cout << "O_psl 1 : " << O_psl << endl;
    Aligns.pop_back();

    //cout << "Aligns2" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}


    O_psl += calProbIDHfromPairwiseAlignment(Aligns, Time, oldIDH, params);

    //cout << "O_psl 2 : " << O_psl << endl;

    //---------------------------------------------//
    //
    //  N_psl first!
    //
    //----------------------------------------------//

    N_psl = 0;

    Aligns.resize(0);



    N_psl = Sample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);


    //cout << "N_psl " << endl;
    //cout << "Aligns" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}



    delete pBW;

    Aligns.pop_back();
    N_psl += generateNewIDHfromPairwiseAlignment(Aligns, Time, IDH, rand, params);

    //IDH->printIDH();

    edgeT->ReverseEdge();

  }else{   // baseNode == nodeP

    //cout << "Not " << endl;

    (*oldIDH) = (*IDH);

    Pmat.resize(0);
    nodeP->getProbFromSubTreeProb(Pmat);

    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    seqLen = Pmat.size();
    SeqP.resize(seqLen);
    for(i = 0; i < seqLen; i++)
      SeqP[i] = chars[rand.rwunif(Pmat[i])];


    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;



    if(nodeC->getnumber() >= numLeaves){
    

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);

      //cout << "Qmat " << endl;
      //for(i = 0; i < Qmat.size(); i++){
      //for(j = 0; j < 4; j++)
      //  cout << Qmat[i][j] << " ";
      //	cout << endl;
      //}


      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled and cal BackWard
      //
      //--------------------------------------------//
      


      seqLen = Qmat.size();
      SeqQ.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqQ[i] = chars[rand.rwunif(Qmat[i])];
      
    }else{

      
 
      //cout << "nodeC->getnumber() : " << nodeC->getnumber() << endl;
      


      seqLen = nodeC->getSeqLen();
      SeqQ.resize(seqLen);

      //-- v31 start --//
      //for(h = 0; h < seqLen; h++){
      //	inttmp = nodeC->getSeq(h);
      //	for( i = 0; i < numLetters; i++){
      //	  if(inttmp%2==1){
      //	    SeqQ[h] = chars[i];
      //    }
      //	  inttmp /= 2;
      // }
      //}
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      
    }
    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    Backward(&pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

    O_psl = 0;


    // Get Alignment
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edgeT->getHMG(), N0, Nend, Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);

    O_psl = CalProbSample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

    //cout << "O_psl " << endl;
    //cout << "Aligns1" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}

    //cout << "O_psl 1 : " << O_psl << endl;

    Aligns.pop_back();

    //cout << "Aligns2" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}

    O_psl += calProbIDHfromPairwiseAlignment(Aligns, Time, oldIDH, params);

    //cout << "O_psl 2 : " << O_psl << endl;

    //---------------------------------------------//
    //
    //  N_psl first!
    //
    //----------------------------------------------//

    N_psl = 0;

    Aligns.resize(0);

    N_psl = Sample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);


    //cout << "N_psl " << endl;
    //cout << "Aligns" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}




    delete pBW;

    Aligns.pop_back();
    N_psl += generateNewIDHfromPairwiseAlignment(Aligns, Time, IDH, rand, params);

    //IDH->printIDH();

    edgeT->calHMG();

  }
   

  nodeP->FinishForCalSubTreeProbHere();


  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      

  //cout << "N_datalike : " << N_datalike << endl;
  //printTree();

  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  

  //cout << "AP : " << AP << " O_psl : " << O_psl << " N_psl : " << N_psl << endl;



  if(start)     
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

      

  Pt.resize(0);
  pi.resize(0);

  SeqP.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0); 
  Pmat.resize(0);
  Qmat.resize(0);

  delete oldIDH;

  }

  return AP;

} // End of UpIDHonEdge
//-- v27 end and v29 end --//








//-- v34 start--//
double Tree::UpIDHonEdgebyDPbestLetters(Rand &rand, Parameters &params, ofstream& c, int start) {


  //double powWei = 0.7;

  //cout << "start UpIDHonEdgebyDP" << endl;

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;




  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();



  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();


  if((nodeC->getSeqLen() == 0) | (nodeP->getSeqLen() == 0)){

    AP = 0;

  }else{


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory(); 


  AlignDPTable *pBW;
  vector<char> SeqP(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  chars.resize(4);
  chars[0] = 'A';
  chars[1] = 'C';
  chars[2] = 'G';
  chars[3] = 'T'; 
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  int seqLen;
  int inttmp, h;
  int IX;





  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();



  //cout << "edgeT : " << edgeT->getnumber() << endl;
  //cout << "nodeP : " << nodeP->getnumber() << endl;
  //cout << "nodeC : " << nodeC->getnumber() << endl;

  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();



  iDelta = (1 - exp(-(lambda + mu)*Time))/(double)2;
  iEpsilon = 1 - (rd + ri)/(double)2;
  iTau = 0.3;
		   


  O_datalike = getLogLikeliData();
  O_IDHlike = edgeT->getlogLikeliIDH();

   

  // Ready for HMG selection
  nodeP->ReadyForCalSubTreeProbHere(edgeT->getnumber(), Time,params);
  nodeP->CalSubTreeProbHere();
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  Pt = nodeP->getPt();
  pi = params.getPi();  


  //cout << "pi" << endl;
  //print_vecd(pi);
  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}


  if(baseNode != nodeP){

    //cout << "reverse " << endl;

    N0 = Nend;
    Nend = nodeP->getSeqLen();
    edgeT->ReverseEdge();
    IDH =  edgeT->getIDH();
    (*oldIDH) = (*IDH);


    Qmat.resize(0);
    nodeP->getProbFromSubTreeProb(Qmat);

    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}

    seqLen = Qmat.size();
    SeqQ.resize(seqLen);
    for(i = 0; i < seqLen; i++){
      
      inttmp = which_halfprop(Qmat[i]);
      if(inttmp != -1)
	SeqQ[i] = chars[inttmp];
      else
	SeqQ[i] = chars[rand.rwunif(Qmat[i])];
    }

    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;


    if(nodeC->getnumber() >= numLeaves){

      Pmat.resize(0);
      nodeC->getProbFromSubTreeProb(Pmat);

   
      //cout << "Pmat " << endl;
      //for(i = 0; i < Pmat.size(); i++){
      // 	for(j = 0; j < 4; j++)
      // 	  cout << Pmat[i][j] << " ";
      //	cout << endl;
      //}
      


      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled and cal BackWard
      //
      //--------------------------------------------//
      
      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
      

    }else{

      //cout << "nodeC->getnumber() : " << nodeC->getnumber() << endl;

      seqLen = nodeC->getSeqLen();
      SeqP.resize(seqLen);
      //-- v31 start --//
      //for(h = 0; h < seqLen; h++){
      //	inttmp = nodeC->getSeq(h);
      //	for( i = 0; i < numLetters; i++){
      //	  if(inttmp%2==1){
      //	    SeqP[h] = chars[i];
      //   }
      //	  inttmp /= 2;
      //   }
      //}
      
      
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on
	    //SeqP[h] = chars[rand.rwunif(tempI)];
	    SeqP[h] = chars[k];
	  }else{
	    SeqP[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




    }

 


    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;
    

    Backward(&pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

    O_psl = 0;

    // Get Alignment
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edgeT->getHMG(), N0, Nend, Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);

    //cout << "O_psl " << endl;
    //cout << "Aligns1" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}


    O_psl = CalProbSample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);
    



    //cout << "O_psl 1 : " << O_psl << endl;
    Aligns.pop_back();

    //cout << "Aligns2" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}


    O_psl += calProbIDHfromPairwiseAlignment(Aligns, Time, oldIDH, params);

    //cout << "O_psl 2 : " << O_psl << endl;

    //---------------------------------------------//
    //
    //  N_psl first!
    //
    //----------------------------------------------//

    N_psl = 0;

    Aligns.resize(0);



    N_psl = Sample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);


    //cout << "N_psl " << endl;
    //cout << "Aligns" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}



    delete pBW;

    Aligns.pop_back();
    N_psl += generateNewIDHfromPairwiseAlignment(Aligns, Time, IDH, rand, params);

    //IDH->printIDH();

    edgeT->ReverseEdge();

  }else{   // baseNode == nodeP

    //cout << "Not " << endl;

    (*oldIDH) = (*IDH);

    Pmat.resize(0);
    nodeP->getProbFromSubTreeProb(Pmat);

    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    seqLen = Pmat.size();
    SeqP.resize(seqLen);
    for(i = 0; i < seqLen; i++){
      inttmp = which_halfprop(Pmat[i]);
      if(inttmp != -1)
	SeqP[i] = chars[inttmp];
      else
	SeqP[i] = chars[rand.rwunif(Pmat[i])];
    }

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;



    if(nodeC->getnumber() >= numLeaves){
    

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);

      //cout << "Qmat " << endl;
      //for(i = 0; i < Qmat.size(); i++){
      //for(j = 0; j < 4; j++)
      //  cout << Qmat[i][j] << " ";
      //	cout << endl;
      //}


      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled and cal BackWard
      //
      //--------------------------------------------//
      


      seqLen = Qmat.size();
      SeqQ.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Qmat[i]);
	if(inttmp != -1)
	  SeqQ[i] = chars[inttmp];
	else
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
      }

    }else{

      
 
      //cout << "nodeC->getnumber() : " << nodeC->getnumber() << endl;
      


      seqLen = nodeC->getSeqLen();
      SeqQ.resize(seqLen);

      //-- v31 start --//
      //for(h = 0; h < seqLen; h++){
      //	inttmp = nodeC->getSeq(h);
      //	for( i = 0; i < numLetters; i++){
      //	  if(inttmp%2==1){
      //	    SeqQ[h] = chars[i];
      //    }
      //	  inttmp /= 2;
      // }
      //}
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      
    }
    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    Backward(&pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

    O_psl = 0;


    // Get Alignment
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edgeT->getHMG(), N0, Nend, Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);

    O_psl = CalProbSample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

    //cout << "O_psl " << endl;
    //cout << "Aligns1" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}

    //cout << "O_psl 1 : " << O_psl << endl;

    Aligns.pop_back();

    //cout << "Aligns2" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}

    O_psl += calProbIDHfromPairwiseAlignment(Aligns, Time, oldIDH, params);

    //cout << "O_psl 2 : " << O_psl << endl;

    //---------------------------------------------//
    //
    //  N_psl first!
    //
    //----------------------------------------------//

    N_psl = 0;

    Aligns.resize(0);

    N_psl = Sample(pBW, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);


    //cout << "N_psl " << endl;
    //cout << "Aligns" << endl;
    //for(i =0; i < Aligns.size(); i++){
    //  for(j = 0; j < Aligns[i].size(); j++)
    //	cout << Aligns[i][j] << " ";
    //  cout << endl;
    //}




    delete pBW;

    Aligns.pop_back();
    N_psl += generateNewIDHfromPairwiseAlignment(Aligns, Time, IDH, rand, params);

    //IDH->printIDH();

    edgeT->calHMG();

  }
   

  nodeP->FinishForCalSubTreeProbHere();


  N_IDHlike = edgeT->likeliHistory(params);
  
  
  
  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1
  nodeC->findRootSites();
  
  // 1'
  if(nodeP->getRoot())
    nodeP->findLinkedSites();
  
  // 2
  nodeC->CalloglikeliofRootSitesOrReuse(params);
  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
  
  // 3 4 5
  int edgeTnum = nodeP->getEdgeNum(edgeT);
  if(nodeP->getRoot()){
    nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
  }else{
    nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
    nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
    
    // 4 5
    UpdateAllinfoToRootWithChangedHMG(params, nodeP);
  }
      
      
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
      

  //cout << "N_datalike : " << N_datalike << endl;
  //printTree();

  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  

  //cout << "AP : " << AP << " O_psl : " << O_psl << " N_psl : " << N_psl << endl;



  if(start)     
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

      

  Pt.resize(0);
  pi.resize(0);

  SeqP.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0); 
  Pmat.resize(0);
  Qmat.resize(0);

  delete oldIDH;

  }

  return AP;

} // End of UpIDHonEdge
//-- v34 end --//
















//--- v27 start --//
// Get Pairwise Alignments from HMG relationship
// using 1 and 0
void Tree::getPairwiseAlignmentsFromHMG(vector<int> HMG, int N0, int Nend, vector<vector<int> >& Aligns){

  int i, j, stPosi, enPosi;
  vector<int> temp01(0);
  vector<int> temp11(0);
  vector<int> temp10(0);
  temp01.resize(2);
  temp01[0] = 0;
  temp01[1] = 1;
  temp11.resize(2);
  temp11[0] = 1;
  temp11[1] = 1;
  temp10.resize(2);
  temp10[0] = 1;
  temp10[1] = 0;
  
  if(HMG.size() != N0){
    cout << "ERROR in getPairwiseAlignmentsFromHMG! " << endl;
  }else{

    Aligns.resize(0);
    stPosi = 0;
    for(i = 0; i < N0; i++){
   
      if(HMG[i] != -1){

	enPosi = HMG[i] - 1;

	for(j = stPosi; j <= enPosi; j++)
	  Aligns.push_back(temp01);

	Aligns.push_back(temp11);

	stPosi = enPosi + 2;

      }else{

	Aligns.push_back(temp10);

      }

    }

    enPosi = Nend - 1;
    for(j = stPosi; j <= enPosi; j++)
      Aligns.push_back(temp01);

    temp01.resize(0);
    temp11.resize(0);
    temp10.resize(0);

  }
    
}
  //--- v27 end --//




/*** v30 start ***/ 
// Exactly same with generateNewIDHfromPairwiseAlignment but accept stAlign and enAlign as input together
void Tree::generateNewIDHfromPairwiseAlignmentWOprobCal(vector<vector<int> > Aligns, double edge0len, InDelHistory* IDH, Rand &rand, const Parameters &params){


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  vector<int> delBasePosi(0);
  int stCount, enCount;
  int i, j, IX;
  int len = Aligns.size();



  //---------------------------------
  //
  // Generate all information 
  //
  //---------------------------------
  
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  delBasePosi.resize(0);
  
  IX = 1;
  stCount = 0;
  enCount = 0;
  stPosi.push_back(0);
  enPosi.push_back(0);
  
  for(i = 0; i < len; i++){
    if(Aligns[i][0] == 1){
      stCount++;
      
      if(Aligns[i][1] == 1){
	enCount++;
	
	stPosi.push_back(stCount);
	enPosi.push_back(enCount);
	stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	
	if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
	  delBasePosi.push_back(1);
	else
	  delBasePosi.push_back(0);
	
	IX++;
      }
      
      
    }else{
      
      if(Aligns[i][1] == 1)
	enCount++;
      
    }
    
  }
  
  
  stSeqLen.push_back(stCount-stPosi[IX-1]);
  enSeqLen.push_back(enCount-enPosi[IX-1]);
  
  if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
    delBasePosi.push_back(1);
  else
    delBasePosi.push_back(0);
  
  
  //cout << "edge len : " << edge0len << endl;
  //cout << "stSeqLen" << endl;
  //print_veci(stSeqLen);
  //cout << "enSeqLen" << endl;
  //print_veci(enSeqLen);
  //cout << "stPosi" << endl;
  //print_veci(stPosi);
  //cout << "delBasePosi" << endl;
  //print_veci(delBasePosi);
  
  
  //-------------------------
  //
  // Generate IDH
  //
  //-------------------------
  
  
  //double logProbs = 0;
  
  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  
  int numE;
  vector<vector<double> > delWeight(0);
  vector<int> delBasePosiIX(0);
  
  vector<InDelHistory*> listIDH(0);
  vector<double> timeS(0);
  int k, eventIX, Nend; 
  IX = stPosi.size();
  
  eventIX = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);
  
  
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(stPosi[IX-1] + stSeqLen[IX-1]);
  for(k = 0; k <= N[0]; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);


  // 3. Generate new IDH on Edge0 while keeping the original HMG.
  //            - in separate regions.
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  
  
  for(i = 0; i < IX; i++){
    if(delBasePosi[i] == 0){
      runEdge(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len);
      //logProbs += ProposHistory(params, listIDH[i]);
    }else{
      
      delWeight.resize(0);
      delBasePosiIX.resize(0);
      for(j = 0; j < stSeqLen[i] ; j++)
	delBasePosiIX.push_back(1);
      delBasePosiIX.push_back(0);
      //cout << "i : " << i << endl;
      //cout << "delBasePosiIX " << endl;
      //print_veci(delBasePosiIX);
      runEdgeWithDeletionConstraint(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len, delBasePosiIX, delWeight);
      //logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX, delWeight);
      //logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX);
      delWeight.resize(0);
      delBasePosiIX.resize(0);
    }
  }
  
  
  // 4. Need to combine all 
  int total;
  int selPosi = 0;  
  timeS.resize(IX);
  
  while(1){
    total = 0;
    for(j = 0; j < IX; j++){
      if(listIDH[j]->getNumE() > 0){
	timeS[j] = listIDH[j]->getV(1);
      }else{
	total++;
	timeS[j] = edge0len;
      }
    }
    if(total == IX)
      break;
    selPosi = which_min_vec(timeS);
    V.push_back(listIDH[selPosi]->getV(1));
    ID.push_back(listIDH[selPosi]->getID(1));
    L.push_back(listIDH[selPosi]->getL(1));
    P.push_back(listIDH[selPosi]->getP(1) + stPosi[selPosi]);
    if(ID[eventIX] == 1){
      N.push_back(N[eventIX-1]+L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.insert(HMGin.begin()+ P[eventIX],-1);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] + L[eventIX];
    }else{
      N.push_back(N[eventIX-1]-L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.erase(HMGin.begin()+ P[eventIX]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] - L[eventIX];
    }
    eventIX++;
    listIDH[selPosi]->eraseHistory(false, 1); 
  }
  
  numE = eventIX-1;
  V.push_back(edge0len);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N[numE]);    
  HMG0.push_back(HMG0[numE]);
  
  
  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 
  

  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  
  
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);
  delWeight.resize(0);
  delBasePosiIX.resize(0);
  delBasePosi.resize(0);
  
  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  
  timeS.resize(0);
  listIDH.resize(0);
  
  //return logProbs;
  

}
/*** v30 end ***/



/*** v27 start ***/ 
// Exactly same with generateNewIDHfromPairwiseAlignment but accept stAlign and enAlign as input together
double Tree::generateNewIDHfromPairwiseAlignment(vector<vector<int> > Aligns, double edge0len, InDelHistory* IDH, Rand &rand, const Parameters &params){


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  vector<int> delBasePosi(0);
  int stCount, enCount;
  int i, j, IX;
  int len = Aligns.size();



  //---------------------------------
  //
  // Generate all information 
  //
  //---------------------------------
  
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  delBasePosi.resize(0);
  
  IX = 1;
  stCount = 0;
  enCount = 0;
  stPosi.push_back(0);
  enPosi.push_back(0);
  
  for(i = 0; i < len; i++){
    if(Aligns[i][0] == 1){
      stCount++;
      
      if(Aligns[i][1] == 1){
	enCount++;
	
	stPosi.push_back(stCount);
	enPosi.push_back(enCount);
	stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	
	if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
	  delBasePosi.push_back(1);
	else
	  delBasePosi.push_back(0);
	
	IX++;
      }
      
      
    }else{
      
      if(Aligns[i][1] == 1)
	enCount++;
      
    }
    
  }
  
  
  stSeqLen.push_back(stCount-stPosi[IX-1]);
  enSeqLen.push_back(enCount-enPosi[IX-1]);
  
  if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
    delBasePosi.push_back(1);
  else
    delBasePosi.push_back(0);
  
  
  //cout << "edge len : " << edge0len << endl;
  //cout << "stSeqLen" << endl;
  //print_veci(stSeqLen);
  //cout << "enSeqLen" << endl;
  //print_veci(enSeqLen);
  //cout << "stPosi" << endl;
  //print_veci(stPosi);
  //cout << "delBasePosi" << endl;
  //print_veci(delBasePosi);
  
  
  //-------------------------
  //
  // Generate IDH
  //
  //-------------------------
  
  
  double logProbs = 0;
  
  //some vectors to generate events
  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG0;
  vector<int> HMGin(0);  
  int numE;
  vector<vector<double> > delWeight(0);
  vector<int> delBasePosiIX(0);
  
  vector<InDelHistory*> listIDH(0);
  vector<double> timeS(0);
  int k, eventIX, Nend; 
  IX = stPosi.size();
  
  eventIX = 1;
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);
  
  
  V.push_back(0);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(stPosi[IX-1] + stSeqLen[IX-1]);
  for(k = 0; k <= N[0]; k++){
    HMGin.push_back(k);
  }
  HMG0.push_back(HMGin);
  HMGin.resize(0);


  // 3. Generate new IDH on Edge0 while keeping the original HMG.
  //            - in separate regions.
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  
  
  for(i = 0; i < IX; i++){
    if(delBasePosi[i] == 0){
      runEdge(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len);
      logProbs += ProposHistory(params, listIDH[i]);
    }else{
      
      delWeight.resize(0);
      delBasePosiIX.resize(0);
      for(j = 0; j < stSeqLen[i] ; j++)
	delBasePosiIX.push_back(1);
      delBasePosiIX.push_back(0);
      //cout << "i : " << i << endl;
      //cout << "delBasePosiIX " << endl;
      //print_veci(delBasePosiIX);
      runEdgeWithDeletionConstraint(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len, delBasePosiIX, delWeight);
      //logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX, delWeight);
      logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX);
      delWeight.resize(0);
      delBasePosiIX.resize(0);
    }
  }
  
  
  // 4. Need to combine all 
  int total;
  int selPosi = 0;  
  timeS.resize(IX);
  
  while(1){
    total = 0;
    for(j = 0; j < IX; j++){
      if(listIDH[j]->getNumE() > 0){
	timeS[j] = listIDH[j]->getV(1);
      }else{
	total++;
	timeS[j] = edge0len;
      }
    }
    if(total == IX)
      break;
    selPosi = which_min_vec(timeS);
    V.push_back(listIDH[selPosi]->getV(1));
    ID.push_back(listIDH[selPosi]->getID(1));
    L.push_back(listIDH[selPosi]->getL(1));
    P.push_back(listIDH[selPosi]->getP(1) + stPosi[selPosi]);
    if(ID[eventIX] == 1){
      N.push_back(N[eventIX-1]+L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.insert(HMGin.begin()+ P[eventIX],-1);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] + L[eventIX];
    }else{
      N.push_back(N[eventIX-1]-L[eventIX]);
      HMGin = HMG0[eventIX-1];
      for( k = 0; k< L[eventIX]; k++)
	HMGin.erase(HMGin.begin()+ P[eventIX]);
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(i = selPosi+1; i < IX; i++)
	stPosi[i] = stPosi[i] - L[eventIX];
    }
    eventIX++;
    listIDH[selPosi]->eraseHistory(false, 1); 
  }
  
  numE = eventIX-1;
  V.push_back(edge0len);
  ID.push_back(-2);
  P.push_back(0);
  L.push_back(0);
  N.push_back(N[numE]);    
  HMG0.push_back(HMG0[numE]);
  
  
  IDH->setHistory(numE, V, ID, P, L, N, HMG0); 
  

  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  
  
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);
  delWeight.resize(0);
  delBasePosiIX.resize(0);
  delBasePosi.resize(0);
  
  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  
  timeS.resize(0);
  listIDH.resize(0);
  
  return logProbs;
  

}
/*** v27 end ***/


/*** v27 start ***/
// Exactly same with calProbIDHfromPairwiseAlignment, but accept stAlign and enAlign as input togetehr
double Tree::calProbIDHfromPairwiseAlignment(vector<vector<int> > Aligns, double edge0len, InDelHistory* IDH, const Parameters &params){


  //cout << "In calProbIDHfromPairwiseAlignment " << endl;

  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  vector<int> delBasePosi(0);
  int stCount, enCount;
  int i, IX;
  int len = Aligns.size();



  //---------------------------------
  //
  // Generate all information 
  //
  //---------------------------------
  
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);
  delBasePosi.resize(0);
  
  IX = 1;
  stCount = 0;
  enCount = 0;
  stPosi.push_back(0);
  enPosi.push_back(0);
  
  for(i = 0; i < len; i++){
    if(Aligns[i][0] == 1){
      stCount++;
      
      if(Aligns[i][1] == 1){
	enCount++;
	
	stPosi.push_back(stCount);
	enPosi.push_back(enCount);
	stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	
	if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
	  delBasePosi.push_back(1);
	else
	  delBasePosi.push_back(0);
	
	IX++;
      }
      
      
    }else{
      
      if(Aligns[i][1] == 1)
	enCount++;
      
    }
    
  }
  

  stSeqLen.push_back(stCount-stPosi[IX-1]);
  enSeqLen.push_back(enCount-enPosi[IX-1]);
  
  if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
    delBasePosi.push_back(1);
  else
    delBasePosi.push_back(0);
  
  
  //cout << "edge len : " << edge0len << endl;
  //cout << "stSeqLen" << endl;
  //print_veci(stSeqLen);
  //cout << "enSeqLen" << endl;
  //print_veci(enSeqLen);
  //cout << "stPosi" << endl;
  //print_veci(stPosi);
  //cout << "delBasePosi" << endl;
  //print_veci(delBasePosi);
  
  //-------------------------
  //
  // Generate IDH
  //
  //-------------------------
  
  //IDH->printIDH();
  
  double logProbs = 0;
  
  //some vectors to generate events
  vector<vector<double> > V;
  vector<vector<int> > ID;
  vector<vector<int> > P;
  vector<vector<int> > L;
  vector<vector<int> > N;
  vector<vector<int> >  HMG0;
  vector<int> HMGin(0);
  vector<int> numEall(0);
  vector<int> delBasePosiIX(0);
  

  vector<InDelHistory*> listIDH(0);
  int j, k, numE, tmpnumE, posi, selPosi;
  IX = stPosi.size();
  
  listIDH.resize(IX);
  numEall.resize(IX);
  
  V.resize(IX);
  ID.resize(IX);
  P.resize(IX);
  L.resize(IX);
  N.resize(IX);
  
  // First part
  for(i = 0; i < IX ; i++){
    numEall[i] = 1;
    V[i].push_back(0);
    ID[i].push_back(-2);
    P[i].push_back(0);
    L[i].push_back(0);
    N[i].push_back(stSeqLen[i]);
  }
  
  
  // Separate IDH into several blocks
  listIDH.resize(IX);
  for(i = 0; i < IX ; i++)
    listIDH[i] = new InDelHistory();
  
  
  numE = IDH->getNumE();
  if(numE > 0){
    
    for(i = 1; i <= numE; i++){
      
      posi = IDH->getP(i);
      for(j = 0; j < IX; j++){
	if(j == (IX -1)){
	  selPosi = IX -1;
	  break;
	}else if((stPosi[j] <= posi) & (posi < stPosi[j+1])){
	  selPosi = j;
	  break;
	}
      }   
      V[selPosi].push_back(IDH->getV(i));
      ID[selPosi].push_back(IDH->getID(i));
      L[selPosi].push_back(IDH->getL(i));
      P[selPosi].push_back(IDH->getP(i) - stPosi[selPosi]);
      tmpnumE = numEall[selPosi];
      if(ID[selPosi][tmpnumE] == 1){
	N[selPosi].push_back(N[selPosi][tmpnumE-1]+L[selPosi][tmpnumE]);      
	for(k = selPosi+1; k < IX; k++)
	  stPosi[k] = stPosi[k] + L[selPosi][tmpnumE];
      }else{
	N[selPosi].push_back(N[selPosi][tmpnumE-1]-L[selPosi][tmpnumE]); 
	for(k = selPosi+1; k < IX; k++)
	  stPosi[k] = stPosi[k] - L[selPosi][tmpnumE];
      }
      numEall[selPosi] = numEall[selPosi] + 1;
    }
  }
  
  
  for(i = 0; i < IX ; i++){
    
    numEall[i] =  numEall[i] - 1;
    V[i].push_back(edge0len);
    ID[i].push_back(-2);
    P[i].push_back(0);
    L[i].push_back(0);
    N[i].push_back(enSeqLen[i]);
    if(delBasePosi[i] == 0){
      
      listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 
      logProbs += ProposHistory(params, listIDH[i]);
      
      //cout << "i : " << i << endl;
      //listIDH[i]->printIDHwoHMG();
      //cout << "logProbs : " << logProbs << endl; 
      
    }else{
      
      HMG0.resize(0);
      HMGin.resize(0);
      for(k = 0; k <= N[i][0]; k++){
	HMGin.push_back(k);
      }
      HMG0.push_back(HMGin);
      HMGin.resize(0);
      for(j = 1; j <= numEall[i]; j++){ 
	HMGin = HMG0[j-1];
	if(ID[i][j]==1){
	  for(k = 0; k < L[i][j]; k++)
	    HMGin.insert(HMGin.begin()+ P[i][j],-1);
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	}else{
	  for(k = 0; k< L[i][j]; k++)
	    HMGin.erase(HMGin.begin()+ P[i][j]);
	  HMG0.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
      HMG0.push_back(HMG0[numEall[i]]);
      listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 
      
      delBasePosiIX.resize(0);
      for(j = 0; j < N[i][0] ; j++)
	delBasePosiIX.push_back(1);
      delBasePosiIX.push_back(0);
      
      //cout << "i : " << i << endl;
      //cout << "delBasePosiIX " << endl;
      //print_veci(delBasePosiIX);
      logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX);
      
      //cout << "i : " << i << endl;
      //listIDH[i]->printIDH();
      //cout << "logProbs : " << logProbs << endl; 
      
      

    }
  }
  


  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  
  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG0.resize(0);
  HMGin.resize(0);
  numEall.resize(0);
  delBasePosiIX.resize(0);
  delBasePosi.resize(0);
  
  for(i = 0; i < listIDH.size(); i++)
    delete listIDH[i];
  
  listIDH.resize(0);
  
  return logProbs;
  
}
/*** v27 end ***/





// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMG(Rand &rand, Parameters &params, int numZnode, int Edgenum, int baseNodenum, ofstream& c) {

  int i, j, k, m, tmphmg, tmpint;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  //Edge* TempEdge;
  vector<int> oldHMG(0);
  vector<int> newHMG(0);
  //vector<int> tmpHMG1(0);
  //vector<int> tmpHMG2(0);
  //vector<int> tmpHMG3(0);
  vector<int> oldEdge0HMG(0);
  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);

  vector<vector<int> > delBasePosi(0);
  delBasePosi.resize(0); 
  vector<int> delBasePosi_in(0);
  delBasePosi_in.resize(0);
  bool connect;



  //-- v22 start --//
  double fixProb = 0.85;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  vector<int> fixedHMG(0);
  //-- v22 end --//



  InDelHistory* oldIDH = new InDelHistory();
  //vector<int> newEdge0HMG(0);
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_IDHlike = edge0->likeliHistory(params);

  if(nodeZ == edge0->getStart()){
    (*oldIDH) = (*edge0->getIDH());
    edge0->ReverseEdge();
    oldEdge0HMG = edge0->getHMG();
    edge0->ReverseEdge();
  }else{
    oldEdge0HMG = edge0->getHMG();
    edge0->ReverseEdge();
    (*oldIDH) = (*edge0->getIDH());
    edge0->ReverseEdge();
  }      


  //if(nodeZ == edge0->getEnd()){
  //  edge0->ReverseEdge();
  //  O_psl= edge0->ProposHistory(params);
  //  edge0->ReverseEdge();
  //}else{
  //  O_psl= edge0->ProposHistory(params);
  //}     

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    //cout << "caseIIa " << endl;


   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    

    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    //if(nodeZ == edge0->getEnd()){
    //  edge0->changeStartEnd();
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();     
    //  edge0->ReverseEdge();
    //}else{
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();
    //}    
    

    // FixHMG start
    // 2. Construct several blocks
    /*
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    N_seqlenZ = nodeZ->getSeqLen();  
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < N_seqlenZ; i++){
      if(newHMG[i] != -1){
	for(j = 0; j < T_seqlenZ; j++){
	  if(newHMG[i] == oldEdge0HMG[j]){
	    stPosi.push_back(i+1);
	    enPosi.push_back(j+1);
	    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	    IX++;
	  }
	}
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      edge0->calHMG(); 
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
    }else{
      N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      edge0->calHMG();
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
    }  

    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    stPosi.push_back(i+1);
	    enPosi.push_back(j+1);
	    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	    IX++;
	  }
	}
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);

    O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);

    checkTree();
    */






    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    N_psl = 0;
    fixedHMG.resize(0);
    //-- v22 end --//
    

    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();


    //cout << "O_seqlenZ : " << O_seqlenZ << " N_seqlenZ : " << N_seqlenZ << endl;
    //cout << "oldHMG " << endl;
    //print_veci(oldHMG);
    //cout << "newHMG " << endl;
    //print_veci(newHMG);
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);



    //cout << "T_seqlenZ : " << T_seqlenZ << endl;
    //cout << "N_seqlenZ : " << N_seqlenZ << endl;
    for(i = 0; i < N_seqlenZ; i++){
      //cout << "i : " << i << endl;
      if(newHMG[i] != -1){
	//cout << "A " << endl;
	// Heeee
	//--- v22 start --//
	//connect = false;
	//--- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  //cout << "j : " << j << endl;
	  if(newHMG[i] == oldEdge0HMG[j]){
	    //--- v22 start ---//
	    //connect = true;
	    //cout << "B" << endl;
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      // Heeee
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += logfixProb;
	    }else{
	      N_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//--- v22 start ---//
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]); 
    //-- v22 start --//
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);
    //-- v22 end --//
    enPosi.resize(0);
    
    //cout << "8" << endl;
    //      cout << "oldEdge0HMG " << endl;
    //    print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //  print_veci(delBasePosi[i]);
    
    
    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      //cout << "8.1" << endl;
      edge0->changeStartEnd();
      //cout << "8.1.1" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      
      
      //cout << "8.1.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.1.2" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.1.3" << endl;
    }else{
      //cout << "8.2" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      //cout << "8.2.1" << endl;
      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      
      
      //cout << "8.2.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.3" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.2.4" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.5" << endl;
    }  
    

    //cout << "edge0 IDH" << endl;
    //edge0->getIDH()->printIDH(); 
    //cout << "new " << endl;
    //print_veci(oldEdge0HMG);
    
    

    //cout << "8.3" << endl;
    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    O_psl = 0;
    //-- v22 end --//

    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	//-- v22 start --//
	//connect = false;
	//-- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    //-- v22 start --//
	    //connect = true;
	    if(is_element(fixedHMG, i)){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      O_psl += logfixProb;
	    }else{
	      O_psl += logNfixProb;
	    }
	    //--- v22 end ---//	      
	    break;
	  }
	}
	//--- v22 start ---//	      
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//	      
      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    //--- v22 start ---//	      
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);        
    //--- v22 end ---//	      

    //    cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //  print_veci(delBasePosi[i]);
    
    
    //cout << "9" << endl;

    //-- v22 start --//
    //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
    O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    //-- v22 start --//


      



    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    //    cout << "caseII " << endl;
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }


    //    cout << "caseII 1 " << endl;
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }


    // cout << "caseII 2 " << endl;


    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    //cout << "caseII 3 " << endl;

    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end




    //    cout << "oldHMG " << endl;
    //print_veci(oldHMG);
    //cout << "newHMG " << endl;
    //print_veci(newHMG);
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
      


    //cout << "caseII 4 " << endl;



    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //cout << "caseII 4.1 " << endl;

    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //cout << "caseII 4.2 " << endl;
   

    //edgeA->printEdge();

    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //cout << "caseII 5 " << endl;

    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //    cout << "caseII 6 " << endl;
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    //if(nodeZ == edge0->getEnd()){
    //  edge0->changeStartEnd();
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();     
    //  edge0->ReverseEdge();
    //}else{
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();
    //}    
    
    // FixHMG start
    // 2. Construct several blocks
    /*
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    N_seqlenZ = nodeZ->getSeqLen();
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < N_seqlenZ; i++){
      if(newHMG[i] != -1){
	for(j = 0; j < T_seqlenZ; j++){
	  if(newHMG[i] == oldEdge0HMG[j]){
	    stPosi.push_back(i+1);
	    enPosi.push_back(j+1);
	    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	    IX++;
	  }
	}
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      edge0->calHMG(); 
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
    }else{
      N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      edge0->calHMG();
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
    }  

    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    stPosi.push_back(i+1);
	    enPosi.push_back(j+1);
	    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	    IX++;
	  }
	}
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);

    O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
    */



    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    // Heeee
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    N_psl = 0;
    fixedHMG.resize(0);
    //-- v22 end --// 
  
    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    //    cout << "T_seqlenZ : " << T_seqlenZ << endl;
    //cout << "N_seqlenZ : " << N_seqlenZ << endl;
    for(i = 0; i < N_seqlenZ; i++){
      //cout << "i : " << i << endl;
      if(newHMG[i] != -1){
	//cout << "A " << endl;
	// Heeee
	//--- v22 start --//
	//connect = false;
	//--- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  //cout << "j : " << j << endl;
	  if(newHMG[i] == oldEdge0HMG[j]){
	    //--- v22 start ---//
	    //connect = true;
	    //cout << "B" << endl;
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      // Heeee
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += logfixProb;
	    }else{
	      N_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//--- v22 start --//
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end --//
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
    //-- v22 start --//
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);
    //-- v22 end --//
    enPosi.resize(0);
    
    //cout << "8" << endl;
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //  print_veci(delBasePosi[i]);
    
    

    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      //cout << "8.1" << endl;
      edge0->changeStartEnd();
      //cout << "8.1.1" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//

      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      

      //cout << "8.1.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.1.2" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.1.3" << endl;
    }else{
      //cout << "8.2" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      //cout << "8.2.1" << endl;
      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      

      //cout << "8.2.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.3" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.2.4" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.5" << endl;
    }  
    

    //cout << "edge0 IDH" << endl;
    //edge0->getIDH()->printIDH(); 
    //cout << "new " << endl;
    //print_veci(oldEdge0HMG);
    


    //cout << "8.3" << endl;
    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    O_psl = 0;
    //-- v22 end --//
    
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	//-- v22 start --//
	//connect = false;
	//-- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    //-- v22 start --//
	    //connect = true;
	    if(is_element(fixedHMG, i)){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      O_psl += logfixProb;
	    }else{
	      O_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//-- v22 start --//
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//
      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    //-- v22 start --//
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);        
    //-- v22 end --//


    //    cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //  print_veci(delBasePosi[i]);
    
    
    //cout << "9" << endl;
    //-- v22 start --// 
    O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
    //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    //-- v22 end --//   


  
    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//

    //    cout << "caseI " << endl;
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	edgeA->ReverseEdge();
	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}    
	edgeA->ReverseEdge();
	
      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end


    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    //if(nodeZ == edge0->getEnd()){
    //  edge0->changeStartEnd();
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();     
    //  edge0->ReverseEdge();
    //}else{
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();
    //}    
    
    // FixHMG start
    // 2. Construct several blocks
    /*
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    N_seqlenZ = nodeZ->getSeqLen();
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < N_seqlenZ; i++){
      if(newHMG[i] != -1){
	for(j = 0; j < T_seqlenZ; j++){
	  if(newHMG[i] == oldEdge0HMG[j]){
	    stPosi.push_back(i+1);
	    enPosi.push_back(j+1);
	    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	    IX++;
	  }
	}
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      edge0->calHMG(); 
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
    }else{
      N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      edge0->calHMG();
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
    }  

    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    stPosi.push_back(i+1);
	    enPosi.push_back(j+1);
	    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	    IX++;
	  }
	}
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);

    O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);

    */

    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);

    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    N_psl = 0;
    fixedHMG.resize(0);
    //-- v22 end --//
   
    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    //cout << "T_seqlenZ : " << T_seqlenZ << endl;
    //cout << "N_seqlenZ : " << N_seqlenZ << endl;
    for(i = 0; i < N_seqlenZ; i++){
      //cout << "i : " << i << endl;
      if(newHMG[i] != -1){
	//cout << "A " << endl;
	// Heeee
	//--- v22 start --//
	//connect = false;
	//--- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  //cout << "j : " << j << endl;
	  if(newHMG[i] == oldEdge0HMG[j]){
	    //--- v22 start ---//
	    //connect = true;
	    //cout << "B" << endl;
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      // Heeee
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += logfixProb;
	    }else{
	      N_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//--- v22 start ---//
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
    //-- v22 start --//
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);
    //-- v22 end --//
    enPosi.resize(0);
    
    //cout << "8" << endl;
    //      cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //	print_veci(delBasePosi[i]);
    
    
    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      //cout << "8.1" << endl;
      edge0->changeStartEnd();
      //cout << "8.1.1" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      

      //cout << "8.1.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.1.2" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.1.3" << endl;
    }else{
      //cout << "8.2" << endl;

      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      //cout << "8.2.1" << endl;
      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      


      //cout << "8.2.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.3" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.2.4" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.5" << endl;
    }  
    

    //      cout << "edge0 IDH" << endl;
    //edge0->getIDH()->printIDH(); 
    //cout << "new " << endl;
    //print_veci(oldEdge0HMG);
  


    //cout << "8.3" << endl;
    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    O_psl = 0;
    //-- v22 end --//
   
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	//-- v22 start --//
	//connect = false;
	//-- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    //-- v22 start --//
	    //connect = true;
	    if(is_element(fixedHMG, i)){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      O_psl += logfixProb;
	    }else{
	      O_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//-- v22 start --// 
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//
      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    //-- v22 start --// 
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);        
    //--- v22 end ---//


    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //	print_veci(delBasePosi[i]);
    
    
    //cout << "9" << endl;

    //-- v22 start --//
    O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
    //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
    

    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    //-- v22 end --//
      


       
    //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  //if(nodeZ == edge0->getEnd()){
  //  edge0->ReverseEdge();
  //  N_psl= edge0->ProposHistory(params);
  //  edge0->ReverseEdge();
  //}else{
  //  N_psl= edge0->ProposHistory(params);
  //}           

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];


  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);



  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl) << endl;


  oldHMG.resize(0);
  newHMG.resize(0);
  oldEdge0HMG.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);

  delBasePosi.resize(0);
  delBasePosi_in.resize(0);


  delete oldIDH;

  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 






//--- v25 start --//
/*
// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMG(Rand &rand, Parameters &params, int numZnode, int Edgenum, int baseNodenum, ofstream& c, int start) {

  int i, j, k, m, tmphmg, tmpint;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  //Edge* TempEdge;
  vector<int> oldHMG(0);
  vector<int> newHMG(0);
  //vector<int> tmpHMG1(0);
  //vector<int> tmpHMG2(0);
  //vector<int> tmpHMG3(0);
  vector<int> oldEdge0HMG(0);
  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);

  vector<vector<int> > delBasePosi(0);
  delBasePosi.resize(0); 
  vector<int> delBasePosi_in(0);
  delBasePosi_in.resize(0);
  bool connect;



  //-- v22 start --//
  double fixProb = 0.85;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  vector<int> fixedHMG(0);
  //-- v22 end --//



  InDelHistory* oldIDH = new InDelHistory();
  //vector<int> newEdge0HMG(0);
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_IDHlike = edge0->likeliHistory(params);

  if(nodeZ == edge0->getStart()){
    (*oldIDH) = (*edge0->getIDH());
    edge0->ReverseEdge();
    oldEdge0HMG = edge0->getHMG();
    edge0->ReverseEdge();
  }else{
    oldEdge0HMG = edge0->getHMG();
    edge0->ReverseEdge();
    (*oldIDH) = (*edge0->getIDH());
    edge0->ReverseEdge();
  }      


  //if(nodeZ == edge0->getEnd()){
  //  edge0->ReverseEdge();
  //  O_psl= edge0->ProposHistory(params);
  //  edge0->ReverseEdge();
  //}else{
  //  O_psl= edge0->ProposHistory(params);
  //}     

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    //cout << "caseIIa " << endl;


   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    

    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    //if(nodeZ == edge0->getEnd()){
    //  edge0->changeStartEnd();
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();     
    //  edge0->ReverseEdge();
    //}else{
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();
    //}    
    

    // FixHMG start
    // 2. Construct several blocks
 


    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    N_psl = 0;
    fixedHMG.resize(0);
    //-- v22 end --//
    

    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();


    //cout << "O_seqlenZ : " << O_seqlenZ << " N_seqlenZ : " << N_seqlenZ << endl;
    //cout << "oldHMG " << endl;
    //print_veci(oldHMG);
    //cout << "newHMG " << endl;
    //print_veci(newHMG);
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);



    //cout << "T_seqlenZ : " << T_seqlenZ << endl;
    //cout << "N_seqlenZ : " << N_seqlenZ << endl;
    for(i = 0; i < N_seqlenZ; i++){
      //cout << "i : " << i << endl;
      if(newHMG[i] != -1){
	//cout << "A " << endl;
	// Heeee
	//--- v22 start --//
	//connect = false;
	//--- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  //cout << "j : " << j << endl;
	  if(newHMG[i] == oldEdge0HMG[j]){
	    //--- v22 start ---//
	    //connect = true;
	    //cout << "B" << endl;
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      // Heeee
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += logfixProb;
	    }else{
	      N_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//--- v22 start ---//
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]); 
    //-- v22 start --//
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);
    //-- v22 end --//
    enPosi.resize(0);
    
    //cout << "8" << endl;
    //      cout << "oldEdge0HMG " << endl;
    //    print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //  print_veci(delBasePosi[i]);
    
    
    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      //cout << "8.1" << endl;
      edge0->changeStartEnd();
      //cout << "8.1.1" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      
      
      //cout << "8.1.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.1.2" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.1.3" << endl;
    }else{
      //cout << "8.2" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      //cout << "8.2.1" << endl;
      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      
      
      //cout << "8.2.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.3" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.2.4" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.5" << endl;
    }  
    

    //cout << "edge0 IDH" << endl;
    //edge0->getIDH()->printIDH(); 
    //cout << "new " << endl;
    //print_veci(oldEdge0HMG);
    
    

    //cout << "8.3" << endl;
    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    O_psl = 0;
    //-- v22 end --//

    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	//-- v22 start --//
	//connect = false;
	//-- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    //-- v22 start --//
	    //connect = true;
	    if(is_element(fixedHMG, i)){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      O_psl += logfixProb;
	    }else{
	      O_psl += logNfixProb;
	    }
	    //--- v22 end ---//	      
	    break;
	  }
	}
	//--- v22 start ---//	      
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//	      
      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    //--- v22 start ---//	      
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);        
    //--- v22 end ---//	      

    //    cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //  print_veci(delBasePosi[i]);
    
    
    //cout << "9" << endl;

    //-- v22 start --//
    //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
    O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    //-- v22 start --//


      



    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    //    cout << "caseII " << endl;
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }


    //    cout << "caseII 1 " << endl;
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }


    // cout << "caseII 2 " << endl;


    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    //cout << "caseII 3 " << endl;

    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end




    //    cout << "oldHMG " << endl;
    //print_veci(oldHMG);
    //cout << "newHMG " << endl;
    //print_veci(newHMG);
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
      


    //cout << "caseII 4 " << endl;



    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //cout << "caseII 4.1 " << endl;

    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //cout << "caseII 4.2 " << endl;
   

    //edgeA->printEdge();

    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //cout << "caseII 5 " << endl;

    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //    cout << "caseII 6 " << endl;
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    //if(nodeZ == edge0->getEnd()){
    //  edge0->changeStartEnd();
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();     
    //  edge0->ReverseEdge();
    //}else{
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();
    //}    
    
    // FixHMG start
    // 2. Construct several blocks


    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    // Heeee
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    N_psl = 0;
    fixedHMG.resize(0);
    //-- v22 end --// 
  
    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    //    cout << "T_seqlenZ : " << T_seqlenZ << endl;
    //cout << "N_seqlenZ : " << N_seqlenZ << endl;
    for(i = 0; i < N_seqlenZ; i++){
      //cout << "i : " << i << endl;
      if(newHMG[i] != -1){
	//cout << "A " << endl;
	// Heeee
	//--- v22 start --//
	//connect = false;
	//--- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  //cout << "j : " << j << endl;
	  if(newHMG[i] == oldEdge0HMG[j]){
	    //--- v22 start ---//
	    //connect = true;
	    //cout << "B" << endl;
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      // Heeee
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += logfixProb;
	    }else{
	      N_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//--- v22 start --//
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end --//
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
    //-- v22 start --//
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);
    //-- v22 end --//
    enPosi.resize(0);
    
    //cout << "8" << endl;
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //  print_veci(delBasePosi[i]);
    
    

    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      //cout << "8.1" << endl;
      edge0->changeStartEnd();
      //cout << "8.1.1" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//

      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      

      //cout << "8.1.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.1.2" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.1.3" << endl;
    }else{
      //cout << "8.2" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      //cout << "8.2.1" << endl;
      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      

      //cout << "8.2.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.3" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.2.4" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.5" << endl;
    }  
    

    //cout << "edge0 IDH" << endl;
    //edge0->getIDH()->printIDH(); 
    //cout << "new " << endl;
    //print_veci(oldEdge0HMG);
    


    //cout << "8.3" << endl;
    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    O_psl = 0;
    //-- v22 end --//
    
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	//-- v22 start --//
	//connect = false;
	//-- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    //-- v22 start --//
	    //connect = true;
	    if(is_element(fixedHMG, i)){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      O_psl += logfixProb;
	    }else{
	      O_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//-- v22 start --//
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//
      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    //-- v22 start --//
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);        
    //-- v22 end --//


    //    cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //  print_veci(delBasePosi[i]);
    
    
    //cout << "9" << endl;
    //-- v22 start --// 
    O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
    //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    //-- v22 end --//   


  
    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//

    //    cout << "caseI " << endl;
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	edgeA->ReverseEdge();
	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}    
	edgeA->ReverseEdge();
	
      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end


    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    //if(nodeZ == edge0->getEnd()){
    //  edge0->changeStartEnd();
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();     
    //  edge0->ReverseEdge();
    //}else{
    //  edge0->runEdge(rand,params);
    //  edge0->calHMG();
    //}    
    
    // FixHMG start
    // 2. Construct several blocks

    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);

    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    N_psl = 0;
    fixedHMG.resize(0);
    //-- v22 end --//
   
    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    //cout << "T_seqlenZ : " << T_seqlenZ << endl;
    //cout << "N_seqlenZ : " << N_seqlenZ << endl;
    for(i = 0; i < N_seqlenZ; i++){
      //cout << "i : " << i << endl;
      if(newHMG[i] != -1){
	//cout << "A " << endl;
	// Heeee
	//--- v22 start --//
	//connect = false;
	//--- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  //cout << "j : " << j << endl;
	  if(newHMG[i] == oldEdge0HMG[j]){
	    //--- v22 start ---//
	    //connect = true;
	    //cout << "B" << endl;
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      // Heeee
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += logfixProb;
	    }else{
	      N_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//--- v22 start ---//
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
    //-- v22 start --//
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);
    //-- v22 end --//
    enPosi.resize(0);
    
    //cout << "8" << endl;
    //      cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //	print_veci(delBasePosi[i]);
    
    
    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
      //cout << "8.1" << endl;
      edge0->changeStartEnd();
      //cout << "8.1.1" << endl;
      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      

      //cout << "8.1.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.1.2" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.1.3" << endl;
    }else{
      //cout << "8.2" << endl;

      //-- v22 start --//
      //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
      N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
      //-- v22 end --//
      //cout << "8.2.1" << endl;
      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      


      //cout << "8.2.2" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.3" << endl;
      oldEdge0HMG = edge0->getHMG();
      //cout << "8.2.4" << endl;
      edge0->ReverseEdge();
      //cout << "8.2.5" << endl;
    }  
    

    //      cout << "edge0 IDH" << endl;
    //edge0->getIDH()->printIDH(); 
    //cout << "new " << endl;
    //print_veci(oldEdge0HMG);
  


    //cout << "8.3" << endl;
    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    //-- v22 start --//
    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    O_psl = 0;
    //-- v22 end --//
   
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
	//-- v22 start --//
	//connect = false;
	//-- v22 end --//
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	  if(oldHMG[i] == oldEdge0HMG[j]){
	    //-- v22 start --//
	    //connect = true;
	    if(is_element(fixedHMG, i)){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	      //delBasePosi.push_back(delBasePosi_in);
	      //delBasePosi_in.resize(0);
	      O_psl += logfixProb;
	    }else{
	      O_psl += logNfixProb;
	    }
	    //--- v22 end ---//
	    break;
	  }
	}
	//-- v22 start --// 
	//if(!connect)
	//  delBasePosi_in.push_back(i-stPosi[IX-1]);
	//--- v22 end ---//
      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    enPosi.resize(0);
    //-- v22 start --// 
    //delBasePosi.push_back(delBasePosi_in);
    //delBasePosi_in.resize(0);        
    //--- v22 end ---//


    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi length : " << delBasePosi.size() << endl;
    //for(i = 0; i < delBasePosi.size(); i++)
    //	print_veci(delBasePosi[i]);
    
    
    //cout << "9" << endl;

    //-- v22 start --//
    O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
    //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
    

    //delBasePosi.resize(0);
    //delBasePosi_in.resize(0);
    //-- v22 end --//
      


       
    //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  //if(nodeZ == edge0->getEnd()){
  //  edge0->ReverseEdge();
  //  N_psl= edge0->ProposHistory(params);
  //  edge0->ReverseEdge();
  //}else{
  //  N_psl= edge0->ProposHistory(params);
  //}           

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];


  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl) << endl;


  oldHMG.resize(0);
  newHMG.resize(0);
  oldEdge0HMG.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);

  delBasePosi.resize(0);
  delBasePosi_in.resize(0);


  delete oldIDH;

  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 
*/
//-- v25 end --//


//--- v25 start --//
// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMG(Rand &rand, Parameters &params, int numZnode, int Edgenum, int baseNodenum, ofstream& c, int start) {

  int i, j, k, m, tmphmg, tmpint;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  vector<int> oldHMG(0);
  vector<int> newHMG(0);
  vector<int> oldEdge0HMG(0);
  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);

  vector<vector<int> > delBasePosi(0);
  delBasePosi.resize(0); 
  vector<int> delBasePosi_in(0);
  delBasePosi_in.resize(0);
  bool connect;



  //-- v22 start --//
  double fixProb = 0.85;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  vector<int> fixedHMG(0);
  //-- v22 end --//


  //-- v25 start --//
  vector<vector<double> > DistT(0);
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<double> > oldPmat(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  //int numLetters;
  double MaxT, dist;
  int ki;
  int EndSeqLen;
  double powWei = params.getPowWei();
  //-- v25 end --//





  InDelHistory* oldIDH = new InDelHistory();
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_IDHlike = edge0->likeliHistory(params);

  if(nodeZ == edge0->getStart()){
    (*oldIDH) = (*edge0->getIDH());
    edge0->ReverseEdge();
    oldEdge0HMG = edge0->getHMG();
    edge0->ReverseEdge();
  }else{
    oldEdge0HMG = edge0->getHMG();
    edge0->ReverseEdge();
    (*oldIDH) = (*edge0->getIDH());
    edge0->ReverseEdge();
  }      



  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  
  EndSeqLen = nodeC->getSeqLen();


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    //cout << "caseIIa " << endl;

  

    //-- v25 start --//
    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
    
    Pt = nodeZ->getPt();
    pi = params.getPi(); 
    
    //numLetters = Pt.size();
    MaxT = 0;
    for(i = 0; i < numLetters; i++){
      for(j = 0; j < numLetters; j++){
	Pt[i][j] *= pi[i];
	MaxT = MAX(MaxT, Pt[i][j]);
      }
    }
    
    
    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);
    Qmat.resize(0);
    nodeC->getProbFromSubTreeProb(Qmat);
    
    nodeZ->FinishForCalSubTreeProbHere();
    
      //-- v25 end --//



  
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));



        //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    //nodeC->findRootSites();  // later     
    
    // 1'
    //nodeZ->findLinkedSites();  // later
    
    // 2
    //nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ); // later


    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
    
    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
    
    nodeZ->FinishForCalSubTreeProbHere();

    //-- v25 end --//



    
    //----- Reconstruct a tree --------------//
    

    // FixHMG start
    // 2. Construct several blocks
 


    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
    
    N_psl = 0;
    fixedHMG.resize(0);

    for(i = 0; i < O_seqlenZ; i++)
      fixedHMG.push_back(0);

    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();


    //cout << "O_seqlenZ : " << O_seqlenZ << " N_seqlenZ : " << N_seqlenZ << endl;
    //cout << "oldHMG " << endl;
    //print_veci(oldHMG);
    //cout << "newHMG " << endl;
    //print_veci(newHMG);
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);



    //--- v25 start --//
    DistT.resize(N_seqlenZ + 1);
    for(i = 0; i <= N_seqlenZ; i++)
      DistT[i].resize(EndSeqLen+1);
    //--- v25 end --//
    


    for(i = 0; i < N_seqlenZ; i++){
  
      if(newHMG[i] != -1){

	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){

	  if(newHMG[i] == oldEdge0HMG[j]){


	    //--- v25 start --//
	    dist = 0;
	    for(k = 0; k < numLetters; k++){
	      for(ki = 0; ki < numLetters; ki++)
		dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	    }
	    
	    
	    DistT[i][j] = log(dist);
	    
	    dist = pow(dist/MaxT, powWei);

	    if(rand.runif()- dist < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      fixedHMG[newHMG[i]] = 1;
	      //fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += log(dist);
	    }else{
	      N_psl += log(1-dist);
	    }
       
	    break;
	  }
	}

      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]); 
 
    //enPosi.resize(0);
    
 
    //      cout << "oldEdge0HMG " << endl;
    //    print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);

    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
    
      edge0->changeStartEnd();
  
      N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  
      //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
    
      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
     
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
    }else{

      N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  

      //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
   
      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
    }  
    

   

    Pmat.resize(0);
    Pmat = oldPmat;
    oldPmat.resize(0);
    DistT.resize(0);
    //--- v25 start --//
    DistT.resize(O_seqlenZ + 1);
    for(i = 0; i <= O_seqlenZ; i++)
      DistT[i].resize(EndSeqLen+1);
    //--- v25 end --//
    
    



    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
 
    O_psl = 0;


    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){

	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
     
	  if(oldHMG[i] == oldEdge0HMG[j]){

	    dist = 0;
	    for(k = 0; k < numLetters; k++){
	      for(ki = 0; ki < numLetters; ki++)
		dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	    }
	    
	    
	    DistT[i][j] = log(dist);
	      
	    dist = pow(dist/MaxT, powWei);
	      
	    if(fixedHMG[i] == 1){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	  
	      O_psl += log(dist);
	    }else{
	      O_psl += log(1-dist);
	    }
       
	    break;
	  }
	}
	      
      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    //enPosi.resize(0);

    //    cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
 
    //O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
 
    O_psl += calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), oldIDH, Pmat, Qmat, DistT, Pt, pi, O_seqlenZ, T_seqlenZ);


    DistT.resize(0);

    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    //nodeA->findRootSites();
    //nodeB->findRootSites();
    nodeC->findRootSites();  // later     
    
    // 1'
    nodeZ->findLinkedSites();  // later
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3
    //nodeA->CalSubTreeProb(params);
    //nodeA->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); // later
    //-- v25 end --//
 
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    //    cout << "caseII " << endl;
    
    

    //-- v25 start --//
    nodeC->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeC->CalSubTreeProbHere();

    Pt = nodeC->getPt();
    pi = params.getPi(); 

    //numLetters = Pt.size();
    MaxT = 0;
    for(i = 0; i < numLetters; i++){
      for(j = 0; j < numLetters; j++){
	Pt[i][j] *= pi[i];
	MaxT = MAX(MaxT, Pt[i][j]);
      }
    }
    
    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);
    Qmat.resize(0);
    nodeC->getProbFromSubTreeProb(Qmat);
    
    nodeC->FinishForCalSubTreeProbHere();
    
    //-- v25 end --//




    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end




    //    cout << "oldHMG " << endl;
    //print_veci(oldHMG);
    //cout << "newHMG " << endl;
    //print_veci(newHMG);
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
      


 


    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
 

    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

   
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    


    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    //nodeZ->findRootSites();   // later     
    
    // 1'
    //if(nodeC->getRoot())      // later
    //  nodeC->findLinkedSites();  // later
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ);   // later


    nodeZ->CalSubTreeProb(params);

    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
   


    //-- v25 end --//

 

   
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    // FixHMG start
    // 2. Construct several blocks


    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);
 
    N_psl = 0;
    fixedHMG.resize(0);
    for(i = 0; i < O_seqlenZ; i++)
      fixedHMG.push_back(0);


  
    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();

    //--- v25 start --//
    DistT.resize(N_seqlenZ + 1);
    for(i = 0; i <= N_seqlenZ; i++)
      DistT[i].resize(EndSeqLen+1);
    //--- v25 end --//




    for(i = 0; i < N_seqlenZ; i++){
      if(newHMG[i] != -1){
    
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
       
	  if(newHMG[i] == oldEdge0HMG[j]){
	
	    //--- v25 start --//
	    dist = 0;
	    for(k = 0; k < numLetters; k++){
	      for(ki = 0; ki < numLetters; ki++)
		dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	    }
	    
	    
	    DistT[i][j] = log(dist);
	    
	    dist = pow(dist/MaxT, powWei);
	    
	    if(rand.runif()- dist < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      fixedHMG[newHMG[i]] = 1;
	      //fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += log(dist);
	    }else{
	      N_psl += log(1-dist);
	    }
     
	    break;
	  }
	}
      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
    //enPosi.resize(0);
    
  
    //cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);

    



    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
 
      edge0->changeStartEnd();
  
      N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);

      //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
   

      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
     
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
    
    }else{

      N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);

      //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());

      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
    
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
  
    }  
    


    Pmat.resize(0);
    Pmat = oldPmat;
    oldPmat.resize(0);
    DistT.resize(0);
    //--- v25 start --//
    DistT.resize(O_seqlenZ + 1);
    for(i = 0; i <= O_seqlenZ; i++)
      DistT[i].resize(EndSeqLen+1);
    //--- v25 end --//
    



    //cout << "edge0 IDH" << endl;
    //edge0->getIDH()->printIDH(); 
    //cout << "new " << endl;
    //print_veci(oldEdge0HMG);
    

    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    
   
    O_psl = 0;
  
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){
      
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
     
	  if(oldHMG[i] == oldEdge0HMG[j]){
	 

	    dist = 0;
	    for(k = 0; k < numLetters; k++){
	      for(ki = 0; ki < numLetters; ki++)
		dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	    }
	    
	      
	    DistT[i][j] = log(dist);

	    dist = pow(dist/MaxT, powWei);
	      
	    if(fixedHMG[i] == 1){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	  
	      O_psl += log(dist);
	    }else{
	      O_psl += log(1-dist);
	    }
	    break;
	  }
	}

      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    //enPosi.resize(0);
 
    //    cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
  
    //O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);

    O_psl += calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), oldIDH, Pmat, Qmat, DistT, Pt, pi, O_seqlenZ, T_seqlenZ);


    DistT.resize(0);


    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    //nodeA->findRootSites();
    //nodeB->findRootSites();
    nodeZ->findRootSites();   // later     
    
    // 1'
    if(nodeC->getRoot())      // later
      nodeC->findLinkedSites();  // later
    
    //3
    //nodeA->CalSubTreeProb(params);
    //nodeA->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

    nodeZ->CalloglikeliofRootSites(params);
    UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeC);   // later
    //-- v25 end --//
 
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//

    //    cout << "caseI " << endl;
    
    //-- v25 start --//
    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
	
    Pt = nodeZ->getPt();
    pi = params.getPi(); 
	
    //numLetters = Pt.size();
    MaxT = 0;
    for(i = 0; i < numLetters; i++){
      for(j = 0; j < numLetters; j++){
	Pt[i][j] *= pi[i];
	MaxT = MAX(MaxT, Pt[i][j]);
      }
    }


    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);
    Qmat.resize(0);
    nodeC->getProbFromSubTreeProb(Qmat);
    
    nodeZ->FinishForCalSubTreeProbHere();
    //-- v25 end --//
 


    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();
    oldHMG.resize(O_seqlenZ);
    for(i = 0; i < O_seqlenZ; i++)
      oldHMG[i] = -1;


    if(newAlen < edgeA->getEdgeLen()){ // new Z is on edge A
      
      // Find the position of new Z
      if(edgeA->getIDH()->getNumE() > 0){

	edgeA->ReverseEdge();
	for(i = 1; i <= edgeA->getIDH()->getNumE(); i++){
	  if(edgeA->getIDH()->getV(i) > (edgeA->getEdgeLen() - newAlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeA->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}    
	edgeA->ReverseEdge();
	
      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }

    }else{  // new Z is on edge B

     // Find the position of new Z
      if(edgeB->getIDH()->getNumE() > 0){

	for(i = 1; i <= edgeB->getIDH()->getNumE(); i++){
	  if(edgeB->getIDH()->getV(i) > (edgeB->getEdgeLen() - newBlen))
	    break;
        }
	newHMG.resize(0);
	newHMG = edgeB->getIDH()->getHMG(i-1);
	newHMG.pop_back();
	tmpint = newHMG.size();
	for(i = 0; i < tmpint; i++){
	  if(newHMG[i] >= 0)
	    oldHMG[newHMG[i]] = i;
	}

      }else{
  
	newHMG.resize(0);
	tmpint = oldHMG.size();
	for(i = 0; i < tmpint; i++){
	  oldHMG[i] = i;
	  newHMG.push_back(i);
	}
 
      }
  
    }
    // FixHMG end


    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    

    //--- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();         
    nodeB->findRootSites(); 
    //nodeC->findRootSites();  // later    
    
    // 1'
    if(nodeA->getRoot())   
      nodeA->findLinkedSites();
    
    // 2
    //nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ);   // later



    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
	
    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
	
    nodeZ->FinishForCalSubTreeProbHere();






    //--- v25 end --//


    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //

    
    // FixHMG start
    // 2. Construct several blocks

    // 2. Construct several blocks
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    stPosi.push_back(0);
    enPosi.push_back(0);

  
    N_psl = 0;
    fixedHMG.resize(0);
    for(i = 0; i < O_seqlenZ; i++)
      fixedHMG.push_back(0);

    N_seqlenZ = nodeZ->getSeqLen();
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();


    //--- v25 start --//
    DistT.resize(N_seqlenZ + 1);
    for(i = 0; i <= N_seqlenZ; i++)
      DistT[i].resize(EndSeqLen+1);
    //--- v25 end --//




    for(i = 0; i < N_seqlenZ; i++){
  
      if(newHMG[i] != -1){
      
	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
     
	  if(newHMG[i] == oldEdge0HMG[j]){
	

	    //--- v25 start --//
	    dist = 0;
	    for(k = 0; k < numLetters; k++){
	      for(ki = 0; ki < numLetters; ki++)
		dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	    }
	    
	
	    DistT[i][j] = log(dist);
	    
	    dist = pow(dist/MaxT, powWei);
	     
   


	    if(rand.runif()- dist < 0){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      fixedHMG[newHMG[i]] = 1;
	      //fixedHMG.push_back(newHMG[i]);
	      IX++;
	      N_psl += log(dist);
	    }else{
	      N_psl += log(1-dist);
	    }
      
	    break;
	  }
	}

      }
    }
    stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
 
    //enPosi.resize(0);
    

    //      cout << "oldEdge0HMG " << endl;
    //print_veci(oldEdge0HMG);
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
 
    
    oldEdge0HMG.resize(0);
    // 3. Generate new IDH on Edge0 while keeping the original HMG.      
    if(nodeZ == edge0->getEnd()){
    
      edge0->changeStartEnd();
  

      N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  

      //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
 
      edge0->calHMG(); 
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
      
   
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
    
    }else{


      N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  
      //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());

      edge0->calHMG();
      
      //cout << "N_psl " << N_psl << endl;
      //edge0->getIDH()->printIDH();
     
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
 
    }  
    


    Pmat.resize(0);
    Pmat = oldPmat;
    oldPmat.resize(0);
    DistT.resize(0);
    //--- v25 start --//
    DistT.resize(O_seqlenZ + 1);
    for(i = 0; i <= O_seqlenZ; i++)
      DistT[i].resize(EndSeqLen+1);
    //--- v25 end --//
      


    //      cout << "edge0 IDH" << endl;
    //edge0->getIDH()->printIDH(); 
    //cout << "new " << endl;
    //print_veci(oldEdge0HMG);
  

    // 4. Calculate proposal prob for old IDH 
    // 4.1  Construct several blocks and save starting position
    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);

    O_psl = 0;

   
    stPosi.push_back(0);
    enPosi.push_back(0);
    IX=1;
    T_seqlenZ = oldEdge0HMG.size();
    for(i = 0; i < O_seqlenZ; i++){
      if(oldHMG[i] != -1){

	for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
  
	  if(oldHMG[i] == oldEdge0HMG[j]){
	 

	    dist = 0;
	    for(k = 0; k < numLetters; k++){
	      for(ki = 0; ki < numLetters; ki++)
		dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	    }
		
	      
	    DistT[i][j] = log(dist);

	    dist = pow(dist/MaxT, powWei);
	      

	    if(fixedHMG[i] == 1){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	 
	      O_psl += log(dist);
	    }else{
	      O_psl += log(1-dist);
	    }
	    break;
	  }
	}

      }
    }
    stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
    enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
    //enPosi.resize(0);

    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);

    //O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
  
      

    O_psl += calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), oldIDH, Pmat, Qmat, DistT, Pt, pi, O_seqlenZ, T_seqlenZ);


    DistT.resize(0);
    


       
    //--- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    //nodeZ->findRootSites();         
    //nodeB->findRootSites(); 
    nodeC->findRootSites();  // later    
    
    // 1'
    //if(nodeA->getRoot())   
    //  nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3      
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ);   // later
    //--- v25 end --//
 
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    



  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl) << endl;


  oldHMG.resize(0);
  newHMG.resize(0);
  oldEdge0HMG.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);

  delBasePosi.resize(0);
  delBasePosi_in.resize(0);

  DistT.resize(0);
  Pt.resize(0);
  pi.resize(0);
  oldPmat.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  delete oldIDH;

  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 
//-- v25 end --//



//--- v28 start v29 start --//
// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreebyDP(Rand &rand, Parameters &params, int numZnode, int Edgenum, int baseNodenum, ofstream& c, int start) {

  int i, j, k, m, tmphmg, tmpint;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;


  //-- v25 start --//
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<double> > oldPmat(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  //-- v25 end --//

  //-- v28 start --//
  vector<char> SeqP(0);
  vector<char> SeqPold(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  AlignDPTable *pBW_O;
  AlignDPTable *pBW_N;
  double lambda, mu, rd, ri;
  int EndSeqLen, seqLen;
  //-- v28 end --//

  //-- v29 start --//
  int inttmp, h;
  //-- v29 end --//




  InDelHistory* oldIDH = new InDelHistory();
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_IDHlike = edge0->likeliHistory(params);


  //-- v28 start --//
  chars.resize(4);
  chars[0] = 'A';
  chars[1] = 'C';
  chars[2] = 'G';
  chars[3] = 'T';   
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();
  
  iDelta = (1 - exp(-(lambda + mu)*edge0->getEdgeLen()))/(double)2;
  iEpsilon = 1 - (rd + ri)/(double)2;
  iTau = 0.3;
  
  //-- v28 end --//



  if(nodeZ == edge0->getStart()){
    (*oldIDH) = (*edge0->getIDH());
    //-- v28 start --//
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edge0->getHMG(), edge0->getStart()->getSeqLen(), edge0->getEnd()->getSeqLen(), Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);    
    //-- v28 end --//    
  }else{
    edge0->ReverseEdge();
    (*oldIDH) = (*edge0->getIDH());
    //-- v28 start --//
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edge0->getHMG(), edge0->getStart()->getSeqLen(), edge0->getEnd()->getSeqLen(), Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);    
    //-- v28 end --//
    edge0->ReverseEdge();
  }      



  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  
  EndSeqLen = nodeC->getSeqLen();


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    //    cout << "caseIIa " << endl;

  

    //-- v25 start --//
    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
    
    Pt = nodeZ->getPt();
    pi = params.getPi(); 
    

    //  cout << "pi" << endl;
    //print_vecd(pi);
    //cout << "Pt " << endl;
    //for(i = 0; i<Pt.size(); i++){
    //for(j=0; j<Pt[i].size(); j++)
    //  cout << Pt[i][j] << " " ;
    //cout << endl;
    //}

    
    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);

    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
    
    }
    //-- v29 end --//


    nodeZ->FinishForCalSubTreeProbHere();
    
      //-- v25 end --//



  
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();


    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));



        //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    //nodeC->findRootSites();  // later     
    
    // 1'
    //nodeZ->findLinkedSites();  // later
    
    // 2
    //nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ); // later


    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
    
    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
    
    nodeZ->FinishForCalSubTreeProbHere();

    //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];




      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){


	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	//for(h = 0; h < seqLen; h++){
	//  inttmp = nodeC->getSeq(h);
	//  for( i = 0; i < numLetters; i++){
	//   if(inttmp%2==1){
	//      SeqQ[h] = chars[i];
	//    }
	//    inttmp /= 2;
	//  }
	//}
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }
      //-- v29 end --//



      //cout << "SeqP " << endl;
      //for(i = 0; i < SeqP.size(); i++)
      //cout << SeqP[i] << " ";
      //cout << endl;

      //cout << "SeqPold " << endl;
      //for(i = 0; i < SeqPold.size(); i++)
      //cout << SeqPold[i] << " ";
      //cout << endl;

    
      //cout << "SeqQ " << endl;
      //for(i = 0; i < SeqQ.size(); i++)
      //cout << SeqQ[i] << " ";
      //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }




      

    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    //nodeA->findRootSites();
    //nodeB->findRootSites();
    nodeC->findRootSites();  // later     
    
    // 1'
    nodeZ->findLinkedSites();  // later
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3
    //nodeA->CalSubTreeProb(params);
    //nodeA->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); // later
    //-- v25 end --//
 
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    //       cout << "caseII " << endl;
    
    

    //-- v25 start --//

    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      nodeC->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeC->CalSubTreeProbHere();

      Pt = nodeC->getPt();
      pi = params.getPi(); 

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
      
      nodeC->FinishForCalSubTreeProbHere();

    }else{

      nodeC->CalPt(edge0->getEdgeLen(),params);

      Pt = nodeC->getPt();
      nodeC->Ptreset();
      pi = params.getPi();
 
    }
    //-- v29 end --//

    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);

    
    //-- v25 end --//




    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }



    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
 

    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

   
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    


    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    //nodeZ->findRootSites();   // later     
    
    // 1'
    //if(nodeC->getRoot())      // later
    //  nodeC->findLinkedSites();  // later
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ);   // later


    nodeZ->CalSubTreeProb(params);

    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
   


    //-- v25 end --//





    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	
	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);
	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }
      //-- v29 end --//
      
      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
  

      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }




 

    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    //nodeA->findRootSites();
    //nodeB->findRootSites();
    nodeZ->findRootSites();   // later     
    
    // 1'
    if(nodeC->getRoot())      // later
      nodeC->findLinkedSites();  // later
    
    //3
    //nodeA->CalSubTreeProb(params);
    //nodeA->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

    nodeZ->CalloglikeliofRootSites(params);
    UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeC);   // later
    //-- v25 end --//
 
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//

    //       cout << "caseI " << endl;
    
    //-- v25 start --//
    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
	
    Pt = nodeZ->getPt();
    pi = params.getPi(); 
	


    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);


    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
    }
    //-- v29 end --//

    nodeZ->FinishForCalSubTreeProbHere();
    //-- v25 end --//
 


    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();

    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    

    //--- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();         
    nodeB->findRootSites(); 
    //nodeC->findRootSites();  // later    
    
    // 1'
    if(nodeA->getRoot())   
      nodeA->findLinkedSites();
    
    // 2
    //nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ);   // later



    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
	
    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
	
    nodeZ->FinishForCalSubTreeProbHere();






    //--- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{


     	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//







      }
      //-- v29 end --//

 

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
      


      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }


 
       
    //--- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    //nodeZ->findRootSites();         
    //nodeB->findRootSites(); 
    nodeC->findRootSites();  // later    
    
    // 1'
    //if(nodeA->getRoot())   
    //  nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3      
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ);   // later
    //--- v25 end --//
 
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    



  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl) << endl;



  Pt.resize(0);
  pi.resize(0);
  oldPmat.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  SeqP.resize(0);
  SeqPold.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0);
  delete oldIDH;

  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 
//-- v28 end --//



//--- v35 start --//
// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMGbyDP(Rand &rand, Parameters &params, int numZnode, int Edgenum, int baseNodenum, ofstream& c, int start) {

  int i, j, k, m, tmphmg, tmpint;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;


  //-- v25 start --//
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<double> > oldPmat(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  //-- v25 end --//

  //-- v28 start --//
  vector<char> SeqP(0);
  vector<char> SeqPold(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  AlignDPTable *pVT;
  double lambda, mu, rd, ri;
  int EndSeqLen, seqLen;
  //-- v28 end --//

  //-- v29 start --//
  int inttmp, h;
  //-- v29 end --//


  //-- v35 start --//
  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  vector<int> oldHMG(0);
  vector<int> HMG(0);
  double fixProb = 0.8;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  int oldNum, newNum, oldTnum, newTnum;
  InDelHistory* IDH;
  int intTemp, Tnum, Dnum, s;
  //-- v35 end --//

  

  InDelHistory* oldIDH = new InDelHistory();
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_IDHlike = edge0->likeliHistory(params);


  //-- v28 start --//
  chars.resize(4);
  chars[0] = 'A';
  chars[1] = 'C';
  chars[2] = 'G';
  chars[3] = 'T';   
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();
  
  iDelta = (1 - exp(-(lambda + mu)*edge0->getEdgeLen()))/(double)2;
  iEpsilon = 1 - (rd + ri)/(double)2;
  iTau = 0.3;
  
  //-- v28 end --//



  if(nodeZ == edge0->getStart()){
    (*oldIDH) = (*edge0->getIDH());

    oldHMG.resize(0);
    oldHMG = oldIDH->getHMG(oldIDH->getNumE());

  }else{
    edge0->ReverseEdge();
    (*oldIDH) = (*edge0->getIDH());

    oldHMG.resize(0);
    oldHMG = oldIDH->getHMG(oldIDH->getNumE());

    edge0->ReverseEdge();
  }      



  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  
  EndSeqLen = nodeC->getSeqLen();


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    //    cout << "caseIIa " << endl;

  

    //-- v25 start --//
    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
    
    Pt = nodeZ->getPt();
    pi = params.getPi(); 
    

    //  cout << "pi" << endl;
    //print_vecd(pi);
    //cout << "Pt " << endl;
    //for(i = 0; i<Pt.size(); i++){
    //for(j=0; j<Pt[i].size(); j++)
    //  cout << Pt[i][j] << " " ;
    //cout << endl;
    //}

    
    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);

    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
    
    }
    //-- v29 end --//


    nodeZ->FinishForCalSubTreeProbHere();
    
      //-- v25 end --//



  
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();


    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));



        //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    //nodeC->findRootSites();  // later     
    
    // 1'
    //nodeZ->findLinkedSites();  // later
    
    // 2
    //nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ); // later


    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
    
    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
    
    nodeZ->FinishForCalSubTreeProbHere();

    //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];




      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){


	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	//for(h = 0; h < seqLen; h++){
	//  inttmp = nodeC->getSeq(h);
	//  for( i = 0; i < numLetters; i++){
	//   if(inttmp%2==1){
	//      SeqQ[h] = chars[i];
	//    }
	//    inttmp /= 2;
	//  }
	//}
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }
      //-- v29 end --//



      //cout << "SeqP " << endl;
      //for(i = 0; i < SeqP.size(); i++)
      //cout << SeqP[i] << " ";
      //cout << endl;

      //cout << "SeqPold " << endl;
      //for(i = 0; i < SeqPold.size(); i++)
      //cout << SeqPold[i] << " ";
      //cout << endl;

    
      //cout << "SeqQ " << endl;
      //for(i = 0; i < SeqQ.size(); i++)
      //cout << SeqQ[i] << " ";
      //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
 
      O_psl = 0;

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldNum = 0; // for O_psl
      oldTnum = 0;


      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqPold.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    oldTnum++;

	    if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	      oldNum++;
	    
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(Aligns[i][0]+1);
		enPosi.push_back(Aligns[i][1]+1);	    
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	  
	    }
	
	  }
      
	}

	stSeqLen.push_back(SeqPold.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      
      //O_psl += (oldTnum+newNum)*logNfixProb;
 

      //---------------------------------------------//
      //
      //  N_psl
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for O_psl
      newTnum = 0;


      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqP.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    newTnum++;
 
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	stSeqLen.push_back(SeqP.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

 
      if(nodeZ == edge0->getEnd()){

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());

	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;

	  }
	}

	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());
	
	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){
	  
	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;
	    
	  }
	}


	edge0->calHMG();
      }


     N_psl += (newTnum+oldNum)*logNfixProb;
     
     O_psl += (oldTnum+newNum)*logNfixProb;

    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    //nodeA->findRootSites();
    //nodeB->findRootSites();
    nodeC->findRootSites();  // later     
    
    // 1'
    nodeZ->findLinkedSites();  // later
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3
    //nodeA->CalSubTreeProb(params);
    //nodeA->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); // later
    //-- v25 end --//
 
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    //       cout << "caseII " << endl;
    
    

    //-- v25 start --//

    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      nodeC->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeC->CalSubTreeProbHere();

      Pt = nodeC->getPt();
      pi = params.getPi(); 

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
      
      nodeC->FinishForCalSubTreeProbHere();

    }else{

      nodeC->CalPt(edge0->getEdgeLen(),params);

      Pt = nodeC->getPt();
      nodeC->Ptreset();
      pi = params.getPi();
 
    }
    //-- v29 end --//

    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);

    
    //-- v25 end --//




    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }



    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
 

    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

   
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    


    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    //nodeZ->findRootSites();   // later     
    
    // 1'
    //if(nodeC->getRoot())      // later
    //  nodeC->findLinkedSites();  // later
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ);   // later


    nodeZ->CalSubTreeProb(params);

    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
   


    //-- v25 end --//





    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	
	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);
	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }
      //-- v29 end --//
      
      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//



      O_psl = 0;

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldNum = 0; // for O_psl
      oldTnum = 0;


      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqPold.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    oldTnum++;

	    if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	      oldNum++;
	    
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(Aligns[i][0]+1);
		enPosi.push_back(Aligns[i][1]+1);	    
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	  
	    }
	
	  }
      
	}

	stSeqLen.push_back(SeqPold.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      
      //O_psl += (oldTnum+newNum)*logNfixProb;
 

      //---------------------------------------------//
      //
      //  N_psl
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for O_psl
      newTnum = 0;


      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqP.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    newTnum++;
 
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	stSeqLen.push_back(SeqP.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

 
      if(nodeZ == edge0->getEnd()){

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());

	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;

	  }
	}

	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());
	
	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){
	  
	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;
	    
	  }
	}


	edge0->calHMG();
      }


     N_psl += (newTnum+oldNum)*logNfixProb;
     
     O_psl += (oldTnum+newNum)*logNfixProb;
  


 

    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    //nodeA->findRootSites();
    //nodeB->findRootSites();
    nodeZ->findRootSites();   // later     
    
    // 1'
    if(nodeC->getRoot())      // later
      nodeC->findLinkedSites();  // later
    
    //3
    //nodeA->CalSubTreeProb(params);
    //nodeA->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

    nodeZ->CalloglikeliofRootSites(params);
    UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeC);   // later
    //-- v25 end --//
 
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//

    //       cout << "caseI " << endl;
    
    //-- v25 start --//
    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
	
    Pt = nodeZ->getPt();
    pi = params.getPi(); 
	


    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);


    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
    }
    //-- v29 end --//

    nodeZ->FinishForCalSubTreeProbHere();
    //-- v25 end --//
 


    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();

    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    

    //--- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();         
    nodeB->findRootSites(); 
    //nodeC->findRootSites();  // later    
    
    // 1'
    if(nodeA->getRoot())   
      nodeA->findLinkedSites();
    
    // 2
    //nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ);   // later



    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
	
    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
	
    nodeZ->FinishForCalSubTreeProbHere();






    //--- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{


     	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//







      }
      //-- v29 end --//

 

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
      

      O_psl = 0;

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldNum = 0; // for O_psl
      oldTnum = 0;


      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqPold.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    oldTnum++;

	    if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	      oldNum++;
	    
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(Aligns[i][0]+1);
		enPosi.push_back(Aligns[i][1]+1);	    
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	  
	    }
	
	  }
      
	}

	stSeqLen.push_back(SeqPold.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      
      //O_psl += (oldTnum+newNum)*logNfixProb;
 

      //---------------------------------------------//
      //
      //  N_psl
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for O_psl
      newTnum = 0;


      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqP.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    newTnum++;
 
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	stSeqLen.push_back(SeqP.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

 
      if(nodeZ == edge0->getEnd()){

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());

	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;

	  }
	}

	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());
	
	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){
	  
	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;
	    
	  }
	}


	edge0->calHMG();
      }


     N_psl += (newTnum+oldNum)*logNfixProb;
     O_psl += (oldTnum+newNum)*logNfixProb;



       
    //--- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    //nodeZ->findRootSites();         
    //nodeB->findRootSites(); 
    nodeC->findRootSites();  // later    
    
    // 1'
    //if(nodeA->getRoot())   
    //  nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3      
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ);   // later
    //--- v25 end --//
 
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    



  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl) << endl;



  Pt.resize(0);
  pi.resize(0);
  oldPmat.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  SeqP.resize(0);
  SeqPold.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0);
  delete oldIDH;

  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 
//-- v35 end --//



//--- v34 start --//
// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreebyDPbestLetters(Rand &rand, Parameters &params, int numZnode, int Edgenum, int baseNodenum, ofstream& c, int start) {

  int i, j, k, m, tmphmg, tmpint;  
  double r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;


  //-- v25 start --//
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<double> > oldPmat(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  //-- v25 end --//

  //-- v28 start --//
  vector<char> SeqP(0);
  vector<char> SeqPold(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  AlignDPTable *pBW_O;
  AlignDPTable *pBW_N;
  double lambda, mu, rd, ri;
  int EndSeqLen, seqLen;
  //-- v28 end --//

  //-- v29 start --//
  int inttmp, h;
  //-- v29 end --//




  InDelHistory* oldIDH = new InDelHistory();
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_IDHlike = edge0->likeliHistory(params);


  //-- v28 start --//
  chars.resize(4);
  chars[0] = 'A';
  chars[1] = 'C';
  chars[2] = 'G';
  chars[3] = 'T';   
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();
  
  iDelta = (1 - exp(-(lambda + mu)*edge0->getEdgeLen()))/(double)2;
  iEpsilon = 1 - (rd + ri)/(double)2;
  iTau = 0.3;
  
  //-- v28 end --//



  if(nodeZ == edge0->getStart()){
    (*oldIDH) = (*edge0->getIDH());
    //-- v28 start --//
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edge0->getHMG(), edge0->getStart()->getSeqLen(), edge0->getEnd()->getSeqLen(), Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);    
    //-- v28 end --//    
  }else{
    edge0->ReverseEdge();
    (*oldIDH) = (*edge0->getIDH());
    //-- v28 start --//
    Aligns.resize(0);
    getPairwiseAlignmentsFromHMG(edge0->getHMG(), edge0->getStart()->getSeqLen(), edge0->getEnd()->getSeqLen(), Aligns);
    tempI.resize(2);
    tempI[0] = 0;
    tempI[1] = 0;
    Aligns.push_back(tempI);    
    //-- v28 end --//
    edge0->ReverseEdge();
  }      



  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  
  EndSeqLen = nodeC->getSeqLen();


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    //    cout << "caseIIa " << endl;

  

    //-- v25 start --//
    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
    
    Pt = nodeZ->getPt();
    pi = params.getPi(); 
    

    //  cout << "pi" << endl;
    //print_vecd(pi);
    //cout << "Pt " << endl;
    //for(i = 0; i<Pt.size(); i++){
    //for(j=0; j<Pt[i].size(); j++)
    //  cout << Pt[i][j] << " " ;
    //cout << endl;
    //}

    
    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);

    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
    
    }
    //-- v29 end --//


    nodeZ->FinishForCalSubTreeProbHere();
    
      //-- v25 end --//



  
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();


    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));



        //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    //nodeC->findRootSites();  // later     
    
    // 1'
    //nodeZ->findLinkedSites();  // later
    
    // 2
    //nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ); // later


    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
    
    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
    
    nodeZ->FinishForCalSubTreeProbHere();

    //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    // 	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
      
     
      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(oldPmat[i]);
	if(inttmp != -1)
	  SeqPold[i] = chars[inttmp];
	else
	  SeqPold[i] = chars[rand.rwunif(oldPmat[i])];
      }
     



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){


	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++){
	  inttmp = which_halfprop(Qmat[i]);
	  if(inttmp != -1)
	    SeqQ[i] = chars[inttmp];
	  else
	    SeqQ[i] = chars[rand.rwunif(Qmat[i])];
        }
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	//for(h = 0; h < seqLen; h++){
	//  inttmp = nodeC->getSeq(h);
	//  for( i = 0; i < numLetters; i++){
	//   if(inttmp%2==1){
	//      SeqQ[h] = chars[i];
	//    }
	//    inttmp /= 2;
	//  }
	//}
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }
      //-- v29 end --//



      //cout << "SeqP " << endl;
      //for(i = 0; i < SeqP.size(); i++)
      //cout << SeqP[i] << " ";
      //cout << endl;

      //cout << "SeqPold " << endl;
      //for(i = 0; i < SeqPold.size(); i++)
      //cout << SeqPold[i] << " ";
      //cout << endl;

    
      //cout << "SeqQ " << endl;
      //for(i = 0; i < SeqQ.size(); i++)
      //cout << SeqQ[i] << " ";
      //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }




      

    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    //nodeA->findRootSites();
    //nodeB->findRootSites();
    nodeC->findRootSites();  // later     
    
    // 1'
    nodeZ->findLinkedSites();  // later
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3
    //nodeA->CalSubTreeProb(params);
    //nodeA->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); // later
    //-- v25 end --//
 
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    //       cout << "caseII " << endl;
    
    

    //-- v25 start --//

    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      nodeC->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeC->CalSubTreeProbHere();

      Pt = nodeC->getPt();
      pi = params.getPi(); 

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
      
      nodeC->FinishForCalSubTreeProbHere();

    }else{

      nodeC->CalPt(edge0->getEdgeLen(),params);

      Pt = nodeC->getPt();
      nodeC->Ptreset();
      pi = params.getPi();
 
    }
    //-- v29 end --//

    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);

    
    //-- v25 end --//




    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }



    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
 

    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

   
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    


    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    //nodeZ->findRootSites();   // later     
    
    // 1'
    //if(nodeC->getRoot())      // later
    //  nodeC->findLinkedSites();  // later
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ);   // later


    nodeZ->CalSubTreeProb(params);

    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
   


    //-- v25 end --//





    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
      

   

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++){
 
	inttmp = which_halfprop(oldPmat[i]);
	if(inttmp != -1)
	  SeqPold[i] = chars[inttmp];
	else
	  SeqPold[i] = chars[rand.rwunif(oldPmat[i])];
      }
      
    


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	
	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++){
	  inttmp = which_halfprop(Qmat[i]);
	  if(inttmp != -1)
	    SeqQ[i] = chars[inttmp];
	  else
	    SeqQ[i] = chars[rand.rwunif(Qmat[i])];
        }
	

     
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);
	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }
      //-- v29 end --//
      
      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
  

      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }




 

    //-- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    //nodeA->findRootSites();
    //nodeB->findRootSites();
    nodeZ->findRootSites();   // later     
    
    // 1'
    if(nodeC->getRoot())      // later
      nodeC->findLinkedSites();  // later
    
    //3
    //nodeA->CalSubTreeProb(params);
    //nodeA->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;

    nodeZ->CalloglikeliofRootSites(params);
    UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeC);   // later
    //-- v25 end --//
 
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//

    //       cout << "caseI " << endl;
    
    //-- v25 start --//
    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
	
    Pt = nodeZ->getPt();
    pi = params.getPi(); 
	


    oldPmat.resize(0);
    nodeZ->getProbFromSubTreeProb(oldPmat);


    //-- v29 start --//
    if(nodeC->getnumber() >= numLeaves){

      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);
    }
    //-- v29 end --//

    nodeZ->FinishForCalSubTreeProbHere();
    //-- v25 end --//
 


    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = rand.runif()*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //FixHMG start
    O_seqlenZ = nodeZ->getSeqLen();

    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    

    //--- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();         
    nodeB->findRootSites(); 
    //nodeC->findRootSites();  // later    
    
    // 1'
    if(nodeA->getRoot())   
      nodeA->findLinkedSites();
    
    // 2
    //nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    //UpdateAllinfoToRoot(params, nodeZ);   // later



    nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
    nodeZ->CalSubTreeProbHere();
	
    Pmat.resize(0);
    nodeZ->getProbFromSubTreeProb(Pmat);
	
    nodeZ->FinishForCalSubTreeProbHere();






    //--- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
      


      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(oldPmat[i]);
	if(inttmp != -1)
	  SeqPold[i] = chars[inttmp];
	else
	  SeqPold[i] = chars[rand.rwunif(oldPmat[i])];
      }
      


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++){
	  inttmp = which_halfprop(Qmat[i]);
	  if(inttmp != -1)
	    SeqQ[i] = chars[inttmp];
	  else
	    SeqQ[i] = chars[rand.rwunif(Qmat[i])];
        }
	
	  
      }else{


     	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/
	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    // Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//







      }
      //-- v29 end --//

 

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
      


      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }


 
       
    //--- v25 start --//
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    //nodeZ->findRootSites();         
    //nodeB->findRootSites(); 
    nodeC->findRootSites();  // later    
    
    // 1'
    //if(nodeA->getRoot())   
    //  nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
    
    //3      
    //nodeB->CalSubTreeProb(params);
    //nodeB->CalloglikeliofRootSitesOrReuse(params);
    //UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ);   // later
    //--- v25 end --//
 
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    



  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl - N_psl) << endl;



  Pt.resize(0);
  pi.resize(0);
  oldPmat.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  SeqP.resize(0);
  SeqPold.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0);
  delete oldIDH;

  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 
//-- v34 end --//








//-- v23 start --//
void Edge::setNewHMG(){

  //cout << "In setNewHMG edge number : " << getnumber() << endl;
  onLine = true;
  HMG_v2.resize(0);
  HMG_v2 = IDH[current]->getHMG(IDH[current]->getNumE());
  HMG_v2.pop_back();

}
//-- v23 end --//

//-- v23 start --//
void Edge::reSetNewHMG(){

  onLine = false;
  HMG_v2.resize(0);
}
//-- v23 end --//





//-- v29 start --//
void Node::CalPt(double br, Parameters &params){


  //cout << "In ReadyForCalSubTreeProbHere " << endl;
  //cout << "node number " << getnumber() << endl;


  //int k;
  //Edge* pEdge;
  // set onLine
  //onLine = true;


  // set children index
  //child_v2.resize(0);
  
  //for(k = 0; k < numEdges; k++){
  //  if(getEdge(k)->getnumber() != EdgeNum)
  //    child_v2.push_back(k);
  //}
  
  //if(child_v2.size() != 2)
  //  cout << "ERROR in ReadyForCalSubTreeProbHere! Child_v2 should have size 2. " << endl;

  //cout << "child_v2 " << endl;
  //print_veci(child_v2);
  //cout << "br : " << br << endl;


  // calculate transition prob
  Pt.resize(0);

  vector<double> Qtmp(0), pi(0);
  double mu, kappa, piA, piC, piG, piT, piR, piY, pi_j, bold_pi_j;
  double tmp;
  int child, parent; 

  pi = params.getPi();  
  piA = pi[0];
  piC = pi[1];
  piG = pi[2];
  piT = pi[3];
  piR=piA+piG;
  piY=piC+piT;

  kappa = params.getKappa();
  mu = 1/(2*(kappa*(piA*piG + piC*piT) + piR*piY));



  for(parent = 1; parent <= 8; parent = parent*2){
    
    for(child = 1; child <= 8 ; child = child*2){

      if(child==1){ // A
	pi_j=piA;
	bold_pi_j=piR;
      }else if(child==2){ // C
	pi_j=piC;
	bold_pi_j=piY;
      }else if(child==4){// G
	pi_j=piG;
	bold_pi_j=piR;
      }else if(child==8){// T
	pi_j=piT;
	bold_pi_j=piY;
      }

      double A=1+bold_pi_j*(kappa-1);

      if(parent==child){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(bold_pi_j-pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)+exp(c-a)));
	
      }else if((parent==1 && child==4)||(parent==4 && child==1)||(parent==2 &&
								  child==8)||(parent==8 && child==2)){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)-exp(c-a)));
	
      }else{
	tmp=exp(log(pi_j)+log(1-1/exp(mu*br)));
      }

      if(tmp>1)
	tmp=1;
      else if(tmp<0)
	tmp=0;

      Qtmp.push_back(tmp);

    }


    Pt.push_back(Qtmp);
    Qtmp.resize(0);
    
  }

  Qtmp.resize(0);
  pi.resize(0);

  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}


  // Check go more or not
  //if(!getRoot()){
    

  //pEdge = getEdge(getparentIndex());
    //cout << "go more pEdge number : " << pEdge->getnumber() << endl;
    //cout << "pEdge->getStart() number : " << pEdge->getStart()->getnumber() << endl;
    //pEdge->setNewHMG();
    //pEdge->getStart()->ReadyForCalSubTreeProbHere(pEdge->getnumber(), pEdge->getEdgeLen(), params);
  //}
  
  
}
//-- v29 end --//





//-- v23 start --//
void Node::ReadyForCalSubTreeProbHere(int EdgeNum, double br, Parameters &params){


  //cout << "In ReadyForCalSubTreeProbHere " << endl;
  //cout << "node number " << getnumber() << endl;


  int k;
  Edge* pEdge;
  // set onLine
  onLine = true;


  // set children index
  child_v2.resize(0);
  
  for(k = 0; k < numEdges; k++){
    if(getEdge(k)->getnumber() != EdgeNum)
      child_v2.push_back(k);
  }
  
  if(child_v2.size() != 2)
    cout << "ERROR in ReadyForCalSubTreeProbHere! Child_v2 should have size 2. " << endl;

  //cout << "child_v2 " << endl;
  //print_veci(child_v2);
  //cout << "br : " << br << endl;


  // calculate transition prob
  Pt.resize(0);

  vector<double> Qtmp(0), pi(0);
  double mu, kappa, piA, piC, piG, piT, piR, piY, pi_j, bold_pi_j;
  double tmp;
  int child, parent; 

  pi = params.getPi();  
  piA = pi[0];
  piC = pi[1];
  piG = pi[2];
  piT = pi[3];
  piR=piA+piG;
  piY=piC+piT;

  kappa = params.getKappa();
  mu = 1/(2*(kappa*(piA*piG + piC*piT) + piR*piY));



  for(parent = 1; parent <= 8; parent = parent*2){
    
    for(child = 1; child <= 8 ; child = child*2){

      if(child==1){ // A
	pi_j=piA;
	bold_pi_j=piR;
      }else if(child==2){ // C
	pi_j=piC;
	bold_pi_j=piY;
      }else if(child==4){// G
	pi_j=piG;
	bold_pi_j=piR;
      }else if(child==8){// T
	pi_j=piT;
	bold_pi_j=piY;
      }

      double A=1+bold_pi_j*(kappa-1);

      if(parent==child){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(bold_pi_j-pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)+exp(c-a)));
	
      }else if((parent==1 && child==4)||(parent==4 && child==1)||(parent==2 &&
								  child==8)||(parent==8 && child==2)){
	double a=log(pi_j);
	double b=log(pi_j)+log(1/bold_pi_j-1)-mu*br;
	double c=log(pi_j)-log(bold_pi_j)-mu*br*A;
	tmp=exp(a+log(1+exp(b-a)-exp(c-a)));
	
      }else{
	tmp=exp(log(pi_j)+log(1-1/exp(mu*br)));
      }

      if(tmp>1)
	tmp=1;
      else if(tmp<0)
	tmp=0;

      Qtmp.push_back(tmp);

    }


    Pt.push_back(Qtmp);
    Qtmp.resize(0);
    
  }

  Qtmp.resize(0);
  pi.resize(0);

  //cout << "Pt " << endl;
  //for(int i = 0; i<Pt.size(); i++){
  //  for(int j=0; j<Pt[i].size(); j++)
  //    cout << Pt[i][j] << " " ;
  //  cout << endl;
  //}


  // Check go more or not
  if(!getRoot()){
    

    pEdge = getEdge(getparentIndex());
    //cout << "go more pEdge number : " << pEdge->getnumber() << endl;
    //cout << "pEdge->getStart() number : " << pEdge->getStart()->getnumber() << endl;
    pEdge->setNewHMG();
    pEdge->getStart()->ReadyForCalSubTreeProbHere(pEdge->getnumber(), pEdge->getEdgeLen(), params);
  }
  
  
}
//-- v23 end --//


//-- v23 start --//
void Node::FinishForCalSubTreeProbHere(){

  Edge* pEdge;
  onLine = false;
  child_v2.resize(0);
  Pt.resize(0);
  subtreeprob_v2.resize(0);  

  if(!getRoot()){
    pEdge = getEdge(getparentIndex());
    pEdge->reSetNewHMG();
    pEdge->getStart()->FinishForCalSubTreeProbHere();
  }

  
}
//-- v23 end --//




//-- v23 start --//
void Node::getProbFromSubTreeProb(vector<vector<double> >  &prob){

  prob.resize(0);

  int i, j, size;
  double sum;
  vector<vector<double> >  Gmat;
 
  


  if(onLine)
    Gmat = subtreeprob_v2;
  else
    Gmat = subtreeprob[current];


  size = Gmat[1].size();
  prob.resize(size);

  for(i = 0; i < size; i++){
    prob[i].resize(numLetters);
    sum = 0;
    for(j = 0; j < numLetters; j++)
      sum += Gmat[j][i];
    for(j = 0; j < numLetters; j++)
      prob[i][j] = Gmat[j][i]/sum;
  }
	
  Gmat.resize(0);


}
//-- v23 end ---//


//-- v23 start --//
void Node::getProbFromSubTreeProb(vector<double>  &prob, int posi){

  prob.resize(0);

  int i, j;
  double sum;


  prob.resize(numLetters);
  i = posi;
  sum = 0;

  if(onLine){
    for(j = 0; j < numLetters; j++)
      sum += subtreeprob_v2[j][i];
    for(j = 0; j < numLetters; j++)
      prob[j] = subtreeprob_v2[j][i]/sum;
  }else{
    for(j = 0; j < numLetters; j++)
      sum += subtreeprob[current][j][i];
    for(j = 0; j < numLetters; j++)
      prob[j] = subtreeprob[current][j][i]/sum;
  }


}
//-- v23 end ---//


//-- v23 start --//
void Node::CalSubTreeProbHere(){


  //cout << "In CalSubTreeProbHere node number : " << getnumber() << endl;


  int b, h, i;
  double tmpres0, tmpres1;
  Node* nodeL;
  Node* nodeR;
  Edge* edgeL;
  Edge* edgeR;

  //-- v32 start --//
  double maxVal;
  bool done;
  //-- v32 end --//
  


  if(getLeaf()){
    cout << "ERROR in CalSubTreeProbHere! It shouldn't be called from Leaf. " << endl;
  }else{

    edgeL = getEdge(child_v2[0]);
    //cout << "edgeL : " << edgeL->getnumber() << endl;
    if(edgeL->getOnLine()){
      nodeL = getEdge(child_v2[0])->getStart();
      //cout << "edgeL onLine nodeL " << nodeL->getnumber() << endl;
      nodeL->CalSubTreeProbHere();
    }else{
      nodeL = getEdge(child_v2[0])->getEnd();
      //cout << "edgeL Not onLine nodeL " << nodeL->getnumber() << endl;
    }

    
    edgeR = getEdge(child_v2[1]);
    //cout << "edgeR : " << edgeR->getnumber() << endl;
    if(edgeR->getOnLine()){
      nodeR = getEdge(child_v2[1])->getStart();
      //cout << "edgeR onLine nodeR " << nodeR->getnumber() << endl;
      nodeR->CalSubTreeProbHere();
    }else{
      nodeR = getEdge(child_v2[1])->getEnd();
      //cout << "edgeR Not onLine nodeR " << nodeR->getnumber() << endl;
    }
    
    subtreeprob_v2.resize(numLetters);
    for( b = 0; b < numLetters; b++)
      subtreeprob_v2[b].resize(0);
    


    //cout << "nodeL " << nodeL->getnumber() << " nodeR " << nodeR->getnumber() << endl;
    //cout << "nodeL " << nodeL->getOnLine() << " nodeR " << nodeR->getOnLine() << endl;
    if((nodeL->getOnLine()) & (!nodeR->getOnLine())){

      //cout << "A1" << endl;
      // nodeL : onLine
      // nodeR : not onLine

      for(h = 0; h < seqLen[current]; h++){
	maxVal = 0;

	for(b = 0; b < numLetters; b++){

	  tmpres0 = 0;

	  for(i = 0; i < numLetters; i++){

	    tmpres1 = Pt[b][i];
	    
	    if(edgeL->getHMG_v2(h)>=0)
	      tmpres1 *= nodeL->getsubtreeprob_v2(i, edgeL->getHMG_v2(h));

	    if(edgeR->getHMG(h)>=0)
	      tmpres1 *= nodeR->getsubtreeprob(i, edgeR->getHMG(h));

	    tmpres0 += tmpres1;
	  }
	  
	  subtreeprob_v2[b].push_back(tmpres0);
	  //-- v32 start --//
	  if(subtreeprob_v2[b][h] > maxVal)
	    maxVal = subtreeprob_v2[b][h];
	  //-- v32 end --//
	}
	//-- v32 start --//
	for( b = 0; b < numLetters; b++)
	  subtreeprob_v2[b][h] /= maxVal;
	//-- v32 end --//
      }

    }else if((!nodeL->getOnLine()) & (nodeR->getOnLine())){
      // nodeL : not onLine
      // nodeR : onLine

      for(h = 0; h < seqLen[current]; h++){

	maxVal = 0;
	for(b = 0; b < numLetters; b++){

	  tmpres0 = 0;

	  for(i = 0; i < numLetters; i++){

	    tmpres1 = Pt[b][i];
	    
	    if(edgeL->getHMG(h)>=0)
	      tmpres1 *= nodeL->getsubtreeprob(i, edgeL->getHMG(h));

	    if(edgeR->getHMG_v2(h)>=0)
	      tmpres1 *= nodeR->getsubtreeprob_v2(i, edgeR->getHMG_v2(h));

	    tmpres0 += tmpres1;
	  }
	  
	  subtreeprob_v2[b].push_back(tmpres0);
	  //-- v32 start --//
	  if(subtreeprob_v2[b][h] > maxVal)
	    maxVal = subtreeprob_v2[b][h];
	  //-- v32 end --//
	}
	//-- v32 start --//
	for( b = 0; b < numLetters; b++)
	  subtreeprob_v2[b][h] /= maxVal;
	//-- v32 end --//
      }

    }else if((!nodeL->getOnLine()) & (!nodeR->getOnLine())){
      // nodeL : not onLine
      // nodeR : not onLine

      for(h = 0; h < seqLen[current]; h++){

	maxVal = 0;
	for(b = 0; b < numLetters; b++){

	  tmpres0 = 0;

	  for(i = 0; i < numLetters; i++){

	    tmpres1 = Pt[b][i];
	    
	    if(edgeL->getHMG(h)>=0)
	      tmpres1 *= nodeL->getsubtreeprob(i, edgeL->getHMG(h));

	    if(edgeR->getHMG(h)>=0)
	      tmpres1 *= nodeR->getsubtreeprob(i, edgeR->getHMG(h));

	    tmpres0 += tmpres1;
	  }
	  
	  subtreeprob_v2[b].push_back(tmpres0);
	  //-- v32 start --//
	  if(subtreeprob_v2[b][h] > maxVal)
	    maxVal = subtreeprob_v2[b][h];
	  //-- v32 end --//
	}
	//-- v32 start --//
	for( b = 0; b < numLetters; b++)
	  subtreeprob_v2[b][h] /= maxVal;
	//-- v32 end --//
      }
    }else{
      cout << "ERROR in CalSubTreeProbHere! This case never happen! " << endl;
    }
  }


  //for(b=0; b<4; b++){
  //  for(i = 0; i < getSeqLen(); i++)
  //    cout << subtreeprob_v2[b][i] << " " ;
  //  cout << endl;
  // }
  //cout << endl;

  //cout << "done" << endl;

}
//-- v23 end --//



double Tree::SPRonSubTreeWithFixedHMG(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c2) {


  //cout << "SPRonSubTreeWithFixedHMG" << endl;


  int i, j;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  vector<int> oldHMG(0);
  vector<int> newHMG(0);
  vector<int> tmpHMG1(0);
  vector<int> tmpHMG2(0);
  vector<int> tmpHMG3(0);
  vector<int> oldEdge0HMG(0);
  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  
  //-- v22 start --//
  double fixProb = 0.85;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  vector<int> fixedHMG(0);
  //-- v22 end --//



  InDelHistory* oldIDH = new InDelHistory();
  //vector<int> newEdge0HMG(0);
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  
  // Heeee
  vector<vector<int> > delBasePosi(0);
  delBasePosi.resize(0); 
  vector<int> delBasePosi_in(0);
  delBasePosi_in.resize(0);
  bool connect;



  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  // Pick M on edge0, which is the end point of window
  //double posiM = rand.runif()*(edge0->getEdgeLen()); 

  //cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
  

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 



  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];


  //cout << "selectedposi : " << selectedposi << "TargetEdgeNum : " << TargetEdgeNum << endl;


  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "AAA " << endl;
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMG(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, c2);
    //AP = SPRonSingleEdgeAsPartOfSPRonSubTree(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum);
    //AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiM);

  }else{                  // else if edge which is connected to Z is selected

    //cout << "BBB " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);
    //cout << "edgeT number " << edgeT->getnumber() << endl;


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }

    //cout << "posiNewZ : " << posiNewZ << endl;

 
    lenXt = edgeT->getEdgeLen();

    O_IDHlike = edge0->likeliHistory(params);



    if(nodeZ == edge0->getStart()){
      (*oldIDH) = (*edge0->getIDH());
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
    }else{
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
      (*oldIDH) = (*edge0->getIDH());
      edge0->ReverseEdge();
    }      


    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){


      //cout << "caseIa " << endl;

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();



      //outfile << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();




      //cout << "1" << endl;

      //FixHMG
      O_seqlenZ = nodeZ->getSeqLen();
      oldHMG.resize(O_seqlenZ);
      for(i = 0; i < O_seqlenZ; i++)
	oldHMG[i] = -1;
      
      //cout << "2" << endl;   
     
      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
    

      //FixHMG
      tmpHMG1.resize(0);
      tmpHMG1 = edgeY->getHMG();  


      //cout << "3" << endl;
  
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));

      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      /*
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
      */


      //cout << "HAHAHA " << endl;
      //printTree(outfile);


      //FixHMG
      // 1. Get homology structure between oldZ and newZ //

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);
      
      //cout << "4" << endl;


      //Heejung Shim

      TempEdge = edgeY->getParentEdge();
      //outfile << "4.0 " << endl;
      T_seqlenZ = (TempEdge->getHMG()).size();
      //vector<int> tmp;
      //outfile << "4.0.1 " << endl;
      //tmp.resize(0);
      //outfile << "4.0.2 " << endl;
      //tmp = TempEdge->getHMG();
      
      //outfile << "hmglength " << TempEdge->getStart()->getnumber() << endl;
      //for(i =0; i < TempEdge->getStart()->getSeqLen(); i++)
      //	tmp.push_back(TempEdge->getHMG(i));
      //T_seqlenZ = tmp.size();
      //T_seqlenZ = 1;
      //cout << "4.1 T_seqlenZ :" << T_seqlenZ << endl;

      for(i = 0; i < T_seqlenZ; i++){
	//cout << "i : " << i << endl;
	if(TempEdge->getHMG()[i] >= 0)
	  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	else
	  tmpHMG1.push_back(-1);
      }
      
      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);


      //cout << "5" << endl;


      while(TempEdge->getStart() != nodeZ){

	TempEdge = TempEdge->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }

	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);

      }

      //cout << "6" << endl;

      newHMG = tmpHMG2;
      N_seqlenZ = nodeZ->getSeqLen();
      for(i = 0; i < N_seqlenZ; i++){
	if(newHMG[i] != -1){
	  oldHMG[newHMG[i]] = i;
        }
      }
      //if(newHMG.size() != N_seqlenZ){
      //cout << "ERROR!!!!!! tmpHMG2.size() != N_seqlenZ" << endl;
      //}else{
      //	cout << "oldHMG " << endl;
      // print_veci(oldHMG);
      //cout << "newHMG " << endl;
      //print_veci(newHMG);
      //}	
	
      tmpHMG1.resize(0);
      tmpHMG2.resize(0);

      //cout << "O_seqlenZ : " << O_seqlenZ << " N_seqlenZ : " << N_seqlenZ << endl;
      //cout << "oldHMG " << endl;
      //print_veci(oldHMG);
      //cout << "newHMG " << endl;
      //print_veci(newHMG);
      //cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);


      //cout << "7" << endl;

      // 2. Construct several blocks
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      
      //-- v22 start --//
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      N_psl = 0;
      fixedHMG.resize(0);
      //-- v22 end --//

      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      //cout << "T_seqlenZ : " << T_seqlenZ << endl;
      //cout << "N_seqlenZ : " << N_seqlenZ << endl;
      for(i = 0; i < N_seqlenZ; i++){
	//cout << "i : " << i << endl;
	if(newHMG[i] != -1){
	  
	  //--- v22 start --//
	  //connect = false;
	  //--- v22 end --//
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	    //cout << "j : " << j << endl;
	    if(newHMG[i] == oldEdge0HMG[j]){
	      //--- v22 start ---//
	      //connect = true;
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		fixedHMG.push_back(newHMG[i]);
		//delBasePosi.push_back(delBasePosi_in);
		//delBasePosi_in.resize(0);
		IX++;
		N_psl += logfixProb;
              }else{
		N_psl += logNfixProb;
              }
	      //--- v22 end ---//
	      break;
            }
          }
	  //--- v22 start --//
	  //if(!connect)
	  //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	  //--- v22 end --//
	}
      }
      stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
      //-- v22 start --//
      //delBasePosi.push_back(delBasePosi_in);
      //delBasePosi_in.resize(0);
      //-- v22 end --//
      enPosi.resize(0);

      //cout << "8" << endl;
      //      cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "delBasePosi length : " << delBasePosi.size() << endl;
      //for(i = 0; i < delBasePosi.size(); i++)
      //	print_veci(delBasePosi[i]);
      


      oldEdge0HMG.resize(0);
      // 3. Generate new IDH on Edge0 while keeping the original HMG.      
      if(nodeZ == edge0->getEnd()){
	//cout << "8.1" << endl;
	edge0->changeStartEnd();
	//cout << "8.1.1" << endl;
	//-- v22 start --//
	//N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	//-- v22 end --//

	edge0->calHMG(); 

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();



        //cout << "8.1.2" << endl;
        edge0->ReverseEdge();
	//cout << "8.1.2" << endl;
	oldEdge0HMG = edge0->getHMG();
	//cout << "8.1.3" << endl;
      }else{
	//cout << "8.2" << endl;
	//-- v22 start --//
	//N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	//-- v22 end --//
	//cout << "8.2.1" << endl;
	edge0->calHMG();

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();



	//cout << "8.2.2" << endl;
	edge0->ReverseEdge();
	//cout << "8.2.3" << endl;
	oldEdge0HMG = edge0->getHMG();
	//cout << "8.2.4" << endl;
	edge0->ReverseEdge();
	//cout << "8.2.5" << endl;
      }  


      //cout << "edge0 IDH" << endl;
      //edge0->getIDH()->printIDH(); 
      //cout << "new " << endl;
      //print_veci(oldEdge0HMG);
  


      //cout << "8.3" << endl;
      // 4. Calculate proposal prob for old IDH 
      // 4.1  Construct several blocks and save starting position
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      //-- v22 start --//
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      O_psl = 0;
      //-- v22 end --//
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      for(i = 0; i < O_seqlenZ; i++){
	if(oldHMG[i] != -1){
	  //-- v22 start --//
	  //connect = false;
	  //-- v22 end --//
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	    if(oldHMG[i] == oldEdge0HMG[j]){
	      //-- v22 start --//
	      //connect = true;
	      if(is_element(fixedHMG, i)){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		//delBasePosi.push_back(delBasePosi_in);
		//delBasePosi_in.resize(0);
		IX++;
		O_psl += logfixProb;
              }else{
		O_psl += logNfixProb;
              }
	      //--- v22 end ---//
	      break;
	    }
          }
	  //-- v22 start --// 
	  //if(!connect)
	  //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	  //-- v22 end --//
        }
      }
      stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
      enPosi.resize(0);
      //-- v22 start --//
      //delBasePosi.push_back(delBasePosi_in);
      //delBasePosi_in.resize(0);        
      //-- v22 end --//

      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "delBasePosi length : " << delBasePosi.size() << endl;
      //for(i = 0; i < delBasePosi.size(); i++)
      //	print_veci(delBasePosi[i]);
      
      
      //cout << "9" << endl;

      //-- v22 start --//
      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      //-- v22 end --//


      //      cout << "O_psl " << O_psl << endl;

      //cout << "10" << endl;

      //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 
      //      cout << "caseI " << endl;

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     

      //FixHMG
      O_seqlenZ = nodeZ->getSeqLen();
      oldHMG.resize(O_seqlenZ);
      for(i = 0; i < O_seqlenZ; i++)
	oldHMG[i] = -1;
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //FixHMG
      tmpHMG1.resize(0);
      tmpHMG1 = edgeY->getHMG();  


      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      /*
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
      */
  


      //FixHMG
      // 1. Get homology structure between oldZ and newZ //

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);
      

      TempEdge = edgeY->getParentEdge();
      T_seqlenZ = (TempEdge->getHMG()).size();
      for(i = 0; i < T_seqlenZ; i++){
	if(TempEdge->getHMG()[i] >= 0)
	  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	else
	  tmpHMG1.push_back(-1);
      }

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);


      while(TempEdge->getStart() != nodeZ){

	TempEdge = TempEdge->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);

      }

      newHMG = tmpHMG2;
      N_seqlenZ = nodeZ->getSeqLen();
      for(i = 0; i < N_seqlenZ; i++){
	if(newHMG[i] != -1){
	  oldHMG[newHMG[i]] = i;
        }
      }
      //if(newHMG.size() != N_seqlenZ){
      //	cout << "ERROR!!!!!! tmpHMG2.size() != N_seqlenZ" << endl;
      // }else{
      //cout << "oldHMG " << endl;
      //print_veci(oldHMG);
      //cout << "newHMG " << endl;
      //print_veci(newHMG);
      //}	
	
      tmpHMG1.resize(0);
      tmpHMG2.resize(0);

      // 2. Construct several blocks
      /*
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);      
      enPosi.push_back(0);
      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      for(i = 0; i < N_seqlenZ; i++){
	if(newHMG[i] != -1){
	  for(j = enPosi[enPosi.size()-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	    if(newHMG[i] == oldEdge0HMG[j]){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
              IX++;
            }
          }
        }
      }
      stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
      enPosi.resize(0);

      //      cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);


      oldEdge0HMG.resize(0);
      // 3. Generate new IDH on Edge0 while keeping the original HMG.      
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	edge0->calHMG();     
	//edge0->getIDH()->printIDH();
        edge0->ReverseEdge();
	oldEdge0HMG = edge0->getHMG();
      }else{
	N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	edge0->calHMG();
	//edge0->getIDH()->printIDH();
	edge0->ReverseEdge();
	oldEdge0HMG = edge0->getHMG();
	edge0->ReverseEdge();
      }  

      // 4. Calculate proposal prob for old IDH 
      // 4.1  Construct several blocks and save starting position
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      for(i = 0; i < O_seqlenZ; i++){
	if(oldHMG[i] != -1){
	  for(j = enPosi[enPosi.size()-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	    if(oldHMG[i] == oldEdge0HMG[j]){
	      stPosi.push_back(i+1);
	      enPosi.push_back(j+1);
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
              IX++;
            }
          }
        }
      }
      stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
      enPosi.resize(0);


      O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);

      */




      // 2. Construct several blocks
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      
      //-- v22 start --//
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      N_psl = 0;
      fixedHMG.resize(0);
      //-- v22 end --//



      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      //cout << "T_seqlenZ : " << T_seqlenZ << endl;
      //cout << "N_seqlenZ : " << N_seqlenZ << endl;
      for(i = 0; i < N_seqlenZ; i++){
	//cout << "i : " << i << endl;
	if(newHMG[i] != -1){
	  //--- v22 start --//
	  //connect = false;
	  //--- v22 end --//
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	    //cout << "j : " << j << endl;
	    if(newHMG[i] == oldEdge0HMG[j]){
	      //--- v22 start ---//
	      //connect = true;
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		fixedHMG.push_back(newHMG[i]);
		//delBasePosi.push_back(delBasePosi_in);
		//delBasePosi_in.resize(0);
		IX++;
		N_psl += logfixProb;
              }else{
		N_psl += logNfixProb;
              }	
	      //--- v22 end ---//
	      break;
            }
          }
	  //--- v22 start --//
	  //if(!connect)
	  //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	  //--- v22 end --//
	}
      }
      stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]); 
      //-- v22 start --//
      //delBasePosi.push_back(delBasePosi_in);
      //delBasePosi_in.resize(0);      
      //-- v22 end --//
      enPosi.resize(0);

      //cout << "8" << endl;
      //      cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "delBasePosi length : " << delBasePosi.size() << endl;
      //for(i = 0; i < delBasePosi.size(); i++)
      //	print_veci(delBasePosi[i]);
      


      oldEdge0HMG.resize(0);
      // 3. Generate new IDH on Edge0 while keeping the original HMG.      
      if(nodeZ == edge0->getEnd()){
	//cout << "8.1" << endl;
	edge0->changeStartEnd();
	//cout << "8.1.1" << endl;
	//-- v22 start --//
	//N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	//-- v22 end --//
	edge0->calHMG(); 

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();



        //cout << "8.1.2" << endl;
        edge0->ReverseEdge();
	//cout << "8.1.2" << endl;
	oldEdge0HMG = edge0->getHMG();
	//cout << "8.1.3" << endl;
      }else{
	//cout << "8.2" << endl;
	//-- v22 start --//
	//N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	//-- v22 end --//

	//cout << "8.2.1" << endl;
	edge0->calHMG();

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();



	//cout << "8.2.2" << endl;
	edge0->ReverseEdge();
	//cout << "8.2.3" << endl;
	oldEdge0HMG = edge0->getHMG();
	//cout << "8.2.4" << endl;
	edge0->ReverseEdge();
	//cout << "8.2.5" << endl;
      }  


      //      cout << "edge0 IDH" << endl;
      //edge0->getIDH()->printIDH(); 
      //cout << "new " << endl;
      //print_veci(oldEdge0HMG);
  


      //cout << "8.3" << endl;
      // 4. Calculate proposal prob for old IDH 
      // 4.1  Construct several blocks and save starting position
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      //-- v22 start --//
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      O_psl = 0;
      //-- v22 end --//
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      for(i = 0; i < O_seqlenZ; i++){
	if(oldHMG[i] != -1){
	  //-- v22 start --//
	  //connect = false;
	  //-- v22 end --//
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	    //for(j = 0; j < T_seqlenZ; j++){
	    if(oldHMG[i] == oldEdge0HMG[j]){
	      //-- v22 start --//
	      //connect = true;
	      if(is_element(fixedHMG, i)){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
		//delBasePosi.push_back(delBasePosi_in);
		//delBasePosi_in.resize(0);
		O_psl += logfixProb;
              }else{
		O_psl += logNfixProb;
              }
	      //--- v22 end ---//
	      break;
            }
          }
	  //-- v22 start --//
	  //if(!connect)
	  //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	  //-- v22 end --//
        }
      }
      stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
      enPosi.resize(0);
      //-- v22 start --//
      //delBasePosi.push_back(delBasePosi_in);
      //delBasePosi_in.resize(0);        
      //-- v22 end --//


      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "delBasePosi length : " << delBasePosi.size() << endl;
      //for(i = 0; i < delBasePosi.size(); i++)
      //	print_veci(delBasePosi[i]);
      
      
      //cout << "9" << endl;

      //-- v22 start --//
      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);


      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      //-- v22 end --//     








      //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT


	//	cout << "caseIII " << endl;
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();


	//FixHMG
	O_seqlenZ = nodeZ->getSeqLen();
	oldHMG.resize(O_seqlenZ);
	for(i = 0; i < O_seqlenZ; i++)
	  oldHMG[i] = -1;
      
	//FixHMG
	tmpHMG1.resize(0);
	tmpHMG1 = edgeY->getHMG();  
	


	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	/*
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  edge0->runEdge(rand,params);
	  edge0->calHMG();     
	  edge0->ReverseEdge();
	}else{
	  edge0->runEdge(rand,params);
	  edge0->calHMG();
	}    
        */


	//FixHMG
	// 1. Get homology structure between oldZ and newZ //
	
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);
	
	
	TempEdge = edgeY->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);
	

	while(TempEdge->getStart() != nodeZ){

	  TempEdge = TempEdge->getParentEdge();
	  T_seqlenZ = (TempEdge->getHMG()).size();
	  for(i = 0; i < T_seqlenZ; i++){
	    if(TempEdge->getHMG()[i] >= 0)
	      tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	    else
	      tmpHMG1.push_back(-1);
          }
	  tmpHMG2 = tmpHMG1;
	  tmpHMG1.resize(0);
	  
	}
	
	newHMG = tmpHMG2;
	N_seqlenZ = nodeZ->getSeqLen();
	for(i = 0; i < N_seqlenZ; i++){
	  if(newHMG[i] != -1){
	    oldHMG[newHMG[i]] = i;
	  }
	}
	//	if(newHMG.size() != N_seqlenZ){
	//cout << "ERROR!!!!!! tmpHMG2.size() != N_seqlenZ" << endl;
	//}else{
	// cout << "oldHMG " << endl;
	//print_veci(oldHMG);
	//cout << "newHMG " << endl;
	//print_veci(newHMG);
	//}	
	
	tmpHMG1.resize(0);
	tmpHMG2.resize(0);
	
	// 2. Construct several blocks
	/*
	stSeqLen.resize(0);
	enSeqLen.resize(0);
	stPosi.resize(0);
	enPosi.resize(0);
	stPosi.push_back(0);
	enPosi.push_back(0);
	IX=1;
	T_seqlenZ = oldEdge0HMG.size();
	for(i = 0; i < N_seqlenZ; i++){
	  if(newHMG[i] != -1){
	    for(j = enPosi[enPosi.size()-1]; j < T_seqlenZ; j++){
	    //for(j = 0; j < T_seqlenZ; j++){
	      if(newHMG[i] == oldEdge0HMG[j]){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	    }
	  }
	}
	stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	enPosi.resize(0);


	//	cout << "oldEdge0HMG " << endl;
	//print_veci(oldEdge0HMG);
	//cout << "stSeqLen" << endl;
	//print_veci(stSeqLen);
	//cout << "enSeqLen" << endl;
	//print_veci(enSeqLen);
	//cout << "stPosi" << endl;
	//print_veci(stPosi);
      
	
	oldEdge0HMG.resize(0);
	// 3. Generate new IDH on Edge0 while keeping the original HMG.      
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	  edge0->calHMG(); 
	  //edge0->getIDH()->printIDH();
	  edge0->ReverseEdge();
	  oldEdge0HMG = edge0->getHMG();
	}else{
	  N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	  edge0->calHMG();
	  //edge0->getIDH()->printIDH();
	  edge0->ReverseEdge();
	  oldEdge0HMG = edge0->getHMG();
	  edge0->ReverseEdge();
	}  
	
	// 4. Calculate proposal prob for old IDH 
	// 4.1  Construct several blocks and save starting position
	stSeqLen.resize(0);
	enSeqLen.resize(0);
	stPosi.resize(0);
	enPosi.resize(0);
	stPosi.push_back(0);
	enPosi.push_back(0);
	IX=1;
	T_seqlenZ = oldEdge0HMG.size();
	for(i = 0; i < O_seqlenZ; i++){
	  if(oldHMG[i] != -1){
	    for(j = enPosi[enPosi.size()-1]; j < T_seqlenZ; j++){
	    //for(j = 0; j < T_seqlenZ; j++){
	      if(oldHMG[i] == oldEdge0HMG[j]){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	    }
	  }
	}
	stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	enPosi.resize(0);
	
	
	O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
	

	*/


	// 2. Construct several blocks
	stSeqLen.resize(0);
	enSeqLen.resize(0);
	stPosi.resize(0);
	enPosi.resize(0);
	stPosi.push_back(0);
	enPosi.push_back(0);
	//-- v22 start --//
	//delBasePosi.resize(0);
	//delBasePosi_in.resize(0);
	N_psl = 0;
	fixedHMG.resize(0);
	//-- v22 end --//
	
	IX=1;
	T_seqlenZ = oldEdge0HMG.size();
	//cout << "T_seqlenZ : " << T_seqlenZ << endl;
	//cout << "N_seqlenZ : " << N_seqlenZ << endl;
	for(i = 0; i < N_seqlenZ; i++){
	  //cout << "i : " << i << endl;
	  if(newHMG[i] != -1){
	    //--- v22 start --//
	    //connect = false;
	    //--- v22 end --//
	    for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	      //for(j = 0; j < T_seqlenZ; j++){
	      //cout << "j : " << j << endl;
	      if(newHMG[i] == oldEdge0HMG[j]){
		//--- v22 start ---//
		//connect = true;
		//cout << "B" << endl;
		if(rand.runif()- fixProb < 0){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  fixedHMG.push_back(newHMG[i]);
		  // Heeee
		  //delBasePosi.push_back(delBasePosi_in);
		  //delBasePosi_in.resize(0);
		  IX++;
		  N_psl += logfixProb;
		}else{
		  N_psl += logNfixProb;
		}
		//--- v22 end ---//
		break;
	      }
	    }
	    //--- v22 start ---//
	    //if(!connect)
	    //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	    //--- v22 end ---//
	  }
	}
	stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
	//-- v22 start --//
	//delBasePosi.push_back(delBasePosi_in);
	//delBasePosi_in.resize(0);    
	//-- v22 end --//
	enPosi.resize(0);
	
	//cout << "8" << endl;
	//      cout << "oldEdge0HMG " << endl;
	//print_veci(oldEdge0HMG);
	//cout << "stSeqLen" << endl;
	//print_veci(stSeqLen);
	//cout << "enSeqLen" << endl;
	//print_veci(enSeqLen);
	//cout << "stPosi" << endl;
	//print_veci(stPosi);
	//cout << "delBasePosi length : " << delBasePosi.size() << endl;
	//for(i = 0; i < delBasePosi.size(); i++)
	//	print_veci(delBasePosi[i]);
	


	oldEdge0HMG.resize(0);
	// 3. Generate new IDH on Edge0 while keeping the original HMG.      
	if(nodeZ == edge0->getEnd()){
	  //cout << "8.1" << endl;
	  edge0->changeStartEnd();
	  //cout << "8.1.1" << endl;

	  //-- v22 start --//
	  //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	  N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	  //-- v22 end --//

	  edge0->calHMG(); 
	  
	  //cout << "N_psl " << N_psl << endl;
	  //edge0->getIDH()->printIDH();
	  


	  //cout << "8.1.2" << endl;
	  edge0->ReverseEdge();
	  //cout << "8.1.2" << endl;
	  oldEdge0HMG = edge0->getHMG();
	  //cout << "8.1.3" << endl;
	}else{
	  //cout << "8.2" << endl;
	  //-- v22 start --//
	  //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	  N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	  //-- v22 end --//



	  //cout << "8.2.1" << endl;
	  edge0->calHMG();
	  
	  //cout << "N_psl " << N_psl << endl;
	  //edge0->getIDH()->printIDH();
	  


	  //cout << "8.2.2" << endl;
	  edge0->ReverseEdge();
	  //cout << "8.2.3" << endl;
	  oldEdge0HMG = edge0->getHMG();
	  //cout << "8.2.4" << endl;
	  edge0->ReverseEdge();
	  //cout << "8.2.5" << endl;
	}  


	//      cout << "edge0 IDH" << endl;
	//edge0->getIDH()->printIDH(); 
	//cout << "new " << endl;
	//print_veci(oldEdge0HMG);
	


	//cout << "8.3" << endl;
	// 4. Calculate proposal prob for old IDH 
	// 4.1  Construct several blocks and save starting position
	stSeqLen.resize(0);
	enSeqLen.resize(0);
	stPosi.resize(0);
	enPosi.resize(0);
	//-- v22 start --//
	//delBasePosi.resize(0);
	//delBasePosi_in.resize(0);
	O_psl = 0;
	//-- v22 end --//
	stPosi.push_back(0);
	enPosi.push_back(0);
	IX=1;
	T_seqlenZ = oldEdge0HMG.size();
	for(i = 0; i < O_seqlenZ; i++){
	  if(oldHMG[i] != -1){
	    //-- v22 start --//
	    //connect = false;
	    //-- v22 end --//
	    for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	      //for(j = 0; j < T_seqlenZ; j++){
	      if(oldHMG[i] == oldEdge0HMG[j]){
		//-- v22 start --//
		//connect = true;
		if(is_element(fixedHMG, i)){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  IX++;
		  //delBasePosi.push_back(delBasePosi_in);
		  //delBasePosi_in.resize(0);
		  O_psl += logfixProb;
		}else{
		  O_psl += logNfixProb;
		}
		//--- v22 end ---//
		break;
	      }
	    }
	    //-- v22 start --//
	    //if(!connect)
	    //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	    //-- v22 end --//
	  }
	}
	stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	enPosi.resize(0);
	//-- v22 start --//
	//delBasePosi.push_back(delBasePosi_in);
	//delBasePosi_in.resize(0);        
	//-- v22 end --//


	//cout << "stSeqLen" << endl;
	//print_veci(stSeqLen);
	//cout << "enSeqLen" << endl;
	//print_veci(enSeqLen);
	//cout << "stPosi" << endl;
	//print_veci(stPosi);
	//cout << "delBasePosi length : " << delBasePosi.size() << endl;
	//for(i = 0; i < delBasePosi.size(); i++)
	//	print_veci(delBasePosi[i]);
	
	
	//cout << "9" << endl;

	//-- v22 start --//
	//O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
	O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
	//delBasePosi.resize(0);
	//delBasePosi_in.resize(0);
	//-- v22 end --//




	//	checkTree();


	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z
	  //cout << "caseIV " << endl;

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();


	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();
	  //oldHMG.resize(O_seqlenZ);
	  //for(i = 0; i < O_seqlenZ; i++)
	  //  oldHMG[i] = -1;
	  

	  //FixHMG
	  tmpHMG3.resize(0);
	  tmpHMG3 = edgeX->getHMG();    


	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  /*
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	  */

 
	  //FixHMG
	  // 1. Get homology structure between oldZ and newZ //

	  tmpHMG2.resize(0);
	  tmpHMG2 = edgeT->getHMG();  

	  //tmpHMG1.resize(0);
	  //TempEdge = edgeT->getParentEdge();
	  //T_seqlenZ = (TempEdge->getHMG()).size();
	  //for(i = 0; i < T_seqlenZ; i++){
	  //  if(TempEdge->getHMG()[i] >= 0)
	  //    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  //  else
	  //    tmpHMG1.push_back(-1);
          //}	      
	  //tmpHMG2 = tmpHMG1;
	  //tmpHMG1.resize(0);
	  
	  //TempEdge = edgeT;
	  TempEdge = edgeT->getParentEdge();
	  tmpHMG1.resize(0);

	  while(TempEdge->getEnd() != nodeBend){

	    //TempEdge = TempEdge->getParentEdge();
	    T_seqlenZ = (TempEdge->getHMG()).size();
	    for(i = 0; i < T_seqlenZ; i++){
	      if(TempEdge->getHMG()[i] >= 0)
		tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
              else
		tmpHMG1.push_back(-1);
	    }
	    tmpHMG2 = tmpHMG1;
	    tmpHMG1.resize(0);	    
	    TempEdge = TempEdge->getParentEdge();
	  }

	  
	  T_seqlenZ = tmpHMG3.size();
	  for(i = 0; i < T_seqlenZ; i++){
	    if(tmpHMG3[i] >= 0)
	      tmpHMG1.push_back(tmpHMG2[tmpHMG3[i]]);
	    else
	      tmpHMG1.push_back(-1);
	    }
	  tmpHMG2 = tmpHMG1;
	  tmpHMG1.resize(0);	    

	  //O_seqlenZ = nodeZ->getSeqLen();
	  //oldHMG.resize(O_seqlenZ);
	  //for(i = 0; i < O_seqlenZ; i++)
	  //  oldHMG[i] = -1;
	  


	  oldHMG.resize(0);
	  newHMG.resize(0);

	  oldHMG = tmpHMG2;
	  N_seqlenZ = nodeZ->getSeqLen();
	  newHMG.resize(N_seqlenZ);
	  for(i = 0; i < N_seqlenZ; i++)
	    newHMG[i] = -1;	  
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      newHMG[oldHMG[i]] = i;
	    }
	  }
	  //	  if(oldHMG.size() != O_seqlenZ){
	  //cout << "ERROR!!!!!! tmpHMG2 != O_seqlenZ" << endl;
	  //}else{
	  // cout << "oldHMG " << endl;
	  //  print_veci(oldHMG);
	  //  cout << "newHMG " << endl;
	  //  print_veci(newHMG);
	  //}	
	  
	  tmpHMG1.resize(0);
	  tmpHMG2.resize(0);
	  tmpHMG3.resize(0);

	  // 2. Construct several blocks
	  /*
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < N_seqlenZ; i++){
	    if(newHMG[i] != -1){
	      for(j = enPosi[enPosi.size()-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		if(newHMG[i] == oldEdge0HMG[j]){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  IX++;
		}
	      }
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  enPosi.resize(0);
	  


	  //	  cout << "oldEdge0HMG " << endl;
	  //print_veci(oldEdge0HMG);
	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  
	  

	  
	  oldEdge0HMG.resize(0);
	  // 3. Generate new IDH on Edge0 while keeping the original HMG.      
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    edge0->calHMG();     
	    //edge0->getIDH()->printIDH();
	    edge0->ReverseEdge();
	    oldEdge0HMG = edge0->getHMG();
	  }else{
	    N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    edge0->calHMG();
	    //edge0->getIDH()->printIDH();
	    edge0->ReverseEdge();
	    oldEdge0HMG = edge0->getHMG();
	    edge0->ReverseEdge();
	  }  
	  
	  // 4. Calculate proposal prob for old IDH 
	  // 4.1  Construct several blocks and save starting position
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      for(j = enPosi[enPosi.size()-1]; j < T_seqlenZ; j++){
	      //for(j = 0; j < T_seqlenZ; j++){
		if(oldHMG[i] == oldEdge0HMG[j]){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  IX++;
		}
	      }
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  enPosi.resize(0);
	  
	  
 	  O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);

	  */

	  // 2. Construct several blocks
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  
	  //-- v22 start --//
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  N_psl = 0;
	  fixedHMG.resize(0);
	  //-- v22 end --//
	  

	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  //cout << "T_seqlenZ : " << T_seqlenZ << endl;
	  //cout << "N_seqlenZ : " << N_seqlenZ << endl;
	  for(i = 0; i < N_seqlenZ; i++){
	    //cout << "i : " << i << endl;
	    if(newHMG[i] != -1){
	      //--- v22 start --//
	      //connect = false;
	      //--- v22 end --//
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		//cout << "j : " << j << endl;
		if(newHMG[i] == oldEdge0HMG[j]){
		  //--- v22 start ---//
		  //connect = true;
		  //cout << "B" << endl;
		  if(rand.runif()- fixProb < 0){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    fixedHMG.push_back(newHMG[i]);
		    // Heeee
		    //delBasePosi.push_back(delBasePosi_in);
		    //delBasePosi_in.resize(0);
		    IX++;
		    N_psl += logfixProb;
		  }else{
		    N_psl += logNfixProb;
		  }		    
		  //--- v22 end ---//
		  break;
		}
	      }
	      //--- v22 start ---//
	      //if(!connect)
	      //	delBasePosi_in.push_back(i-stPosi[IX-1]);
	      //--- v22 end ---//
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
	  //-- v22 start --//
	  //delBasePosi.push_back(delBasePosi_in);
	  //delBasePosi_in.resize(0);
	  //-- v22 end --//
	  enPosi.resize(0);
	  
	  //cout << "8" << endl;
	  //      cout << "oldEdge0HMG " << endl;
	  //print_veci(oldEdge0HMG);
	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  //cout << "delBasePosi length : " << delBasePosi.size() << endl;
	  //for(i = 0; i < delBasePosi.size(); i++)
	  //	print_veci(delBasePosi[i]);
	  
	  

	  oldEdge0HMG.resize(0);
	  // 3. Generate new IDH on Edge0 while keeping the original HMG.      
	  if(nodeZ == edge0->getEnd()){
	    //cout << "8.1" << endl;
	    edge0->changeStartEnd();
	    //cout << "8.1.1" << endl;
	    //-- v22 start --//
	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    //-- v22 end --//

	    edge0->calHMG(); 
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    

	    
	    //cout << "8.1.2" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.1.2" << endl;
	    oldEdge0HMG = edge0->getHMG();
	    //cout << "8.1.3" << endl;
	  }else{
	    //cout << "8.2" << endl;
	    //-- v22 start --//
	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    //-- v22 end --//


	    //cout << "8.2.1" << endl;
	    edge0->calHMG();
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    


	    //cout << "8.2.2" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.2.3" << endl;
	    oldEdge0HMG = edge0->getHMG();
	    //cout << "8.2.4" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.2.5" << endl;
	  }  
	  
	  
	  //      cout << "edge0 IDH" << endl;
	  //edge0->getIDH()->printIDH(); 
	  //cout << "new " << endl;
	  //print_veci(oldEdge0HMG);
	  


	  //cout << "8.3" << endl;
	  // 4. Calculate proposal prob for old IDH 
	  // 4.1  Construct several blocks and save starting position
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  //-- v22 start --//
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  O_psl = 0;
	  //-- v22 end --//
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      //-- v22 start --//
	      //connect = false;
	      //-- v22 end --//
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		if(oldHMG[i] == oldEdge0HMG[j]){
		  //-- v22 start --//
		  //connect = true;
		  if(is_element(fixedHMG, i)){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    IX++;
		    //delBasePosi.push_back(delBasePosi_in);
		    //delBasePosi_in.resize(0);
		    O_psl += logfixProb;
		  }else{
		    O_psl += logNfixProb;
		  }
		  //--- v22 end ---//
		  break;
		}
	      }
	      //--- v22 start ---//
	      //if(!connect)
	      //	delBasePosi_in.push_back(i-stPosi[IX-1]);
	      //--- v22 end ---//
	    }
	  }
	  stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  enPosi.resize(0);
	  //-- v22 start --//
	  //delBasePosi.push_back(delBasePosi_in);
	  //delBasePosi_in.resize(0);        
	  //-- v22 end --//


	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  //cout << "delBasePosi length : " << delBasePosi.size() << endl;
	  //for(i = 0; i < delBasePosi.size(); i++)
	  //	print_veci(delBasePosi[i]);
	  
	  
	  //cout << "9" << endl;

	  //-- v22 start --//
	  O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
	  //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  //-- v22 end --//



      



	  //	  checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //	  	  cout << "caseII " << endl;

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //	  cout << "1" << endl;

	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();
	  oldHMG.resize(O_seqlenZ);
	  for(i = 0; i < O_seqlenZ; i++)
	    oldHMG[i] = -1;

	  tmpHMG3.resize(0);
	  tmpHMG3 = edgeY->getHMG();  


	  //cout << "2" << endl;
	  

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));


	  //FixHMG
	  N_seqlenZ = nodeZ->getSeqLen();
	  newHMG.resize(N_seqlenZ);
	  for(i = 0; i < N_seqlenZ; i++)
	    newHMG[i] = -1;


	  //	  cout << "3" << endl;
	  

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  //if(nodeZ == edge0->getEnd()){
	  //  edge0->changeStartEnd();
	  //  edge0->runEdge(rand,params);
	  //  edge0->calHMG();     
	  //  edge0->ReverseEdge();
	  //}else{
	  //  edge0->runEdge(rand,params);
	  //  edge0->calHMG();
	  //}    


	  tmpHMG2.resize(0);
	  tmpHMG2 = edgeT->getHMG();  


	  if(!edgeT->getStart()->getRoot()){

	    TempEdge = edgeT->getParentEdge();
	    tmpHMG1.resize(0);

	    //cout << "4" << endl;


	    while(TempEdge->getEnd() != nodeBm){

	      //TempEdge = TempEdge->getParentEdge();
	      T_seqlenZ = (TempEdge->getHMG()).size();
	      for(i = 0; i < T_seqlenZ; i++){
		if(TempEdge->getHMG()[i] >= 0)
		  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
		else
		  tmpHMG1.push_back(-1);
	      }
	      tmpHMG2 = tmpHMG1;
	      tmpHMG1.resize(0);
	      if(TempEdge->getStart()->getRoot())
		break;
              else
		TempEdge = TempEdge->getParentEdge();
	    }
          }
	    


	  if(!edgeY->getStart()->getRoot()){

	    TempEdge = edgeY->getParentEdge();
	    tmpHMG1.resize(0);


	    while(TempEdge->getEnd() != nodeBm){

	      //TempEdge = TempEdge->getParentEdge();
	      T_seqlenZ = (TempEdge->getHMG()).size();
	      for(i = 0; i < T_seqlenZ; i++){
		if(TempEdge->getHMG()[i] >= 0)
		  tmpHMG1.push_back(tmpHMG3[TempEdge->getHMG()[i]]);
		else
		  tmpHMG1.push_back(-1);
	      }
	      tmpHMG3 = tmpHMG1;
	      tmpHMG1.resize(0);
	      if(TempEdge->getStart()->getRoot())
		break;
              else
		TempEdge = TempEdge->getParentEdge();	    
	    }

	  }
	    
	  T_seqlenZ = tmpHMG3.size();
	  
	  for(i = 0; i < T_seqlenZ; i++){
	    if((tmpHMG3[i] != -1) & (tmpHMG2[i] != -1)){
	      oldHMG[tmpHMG3[i]] = tmpHMG2[i];
	      newHMG[tmpHMG2[i]] = tmpHMG3[i];
	    }
	  }
	  
	  //	  if(tmpHMG3.size() != tmpHMG2.size()){
	  //cout << "ERROR!!!!!! tmpHMG2 != tmpHMG3" << endl;
	  //}else{
	  //  cout << "oldHMG " << endl;
	  //  print_veci(oldHMG);
	  //  cout << "newHMG " << endl;
	  //  print_veci(newHMG);
	  //}	
	  
	  tmpHMG1.resize(0);
	  tmpHMG2.resize(0);
	  tmpHMG3.resize(0);
	  
	  
	  // 2. Construct several blocks
	  /*
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < N_seqlenZ; i++){
	    if(newHMG[i] != -1){
	      for(j = enPosi[enPosi.size()-1]; j < T_seqlenZ; j++){
	      //for(j = 0; j < T_seqlenZ; j++){
		if(newHMG[i] == oldEdge0HMG[j]){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  IX++;
		}
	      }
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  enPosi.resize(0);

	  //	  cout << "oldEdge0HMG " << endl;
	  //print_veci(oldEdge0HMG);
	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  
	  
	  
	  oldEdge0HMG.resize(0);
	  // 3. Generate new IDH on Edge0 while keeping the original HMG.      
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    edge0->calHMG();     
	    //	    edge0->getIDH()->printIDH();
	    edge0->ReverseEdge();
	    oldEdge0HMG = edge0->getHMG();
	  }else{
	    N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    edge0->calHMG();
	    //edge0->getIDH()->printIDH();
	    edge0->ReverseEdge();
	    oldEdge0HMG = edge0->getHMG();
	    edge0->ReverseEdge();
	  }  
	  
	  // 4. Calculate proposal prob for old IDH 
	  // 4.1  Construct several blocks and save starting position
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      for(j = enPosi[enPosi.size()-1]; j < T_seqlenZ; j++){
	      //for(j = 0; j < T_seqlenZ; j++){
		if(oldHMG[i] == oldEdge0HMG[j]){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  IX++;
		}
	      }
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  enPosi.resize(0);
	  
	  
	  O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);

	  */




	  // 2. Construct several blocks
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  
	  //-- v22 start --//
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  N_psl = 0;
	  fixedHMG.resize(0);
	  //-- v22 end --//
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  //cout << "T_seqlenZ : " << T_seqlenZ << endl;
	  //cout << "N_seqlenZ : " << N_seqlenZ << endl;
	  for(i = 0; i < N_seqlenZ; i++){
	    //cout << "i : " << i << endl;
	    if(newHMG[i] != -1){
	      //--- v22 start --//
	      //connect = false;
	      //--- v22 end --//
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		//cout << "j : " << j << endl;
		if(newHMG[i] == oldEdge0HMG[j]){
		  //--- v22 start ---//
		  //connect = true;
		  if(rand.runif()- fixProb < 0){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    fixedHMG.push_back(newHMG[i]);
		    // Heeee
		    //delBasePosi.push_back(delBasePosi_in);
		    //delBasePosi_in.resize(0);
		    IX++;
		    N_psl += logfixProb;
		  }else{
		    N_psl += logNfixProb;
		  }
		  //--- v22 end ---//
		  break;
		}
	      }
	      //--- v22 start --//
	      //if(!connect)
	      //	delBasePosi_in.push_back(i-stPosi[IX-1]);
	      //--- v22 end --//
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
	  //-- v22 start --//
	  //delBasePosi.push_back(delBasePosi_in);
	  //delBasePosi_in.resize(0);
	  //-- v22 end --//
	  enPosi.resize(0);
	  
	  //cout << "8" << endl;
	  //      cout << "oldEdge0HMG " << endl;
	  //print_veci(oldEdge0HMG);
	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  //cout << "delBasePosi length : " << delBasePosi.size() << endl;
	  //for(i = 0; i < delBasePosi.size(); i++)
	  //	print_veci(delBasePosi[i]);
      

	  
	  oldEdge0HMG.resize(0);
	  // 3. Generate new IDH on Edge0 while keeping the original HMG.      
	  if(nodeZ == edge0->getEnd()){
	    //cout << "8.1" << endl;
	    edge0->changeStartEnd();
	    //cout << "8.1.1" << endl;
	    //-- v22 start --//
	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	    N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    //-- v22 end --//

	    edge0->calHMG(); 
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    
	    
	    
	    //cout << "8.1.2" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.1.2" << endl;
	    oldEdge0HMG = edge0->getHMG();
	    //cout << "8.1.3" << endl;
	  }else{
	    //cout << "8.2" << endl;

	    //-- v22 start --//
	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    //-- v22 end --//


	    //cout << "8.2.1" << endl;
	    edge0->calHMG();
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    

	    
	    //cout << "8.2.2" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.2.3" << endl;
	    oldEdge0HMG = edge0->getHMG();
	    //cout << "8.2.4" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.2.5" << endl;
	  }  


	  //      cout << "edge0 IDH" << endl;
	  //edge0->getIDH()->printIDH(); 
	  //cout << "new " << endl;
	  //print_veci(oldEdge0HMG);
	  
	  
	  
	  //cout << "8.3" << endl;
	  // 4. Calculate proposal prob for old IDH 
	  // 4.1  Construct several blocks and save starting position
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  //-- v22 start --//
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  O_psl = 0;
	  //-- v22 end --//
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      //-- v22 start --//
	      //connect = false;
	      //-- v22 end --//
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		if(oldHMG[i] == oldEdge0HMG[j]){
		  //-- v22 start --//
		  //connect = true;
		  if(is_element(fixedHMG, i)){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    IX++;
		    //delBasePosi.push_back(delBasePosi_in);
		    //delBasePosi_in.resize(0);
		    O_psl += logfixProb;
		  }else{
		    O_psl += logNfixProb;
		  }
		  //--- v22 end ---//
		  break;
		}
	      }
	      //-- v22 start --// 
	      //if(!connect)
	      //	delBasePosi_in.push_back(i-stPosi[IX-1]);
	      //-- v22 end --//
	    }
	  }
	  stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  enPosi.resize(0);
	  //-- v22 start --//
	  //delBasePosi.push_back(delBasePosi_in);
	  //delBasePosi_in.resize(0);        
	  //-- v22 end --//


	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  //cout << "delBasePosi length : " << delBasePosi.size() << endl;
	  //for(i = 0; i < delBasePosi.size(); i++)
	  //	print_veci(delBasePosi[i]);
      
	  
	  //cout << "9" << endl;

	  //-- v22 start --//
	  O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
	  //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
	  //-- v22 end --//

	  delBasePosi.resize(0);
	  delBasePosi_in.resize(0);
      



	  //	  checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    //if(nodeZ == edge0->getEnd()){
    //  edge0->ReverseEdge();
    //  N_psl= edge0->ProposHistory(params);
    //  edge0->ReverseEdge();
    //}else{
    //  N_psl= edge0->ProposHistory(params);
    //}     


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));

    //    cout << "AP : " << AP << endl;
    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  
  //cout << "done" << endl;

  Mset.resize(0);

  oldHMG.resize(0);
  newHMG.resize(0);
  tmpHMG1.resize(0);
  tmpHMG2.resize(0);
  tmpHMG3.resize(0);
  oldEdge0HMG.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);

  delBasePosi.resize(0);
  delBasePosi_in.resize(0);



  delete oldIDH;

  return AP;  

} // SPRonSubTree








//-- v25 start --//
/*
double Tree::SPRonSubTreeWithFixedHMG(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c2, int start) {


  //cout << "SPRonSubTreeWithFixedHMG" << endl;


  int i, j;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  vector<int> oldHMG(0);
  vector<int> newHMG(0);
  vector<int> tmpHMG1(0);
  vector<int> tmpHMG2(0);
  vector<int> tmpHMG3(0);
  vector<int> oldEdge0HMG(0);
  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  
  //-- v22 start --//
  double fixProb = 0.85;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  vector<int> fixedHMG(0);
  //-- v22 end --//



  InDelHistory* oldIDH = new InDelHistory();
  //vector<int> newEdge0HMG(0);
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  
  // Heeee
  vector<vector<int> > delBasePosi(0);
  delBasePosi.resize(0); 
  vector<int> delBasePosi_in(0);
  delBasePosi_in.resize(0);
  bool connect;



  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  // Pick M on edge0, which is the end point of window
  //double posiM = rand.runif()*(edge0->getEdgeLen()); 

  //cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
  

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 



  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];


  //cout << "selectedposi : " << selectedposi << "TargetEdgeNum : " << TargetEdgeNum << endl;


  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "AAA " << endl;
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMG(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, c2, start);
    //AP = SPRonSingleEdgeAsPartOfSPRonSubTree(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum);
    //AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithinWindow(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, posiM);

  }else{                  // else if edge which is connected to Z is selected

    //cout << "BBB " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);
    //cout << "edgeT number " << edgeT->getnumber() << endl;


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }

    //cout << "posiNewZ : " << posiNewZ << endl;

 
    lenXt = edgeT->getEdgeLen();

    O_IDHlike = edge0->likeliHistory(params);



    if(nodeZ == edge0->getStart()){
      (*oldIDH) = (*edge0->getIDH());
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
    }else{
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
      (*oldIDH) = (*edge0->getIDH());
      edge0->ReverseEdge();
    }      


    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){


      //cout << "caseIa " << endl;

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();



      //outfile << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();




      //cout << "1" << endl;

      //FixHMG
      O_seqlenZ = nodeZ->getSeqLen();
      oldHMG.resize(O_seqlenZ);
      for(i = 0; i < O_seqlenZ; i++)
	oldHMG[i] = -1;
      
      //cout << "2" << endl;   
     
      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
    

      //FixHMG
      tmpHMG1.resize(0);
      tmpHMG1 = edgeY->getHMG();  


      //cout << "3" << endl;
  
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));

      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //


      //cout << "HAHAHA " << endl;
      //printTree(outfile);


      //FixHMG
      // 1. Get homology structure between oldZ and newZ //

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);
      
      //cout << "4" << endl;


      //Heejung Shim

      TempEdge = edgeY->getParentEdge();
      //outfile << "4.0 " << endl;
      T_seqlenZ = (TempEdge->getHMG()).size();
      //vector<int> tmp;
      //outfile << "4.0.1 " << endl;
      //tmp.resize(0);
      //outfile << "4.0.2 " << endl;
      //tmp = TempEdge->getHMG();
      
      //outfile << "hmglength " << TempEdge->getStart()->getnumber() << endl;
      //for(i =0; i < TempEdge->getStart()->getSeqLen(); i++)
      //	tmp.push_back(TempEdge->getHMG(i));
      //T_seqlenZ = tmp.size();
      //T_seqlenZ = 1;
      //cout << "4.1 T_seqlenZ :" << T_seqlenZ << endl;

      for(i = 0; i < T_seqlenZ; i++){
	//cout << "i : " << i << endl;
	if(TempEdge->getHMG()[i] >= 0)
	  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	else
	  tmpHMG1.push_back(-1);
      }
      
      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);


      //cout << "5" << endl;


      while(TempEdge->getStart() != nodeZ){

	TempEdge = TempEdge->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }

	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);

      }

      //cout << "6" << endl;

      newHMG = tmpHMG2;
      N_seqlenZ = nodeZ->getSeqLen();
      for(i = 0; i < N_seqlenZ; i++){
	if(newHMG[i] != -1){
	  oldHMG[newHMG[i]] = i;
        }
      }
      //if(newHMG.size() != N_seqlenZ){
      //cout << "ERROR!!!!!! tmpHMG2.size() != N_seqlenZ" << endl;
      //}else{
      //	cout << "oldHMG " << endl;
      // print_veci(oldHMG);
      //cout << "newHMG " << endl;
      //print_veci(newHMG);
      //}	
	
      tmpHMG1.resize(0);
      tmpHMG2.resize(0);

      //cout << "O_seqlenZ : " << O_seqlenZ << " N_seqlenZ : " << N_seqlenZ << endl;
      //cout << "oldHMG " << endl;
      //print_veci(oldHMG);
      //cout << "newHMG " << endl;
      //print_veci(newHMG);
      //cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);


      //cout << "7" << endl;

      // 2. Construct several blocks
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      
      //-- v22 start --//
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      N_psl = 0;
      fixedHMG.resize(0);
      //-- v22 end --//

      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      //cout << "T_seqlenZ : " << T_seqlenZ << endl;
      //cout << "N_seqlenZ : " << N_seqlenZ << endl;
      for(i = 0; i < N_seqlenZ; i++){
	//cout << "i : " << i << endl;
	if(newHMG[i] != -1){
	  
	  //--- v22 start --//
	  //connect = false;
	  //--- v22 end --//
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	    //cout << "j : " << j << endl;
	    if(newHMG[i] == oldEdge0HMG[j]){
	      //--- v22 start ---//
	      //connect = true;
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		fixedHMG.push_back(newHMG[i]);
		//delBasePosi.push_back(delBasePosi_in);
		//delBasePosi_in.resize(0);
		IX++;
		N_psl += logfixProb;
              }else{
		N_psl += logNfixProb;
              }
	      //--- v22 end ---//
	      break;
            }
          }
	  //--- v22 start --//
	  //if(!connect)
	  //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	  //--- v22 end --//
	}
      }
      stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
      //-- v22 start --//
      //delBasePosi.push_back(delBasePosi_in);
      //delBasePosi_in.resize(0);
      //-- v22 end --//
      enPosi.resize(0);

      //cout << "8" << endl;
      //      cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "delBasePosi length : " << delBasePosi.size() << endl;
      //for(i = 0; i < delBasePosi.size(); i++)
      //	print_veci(delBasePosi[i]);
      


      oldEdge0HMG.resize(0);
      // 3. Generate new IDH on Edge0 while keeping the original HMG.      
      if(nodeZ == edge0->getEnd()){
	//cout << "8.1" << endl;
	edge0->changeStartEnd();
	//cout << "8.1.1" << endl;
	//-- v22 start --//
	//N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	//-- v22 end --//

	edge0->calHMG(); 

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();



        //cout << "8.1.2" << endl;
        edge0->ReverseEdge();
	//cout << "8.1.2" << endl;
	oldEdge0HMG = edge0->getHMG();
	//cout << "8.1.3" << endl;
      }else{
	//cout << "8.2" << endl;
	//-- v22 start --//
	//N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	//-- v22 end --//
	//cout << "8.2.1" << endl;
	edge0->calHMG();

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();



	//cout << "8.2.2" << endl;
	edge0->ReverseEdge();
	//cout << "8.2.3" << endl;
	oldEdge0HMG = edge0->getHMG();
	//cout << "8.2.4" << endl;
	edge0->ReverseEdge();
	//cout << "8.2.5" << endl;
      }  


      //cout << "edge0 IDH" << endl;
      //edge0->getIDH()->printIDH(); 
      //cout << "new " << endl;
      //print_veci(oldEdge0HMG);
  


      //cout << "8.3" << endl;
      // 4. Calculate proposal prob for old IDH 
      // 4.1  Construct several blocks and save starting position
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      //-- v22 start --//
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      O_psl = 0;
      //-- v22 end --//
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      for(i = 0; i < O_seqlenZ; i++){
	if(oldHMG[i] != -1){
	  //-- v22 start --//
	  //connect = false;
	  //-- v22 end --//
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	    if(oldHMG[i] == oldEdge0HMG[j]){
	      //-- v22 start --//
	      //connect = true;
	      if(is_element(fixedHMG, i)){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		//delBasePosi.push_back(delBasePosi_in);
		//delBasePosi_in.resize(0);
		IX++;
		O_psl += logfixProb;
              }else{
		O_psl += logNfixProb;
              }
	      //--- v22 end ---//
	      break;
	    }
          }
	  //-- v22 start --// 
	  //if(!connect)
	  //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	  //-- v22 end --//
        }
      }
      stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
      enPosi.resize(0);
      //-- v22 start --//
      //delBasePosi.push_back(delBasePosi_in);
      //delBasePosi_in.resize(0);        
      //-- v22 end --//

      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "delBasePosi length : " << delBasePosi.size() << endl;
      //for(i = 0; i < delBasePosi.size(); i++)
      //	print_veci(delBasePosi[i]);
      
      
      //cout << "9" << endl;

      //-- v22 start --//
      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      //-- v22 end --//


      //      cout << "O_psl " << O_psl << endl;

      //cout << "10" << endl;

      //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 
      //      cout << "caseI " << endl;

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     

      //FixHMG
      O_seqlenZ = nodeZ->getSeqLen();
      oldHMG.resize(O_seqlenZ);
      for(i = 0; i < O_seqlenZ; i++)
	oldHMG[i] = -1;
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //FixHMG
      tmpHMG1.resize(0);
      tmpHMG1 = edgeY->getHMG();  


      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //


      //FixHMG
      // 1. Get homology structure between oldZ and newZ //

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);
      

      TempEdge = edgeY->getParentEdge();
      T_seqlenZ = (TempEdge->getHMG()).size();
      for(i = 0; i < T_seqlenZ; i++){
	if(TempEdge->getHMG()[i] >= 0)
	  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	else
	  tmpHMG1.push_back(-1);
      }

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);


      while(TempEdge->getStart() != nodeZ){

	TempEdge = TempEdge->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);

      }

      newHMG = tmpHMG2;
      N_seqlenZ = nodeZ->getSeqLen();
      for(i = 0; i < N_seqlenZ; i++){
	if(newHMG[i] != -1){
	  oldHMG[newHMG[i]] = i;
        }
      }
      //if(newHMG.size() != N_seqlenZ){
      //	cout << "ERROR!!!!!! tmpHMG2.size() != N_seqlenZ" << endl;
      // }else{
      //cout << "oldHMG " << endl;
      //print_veci(oldHMG);
      //cout << "newHMG " << endl;
      //print_veci(newHMG);
      //}	
	
      tmpHMG1.resize(0);
      tmpHMG2.resize(0);

      // 2. Construct several blocks




      // 2. Construct several blocks
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      
      //-- v22 start --//
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      N_psl = 0;
      fixedHMG.resize(0);
      //-- v22 end --//



      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      //cout << "T_seqlenZ : " << T_seqlenZ << endl;
      //cout << "N_seqlenZ : " << N_seqlenZ << endl;
      for(i = 0; i < N_seqlenZ; i++){
	//cout << "i : " << i << endl;
	if(newHMG[i] != -1){
	  //--- v22 start --//
	  //connect = false;
	  //--- v22 end --//
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  //for(j = 0; j < T_seqlenZ; j++){
	    //cout << "j : " << j << endl;
	    if(newHMG[i] == oldEdge0HMG[j]){
	      //--- v22 start ---//
	      //connect = true;
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		fixedHMG.push_back(newHMG[i]);
		//delBasePosi.push_back(delBasePosi_in);
		//delBasePosi_in.resize(0);
		IX++;
		N_psl += logfixProb;
              }else{
		N_psl += logNfixProb;
              }	
	      //--- v22 end ---//
	      break;
            }
          }
	  //--- v22 start --//
	  //if(!connect)
	  //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	  //--- v22 end --//
	}
      }
      stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]); 
      //-- v22 start --//
      //delBasePosi.push_back(delBasePosi_in);
      //delBasePosi_in.resize(0);      
      //-- v22 end --//
      enPosi.resize(0);

      //cout << "8" << endl;
      //      cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "delBasePosi length : " << delBasePosi.size() << endl;
      //for(i = 0; i < delBasePosi.size(); i++)
      //	print_veci(delBasePosi[i]);
      


      oldEdge0HMG.resize(0);
      // 3. Generate new IDH on Edge0 while keeping the original HMG.      
      if(nodeZ == edge0->getEnd()){
	//cout << "8.1" << endl;
	edge0->changeStartEnd();
	//cout << "8.1.1" << endl;
	//-- v22 start --//
	//N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	//-- v22 end --//
	edge0->calHMG(); 

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();



        //cout << "8.1.2" << endl;
        edge0->ReverseEdge();
	//cout << "8.1.2" << endl;
	oldEdge0HMG = edge0->getHMG();
	//cout << "8.1.3" << endl;
      }else{
	//cout << "8.2" << endl;
	//-- v22 start --//
	//N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	//-- v22 end --//

	//cout << "8.2.1" << endl;
	edge0->calHMG();

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();



	//cout << "8.2.2" << endl;
	edge0->ReverseEdge();
	//cout << "8.2.3" << endl;
	oldEdge0HMG = edge0->getHMG();
	//cout << "8.2.4" << endl;
	edge0->ReverseEdge();
	//cout << "8.2.5" << endl;
      }  


      //      cout << "edge0 IDH" << endl;
      //edge0->getIDH()->printIDH(); 
      //cout << "new " << endl;
      //print_veci(oldEdge0HMG);
  


      //cout << "8.3" << endl;
      // 4. Calculate proposal prob for old IDH 
      // 4.1  Construct several blocks and save starting position
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      //-- v22 start --//
      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      O_psl = 0;
      //-- v22 end --//
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      for(i = 0; i < O_seqlenZ; i++){
	if(oldHMG[i] != -1){
	  //-- v22 start --//
	  //connect = false;
	  //-- v22 end --//
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	    //for(j = 0; j < T_seqlenZ; j++){
	    if(oldHMG[i] == oldEdge0HMG[j]){
	      //-- v22 start --//
	      //connect = true;
	      if(is_element(fixedHMG, i)){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
		//delBasePosi.push_back(delBasePosi_in);
		//delBasePosi_in.resize(0);
		O_psl += logfixProb;
              }else{
		O_psl += logNfixProb;
              }
	      //--- v22 end ---//
	      break;
            }
          }
	  //-- v22 start --//
	  //if(!connect)
	  //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	  //-- v22 end --//
        }
      }
      stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
      enPosi.resize(0);
      //-- v22 start --//
      //delBasePosi.push_back(delBasePosi_in);
      //delBasePosi_in.resize(0);        
      //-- v22 end --//


      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);
      //cout << "delBasePosi length : " << delBasePosi.size() << endl;
      //for(i = 0; i < delBasePosi.size(); i++)
      //	print_veci(delBasePosi[i]);
      
      
      //cout << "9" << endl;

      //-- v22 start --//
      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);


      //delBasePosi.resize(0);
      //delBasePosi_in.resize(0);
      //-- v22 end --//     








      //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT


	//	cout << "caseIII " << endl;
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();


	//FixHMG
	O_seqlenZ = nodeZ->getSeqLen();
	oldHMG.resize(O_seqlenZ);
	for(i = 0; i < O_seqlenZ; i++)
	  oldHMG[i] = -1;
      
	//FixHMG
	tmpHMG1.resize(0);
	tmpHMG1 = edgeY->getHMG();  
	


	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //


	//FixHMG
	// 1. Get homology structure between oldZ and newZ //
	
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);
	
	
	TempEdge = edgeY->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);
	

	while(TempEdge->getStart() != nodeZ){

	  TempEdge = TempEdge->getParentEdge();
	  T_seqlenZ = (TempEdge->getHMG()).size();
	  for(i = 0; i < T_seqlenZ; i++){
	    if(TempEdge->getHMG()[i] >= 0)
	      tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	    else
	      tmpHMG1.push_back(-1);
          }
	  tmpHMG2 = tmpHMG1;
	  tmpHMG1.resize(0);
	  
	}
	
	newHMG = tmpHMG2;
	N_seqlenZ = nodeZ->getSeqLen();
	for(i = 0; i < N_seqlenZ; i++){
	  if(newHMG[i] != -1){
	    oldHMG[newHMG[i]] = i;
	  }
	}
	//	if(newHMG.size() != N_seqlenZ){
	//cout << "ERROR!!!!!! tmpHMG2.size() != N_seqlenZ" << endl;
	//}else{
	// cout << "oldHMG " << endl;
	//print_veci(oldHMG);
	//cout << "newHMG " << endl;
	//print_veci(newHMG);
	//}	
	
	tmpHMG1.resize(0);
	tmpHMG2.resize(0);
	
	// 2. Construct several blocks


	// 2. Construct several blocks
	stSeqLen.resize(0);
	enSeqLen.resize(0);
	stPosi.resize(0);
	enPosi.resize(0);
	stPosi.push_back(0);
	enPosi.push_back(0);
	//-- v22 start --//
	//delBasePosi.resize(0);
	//delBasePosi_in.resize(0);
	N_psl = 0;
	fixedHMG.resize(0);
	//-- v22 end --//
	
	IX=1;
	T_seqlenZ = oldEdge0HMG.size();
	//cout << "T_seqlenZ : " << T_seqlenZ << endl;
	//cout << "N_seqlenZ : " << N_seqlenZ << endl;
	for(i = 0; i < N_seqlenZ; i++){
	  //cout << "i : " << i << endl;
	  if(newHMG[i] != -1){
	    //--- v22 start --//
	    //connect = false;
	    //--- v22 end --//
	    for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	      //for(j = 0; j < T_seqlenZ; j++){
	      //cout << "j : " << j << endl;
	      if(newHMG[i] == oldEdge0HMG[j]){
		//--- v22 start ---//
		//connect = true;
		//cout << "B" << endl;
		if(rand.runif()- fixProb < 0){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  fixedHMG.push_back(newHMG[i]);
		  // Heeee
		  //delBasePosi.push_back(delBasePosi_in);
		  //delBasePosi_in.resize(0);
		  IX++;
		  N_psl += logfixProb;
		}else{
		  N_psl += logNfixProb;
		}
		//--- v22 end ---//
		break;
	      }
	    }
	    //--- v22 start ---//
	    //if(!connect)
	    //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	    //--- v22 end ---//
	  }
	}
	stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
	//-- v22 start --//
	//delBasePosi.push_back(delBasePosi_in);
	//delBasePosi_in.resize(0);    
	//-- v22 end --//
	enPosi.resize(0);
	
	//cout << "8" << endl;
	//      cout << "oldEdge0HMG " << endl;
	//print_veci(oldEdge0HMG);
	//cout << "stSeqLen" << endl;
	//print_veci(stSeqLen);
	//cout << "enSeqLen" << endl;
	//print_veci(enSeqLen);
	//cout << "stPosi" << endl;
	//print_veci(stPosi);
	//cout << "delBasePosi length : " << delBasePosi.size() << endl;
	//for(i = 0; i < delBasePosi.size(); i++)
	//	print_veci(delBasePosi[i]);
	


	oldEdge0HMG.resize(0);
	// 3. Generate new IDH on Edge0 while keeping the original HMG.      
	if(nodeZ == edge0->getEnd()){
	  //cout << "8.1" << endl;
	  edge0->changeStartEnd();
	  //cout << "8.1.1" << endl;

	  //-- v22 start --//
	  //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	  N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	  //-- v22 end --//

	  edge0->calHMG(); 
	  
	  //cout << "N_psl " << N_psl << endl;
	  //edge0->getIDH()->printIDH();
	  


	  //cout << "8.1.2" << endl;
	  edge0->ReverseEdge();
	  //cout << "8.1.2" << endl;
	  oldEdge0HMG = edge0->getHMG();
	  //cout << "8.1.3" << endl;
	}else{
	  //cout << "8.2" << endl;
	  //-- v22 start --//
	  //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	  N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	  //-- v22 end --//



	  //cout << "8.2.1" << endl;
	  edge0->calHMG();
	  
	  //cout << "N_psl " << N_psl << endl;
	  //edge0->getIDH()->printIDH();
	  


	  //cout << "8.2.2" << endl;
	  edge0->ReverseEdge();
	  //cout << "8.2.3" << endl;
	  oldEdge0HMG = edge0->getHMG();
	  //cout << "8.2.4" << endl;
	  edge0->ReverseEdge();
	  //cout << "8.2.5" << endl;
	}  


	//      cout << "edge0 IDH" << endl;
	//edge0->getIDH()->printIDH(); 
	//cout << "new " << endl;
	//print_veci(oldEdge0HMG);
	


	//cout << "8.3" << endl;
	// 4. Calculate proposal prob for old IDH 
	// 4.1  Construct several blocks and save starting position
	stSeqLen.resize(0);
	enSeqLen.resize(0);
	stPosi.resize(0);
	enPosi.resize(0);
	//-- v22 start --//
	//delBasePosi.resize(0);
	//delBasePosi_in.resize(0);
	O_psl = 0;
	//-- v22 end --//
	stPosi.push_back(0);
	enPosi.push_back(0);
	IX=1;
	T_seqlenZ = oldEdge0HMG.size();
	for(i = 0; i < O_seqlenZ; i++){
	  if(oldHMG[i] != -1){
	    //-- v22 start --//
	    //connect = false;
	    //-- v22 end --//
	    for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	      //for(j = 0; j < T_seqlenZ; j++){
	      if(oldHMG[i] == oldEdge0HMG[j]){
		//-- v22 start --//
		//connect = true;
		if(is_element(fixedHMG, i)){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  IX++;
		  //delBasePosi.push_back(delBasePosi_in);
		  //delBasePosi_in.resize(0);
		  O_psl += logfixProb;
		}else{
		  O_psl += logNfixProb;
		}
		//--- v22 end ---//
		break;
	      }
	    }
	    //-- v22 start --//
	    //if(!connect)
	    //  delBasePosi_in.push_back(i-stPosi[IX-1]);
	    //-- v22 end --//
	  }
	}
	stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	enPosi.resize(0);
	//-- v22 start --//
	//delBasePosi.push_back(delBasePosi_in);
	//delBasePosi_in.resize(0);        
	//-- v22 end --//


	//cout << "stSeqLen" << endl;
	//print_veci(stSeqLen);
	//cout << "enSeqLen" << endl;
	//print_veci(enSeqLen);
	//cout << "stPosi" << endl;
	//print_veci(stPosi);
	//cout << "delBasePosi length : " << delBasePosi.size() << endl;
	//for(i = 0; i < delBasePosi.size(); i++)
	//	print_veci(delBasePosi[i]);
	
	
	//cout << "9" << endl;

	//-- v22 start --//
	//O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
	O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
	//delBasePosi.resize(0);
	//delBasePosi_in.resize(0);
	//-- v22 end --//




	//	checkTree();


	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z
	  //cout << "caseIV " << endl;

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();


	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();
	  //oldHMG.resize(O_seqlenZ);
	  //for(i = 0; i < O_seqlenZ; i++)
	  //  oldHMG[i] = -1;
	  

	  //FixHMG
	  tmpHMG3.resize(0);
	  tmpHMG3 = edgeX->getHMG();    


	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //

	  //FixHMG
	  // 1. Get homology structure between oldZ and newZ //

	  tmpHMG2.resize(0);
	  tmpHMG2 = edgeT->getHMG();  

	  //tmpHMG1.resize(0);
	  //TempEdge = edgeT->getParentEdge();
	  //T_seqlenZ = (TempEdge->getHMG()).size();
	  //for(i = 0; i < T_seqlenZ; i++){
	  //  if(TempEdge->getHMG()[i] >= 0)
	  //    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  //  else
	  //    tmpHMG1.push_back(-1);
          //}	      
	  //tmpHMG2 = tmpHMG1;
	  //tmpHMG1.resize(0);
	  
	  //TempEdge = edgeT;
	  TempEdge = edgeT->getParentEdge();
	  tmpHMG1.resize(0);

	  while(TempEdge->getEnd() != nodeBend){

	    //TempEdge = TempEdge->getParentEdge();
	    T_seqlenZ = (TempEdge->getHMG()).size();
	    for(i = 0; i < T_seqlenZ; i++){
	      if(TempEdge->getHMG()[i] >= 0)
		tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
              else
		tmpHMG1.push_back(-1);
	    }
	    tmpHMG2 = tmpHMG1;
	    tmpHMG1.resize(0);	    
	    TempEdge = TempEdge->getParentEdge();
	  }

	  
	  T_seqlenZ = tmpHMG3.size();
	  for(i = 0; i < T_seqlenZ; i++){
	    if(tmpHMG3[i] >= 0)
	      tmpHMG1.push_back(tmpHMG2[tmpHMG3[i]]);
	    else
	      tmpHMG1.push_back(-1);
	    }
	  tmpHMG2 = tmpHMG1;
	  tmpHMG1.resize(0);	    

	  //O_seqlenZ = nodeZ->getSeqLen();
	  //oldHMG.resize(O_seqlenZ);
	  //for(i = 0; i < O_seqlenZ; i++)
	  //  oldHMG[i] = -1;
	  


	  oldHMG.resize(0);
	  newHMG.resize(0);

	  oldHMG = tmpHMG2;
	  N_seqlenZ = nodeZ->getSeqLen();
	  newHMG.resize(N_seqlenZ);
	  for(i = 0; i < N_seqlenZ; i++)
	    newHMG[i] = -1;	  
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      newHMG[oldHMG[i]] = i;
	    }
	  }
	  //	  if(oldHMG.size() != O_seqlenZ){
	  //cout << "ERROR!!!!!! tmpHMG2 != O_seqlenZ" << endl;
	  //}else{
	  // cout << "oldHMG " << endl;
	  //  print_veci(oldHMG);
	  //  cout << "newHMG " << endl;
	  //  print_veci(newHMG);
	  //}	
	  
	  tmpHMG1.resize(0);
	  tmpHMG2.resize(0);
	  tmpHMG3.resize(0);



	  // 2. Construct several blocks
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  
	  //-- v22 start --//
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  N_psl = 0;
	  fixedHMG.resize(0);
	  //-- v22 end --//
	  

	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  //cout << "T_seqlenZ : " << T_seqlenZ << endl;
	  //cout << "N_seqlenZ : " << N_seqlenZ << endl;
	  for(i = 0; i < N_seqlenZ; i++){
	    //cout << "i : " << i << endl;
	    if(newHMG[i] != -1){
	      //--- v22 start --//
	      //connect = false;
	      //--- v22 end --//
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		//cout << "j : " << j << endl;
		if(newHMG[i] == oldEdge0HMG[j]){
		  //--- v22 start ---//
		  //connect = true;
		  //cout << "B" << endl;
		  if(rand.runif()- fixProb < 0){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    fixedHMG.push_back(newHMG[i]);
		    // Heeee
		    //delBasePosi.push_back(delBasePosi_in);
		    //delBasePosi_in.resize(0);
		    IX++;
		    N_psl += logfixProb;
		  }else{
		    N_psl += logNfixProb;
		  }		    
		  //--- v22 end ---//
		  break;
		}
	      }
	      //--- v22 start ---//
	      //if(!connect)
	      //	delBasePosi_in.push_back(i-stPosi[IX-1]);
	      //--- v22 end ---//
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
	  //-- v22 start --//
	  //delBasePosi.push_back(delBasePosi_in);
	  //delBasePosi_in.resize(0);
	  //-- v22 end --//
	  enPosi.resize(0);
	  
	  //cout << "8" << endl;
	  //      cout << "oldEdge0HMG " << endl;
	  //print_veci(oldEdge0HMG);
	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  //cout << "delBasePosi length : " << delBasePosi.size() << endl;
	  //for(i = 0; i < delBasePosi.size(); i++)
	  //	print_veci(delBasePosi[i]);
	  
	  

	  oldEdge0HMG.resize(0);
	  // 3. Generate new IDH on Edge0 while keeping the original HMG.      
	  if(nodeZ == edge0->getEnd()){
	    //cout << "8.1" << endl;
	    edge0->changeStartEnd();
	    //cout << "8.1.1" << endl;
	    //-- v22 start --//
	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    //-- v22 end --//

	    edge0->calHMG(); 
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    

	    
	    //cout << "8.1.2" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.1.2" << endl;
	    oldEdge0HMG = edge0->getHMG();
	    //cout << "8.1.3" << endl;
	  }else{
	    //cout << "8.2" << endl;
	    //-- v22 start --//
	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    //-- v22 end --//


	    //cout << "8.2.1" << endl;
	    edge0->calHMG();
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    


	    //cout << "8.2.2" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.2.3" << endl;
	    oldEdge0HMG = edge0->getHMG();
	    //cout << "8.2.4" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.2.5" << endl;
	  }  
	  
	  
	  //      cout << "edge0 IDH" << endl;
	  //edge0->getIDH()->printIDH(); 
	  //cout << "new " << endl;
	  //print_veci(oldEdge0HMG);
	  


	  //cout << "8.3" << endl;
	  // 4. Calculate proposal prob for old IDH 
	  // 4.1  Construct several blocks and save starting position
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  //-- v22 start --//
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  O_psl = 0;
	  //-- v22 end --//
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      //-- v22 start --//
	      //connect = false;
	      //-- v22 end --//
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		if(oldHMG[i] == oldEdge0HMG[j]){
		  //-- v22 start --//
		  //connect = true;
		  if(is_element(fixedHMG, i)){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    IX++;
		    //delBasePosi.push_back(delBasePosi_in);
		    //delBasePosi_in.resize(0);
		    O_psl += logfixProb;
		  }else{
		    O_psl += logNfixProb;
		  }
		  //--- v22 end ---//
		  break;
		}
	      }
	      //--- v22 start ---//
	      //if(!connect)
	      //	delBasePosi_in.push_back(i-stPosi[IX-1]);
	      //--- v22 end ---//
	    }
	  }
	  stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  enPosi.resize(0);
	  //-- v22 start --//
	  //delBasePosi.push_back(delBasePosi_in);
	  //delBasePosi_in.resize(0);        
	  //-- v22 end --//


	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  //cout << "delBasePosi length : " << delBasePosi.size() << endl;
	  //for(i = 0; i < delBasePosi.size(); i++)
	  //	print_veci(delBasePosi[i]);
	  
	  
	  //cout << "9" << endl;

	  //-- v22 start --//
	  O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
	  //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  //-- v22 end --//



      



	  //	  checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //	  	  cout << "caseII " << endl;

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //	  cout << "1" << endl;

	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();
	  oldHMG.resize(O_seqlenZ);
	  for(i = 0; i < O_seqlenZ; i++)
	    oldHMG[i] = -1;

	  tmpHMG3.resize(0);
	  tmpHMG3 = edgeY->getHMG();  


	  //cout << "2" << endl;
	  

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));


	  //FixHMG
	  N_seqlenZ = nodeZ->getSeqLen();
	  newHMG.resize(N_seqlenZ);
	  for(i = 0; i < N_seqlenZ; i++)
	    newHMG[i] = -1;


	  //	  cout << "3" << endl;
	  

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  //if(nodeZ == edge0->getEnd()){
	  //  edge0->changeStartEnd();
	  //  edge0->runEdge(rand,params);
	  //  edge0->calHMG();     
	  //  edge0->ReverseEdge();
	  //}else{
	  //  edge0->runEdge(rand,params);
	  //  edge0->calHMG();
	  //}    


	  tmpHMG2.resize(0);
	  tmpHMG2 = edgeT->getHMG();  


	  if(!edgeT->getStart()->getRoot()){

	    TempEdge = edgeT->getParentEdge();
	    tmpHMG1.resize(0);

	    //cout << "4" << endl;


	    while(TempEdge->getEnd() != nodeBm){

	      //TempEdge = TempEdge->getParentEdge();
	      T_seqlenZ = (TempEdge->getHMG()).size();
	      for(i = 0; i < T_seqlenZ; i++){
		if(TempEdge->getHMG()[i] >= 0)
		  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
		else
		  tmpHMG1.push_back(-1);
	      }
	      tmpHMG2 = tmpHMG1;
	      tmpHMG1.resize(0);
	      if(TempEdge->getStart()->getRoot())
		break;
              else
		TempEdge = TempEdge->getParentEdge();
	    }
          }
	    


	  if(!edgeY->getStart()->getRoot()){

	    TempEdge = edgeY->getParentEdge();
	    tmpHMG1.resize(0);


	    while(TempEdge->getEnd() != nodeBm){

	      //TempEdge = TempEdge->getParentEdge();
	      T_seqlenZ = (TempEdge->getHMG()).size();
	      for(i = 0; i < T_seqlenZ; i++){
		if(TempEdge->getHMG()[i] >= 0)
		  tmpHMG1.push_back(tmpHMG3[TempEdge->getHMG()[i]]);
		else
		  tmpHMG1.push_back(-1);
	      }
	      tmpHMG3 = tmpHMG1;
	      tmpHMG1.resize(0);
	      if(TempEdge->getStart()->getRoot())
		break;
              else
		TempEdge = TempEdge->getParentEdge();	    
	    }

	  }
	    
	  T_seqlenZ = tmpHMG3.size();
	  
	  for(i = 0; i < T_seqlenZ; i++){
	    if((tmpHMG3[i] != -1) & (tmpHMG2[i] != -1)){
	      oldHMG[tmpHMG3[i]] = tmpHMG2[i];
	      newHMG[tmpHMG2[i]] = tmpHMG3[i];
	    }
	  }
	  
	  //	  if(tmpHMG3.size() != tmpHMG2.size()){
	  //cout << "ERROR!!!!!! tmpHMG2 != tmpHMG3" << endl;
	  //}else{
	  //  cout << "oldHMG " << endl;
	  //  print_veci(oldHMG);
	  //  cout << "newHMG " << endl;
	  //  print_veci(newHMG);
	  //}	
	  
	  tmpHMG1.resize(0);
	  tmpHMG2.resize(0);
	  tmpHMG3.resize(0);
	  
	  
	  // 2. Construct several blocks


	  // 2. Construct several blocks
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  
	  //-- v22 start --//
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  N_psl = 0;
	  fixedHMG.resize(0);
	  //-- v22 end --//
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  //cout << "T_seqlenZ : " << T_seqlenZ << endl;
	  //cout << "N_seqlenZ : " << N_seqlenZ << endl;
	  for(i = 0; i < N_seqlenZ; i++){
	    //cout << "i : " << i << endl;
	    if(newHMG[i] != -1){
	      //--- v22 start --//
	      //connect = false;
	      //--- v22 end --//
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		//cout << "j : " << j << endl;
		if(newHMG[i] == oldEdge0HMG[j]){
		  //--- v22 start ---//
		  //connect = true;
		  if(rand.runif()- fixProb < 0){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    fixedHMG.push_back(newHMG[i]);
		    // Heeee
		    //delBasePosi.push_back(delBasePosi_in);
		    //delBasePosi_in.resize(0);
		    IX++;
		    N_psl += logfixProb;
		  }else{
		    N_psl += logNfixProb;
		  }
		  //--- v22 end ---//
		  break;
		}
	      }
	      //--- v22 start --//
	      //if(!connect)
	      //	delBasePosi_in.push_back(i-stPosi[IX-1]);
	      //--- v22 end --//
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
	  //-- v22 start --//
	  //delBasePosi.push_back(delBasePosi_in);
	  //delBasePosi_in.resize(0);
	  //-- v22 end --//
	  enPosi.resize(0);
	  
	  //cout << "8" << endl;
	  //      cout << "oldEdge0HMG " << endl;
	  //print_veci(oldEdge0HMG);
	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  //cout << "delBasePosi length : " << delBasePosi.size() << endl;
	  //for(i = 0; i < delBasePosi.size(); i++)
	  //	print_veci(delBasePosi[i]);
      

	  
	  oldEdge0HMG.resize(0);
	  // 3. Generate new IDH on Edge0 while keeping the original HMG.      
	  if(nodeZ == edge0->getEnd()){
	    //cout << "8.1" << endl;
	    edge0->changeStartEnd();
	    //cout << "8.1.1" << endl;
	    //-- v22 start --//
	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	    N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    //-- v22 end --//

	    edge0->calHMG(); 
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    
	    
	    
	    //cout << "8.1.2" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.1.2" << endl;
	    oldEdge0HMG = edge0->getHMG();
	    //cout << "8.1.3" << endl;
	  }else{
	    //cout << "8.2" << endl;

	    //-- v22 start --//
	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH(), delBasePosi);
	    N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
	    //-- v22 end --//


	    //cout << "8.2.1" << endl;
	    edge0->calHMG();
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    

	    
	    //cout << "8.2.2" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.2.3" << endl;
	    oldEdge0HMG = edge0->getHMG();
	    //cout << "8.2.4" << endl;
	    edge0->ReverseEdge();
	    //cout << "8.2.5" << endl;
	  }  


	  //      cout << "edge0 IDH" << endl;
	  //edge0->getIDH()->printIDH(); 
	  //cout << "new " << endl;
	  //print_veci(oldEdge0HMG);
	  
	  
	  
	  //cout << "8.3" << endl;
	  // 4. Calculate proposal prob for old IDH 
	  // 4.1  Construct several blocks and save starting position
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  //-- v22 start --//
	  //delBasePosi.resize(0);
	  //delBasePosi_in.resize(0);
	  O_psl = 0;
	  //-- v22 end --//
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      //-- v22 start --//
	      //connect = false;
	      //-- v22 end --//
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		//for(j = 0; j < T_seqlenZ; j++){
		if(oldHMG[i] == oldEdge0HMG[j]){
		  //-- v22 start --//
		  //connect = true;
		  if(is_element(fixedHMG, i)){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    IX++;
		    //delBasePosi.push_back(delBasePosi_in);
		    //delBasePosi_in.resize(0);
		    O_psl += logfixProb;
		  }else{
		    O_psl += logNfixProb;
		  }
		  //--- v22 end ---//
		  break;
		}
	      }
	      //-- v22 start --// 
	      //if(!connect)
	      //	delBasePosi_in.push_back(i-stPosi[IX-1]);
	      //-- v22 end --//
	    }
	  }
	  stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  enPosi.resize(0);
	  //-- v22 start --//
	  //delBasePosi.push_back(delBasePosi_in);
	  //delBasePosi_in.resize(0);        
	  //-- v22 end --//


	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);
	  //cout << "delBasePosi length : " << delBasePosi.size() << endl;
	  //for(i = 0; i < delBasePosi.size(); i++)
	  //	print_veci(delBasePosi[i]);
      
	  
	  //cout << "9" << endl;

	  //-- v22 start --//
	  O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
	  //O_psl = calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH, delBasePosi);
	  //-- v22 end --//

	  delBasePosi.resize(0);
	  delBasePosi_in.resize(0);
      



	  //	  checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    //if(nodeZ == edge0->getEnd()){
    //  edge0->ReverseEdge();
    //  N_psl= edge0->ProposHistory(params);
    //  edge0->ReverseEdge();
    //}else{
    //  N_psl= edge0->ProposHistory(params);
    //}     


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    //    cout << "AP : " << AP << endl;
    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  
  //cout << "done" << endl;

  Mset.resize(0);

  oldHMG.resize(0);
  newHMG.resize(0);
  tmpHMG1.resize(0);
  tmpHMG2.resize(0);
  tmpHMG3.resize(0);
  oldEdge0HMG.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);

  delBasePosi.resize(0);
  delBasePosi_in.resize(0);



  delete oldIDH;

  return AP;  

} // SPRonSubTree
*/
//-- v25 end --//





//-- v25 start --//
double Tree::SPRonSubTreeWithFixedHMG(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c2, int start) {


  //cout << "SPRonSubTreeWithFixedHMGbyDistance" << endl;


  int i, j;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  vector<int> oldHMG(0);
  vector<int> newHMG(0);
  vector<int> tmpHMG1(0);
  vector<int> tmpHMG2(0);
  vector<int> tmpHMG3(0);
  vector<int> oldEdge0HMG(0);
  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  
  //-- v22 start --//
  double fixProb = 0.85;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  vector<int> fixedHMG(0);
  //-- v22 end --//


  //-- v25 start --//
  vector<vector<double> > DistT(0);
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<double> > oldPmat(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  //int numLetters;
  double MaxT, dist;
  int k, ki;
  int EndSeqLen;
  double powWei = params.getPowWei();
  //-- v25 end --//



  InDelHistory* oldIDH = new InDelHistory();
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  vector<vector<int> > delBasePosi(0);
  delBasePosi.resize(0); 
  vector<int> delBasePosi_in(0);
  delBasePosi_in.resize(0);
  bool connect;



  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];  
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  // Pick M on edge0, which is the end point of window
  //double posiM = rand.runif()*(edge0->getEdgeLen()); 

  //cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
  

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 



  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];


  //cout << "selectedposi : " << selectedposi << "TargetEdgeNum : " << TargetEdgeNum << endl;


  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "AAA " << endl;
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMG(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, c2, start);


  }else{                  // else if edge which is connected to Z is selected



    //cout << "BBB " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);
    //cout << "edgeT number " << edgeT->getnumber() << endl;


    EndSeqLen = nodeC->getSeqLen();

    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }

    //cout << "posiNewZ : " << posiNewZ << endl;

 
    lenXt = edgeT->getEdgeLen();

    O_IDHlike = edge0->likeliHistory(params);



    if(nodeZ == edge0->getStart()){
      (*oldIDH) = (*edge0->getIDH());
      edge0->ReverseEdge();
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
    }else{
      oldEdge0HMG = edge0->getHMG();
      edge0->ReverseEdge();
      (*oldIDH) = (*edge0->getIDH());
      edge0->ReverseEdge();
    }      


    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){


      //cout << "caseIa " << endl;

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//

      //-- v25 start --//
      nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeZ->CalSubTreeProbHere();

      Pt = nodeZ->getPt();
      pi = params.getPi(); 

      //numLetters = Pt.size();
      MaxT = 0;
      for(i = 0; i < numLetters; i++){
	for(j = 0; j < numLetters; j++){
	  Pt[i][j] *= pi[i];
	  MaxT = MAX(MaxT, Pt[i][j]);
	}
      }


      oldPmat.resize(0);
      nodeZ->getProbFromSubTreeProb(oldPmat);
      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);

      nodeZ->FinishForCalSubTreeProbHere();
        
      //-- v25 end --//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();



      //outfile << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();




      O_seqlenZ = nodeZ->getSeqLen();
      oldHMG.resize(O_seqlenZ);
      for(i = 0; i < O_seqlenZ; i++)
	oldHMG[i] = -1;
           
      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
    

      //FixHMG
      tmpHMG1.resize(0);
      tmpHMG1 = edgeY->getHMG();  



      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));

      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }




      //-- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      //nodeC->findRootSites(); // later
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      //if(nodeZ->getRoot())  // later
      //nodeZ->findLinkedSites(); // later

      // 2
      //nodeC->CalloglikeliofRootSitesOrReuse(params); // later
      //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

      //3
      nodeA->CalSubTreeProb(params);  
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      //UpdateAllinfoToRoot(params, nodeBend);  // Bend to Z...later start from Z;
      UpdateAllinfoTogivenNode(params, nodeBend, nodeZ);



      nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeZ->CalSubTreeProbHere();

      Pmat.resize(0);
      nodeZ->getProbFromSubTreeProb(Pmat);
   
      nodeZ->FinishForCalSubTreeProbHere();

      //-- v25 end --//


      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //

      //FixHMG
      // 1. Get homology structure between oldZ and newZ //

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);
      
      TempEdge = edgeY->getParentEdge();
      T_seqlenZ = (TempEdge->getHMG()).size();

      for(i = 0; i < T_seqlenZ; i++){
	if(TempEdge->getHMG()[i] >= 0)
	  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	else
	  tmpHMG1.push_back(-1);
      }
      
      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);

      while(TempEdge->getStart() != nodeZ){

	TempEdge = TempEdge->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }

	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);

      }

      newHMG = tmpHMG2;
      N_seqlenZ = nodeZ->getSeqLen();
      for(i = 0; i < N_seqlenZ; i++){
	if(newHMG[i] != -1){
	  oldHMG[newHMG[i]] = i;
        }
      }


      tmpHMG1.resize(0);
      tmpHMG2.resize(0);

      //cout << "O_seqlenZ : " << O_seqlenZ << " N_seqlenZ : " << N_seqlenZ << endl;
      //cout << "oldHMG " << endl;
      //print_veci(oldHMG);
      //cout << "newHMG " << endl;
      //print_veci(newHMG);
      //cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);


      // 2. Construct several blocks
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      

      N_psl = 0;
      fixedHMG.resize(0);
      for(i = 0; i < O_seqlenZ; i++)
	fixedHMG.push_back(0);

      IX=1;
      T_seqlenZ = oldEdge0HMG.size();


      //--- v25 start --//
      DistT.resize(N_seqlenZ + 1);
      for(i = 0; i <= N_seqlenZ; i++)
	DistT[i].resize(EndSeqLen+1);
      //--- v25 end --//



      for(i = 0; i < N_seqlenZ; i++){

	if(newHMG[i] != -1){
	 
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
     
	    if(newHMG[i] == oldEdge0HMG[j]){

	      //--- v25 start --//
	      dist = 0;
	      for(k = 0; k < numLetters; k++){
		for(ki = 0; ki < numLetters; ki++)
		  dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	      }

	
	      DistT[i][j] = log(dist);

	      dist = pow(dist/MaxT, powWei);
	      //oldFixProb[j] = dist;

   
	      if(rand.runif()- dist < 0){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		fixedHMG[newHMG[i]] = 1;
		IX++;
		N_psl += log(dist);
              }else{
		N_psl += log(1-dist);
              }
	      break;
            }
          }
	}
      }
      stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);

      //enPosi.resize(0);


      //      cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);



      oldEdge0HMG.resize(0);






      // 3. Generate new IDH on Edge0 while keeping the original HMG.      
      if(nodeZ == edge0->getEnd()){
    
	edge0->changeStartEnd();

	N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  

	//N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
     
	edge0->calHMG(); 

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();

        edge0->ReverseEdge();
	oldEdge0HMG = edge0->getHMG();
    
      }else{

	N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  
	//N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());

	edge0->calHMG();

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();

	edge0->ReverseEdge();
	oldEdge0HMG = edge0->getHMG();
	edge0->ReverseEdge();

      }  



      Pmat.resize(0);
      Pmat = oldPmat;
      oldPmat.resize(0);
      DistT.resize(0);
     //--- v25 start --//
      DistT.resize(O_seqlenZ + 1);
      for(i = 0; i <= O_seqlenZ; i++)
	DistT[i].resize(EndSeqLen+1);
      //--- v25 end --//
      



      // 4. Calculate proposal prob for old IDH 
      // 4.1  Construct several blocks and save starting position
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      O_psl = 0;
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      for(i = 0; i < O_seqlenZ; i++){
      	if(oldHMG[i] != -1){
	  
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
      	    if(oldHMG[i] == oldEdge0HMG[j]){


	      dist = 0;
	      for(k = 0; k < numLetters; k++){
		for(ki = 0; ki < numLetters; ki++)
		  dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	      }
	      
	      
	      DistT[i][j] = log(dist);

	      dist = pow(dist/MaxT, powWei);
	      

	      if(fixedHMG[i] == 1){
      		stPosi.push_back(i+1);
      		enPosi.push_back(j+1);
      		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
      		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
      	  
      		IX++;
      		O_psl += log(dist);
                    }else{
      		O_psl += log(1-dist);
                   }
      	      break;
      	    }
         }
       }
      }
      stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
      //enPosi.resize(0);
 

      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);


      O_psl += calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), oldIDH, Pmat, Qmat, DistT, Pt, pi, O_seqlenZ, T_seqlenZ);


      DistT.resize(0);

      //O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);



   

      //--- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //nodeA->findRootSites();
      nodeC->findRootSites(); // later
      //TempNode = nodeD;
      //while(TempNode != nodeZ){
      //	TempNode->findRootSites();
      //	TempNode = TempNode->getParent();
      //}

      // 1'
      if(nodeZ->getRoot())  // later
	nodeZ->findLinkedSites(); // later

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params); // later
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

      //3
      //nodeA->CalSubTreeProb(params);  
      //nodeA->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      //nodeD->CalSubTreeProb(params);
      //nodeD->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      //UpdateAllinfoToRoot(params, nodeBend);  // Bend to Z...later start from Z;
      UpdateAllinfoToRoot(params, nodeZ);
      //-- v25 end --//



      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 
    
    }else if(edge0 == nodeZ->getParentEdge()){

 
      //      cout << "caseI " << endl;

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//

      //-- v25 start --//
      nodeC->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeC->CalSubTreeProbHere();

      Pt = nodeC->getPt();
      pi = params.getPi(); 

      //numLetters = Pt.size();
      MaxT = 0;
      for(i = 0; i < numLetters; i++){
	for(j = 0; j < numLetters; j++){
	  Pt[i][j] *= pi[i];
	  MaxT = MAX(MaxT, Pt[i][j]);
	}
      }

      oldPmat.resize(0);
      nodeZ->getProbFromSubTreeProb(oldPmat);
      Qmat.resize(0);
      nodeC->getProbFromSubTreeProb(Qmat);

      nodeC->FinishForCalSubTreeProbHere();
        
      //-- v25 end --//


      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     

      //FixHMG
      O_seqlenZ = nodeZ->getSeqLen();
      oldHMG.resize(O_seqlenZ);
      for(i = 0; i < O_seqlenZ; i++)
	oldHMG[i] = -1;
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //FixHMG
      tmpHMG1.resize(0);
      tmpHMG1 = edgeY->getHMG();  


      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }


      //-- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      //nodeZ->findRootSites();  // later

      // 1'
      //if(nodeC->getRoot())  // later
      //	nodeC->findLinkedSites();  // later

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      //UpdateAllinfoToRoot(params, nodeBend); // later to nodeZ from nodeZ 
      UpdateAllinfoTogivenNode(params, nodeBend, nodeZ);
      nodeZ->CalSubTreeProb(params);



      Pmat.resize(0);
      nodeZ->getProbFromSubTreeProb(Pmat);
   
      //-- v25 end --//

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //


      //FixHMG
      // 1. Get homology structure between oldZ and newZ //

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);
      

      TempEdge = edgeY->getParentEdge();
      T_seqlenZ = (TempEdge->getHMG()).size();
      for(i = 0; i < T_seqlenZ; i++){
	if(TempEdge->getHMG()[i] >= 0)
	  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	else
	  tmpHMG1.push_back(-1);
      }

      tmpHMG2 = tmpHMG1;
      tmpHMG1.resize(0);


      while(TempEdge->getStart() != nodeZ){

	TempEdge = TempEdge->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);

      }

      newHMG = tmpHMG2;
      N_seqlenZ = nodeZ->getSeqLen();
      for(i = 0; i < N_seqlenZ; i++){
	if(newHMG[i] != -1){
	  oldHMG[newHMG[i]] = i;
        }
      }

	
      tmpHMG1.resize(0);
      tmpHMG2.resize(0);

      // 2. Construct several blocks
 


      // 2. Construct several blocks
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      

      N_psl = 0;
      fixedHMG.resize(0);
      for(i = 0; i < O_seqlenZ; i++)
	fixedHMG.push_back(0);



      IX=1;
      T_seqlenZ = oldEdge0HMG.size();



      //--- v25 start --//
      DistT.resize(N_seqlenZ + 1);
      for(i = 0; i <= N_seqlenZ; i++)
	DistT[i].resize(EndSeqLen+1);
      //--- v25 end --//


      for(i = 0; i < N_seqlenZ; i++){
      
	if(newHMG[i] != -1){
	
	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	  
	    if(newHMG[i] == oldEdge0HMG[j]){

	      //--- v25 start --//
	      dist = 0;
	      for(k = 0; k < numLetters; k++){
		for(ki = 0; ki < numLetters; ki++)
		  dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	      }

	
	      DistT[i][j] = log(dist);

	      dist = pow(dist/MaxT, powWei);


	      if(rand.runif()- dist < 0){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		//fixedHMG.push_back(newHMG[i]);
		fixedHMG[newHMG[i]] = 1;
		IX++;
		N_psl += log(dist);
              }else{
		N_psl += log(1-dist);
              }	
	      break;
            }
          }

	}
      }
      stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]); 
 
      //enPosi.resize(0);


      //      cout << "oldEdge0HMG " << endl;
      //print_veci(oldEdge0HMG);
      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);



      oldEdge0HMG.resize(0);
      // 3. Generate new IDH on Edge0 while keeping the original HMG.      
      if(nodeZ == edge0->getEnd()){
    
	edge0->changeStartEnd();

	
	N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  
	//N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());

	edge0->calHMG(); 

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();

        edge0->ReverseEdge();
	oldEdge0HMG = edge0->getHMG();

      }else{


	N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  
	//N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
       
	edge0->calHMG();

	//cout << "N_psl " << N_psl << endl;
	//edge0->getIDH()->printIDH();

	edge0->ReverseEdge();
	oldEdge0HMG = edge0->getHMG();
	edge0->ReverseEdge();

      }  


      Pmat.resize(0);
      Pmat = oldPmat;
      oldPmat.resize(0);
      DistT.resize(0);
      //--- v25 start --//
      DistT.resize(O_seqlenZ + 1);
      for(i = 0; i <= O_seqlenZ; i++)
	DistT[i].resize(EndSeqLen+1);
      //--- v25 end --//
      




      //      cout << "edge0 IDH" << endl;
      //edge0->getIDH()->printIDH(); 
      //cout << "new " << endl;
      //print_veci(oldEdge0HMG);
  


      // 4. Calculate proposal prob for old IDH 
      // 4.1  Construct several blocks and save starting position
      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);

      O_psl = 0;
   
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      T_seqlenZ = oldEdge0HMG.size();
      for(i = 0; i < O_seqlenZ; i++){
	if(oldHMG[i] != -1){

	  for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	 
	    if(oldHMG[i] == oldEdge0HMG[j]){
	    
	      dist = 0;
	      for(k = 0; k < numLetters; k++){
		for(ki = 0; ki < numLetters; ki++)
		  dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
	      }
	      
	      
	      DistT[i][j] = log(dist);

	      dist = pow(dist/MaxT, powWei);
	      



	      if(fixedHMG[i] == 1){
		stPosi.push_back(i+1);
		enPosi.push_back(j+1);
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
		O_psl += log(dist);
              }else{
		O_psl += log(1-dist);
              }
	      break;
            }
          }
        }
      }
      stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
      enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
      //enPosi.resize(0);


      //cout << "stSeqLen" << endl;
      //print_veci(stSeqLen);
      //cout << "enSeqLen" << endl;
      //print_veci(enSeqLen);
      //cout << "stPosi" << endl;
      //print_veci(stPosi);

      O_psl += calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), oldIDH, Pmat, Qmat, DistT, Pt, pi, O_seqlenZ, T_seqlenZ);


      DistT.resize(0);

      //O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);





      //--- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //nodeA->findRootSites();
      //TempNode = nodeD;
      //while(TempNode != nodeZ){
      //	TempNode->findRootSites();
      //	TempNode = TempNode->getParent();
      // }
      nodeZ->findRootSites();  // later

      // 1'
      if(nodeC->getRoot())  // later
	nodeC->findLinkedSites();  // later

      // 2
      //nodeA->CalSubTreeProb(params);
      //nodeA->CalloglikeliofRootSitesOrReuse(params);
      // UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      // nodeD->CalSubTreeProb(params);
      //nodeD->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      //UpdateAllinfoToRoot(params, nodeBend); // later to nodeC from nodeC
      nodeZ->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
      UpdateAllinfoToRoot(params, nodeC);
  

      //-- v25 end --//

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT


	//	cout << "caseIII " << endl;
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//


	//-- v25 start --//
	nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeZ->CalSubTreeProbHere();
	
	Pt = nodeZ->getPt();
	pi = params.getPi(); 
	
	//numLetters = Pt.size();
	MaxT = 0;
	for(i = 0; i < numLetters; i++){
	  for(j = 0; j < numLetters; j++){
	    Pt[i][j] *= pi[i];
	    MaxT = MAX(MaxT, Pt[i][j]);
	  }
	}


	oldPmat.resize(0);
	nodeZ->getProbFromSubTreeProb(oldPmat);
	Qmat.resize(0);
	nodeC->getProbFromSubTreeProb(Qmat);
	
	nodeZ->FinishForCalSubTreeProbHere();
	//-- v25 end --//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();


	//FixHMG
	O_seqlenZ = nodeZ->getSeqLen();
	oldHMG.resize(O_seqlenZ);
	for(i = 0; i < O_seqlenZ; i++)
	  oldHMG[i] = -1;
      
	//FixHMG
	tmpHMG1.resize(0);
	tmpHMG1 = edgeY->getHMG();  
	


	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	

	//-- v25 start --//
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	//nodeC->findRootSites(); // later
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	//nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
	//UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	//UpdateAllinfoToRoot(params, nodeB1); // later to Z 
	UpdateAllinfoTogivenNode(params, nodeB1, nodeZ);




	nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeZ->CalSubTreeProbHere();
	
	Pmat.resize(0);
	nodeZ->getProbFromSubTreeProb(Pmat);
	
	nodeZ->FinishForCalSubTreeProbHere();





	//-- v25 end --//


  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //


	//FixHMG
	// 1. Get homology structure between oldZ and newZ //
	
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);
	
	
	TempEdge = edgeY->getParentEdge();
	T_seqlenZ = (TempEdge->getHMG()).size();
	for(i = 0; i < T_seqlenZ; i++){
	  if(TempEdge->getHMG()[i] >= 0)
	    tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	  else
	    tmpHMG1.push_back(-1);
        }
	tmpHMG2 = tmpHMG1;
	tmpHMG1.resize(0);
	

	while(TempEdge->getStart() != nodeZ){

	  TempEdge = TempEdge->getParentEdge();
	  T_seqlenZ = (TempEdge->getHMG()).size();
	  for(i = 0; i < T_seqlenZ; i++){
	    if(TempEdge->getHMG()[i] >= 0)
	      tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
	    else
	      tmpHMG1.push_back(-1);
          }
	  tmpHMG2 = tmpHMG1;
	  tmpHMG1.resize(0);
	  
	}
	
	newHMG = tmpHMG2;
	N_seqlenZ = nodeZ->getSeqLen();
	for(i = 0; i < N_seqlenZ; i++){
	  if(newHMG[i] != -1){
	    oldHMG[newHMG[i]] = i;
	  }
	}

	
	tmpHMG1.resize(0);
	tmpHMG2.resize(0);
	
	// 2. Construct several blocks

	// 2. Construct several blocks
	stSeqLen.resize(0);
	enSeqLen.resize(0);
	stPosi.resize(0);
	enPosi.resize(0);
	stPosi.push_back(0);
	enPosi.push_back(0);

	N_psl = 0;
	fixedHMG.resize(0);
	for(i = 0; i < O_seqlenZ; i++)
	  fixedHMG.push_back(0);

	//--- v25 start --//
	DistT.resize(N_seqlenZ + 1);
	for(i = 0; i <= N_seqlenZ; i++)
	  DistT[i].resize(EndSeqLen+1);
	//--- v25 end --//



	
	IX=1;
	T_seqlenZ = oldEdge0HMG.size();

	for(i = 0; i < N_seqlenZ; i++){
      
	  if(newHMG[i] != -1){

	    for(j = enPosi[IX-1]; j < T_seqlenZ; j++){

	      if(newHMG[i] == oldEdge0HMG[j]){

		//--- v25 start --//
		dist = 0;
		for(k = 0; k < numLetters; k++){
		  for(ki = 0; ki < numLetters; ki++)
		    dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
		}
		
	
		DistT[i][j] = log(dist);

		dist = pow(dist/MaxT, powWei);
	     
   


		if(rand.runif()- dist < 0){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  //fixedHMG.push_back(newHMG[i]);
		  fixedHMG[newHMG[i]] = 1;
		  IX++;
		  N_psl += log(dist);
		}else{
		  N_psl += log(1-dist);
		}
		break;
	      }
	    }
	  }
	}
	stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);

	//enPosi.resize(0);
	

	//      cout << "oldEdge0HMG " << endl;
	//print_veci(oldEdge0HMG);
	//cout << "stSeqLen" << endl;
	//print_veci(stSeqLen);
	//cout << "enSeqLen" << endl;
	//print_veci(enSeqLen);
	//cout << "stPosi" << endl;
	//print_veci(stPosi);

	


	oldEdge0HMG.resize(0);
	// 3. Generate new IDH on Edge0 while keeping the original HMG.      
	if(nodeZ == edge0->getEnd()){
     
	  edge0->changeStartEnd();


	  N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  

	  //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());


	  edge0->calHMG(); 

	  edge0->ReverseEdge();
  
	  oldEdge0HMG = edge0->getHMG();

	}else{

	  N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);

	  //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());

	  edge0->calHMG();
	  

	  edge0->ReverseEdge();
	  oldEdge0HMG = edge0->getHMG();
	  edge0->ReverseEdge();
       
	}  


	Pmat.resize(0);
	Pmat = oldPmat;
	oldPmat.resize(0);
	DistT.resize(0);
	//--- v25 start --//
	DistT.resize(O_seqlenZ + 1);
	for(i = 0; i <= O_seqlenZ; i++)
	  DistT[i].resize(EndSeqLen+1);
	//--- v25 end --//
      



	// 4. Calculate proposal prob for old IDH 
	// 4.1  Construct several blocks and save starting position
	stSeqLen.resize(0);
	enSeqLen.resize(0);
	stPosi.resize(0);
	enPosi.resize(0);
	O_psl = 0;
	stPosi.push_back(0);
	enPosi.push_back(0);
	IX=1;
	T_seqlenZ = oldEdge0HMG.size();
	for(i = 0; i < O_seqlenZ; i++){
	  if(oldHMG[i] != -1){
	    for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
	      if(oldHMG[i] == oldEdge0HMG[j]){



		dist = 0;
		for(k = 0; k < numLetters; k++){
		  for(ki = 0; ki < numLetters; ki++)
		    dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
		}
		
	      
		DistT[i][j] = log(dist);

		dist = pow(dist/MaxT, powWei);
	      

		if(fixedHMG[i] == 1){
		  stPosi.push_back(i+1);
		  enPosi.push_back(j+1);
		  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		  IX++;
		  O_psl += log(dist);
		}else{
		  O_psl += log(1-dist);
		}
		break;
	      }
	    }
	  }
	}
	stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	//enPosi.resize(0);

	//cout << "stSeqLen" << endl;
	//print_veci(stSeqLen);
	//cout << "enSeqLen" << endl;
	//print_veci(enSeqLen);
	//cout << "stPosi" << endl;
	//print_veci(stPosi);


	O_psl += calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), oldIDH, Pmat, Qmat, DistT, Pt, pi, O_seqlenZ, T_seqlenZ);


	DistT.resize(0);

	//O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);



	//-- v25 start --//
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	//nodeA->findRootSites();
	//nodeBend->findRootSites();
	nodeC->findRootSites(); // later
	//nodeZ->findRootSites();

	// 1'
	//if(nodeD->getRoot())
	//  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

	// 3
	//nodeA->CalSubTreeProb(params);
	//nodeA->CalloglikeliofRootSitesOrReuse(params);
	//UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	//UpdateAllinfoToRoot(params, nodeB1); // later to Z 
	UpdateAllinfoToRoot(params, nodeZ); 

	//-- v25 end --//

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z
	  //cout << "caseIV " << endl;

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//


	  //-- v25 start --//
	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();
	  
	  Pt = nodeZ->getPt();
	  pi = params.getPi(); 

	  numLetters = Pt.size();
	  MaxT = 0;
	  for(i = 0; i < numLetters; i++){
	    for(j = 0; j < numLetters; j++){
	      Pt[i][j] *= pi[i];
	      MaxT = MAX(MaxT, Pt[i][j]);
	    }
	  }


	  oldPmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(oldPmat);
	  Qmat.resize(0);
	  nodeC->getProbFromSubTreeProb(Qmat);

	  nodeZ->FinishForCalSubTreeProbHere();
        
	  //-- v25 end --//


	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();


	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();


	  //FixHMG
	  tmpHMG3.resize(0);
	  tmpHMG3 = edgeX->getHMG();    


	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));


	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();    
	  nodeBend->findRootSites(); 
	  //nodeC->findRootSites(); // later
	  nodeZ->findRootSites(); 

	  // 1'
	  if(nodeD->getRoot())  
	    nodeD->findLinkedSites();
	  
	  // 2
	  //nodeC->CalloglikeliofRootSitesOrReuse(params);    // later
	  //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  nodeA->CalSubTreeProb(params);  
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  //UpdateAllinfoToRoot(params, nodeZ); // all later



	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(Pmat);
   
	  nodeZ->FinishForCalSubTreeProbHere();

	  //-- v25 end --//


	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //

 
	  //FixHMG
	  // 1. Get homology structure between oldZ and newZ //

	  tmpHMG2.resize(0);
	  tmpHMG2 = edgeT->getHMG();  


	  TempEdge = edgeT->getParentEdge();
	  tmpHMG1.resize(0);

	  while(TempEdge->getEnd() != nodeBend){

	    T_seqlenZ = (TempEdge->getHMG()).size();
	    for(i = 0; i < T_seqlenZ; i++){
	      if(TempEdge->getHMG()[i] >= 0)
		tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
              else
		tmpHMG1.push_back(-1);
	    }
	    tmpHMG2 = tmpHMG1;
	    tmpHMG1.resize(0);	    
	    TempEdge = TempEdge->getParentEdge();
	  }

	  
	  T_seqlenZ = tmpHMG3.size();
	  for(i = 0; i < T_seqlenZ; i++){
	    if(tmpHMG3[i] >= 0)
	      tmpHMG1.push_back(tmpHMG2[tmpHMG3[i]]);
	    else
	      tmpHMG1.push_back(-1);
	    }
	  tmpHMG2 = tmpHMG1;
	  tmpHMG1.resize(0);	    

	  oldHMG.resize(0);
	  newHMG.resize(0);

	  oldHMG = tmpHMG2;
	  N_seqlenZ = nodeZ->getSeqLen();
	  newHMG.resize(N_seqlenZ);
	  for(i = 0; i < N_seqlenZ; i++)
	    newHMG[i] = -1;	  
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      newHMG[oldHMG[i]] = i;
	    }
	  }

	  tmpHMG1.resize(0);
	  tmpHMG2.resize(0);
	  tmpHMG3.resize(0);

	  // 2. Construct several blocks

	  // 2. Construct several blocks
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  

	  N_psl = 0;
	  fixedHMG.resize(0);
	  for(i = 0; i < O_seqlenZ; i++)
	    fixedHMG.push_back(0);
	  


	  //--- v25 start --//
	  DistT.resize(N_seqlenZ + 1);
	  for(i = 0; i <= N_seqlenZ; i++)
	    DistT[i].resize(EndSeqLen+1);
	  //--- v25 end --//
	  


	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();

	  for(i = 0; i < N_seqlenZ; i++){
	 
	    if(newHMG[i] != -1){

	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){

		if(newHMG[i] == oldEdge0HMG[j]){


		  //--- v25 start --//
		  dist = 0;
		  for(k = 0; k < numLetters; k++){
		    for(ki = 0; ki < numLetters; ki++)
		      dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
		  }
		  
		  
		  DistT[i][j] = log(dist);

		  dist = pow(dist/MaxT, powWei);
	     

		  if(rand.runif()- dist < 0){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    //fixedHMG.push_back(newHMG[i]);  
		    fixedHMG[newHMG[i]] = 1;
		    IX++;
		    N_psl += log(dist);
		  }else{
		    N_psl += log(1-dist);
		  }		    
		  break;
		}
	      }

	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);

	  //enPosi.resize(0);
	  

	  //      cout << "oldEdge0HMG " << endl;
	  //print_veci(oldEdge0HMG);
	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);

	  

	  oldEdge0HMG.resize(0);
	  // 3. Generate new IDH on Edge0 while keeping the original HMG.      
	  if(nodeZ == edge0->getEnd()){
     
	    edge0->changeStartEnd();

	    N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  
	    //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());
 
	    edge0->calHMG(); 
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	   
	    edge0->ReverseEdge();
	    oldEdge0HMG = edge0->getHMG();
     
	  }else{


	    N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);

	    //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());

	    edge0->calHMG();
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	   
	    edge0->ReverseEdge();
	    oldEdge0HMG = edge0->getHMG();
	    edge0->ReverseEdge();
	  }  



	  Pmat.resize(0);
	  Pmat = oldPmat;
	  oldPmat.resize(0);
	  DistT.resize(0);
	  //--- v25 start --//
	  DistT.resize(O_seqlenZ + 1);
	  for(i = 0; i <= O_seqlenZ; i++)
	    DistT[i].resize(EndSeqLen+1);
	  //--- v25 end --//
      

	  

	  // 4. Calculate proposal prob for old IDH 
	  // 4.1  Construct several blocks and save starting position
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);

	  O_psl = 0;
  
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){

	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
       
		if(oldHMG[i] == oldEdge0HMG[j]){
	

		  dist = 0;
		  for(k = 0; k < numLetters; k++){
		    for(ki = 0; ki < numLetters; ki++)
		      dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
		  }
	      
	      
		  DistT[i][j] = log(dist);

		  dist = pow(dist/MaxT, powWei);
		  //dist = sqrt(dist/MaxT);
	      
     
		  if(fixedHMG[i] == 1){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    IX++;
	       
		    O_psl += log(dist);
		  }else{
		    O_psl += log(1-dist);
		  }
	 
		  break;
		}
	      }

	    }
	  }
	  stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  //enPosi.resize(0);


	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);



	  O_psl += calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), oldIDH, Pmat, Qmat, DistT, Pt, pi, O_seqlenZ, T_seqlenZ);



	  DistT.resize(0);


	  //O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);


	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  //nodeA->findRootSites();    
	  //nodeBend->findRootSites(); 
	  nodeC->findRootSites(); // later
	  //nodeZ->findRootSites(); 

	  // 1'
	  //if(nodeD->getRoot())  
	  //  nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);    // later
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  //nodeA->CalSubTreeProb(params);  
	  //nodeA->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ); // all later

	  //-- v25 end --//

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	}else{        // didn't hit Z

	  //	  	  cout << "caseII " << endl;

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	 


	  //-- v25 start --//
	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pt = nodeZ->getPt();
	  pi = params.getPi(); 

	  //numLetters = Pt.size();
	  MaxT = 0;
	  for(i = 0; i < numLetters; i++){
	    for(j = 0; j < numLetters; j++){
	      Pt[i][j] *= pi[i];
	      MaxT = MAX(MaxT, Pt[i][j]);
	    }
	  }
	  

	  oldPmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(oldPmat);
	  Qmat.resize(0);
	  nodeC->getProbFromSubTreeProb(Qmat);
	  
	  nodeZ->FinishForCalSubTreeProbHere();
        
	  //-- v25 end --//

 

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

  
	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();
	  oldHMG.resize(O_seqlenZ);
	  for(i = 0; i < O_seqlenZ; i++)
	    oldHMG[i] = -1;

	  tmpHMG3.resize(0);
	  tmpHMG3 = edgeY->getHMG();  


	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));






	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  //nodeC->findRootSites(); // later
	  nodeZ->findRootSites(); 

	  // 1'
	  if(nodeBa->getRoot())   
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  //nodeC->CalloglikeliofRootSitesOrReuse(params); // later
	  //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  //UpdateAllinfoTogivenNode(params, nodeZ, nodeBm); // later
	  
	  // 9 and 10
	  //UpdateAllinfoToRoot(params, nodeBm);	    // later


	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(Pmat);
   
	  nodeZ->FinishForCalSubTreeProbHere();


	  //-- v25 end --//




	  //FixHMG
	  N_seqlenZ = nodeZ->getSeqLen();
	  newHMG.resize(N_seqlenZ);
	  for(i = 0; i < N_seqlenZ; i++)
	    newHMG[i] = -1;



	  //----- Reconstruct a tree --------------//


	  tmpHMG2.resize(0);
	  tmpHMG2 = edgeT->getHMG();  


	  if(!edgeT->getStart()->getRoot()){

	    TempEdge = edgeT->getParentEdge();
	    tmpHMG1.resize(0);

	    while(TempEdge->getEnd() != nodeBm){

	      T_seqlenZ = (TempEdge->getHMG()).size();
	      for(i = 0; i < T_seqlenZ; i++){
		if(TempEdge->getHMG()[i] >= 0)
		  tmpHMG1.push_back(tmpHMG2[TempEdge->getHMG()[i]]);
		else
		  tmpHMG1.push_back(-1);
	      }
	      tmpHMG2 = tmpHMG1;
	      tmpHMG1.resize(0);
	      if(TempEdge->getStart()->getRoot())
		break;
              else
		TempEdge = TempEdge->getParentEdge();
	    }
          }
	    


	  if(!edgeY->getStart()->getRoot()){

	    TempEdge = edgeY->getParentEdge();
	    tmpHMG1.resize(0);


	    while(TempEdge->getEnd() != nodeBm){

	      T_seqlenZ = (TempEdge->getHMG()).size();
	      for(i = 0; i < T_seqlenZ; i++){
		if(TempEdge->getHMG()[i] >= 0)
		  tmpHMG1.push_back(tmpHMG3[TempEdge->getHMG()[i]]);
		else
		  tmpHMG1.push_back(-1);
	      }
	      tmpHMG3 = tmpHMG1;
	      tmpHMG1.resize(0);
	      if(TempEdge->getStart()->getRoot())
		break;
              else
		TempEdge = TempEdge->getParentEdge();	    
	    }

	  }
	    
	  T_seqlenZ = tmpHMG3.size();
	  
	  for(i = 0; i < T_seqlenZ; i++){
	    if((tmpHMG3[i] != -1) & (tmpHMG2[i] != -1)){
	      oldHMG[tmpHMG3[i]] = tmpHMG2[i];
	      newHMG[tmpHMG2[i]] = tmpHMG3[i];
	    }
	  }

	  
	  tmpHMG1.resize(0);
	  tmpHMG2.resize(0);
	  tmpHMG3.resize(0);
	  
	  
	  // 2. Construct several blocks




	  // 2. Construct several blocks
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);
	  stPosi.push_back(0);
	  enPosi.push_back(0);

	  N_psl = 0;
	  fixedHMG.resize(0);
	  for(i = 0; i < O_seqlenZ; i++)
	    fixedHMG.push_back(0);

	  DistT.resize(0);
	  //--- v25 start --//
	  DistT.resize(N_seqlenZ + 1);
	  for(i = 0; i <= N_seqlenZ; i++)
	    DistT[i].resize(EndSeqLen+1);
	  //--- v25 end --//
      



	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < N_seqlenZ; i++){
	    if(newHMG[i] != -1){
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		if(newHMG[i] == oldEdge0HMG[j]){

		  //--- v25 start --//
		  dist = 0;
		  for(k = 0; k < numLetters; k++){
		    for(ki = 0; ki < numLetters; ki++)
		      dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
		  }

		  
		  DistT[i][j] = log(dist);

		  dist = pow(dist/MaxT, powWei);
		  //dist = sqrt(dist/MaxT);


		  if(rand.runif()- dist < 0){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    //fixedHMG.push_back(newHMG[i]);
		    fixedHMG[newHMG[i]] = 1;
		    IX++;
		    N_psl += log(dist);
		  }else{
		    N_psl += log(1-dist);
		  }
		  break;
		}
	      }
	    }
	  }
	  stSeqLen.push_back(newHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);
	  //enPosi.resize(0);
	  

	  //      cout << "oldEdge0HMG " << endl;
	  //print_veci(oldEdge0HMG);
	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);


	  
	  oldEdge0HMG.resize(0);
	  // 3. Generate new IDH on Edge0 while keeping the original HMG.      
	  if(nodeZ == edge0->getEnd()){
     
	    edge0->changeStartEnd();

	    N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  

	    //N_psl = generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());


	    edge0->calHMG(); 
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	    
	    edge0->ReverseEdge();
	    oldEdge0HMG = edge0->getHMG();
	  }else{

	    N_psl += generateNewIDHonEdgeWhileKeepingHMGandAdjust(rand, params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), edge0->getIDH(), Pmat, Qmat, DistT, Pt, pi, N_seqlenZ, T_seqlenZ);
  

	    //N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), edge0->getIDH());

	    edge0->calHMG();
	    
	    //cout << "N_psl " << N_psl << endl;
	    //edge0->getIDH()->printIDH();
	   
	    edge0->ReverseEdge();
	    oldEdge0HMG = edge0->getHMG();
	    edge0->ReverseEdge();
	  }  



	  Pmat.resize(0);
	  Pmat = oldPmat;
	  oldPmat.resize(0);
	  DistT.resize(0);
	  //--- v25 start --//
	  DistT.resize(O_seqlenZ + 1);
	  for(i = 0; i <= O_seqlenZ; i++)
	    DistT[i].resize(EndSeqLen+1);
	  //--- v25 end --//
      




	  // 4. Calculate proposal prob for old IDH 
	  // 4.1  Construct several blocks and save starting position
	  stSeqLen.resize(0);
	  enSeqLen.resize(0);
	  stPosi.resize(0);
	  enPosi.resize(0);

	  O_psl = 0;
	  stPosi.push_back(0);
	  enPosi.push_back(0);
	  IX=1;
	  T_seqlenZ = oldEdge0HMG.size();
	  for(i = 0; i < O_seqlenZ; i++){
	    if(oldHMG[i] != -1){
	      for(j = enPosi[IX-1]; j < T_seqlenZ; j++){
		if(oldHMG[i] == oldEdge0HMG[j]){



		  dist = 0;
		  for(k = 0; k < numLetters; k++){
		    for(ki = 0; ki < numLetters; ki++)
		      dist += Pt[k][ki]*Pmat[i][k]*Qmat[j][ki];
		  }
	      
	      
		  DistT[i][j] = log(dist);

		  dist = pow(dist/MaxT, powWei);
		  //dist = sqrt(dist/MaxT);
	      


		  if(fixedHMG[i] == 1){
		    stPosi.push_back(i+1);
		    enPosi.push_back(j+1);
		    stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		    enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		    IX++;
		    O_psl += log(dist);
		  }else{
		    O_psl += log(1-dist);
		  }
		  break;
		}
	      }
	    }
	  }
	  stSeqLen.push_back(oldHMG.size()-stPosi[IX-1]);
	  enSeqLen.push_back(oldEdge0HMG.size()-enPosi[IX-1]);   
	  //enPosi.resize(0);

	  //cout << "stSeqLen" << endl;
	  //print_veci(stSeqLen);
	  //cout << "enSeqLen" << endl;
	  //print_veci(enSeqLen);
	  //cout << "stPosi" << endl;
	  //print_veci(stPosi);


	  O_psl += calProbIDHonEdgeWhileKeepingHMGandAdjust(params, stSeqLen, enSeqLen, stPosi, enPosi, edge0->getEdgeLen(), oldIDH, Pmat, Qmat, DistT, Pt, pi, O_seqlenZ, T_seqlenZ);


	  DistT.resize(0);

	  //O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
	




	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  //nodeA->findRootSites();
	  //nodeD->findRootSites();
	  nodeC->findRootSites(); // later
	  //nodeZ->findRootSites(); 

	  // 1'
	  //if(nodeBa->getRoot())   
	  //  nodeBa->findLinkedSites();
	  //else if(nodeBd->getRoot())
	  //  nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params); // later
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  //nodeA->CalSubTreeProb(params);
	  //nodeA->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  //nodeD->CalSubTreeProb(params);
	  //nodeD->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  //UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm); // later
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	    // later

	  //-- v25 end --//

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      


	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    //if(nodeZ == edge0->getEnd()){
    //  edge0->ReverseEdge();
    //  N_psl= edge0->ProposHistory(params);
    //  edge0->ReverseEdge();
    //}else{
    //  N_psl= edge0->ProposHistory(params);
    //}     


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    //    cout << "AP : " << AP << endl;
    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  


  //cout << "done" << endl;

  Mset.resize(0);

  oldHMG.resize(0);
  newHMG.resize(0);
  tmpHMG1.resize(0);
  tmpHMG2.resize(0);
  tmpHMG3.resize(0);
  oldEdge0HMG.resize(0);
  stSeqLen.resize(0);
  enSeqLen.resize(0);
  stPosi.resize(0);
  enPosi.resize(0);

  delBasePosi.resize(0);
  delBasePosi_in.resize(0);

  DistT.resize(0);
  Pt.resize(0);
  pi.resize(0);
  oldPmat.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);



  delete oldIDH;

  return AP;  

} // SPRonSubTree
//--- v25 end --//




//-- v34 start--//
double Tree::SPRonSubTreebyDPbestLetters(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c2, int start) {


  //cout << "SPRonSubTreebyDP" << endl;


  int i, j;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;


  //-- v25 start --//
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<double> > oldPmat(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  //int numLetters;
  int k, ki;
  int EndSeqLen;
  //-- v25 end --//

  //-- v28 start --//
  vector<char> SeqP(0);
  vector<char> SeqPold(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  AlignDPTable *pBW_O;
  AlignDPTable *pBW_N;
  double lambda, mu, rd, ri;
  int seqLen;
  //-- v28 end --//

  InDelHistory* oldIDH = new InDelHistory();
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  //-- v29 start --//
  int inttmp, h;
  //-- v29 end --//



  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];  
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  // Pick M on edge0, which is the end point of window
  //double posiM = rand.runif()*(edge0->getEdgeLen()); 

  //cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
  

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 



  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];


  //cout << "selectedposi : " << selectedposi << "TargetEdgeNum : " << TargetEdgeNum << endl


  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "AAA " << endl;
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreebyDPbestLetters(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, c2, start);


  }else{                  // else if edge which is connected to Z is selected



    //cout << "BBB " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);
    //cout << "edgeT number " << edgeT->getnumber() << endl;


    EndSeqLen = nodeC->getSeqLen();

    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }

    //cout << "posiNewZ : " << posiNewZ << endl;

 
    lenXt = edgeT->getEdgeLen();

    O_IDHlike = edge0->likeliHistory(params);


    //-- v28 start --//
    chars.resize(4);
    chars[0] = 'A';
    chars[1] = 'C';
    chars[2] = 'G';
    chars[3] = 'T';   
    lambda = params.getLambda();
    mu = params.getMu();
    ri = params.getRi();
    rd = params.getRd();
    
    iDelta = (1 - exp(-(lambda + mu)*edge0->getEdgeLen()))/(double)2;
    iEpsilon = 1 - (rd + ri)/(double)2;
    iTau = 0.3;
	
    //-- v28 end --//

    if(nodeZ == edge0->getStart()){
      (*oldIDH) = (*edge0->getIDH());

      //-- v28 start --//
      Aligns.resize(0);
      getPairwiseAlignmentsFromHMG(edge0->getHMG(), edge0->getStart()->getSeqLen(), edge0->getEnd()->getSeqLen(), Aligns);
      tempI.resize(2);
      tempI[0] = 0;
      tempI[1] = 0;
      Aligns.push_back(tempI);    
      //-- v28 end --//
    }else{
      edge0->ReverseEdge();
      (*oldIDH) = (*edge0->getIDH());
      //-- v28 start --//
      Aligns.resize(0);
      getPairwiseAlignmentsFromHMG(edge0->getHMG(), edge0->getStart()->getSeqLen(), edge0->getEnd()->getSeqLen(), Aligns);
      tempI.resize(2);
      tempI[0] = 0;
      tempI[1] = 0;
      Aligns.push_back(tempI);    
      //-- v28 end --//
      edge0->ReverseEdge();
    }      


    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){


      //cout << "caseIa " << endl;

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//

      //-- v25 start --//
      nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeZ->CalSubTreeProbHere();

      Pt = nodeZ->getPt();
      pi = params.getPi(); 
	   

      oldPmat.resize(0);
      nodeZ->getProbFromSubTreeProb(oldPmat);

      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	Qmat.resize(0);
	nodeC->getProbFromSubTreeProb(Qmat);

      }
      //-- v29 end --//

      nodeZ->FinishForCalSubTreeProbHere();
        
      //-- v25 end --//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();



      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();




      O_seqlenZ = nodeZ->getSeqLen();
     
      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();


      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      N_seqlenZ = nodeZ->getSeqLen();
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }




      //-- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      //nodeC->findRootSites(); // later
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      //if(nodeZ->getRoot())  // later
      //nodeZ->findLinkedSites(); // later

      // 2
      //nodeC->CalloglikeliofRootSitesOrReuse(params); // later
      //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

      //3
      nodeA->CalSubTreeProb(params);  
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      //UpdateAllinfoToRoot(params, nodeBend);  // Bend to Z...later start from Z;
      UpdateAllinfoTogivenNode(params, nodeBend, nodeZ);

      

      nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeZ->CalSubTreeProbHere();

      Pmat.resize(0);
      nodeZ->getProbFromSubTreeProb(Pmat);
   
      nodeZ->FinishForCalSubTreeProbHere();

      //-- v25 end --//


    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
      

 

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(oldPmat[i]);
	if(inttmp != -1)
	  SeqPold[i] = chars[inttmp];
	else
	  SeqPold[i] = chars[rand.rwunif(oldPmat[i])];
      }
      


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++){
	  inttmp = which_halfprop(Qmat[i]);
	  if(inttmp != -1)
	    SeqQ[i] = chars[inttmp];
	  else
	    SeqQ[i] = chars[rand.rwunif(Qmat[i])];
        }
	
      }else{

	
	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);
	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/

	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }

      //-- v29 end --//

      

      //cout << "SeqP " << endl;
      //for(i = 0; i < SeqP.size(); i++)
      //	cout << SeqP[i] << " ";
      //cout << endl;

      //cout << "SeqPold " << endl;
      //for(i = 0; i < SeqPold.size(); i++)
      //	cout << SeqPold[i] << " ";
      //cout << endl;

    
      //cout << "SeqQ " << endl;
      //for(i = 0; i < SeqQ.size(); i++)
      //	cout << SeqQ[i] << " ";
      // cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }




      //--- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //nodeA->findRootSites();
      nodeC->findRootSites(); // later
      //TempNode = nodeD;
      //while(TempNode != nodeZ){
      //	TempNode->findRootSites();
      //	TempNode = TempNode->getParent();
      //}

      // 1'
      if(nodeZ->getRoot())  // later
	nodeZ->findLinkedSites(); // later

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params); // later
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

      //3
      //nodeA->CalSubTreeProb(params);  
      //nodeA->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      //nodeD->CalSubTreeProb(params);
      //nodeD->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      //UpdateAllinfoToRoot(params, nodeBend);  // Bend to Z...later start from Z;
      UpdateAllinfoToRoot(params, nodeZ);
      //-- v25 end --//

     

      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 
    
    }else if(edge0 == nodeZ->getParentEdge()){

 
      //cout << "caseI " << endl;

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//

      //-- v25 start --//


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	nodeC->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeC->CalSubTreeProbHere();

	Pt = nodeC->getPt();
	pi = params.getPi();
 
	Qmat.resize(0);
	nodeC->getProbFromSubTreeProb(Qmat);

	nodeC->FinishForCalSubTreeProbHere();

      }else{

	nodeC->CalPt(edge0->getEdgeLen(),params);

	Pt = nodeC->getPt();
	nodeC->Ptreset();
	pi = params.getPi();
 
      }
      //-- v29 end --//

      oldPmat.resize(0);
      nodeZ->getProbFromSubTreeProb(oldPmat);

        
      //-- v25 end --//


      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     

      O_seqlenZ = nodeZ->getSeqLen();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }


      //-- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      //nodeZ->findRootSites();  // later

      // 1'
      //if(nodeC->getRoot())  // later
      //	nodeC->findLinkedSites();  // later

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      //UpdateAllinfoToRoot(params, nodeBend); // later to nodeZ from nodeZ 
      UpdateAllinfoTogivenNode(params, nodeBend, nodeZ);
      nodeZ->CalSubTreeProb(params);



      Pmat.resize(0);
      nodeZ->getProbFromSubTreeProb(Pmat);
   
      //-- v25 end --//



    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}




      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
       
      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(oldPmat[i]);
	if(inttmp != -1)
	  SeqPold[i] = chars[inttmp];
	else
	  SeqPold[i] = chars[rand.rwunif(oldPmat[i])];
      }
     


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	
	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++){
	  inttmp = which_halfprop(Qmat[i]);
	  if(inttmp != -1)
	    SeqQ[i] = chars[inttmp];
	  else
	    SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	}
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/


	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//


      }
      //-- v29 end --//
      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//


      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }



      //--- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //nodeA->findRootSites();
      //TempNode = nodeD;
      //while(TempNode != nodeZ){
      //	TempNode->findRootSites();
      //	TempNode = TempNode->getParent();
      // }
      nodeZ->findRootSites();  // later

      // 1'
      if(nodeC->getRoot())  // later
	nodeC->findLinkedSites();  // later

      // 2
      //nodeA->CalSubTreeProb(params);
      //nodeA->CalloglikeliofRootSitesOrReuse(params);
      // UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      // nodeD->CalSubTreeProb(params);
      //nodeD->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      //UpdateAllinfoToRoot(params, nodeBend); // later to nodeC from nodeC
      nodeZ->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
      UpdateAllinfoToRoot(params, nodeC);
  

      //-- v25 end --//

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT


	//	cout << "caseIII " << endl;
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//


	//-- v25 start --//
	nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeZ->CalSubTreeProbHere();
	
	Pt = nodeZ->getPt();
	pi = params.getPi(); 
	

	oldPmat.resize(0);
	nodeZ->getProbFromSubTreeProb(oldPmat);


	//-- v29 start --//
	if(nodeC->getnumber() >= numLeaves){

	  Qmat.resize(0);
	  nodeC->getProbFromSubTreeProb(Qmat);

        }
	//-- v29 end --//
	
	nodeZ->FinishForCalSubTreeProbHere();
	//-- v25 end --//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();


	O_seqlenZ = nodeZ->getSeqLen();



	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	

	//-- v25 start --//
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	//nodeC->findRootSites(); // later
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	//nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
	//UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	//UpdateAllinfoToRoot(params, nodeB1); // later to Z 
	UpdateAllinfoTogivenNode(params, nodeB1, nodeZ);




	nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeZ->CalSubTreeProbHere();
	
	Pmat.resize(0);
	nodeZ->getProbFromSubTreeProb(Pmat);
	
	nodeZ->FinishForCalSubTreeProbHere();

	//-- v25 end --//


    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
      
      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(oldPmat[i]);
	if(inttmp != -1)
	  SeqPold[i] = chars[inttmp];
	else
	  SeqPold[i] = chars[rand.rwunif(oldPmat[i])];
      }

      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++){
	  inttmp = which_halfprop(Qmat[i]);
	  if(inttmp != -1)
	    SeqQ[i] = chars[inttmp];
	  else
	    SeqQ[i] = chars[rand.rwunif(Qmat[i])];
        }
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/



	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//











      }
      //-- v29 end --//


      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//


      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }




	//-- v25 start --//
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	//nodeA->findRootSites();
	//nodeBend->findRootSites();
	nodeC->findRootSites(); // later
	//nodeZ->findRootSites();

	// 1'
	//if(nodeD->getRoot())
	//  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

	// 3
	//nodeA->CalSubTreeProb(params);
	//nodeA->CalloglikeliofRootSitesOrReuse(params);
	//UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	//UpdateAllinfoToRoot(params, nodeB1); // later to Z 
	UpdateAllinfoToRoot(params, nodeZ); 

	//-- v25 end --//

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z
	  // cout << "caseIV " << endl;

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//


	  //-- v25 start --//
	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();
	  
	  Pt = nodeZ->getPt();
	  pi = params.getPi(); 



	  oldPmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(oldPmat);

	  //-- v29 start --//
	  if(nodeC->getnumber() >= numLeaves){

	    Qmat.resize(0);
	    nodeC->getProbFromSubTreeProb(Qmat);

          }
	  //-- v29 end --//

	  nodeZ->FinishForCalSubTreeProbHere();
        
	  //-- v25 end --//


	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();


	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));


	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();    
	  nodeBend->findRootSites(); 
	  //nodeC->findRootSites(); // later
	  nodeZ->findRootSites(); 

	  // 1'
	  if(nodeD->getRoot())  
	    nodeD->findLinkedSites();
	  
	  // 2
	  //nodeC->CalloglikeliofRootSitesOrReuse(params);    // later
	  //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  nodeA->CalSubTreeProb(params);  
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  //UpdateAllinfoToRoot(params, nodeZ); // all later



	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(Pmat);
   
	  nodeZ->FinishForCalSubTreeProbHere();

	  //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
      
     
      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(oldPmat[i]);
	if(inttmp != -1)
	  SeqPold[i] = chars[inttmp];
	else
	  SeqPold[i] = chars[rand.rwunif(oldPmat[i])];
      }
      
    

      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++){
	  inttmp = which_halfprop(Qmat[i]);
	  if(inttmp != -1)
	    SeqQ[i] = chars[inttmp];
	  else
	    SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	}
	 
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/



	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//





      }
      //-- v29 end --//

      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
      

      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }



	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  //nodeA->findRootSites();    
	  //nodeBend->findRootSites(); 
	  nodeC->findRootSites(); // later
	  //nodeZ->findRootSites(); 

	  // 1'
	  //if(nodeD->getRoot())  
	  //  nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);    // later
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  //nodeA->CalSubTreeProb(params);  
	  //nodeA->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ); // all later

	  //-- v25 end --//

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	}else{        // didn't hit Z

	  // cout << "caseII " << endl;

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	 


	  //-- v25 start --//
	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pt = nodeZ->getPt();
	  pi = params.getPi(); 


	  oldPmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(oldPmat);

	  //-- v29 start --//
	  if(nodeC->getnumber() >= numLeaves){

	    Qmat.resize(0);
	    nodeC->getProbFromSubTreeProb(Qmat);

          }
	  //-- v29 end --//
	  
	  nodeZ->FinishForCalSubTreeProbHere();
        
	  //-- v25 end --//

 

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

  
	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();
  

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));






	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  //nodeC->findRootSites(); // later
	  nodeZ->findRootSites(); 

	  // 1'
	  if(nodeBa->getRoot())   
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  //nodeC->CalloglikeliofRootSitesOrReuse(params); // later
	  //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  //UpdateAllinfoTogivenNode(params, nodeZ, nodeBm); // later
	  
	  // 9 and 10
	  //UpdateAllinfoToRoot(params, nodeBm);	    // later


	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(Pmat);
   
	  nodeZ->FinishForCalSubTreeProbHere();


	  //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(Pmat[i]);
	if(inttmp != -1)
	  SeqP[i] = chars[inttmp];
	else
	  SeqP[i] = chars[rand.rwunif(Pmat[i])];
      }
      
    
      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++){
	inttmp = which_halfprop(oldPmat[i]);
	if(inttmp != -1)
	  SeqPold[i] = chars[inttmp];
	else
	  SeqPold[i] = chars[rand.rwunif(oldPmat[i])];
      }
     

      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++){
	  inttmp = which_halfprop(Qmat[i]);
	  if(inttmp != -1)
	    SeqQ[i] = chars[inttmp];
	  else
	    SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	}

   
      }else{


	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/

	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//





      }
      //-- v29 end --//

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
    
      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }






	  //FixHMG
	  N_seqlenZ = nodeZ->getSeqLen();


	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  //nodeA->findRootSites();
	  //nodeD->findRootSites();
	  nodeC->findRootSites(); // later
	  //nodeZ->findRootSites(); 

	  // 1'
	  //if(nodeBa->getRoot())   
	  //  nodeBa->findLinkedSites();
	  //else if(nodeBd->getRoot())
	  //  nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params); // later
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  //nodeA->CalSubTreeProb(params);
	  //nodeA->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  //nodeD->CalSubTreeProb(params);
	  //nodeD->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  //UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm); // later
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	    // later

	  //-- v25 end --//

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      


	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    //if(nodeZ == edge0->getEnd()){
    //  edge0->ReverseEdge();
    //  N_psl= edge0->ProposHistory(params);
    //  edge0->ReverseEdge();
    //}else{
    //  N_psl= edge0->ProposHistory(params);
    //}     


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    //    cout << "AP : " << AP << endl;
    //cout << "N_datalike : " << N_datalike << "O_datalike : " << O_datalike << endl;
    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  


  //cout << "done" << endl;

  Mset.resize(0);

  Pt.resize(0);
  pi.resize(0);
  oldPmat.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  SeqP.resize(0);
  SeqPold.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0);



  delete oldIDH;

  return AP;  

} // SPRonSubTree
//--- v34 end--//





//-- v28 start v29 start--//
double Tree::SPRonSubTreebyDP(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c2, int start) {


  //cout << "SPRonSubTreebyDP" << endl;


  int i, j;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;


  //-- v25 start --//
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<double> > oldPmat(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  //int numLetters;
  int k, ki;
  int EndSeqLen;
  //-- v25 end --//

  //-- v28 start --//
  vector<char> SeqP(0);
  vector<char> SeqPold(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  AlignDPTable *pBW_O;
  AlignDPTable *pBW_N;
  double lambda, mu, rd, ri;
  int seqLen;
  //-- v28 end --//

  InDelHistory* oldIDH = new InDelHistory();
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  //-- v29 start --//
  int inttmp, h;
  //-- v29 end --//



  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];  
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  // Pick M on edge0, which is the end point of window
  //double posiM = rand.runif()*(edge0->getEdgeLen()); 

  //cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
  

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 



  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];


  //cout << "selectedposi : " << selectedposi << "TargetEdgeNum : " << TargetEdgeNum << endl


  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "AAA " << endl;
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreebyDP(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, c2, start);


  }else{                  // else if edge which is connected to Z is selected



    //cout << "BBB " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);
    //cout << "edgeT number " << edgeT->getnumber() << endl;


    EndSeqLen = nodeC->getSeqLen();

    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }

    //cout << "posiNewZ : " << posiNewZ << endl;

 
    lenXt = edgeT->getEdgeLen();

    O_IDHlike = edge0->likeliHistory(params);


    //-- v28 start --//
    chars.resize(4);
    chars[0] = 'A';
    chars[1] = 'C';
    chars[2] = 'G';
    chars[3] = 'T';   
    lambda = params.getLambda();
    mu = params.getMu();
    ri = params.getRi();
    rd = params.getRd();
    
    iDelta = (1 - exp(-(lambda + mu)*edge0->getEdgeLen()))/(double)2;
    iEpsilon = 1 - (rd + ri)/(double)2;
    iTau = 0.3;
	
    //-- v28 end --//

    if(nodeZ == edge0->getStart()){
      (*oldIDH) = (*edge0->getIDH());

      //-- v28 start --//
      Aligns.resize(0);
      getPairwiseAlignmentsFromHMG(edge0->getHMG(), edge0->getStart()->getSeqLen(), edge0->getEnd()->getSeqLen(), Aligns);
      tempI.resize(2);
      tempI[0] = 0;
      tempI[1] = 0;
      Aligns.push_back(tempI);    
      //-- v28 end --//
    }else{
      edge0->ReverseEdge();
      (*oldIDH) = (*edge0->getIDH());
      //-- v28 start --//
      Aligns.resize(0);
      getPairwiseAlignmentsFromHMG(edge0->getHMG(), edge0->getStart()->getSeqLen(), edge0->getEnd()->getSeqLen(), Aligns);
      tempI.resize(2);
      tempI[0] = 0;
      tempI[1] = 0;
      Aligns.push_back(tempI);    
      //-- v28 end --//
      edge0->ReverseEdge();
    }      


    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){


      //cout << "caseIa " << endl;

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//

      //-- v25 start --//
      nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeZ->CalSubTreeProbHere();

      Pt = nodeZ->getPt();
      pi = params.getPi(); 
	   

      oldPmat.resize(0);
      nodeZ->getProbFromSubTreeProb(oldPmat);

      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	Qmat.resize(0);
	nodeC->getProbFromSubTreeProb(Qmat);

      }
      //-- v29 end --//

      nodeZ->FinishForCalSubTreeProbHere();
        
      //-- v25 end --//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();



      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();




      O_seqlenZ = nodeZ->getSeqLen();
     
      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();


      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      N_seqlenZ = nodeZ->getSeqLen();
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }




      //-- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      //nodeC->findRootSites(); // later
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      //if(nodeZ->getRoot())  // later
      //nodeZ->findLinkedSites(); // later

      // 2
      //nodeC->CalloglikeliofRootSitesOrReuse(params); // later
      //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

      //3
      nodeA->CalSubTreeProb(params);  
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      //UpdateAllinfoToRoot(params, nodeBend);  // Bend to Z...later start from Z;
      UpdateAllinfoTogivenNode(params, nodeBend, nodeZ);

      

      nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeZ->CalSubTreeProbHere();

      Pmat.resize(0);
      nodeZ->getProbFromSubTreeProb(Pmat);
   
      nodeZ->FinishForCalSubTreeProbHere();

      //-- v25 end --//


    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];

      }else{

	
	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);
	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/

	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }

      //-- v29 end --//

      

      //cout << "SeqP " << endl;
      //for(i = 0; i < SeqP.size(); i++)
      //	cout << SeqP[i] << " ";
      //cout << endl;

      //cout << "SeqPold " << endl;
      //for(i = 0; i < SeqPold.size(); i++)
      //	cout << SeqPold[i] << " ";
      //cout << endl;

    
      //cout << "SeqQ " << endl;
      //for(i = 0; i < SeqQ.size(); i++)
      //	cout << SeqQ[i] << " ";
      // cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }




      //--- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //nodeA->findRootSites();
      nodeC->findRootSites(); // later
      //TempNode = nodeD;
      //while(TempNode != nodeZ){
      //	TempNode->findRootSites();
      //	TempNode = TempNode->getParent();
      //}

      // 1'
      if(nodeZ->getRoot())  // later
	nodeZ->findLinkedSites(); // later

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params); // later
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

      //3
      //nodeA->CalSubTreeProb(params);  
      //nodeA->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      //nodeD->CalSubTreeProb(params);
      //nodeD->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      //UpdateAllinfoToRoot(params, nodeBend);  // Bend to Z...later start from Z;
      UpdateAllinfoToRoot(params, nodeZ);
      //-- v25 end --//

     

      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 
    
    }else if(edge0 == nodeZ->getParentEdge()){

 
      //cout << "caseI " << endl;

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//

      //-- v25 start --//


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	nodeC->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeC->CalSubTreeProbHere();

	Pt = nodeC->getPt();
	pi = params.getPi();
 
	Qmat.resize(0);
	nodeC->getProbFromSubTreeProb(Qmat);

	nodeC->FinishForCalSubTreeProbHere();

      }else{

	nodeC->CalPt(edge0->getEdgeLen(),params);

	Pt = nodeC->getPt();
	nodeC->Ptreset();
	pi = params.getPi();
 
      }
      //-- v29 end --//

      oldPmat.resize(0);
      nodeZ->getProbFromSubTreeProb(oldPmat);

        
      //-- v25 end --//


      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     

      O_seqlenZ = nodeZ->getSeqLen();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }


      //-- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      //nodeZ->findRootSites();  // later

      // 1'
      //if(nodeC->getRoot())  // later
      //	nodeC->findLinkedSites();  // later

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      //UpdateAllinfoToRoot(params, nodeBend); // later to nodeZ from nodeZ 
      UpdateAllinfoTogivenNode(params, nodeBend, nodeZ);
      nodeZ->CalSubTreeProb(params);



      Pmat.resize(0);
      nodeZ->getProbFromSubTreeProb(Pmat);
   
      //-- v25 end --//



    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}




      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	
	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/


	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//


      }
      //-- v29 end --//
      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//


      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }



      //--- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //nodeA->findRootSites();
      //TempNode = nodeD;
      //while(TempNode != nodeZ){
      //	TempNode->findRootSites();
      //	TempNode = TempNode->getParent();
      // }
      nodeZ->findRootSites();  // later

      // 1'
      if(nodeC->getRoot())  // later
	nodeC->findLinkedSites();  // later

      // 2
      //nodeA->CalSubTreeProb(params);
      //nodeA->CalloglikeliofRootSitesOrReuse(params);
      // UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      // nodeD->CalSubTreeProb(params);
      //nodeD->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      //UpdateAllinfoToRoot(params, nodeBend); // later to nodeC from nodeC
      nodeZ->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
      UpdateAllinfoToRoot(params, nodeC);
  

      //-- v25 end --//

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT


	//	cout << "caseIII " << endl;
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//


	//-- v25 start --//
	nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeZ->CalSubTreeProbHere();
	
	Pt = nodeZ->getPt();
	pi = params.getPi(); 
	

	oldPmat.resize(0);
	nodeZ->getProbFromSubTreeProb(oldPmat);


	//-- v29 start --//
	if(nodeC->getnumber() >= numLeaves){

	  Qmat.resize(0);
	  nodeC->getProbFromSubTreeProb(Qmat);

        }
	//-- v29 end --//
	
	nodeZ->FinishForCalSubTreeProbHere();
	//-- v25 end --//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();


	O_seqlenZ = nodeZ->getSeqLen();



	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	

	//-- v25 start --//
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	//nodeC->findRootSites(); // later
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	//nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
	//UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	//UpdateAllinfoToRoot(params, nodeB1); // later to Z 
	UpdateAllinfoTogivenNode(params, nodeB1, nodeZ);




	nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeZ->CalSubTreeProbHere();
	
	Pmat.resize(0);
	nodeZ->getProbFromSubTreeProb(Pmat);
	
	nodeZ->FinishForCalSubTreeProbHere();

	//-- v25 end --//


    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];

      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/



	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//











      }
      //-- v29 end --//


      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//


      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }




	//-- v25 start --//
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	//nodeA->findRootSites();
	//nodeBend->findRootSites();
	nodeC->findRootSites(); // later
	//nodeZ->findRootSites();

	// 1'
	//if(nodeD->getRoot())
	//  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

	// 3
	//nodeA->CalSubTreeProb(params);
	//nodeA->CalloglikeliofRootSitesOrReuse(params);
	//UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	//UpdateAllinfoToRoot(params, nodeB1); // later to Z 
	UpdateAllinfoToRoot(params, nodeZ); 

	//-- v25 end --//

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z
	  // cout << "caseIV " << endl;

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//


	  //-- v25 start --//
	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();
	  
	  Pt = nodeZ->getPt();
	  pi = params.getPi(); 



	  oldPmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(oldPmat);

	  //-- v29 start --//
	  if(nodeC->getnumber() >= numLeaves){

	    Qmat.resize(0);
	    nodeC->getProbFromSubTreeProb(Qmat);

          }
	  //-- v29 end --//

	  nodeZ->FinishForCalSubTreeProbHere();
        
	  //-- v25 end --//


	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();


	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));


	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();    
	  nodeBend->findRootSites(); 
	  //nodeC->findRootSites(); // later
	  nodeZ->findRootSites(); 

	  // 1'
	  if(nodeD->getRoot())  
	    nodeD->findLinkedSites();
	  
	  // 2
	  //nodeC->CalloglikeliofRootSitesOrReuse(params);    // later
	  //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  nodeA->CalSubTreeProb(params);  
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  //UpdateAllinfoToRoot(params, nodeZ); // all later



	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(Pmat);
   
	  nodeZ->FinishForCalSubTreeProbHere();

	  //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];

      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/



	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//





      }
      //-- v29 end --//

      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
      

      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }



	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  //nodeA->findRootSites();    
	  //nodeBend->findRootSites(); 
	  nodeC->findRootSites(); // later
	  //nodeZ->findRootSites(); 

	  // 1'
	  //if(nodeD->getRoot())  
	  //  nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);    // later
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  //nodeA->CalSubTreeProb(params);  
	  //nodeA->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ); // all later

	  //-- v25 end --//

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	}else{        // didn't hit Z

	  // cout << "caseII " << endl;

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	 


	  //-- v25 start --//
	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pt = nodeZ->getPt();
	  pi = params.getPi(); 


	  oldPmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(oldPmat);

	  //-- v29 start --//
	  if(nodeC->getnumber() >= numLeaves){

	    Qmat.resize(0);
	    nodeC->getProbFromSubTreeProb(Qmat);

          }
	  //-- v29 end --//
	  
	  nodeZ->FinishForCalSubTreeProbHere();
        
	  //-- v25 end --//

 

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

  
	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();
  

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));






	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  //nodeC->findRootSites(); // later
	  nodeZ->findRootSites(); 

	  // 1'
	  if(nodeBa->getRoot())   
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  //nodeC->CalloglikeliofRootSitesOrReuse(params); // later
	  //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  //UpdateAllinfoTogivenNode(params, nodeZ, nodeBm); // later
	  
	  // 9 and 10
	  //UpdateAllinfoToRoot(params, nodeBm);	    // later


	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(Pmat);
   
	  nodeZ->FinishForCalSubTreeProbHere();


	  //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];

      }else{


	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/

	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//





      }
      //-- v29 end --//

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
    
      O_psl = 0;

      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	Aligns.pop_back();
	
      
      }else{

	Backward(&pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	O_psl = CalProbSample(pBW_O, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pBW_O;

	Aligns.pop_back();

      }

      O_psl += calProbIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), oldIDH, params);


      //---------------------------------------------//
      //
      //  N_psl first!
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	if(SeqP.size() > 0){
	  seqLen = SeqP.size();
	  tempI.resize(2);
	  tempI[0] = 1;
	  tempI[1] = 0;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
        }else if(SeqQ.size() > 0){
	  seqLen = SeqQ.size();
	  tempI.resize(2);
	  tempI[0] = 0;
	  tempI[1] = 1;
          for(i = 0; i < seqLen; i++)
	    Aligns.push_back(tempI);
	}

      }else{

	Backward(&pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	N_psl = Sample(pBW_N, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pBW_N;

	Aligns.pop_back();

      }


      if(nodeZ == edge0->getEnd()){

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	N_psl += generateNewIDHfromPairwiseAlignment(Aligns, edge0->getEdgeLen(), edge0->getIDH(), rand, params);
	edge0->calHMG();
      }






	  //FixHMG
	  N_seqlenZ = nodeZ->getSeqLen();


	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  //nodeA->findRootSites();
	  //nodeD->findRootSites();
	  nodeC->findRootSites(); // later
	  //nodeZ->findRootSites(); 

	  // 1'
	  //if(nodeBa->getRoot())   
	  //  nodeBa->findLinkedSites();
	  //else if(nodeBd->getRoot())
	  //  nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params); // later
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  //nodeA->CalSubTreeProb(params);
	  //nodeA->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  //nodeD->CalSubTreeProb(params);
	  //nodeD->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  //UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm); // later
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	    // later

	  //-- v25 end --//

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      


	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    //if(nodeZ == edge0->getEnd()){
    //  edge0->ReverseEdge();
    //  N_psl= edge0->ProposHistory(params);
    //  edge0->ReverseEdge();
    //}else{
    //  N_psl= edge0->ProposHistory(params);
    //}     


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    //    cout << "AP : " << AP << endl;
    //cout << "N_datalike : " << N_datalike << "O_datalike : " << O_datalike << endl;
    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  


  //cout << "done" << endl;

  Mset.resize(0);

  Pt.resize(0);
  pi.resize(0);
  oldPmat.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  SeqP.resize(0);
  SeqPold.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0);



  delete oldIDH;

  return AP;  

} // SPRonSubTree
//--- v28 end v29 end--//




//-- v35 start--//
double Tree::SPRonSubTreeWithFixedHMGbyDP(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c2, int start) {


  //cout << "SPRonSubTreebyDP" << endl;


  int i, j;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;


  //-- v25 start --//
  vector<vector<double> > Pt(0);
  vector<double> pi(0);
  vector<vector<double> > oldPmat(0);
  vector<vector<double> > Pmat(0);
  vector<vector<double> > Qmat(0);
  //int numLetters;
  int k, ki;
  int EndSeqLen;
  //-- v25 end --//

  //-- v28 start --//
  vector<char> SeqP(0);
  vector<char> SeqPold(0);
  vector<char> SeqQ(0);
  vector<vector<int> > Aligns(0);
  vector<char> chars(0);
  vector<int> tempI(0);
  vector<int> tempI2(0);
  double iDelta;
  double iEpsilon;
  double iTau;
  AlignDPTable *pVT;
  double lambda, mu, rd, ri;
  int seqLen;
  //-- v28 end --//

  //-- v35 start --//
  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  vector<int> oldHMG(0);
  vector<int> HMG(0);
  double fixProb = 0.8;
  double logfixProb = log(fixProb);
  double logNfixProb = log(1-fixProb);
  int oldNum, newNum, oldTnum, newTnum;
  int intTemp, Tnum, Dnum, s;
  //-- v35 end --//

  InDelHistory* IDH;
  InDelHistory* oldIDH = new InDelHistory();
  int O_seqlenZ, N_seqlenZ, T_seqlenZ, IX;
  

  //-- v29 start --//
  int inttmp, h;
  //-- v29 end --//



  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];  
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  // Pick M on edge0, which is the end point of window
  //double posiM = rand.runif()*(edge0->getEdgeLen()); 

  //cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
  

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 



  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];


  //cout << "selectedposi : " << selectedposi << "TargetEdgeNum : " << TargetEdgeNum << endl


  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "AAA " << endl;
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTreeWithFixedHMGbyDP(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, c2, start);


  }else{                  // else if edge which is connected to Z is selected



    //cout << "BBB " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);
    //cout << "edgeT number " << edgeT->getnumber() << endl;


    EndSeqLen = nodeC->getSeqLen();

    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }

    //cout << "posiNewZ : " << posiNewZ << endl;

 
    lenXt = edgeT->getEdgeLen();

    O_IDHlike = edge0->likeliHistory(params);


    //-- v28 start --//
    chars.resize(4);
    chars[0] = 'A';
    chars[1] = 'C';
    chars[2] = 'G';
    chars[3] = 'T';   
    lambda = params.getLambda();
    mu = params.getMu();
    ri = params.getRi();
    rd = params.getRd();
    
    iDelta = (1 - exp(-(lambda + mu)*edge0->getEdgeLen()))/(double)2;
    iEpsilon = 1 - (rd + ri)/(double)2;
    iTau = 0.3;
	
    //-- v28 end --//

    if(nodeZ == edge0->getStart()){
      (*oldIDH) = (*edge0->getIDH());

      oldHMG.resize(0);
      oldHMG = oldIDH->getHMG(oldIDH->getNumE());

    }else{
      edge0->ReverseEdge();
      (*oldIDH) = (*edge0->getIDH());
 
      oldHMG.resize(0);
      oldHMG = oldIDH->getHMG(oldIDH->getNumE());

      edge0->ReverseEdge();
    }      


    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){


      //cout << "caseIa " << endl;

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//

      //-- v25 start --//
      nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeZ->CalSubTreeProbHere();

      Pt = nodeZ->getPt();
      pi = params.getPi(); 
	   

      oldPmat.resize(0);
      nodeZ->getProbFromSubTreeProb(oldPmat);

      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	Qmat.resize(0);
	nodeC->getProbFromSubTreeProb(Qmat);

      }
      //-- v29 end --//

      nodeZ->FinishForCalSubTreeProbHere();
        
      //-- v25 end --//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();



      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();




      O_seqlenZ = nodeZ->getSeqLen();
     
      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();


      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      N_seqlenZ = nodeZ->getSeqLen();
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }




      //-- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      //nodeC->findRootSites(); // later
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      //if(nodeZ->getRoot())  // later
      //nodeZ->findLinkedSites(); // later

      // 2
      //nodeC->CalloglikeliofRootSitesOrReuse(params); // later
      //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

      //3
      nodeA->CalSubTreeProb(params);  
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      //UpdateAllinfoToRoot(params, nodeBend);  // Bend to Z...later start from Z;
      UpdateAllinfoTogivenNode(params, nodeBend, nodeZ);

      

      nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
      nodeZ->CalSubTreeProbHere();

      Pmat.resize(0);
      nodeZ->getProbFromSubTreeProb(Pmat);
   
      nodeZ->FinishForCalSubTreeProbHere();

      //-- v25 end --//


      //cout << "Pmat " << endl;
      //for(i = 0; i < Pmat.size(); i++){
      //  for(j = 0; j < 4; j++)
      //	cout << Pmat[i][j] << " ";
      //  cout << endl;
      //}
      
      
      //cout << "oldPmat " << endl;
      //for(i = 0; i < oldPmat.size(); i++){
      //  for(j = 0; j < 4; j++)
      //	cout << oldPmat[i][j] << " ";
      //  cout << endl;
      //}
      
      

      
      //cout << "Qmat " << endl;
      //for(i = 0; i < Qmat.size(); i++){
      //  for(j = 0; j < 4; j++)
      //	cout << Qmat[i][j] << " ";
      //  cout << endl;
      //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];

      }else{

	
	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);
	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/

	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//




      }

      //-- v29 end --//

      

      //cout << "SeqP " << endl;
      //for(i = 0; i < SeqP.size(); i++)
      //	cout << SeqP[i] << " ";
      //cout << endl;

      //cout << "SeqPold " << endl;
      //for(i = 0; i < SeqPold.size(); i++)
      //	cout << SeqPold[i] << " ";
      //cout << endl;

    
      //cout << "SeqQ " << endl;
      //for(i = 0; i < SeqQ.size(); i++)
      //	cout << SeqQ[i] << " ";
      // cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

      O_psl = 0;

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldNum = 0; // for O_psl
      oldTnum = 0;


      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqPold.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    oldTnum++;

	    if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	      oldNum++;
	    
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(Aligns[i][0]+1);
		enPosi.push_back(Aligns[i][1]+1);	    
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	  
	    }
	
	  }
      
	}

	stSeqLen.push_back(SeqPold.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      
      //O_psl += (oldTnum+newNum)*logNfixProb;
 

      //---------------------------------------------//
      //
      //  N_psl
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for O_psl
      newTnum = 0;


      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqP.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    newTnum++;
 
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	stSeqLen.push_back(SeqP.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

 
      if(nodeZ == edge0->getEnd()){

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());

	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;

	  }
	}

	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());
	
	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){
	  
	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;
	    
	  }
	}


	edge0->calHMG();
      }


     N_psl += (newTnum+oldNum)*logNfixProb;
     O_psl += (oldTnum+newNum)*logNfixProb;


      //--- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //nodeA->findRootSites();
      nodeC->findRootSites(); // later
      //TempNode = nodeD;
      //while(TempNode != nodeZ){
      //	TempNode->findRootSites();
      //	TempNode = TempNode->getParent();
      //}

      // 1'
      if(nodeZ->getRoot())  // later
	nodeZ->findLinkedSites(); // later

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params); // later
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

      //3
      //nodeA->CalSubTreeProb(params);  
      //nodeA->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      //nodeD->CalSubTreeProb(params);
      //nodeD->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      //UpdateAllinfoToRoot(params, nodeBend);  // Bend to Z...later start from Z;
      UpdateAllinfoToRoot(params, nodeZ);
      //-- v25 end --//

     

      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 
    
    }else if(edge0 == nodeZ->getParentEdge()){

 
      //cout << "caseI " << endl;

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//

      //-- v25 start --//


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	nodeC->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeC->CalSubTreeProbHere();

	Pt = nodeC->getPt();
	pi = params.getPi();
 
	Qmat.resize(0);
	nodeC->getProbFromSubTreeProb(Qmat);

	nodeC->FinishForCalSubTreeProbHere();

      }else{

	nodeC->CalPt(edge0->getEdgeLen(),params);

	Pt = nodeC->getPt();
	nodeC->Ptreset();
	pi = params.getPi();
 
      }
      //-- v29 end --//

      oldPmat.resize(0);
      nodeZ->getProbFromSubTreeProb(oldPmat);

        
      //-- v25 end --//


      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     

      O_seqlenZ = nodeZ->getSeqLen();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }


      //-- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      //nodeZ->findRootSites();  // later

      // 1'
      //if(nodeC->getRoot())  // later
      //	nodeC->findLinkedSites();  // later

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      //UpdateAllinfoToRoot(params, nodeBend); // later to nodeZ from nodeZ 
      UpdateAllinfoTogivenNode(params, nodeBend, nodeZ);
      nodeZ->CalSubTreeProb(params);



      Pmat.resize(0);
      nodeZ->getProbFromSubTreeProb(Pmat);
   
      //-- v25 end --//



    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}




      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];



      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){
	
	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];
	
      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/


	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//


      }
      //-- v29 end --//
      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//


      O_psl = 0;


      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldNum = 0; // for O_psl
      oldTnum = 0;



      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqPold.size());
	enSeqLen.push_back(SeqQ.size());
	      
      }else{

	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    oldTnum++;

	    if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	      oldNum++;
	    
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(Aligns[i][0]+1);
		enPosi.push_back(Aligns[i][1]+1);	    
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	  
	    }
	
	  }
      
	}

	stSeqLen.push_back(SeqPold.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }
      

      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      
      //O_psl += (oldTnum+newNum)*logNfixProb;
      

      //---------------------------------------------//
      //
      //  N_psl
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for O_psl
      newTnum = 0;


      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqP.size());
	enSeqLen.push_back(SeqQ.size());

      }else{

	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    newTnum++;
 
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	stSeqLen.push_back(SeqP.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }



      if(nodeZ == edge0->getEnd()){

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());

	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;

	  }
	}

	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());
	
	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){
	  
	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;
	    
	  }
	}

	edge0->calHMG();
      }


      N_psl += (newTnum+oldNum)*logNfixProb;
      O_psl += (oldTnum+newNum)*logNfixProb;

 

      //--- v25 start --//
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //nodeA->findRootSites();
      //TempNode = nodeD;
      //while(TempNode != nodeZ){
      //	TempNode->findRootSites();
      //	TempNode = TempNode->getParent();
      // }
      nodeZ->findRootSites();  // later

      // 1'
      if(nodeC->getRoot())  // later
	nodeC->findLinkedSites();  // later

      // 2
      //nodeA->CalSubTreeProb(params);
      //nodeA->CalloglikeliofRootSitesOrReuse(params);
      // UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      // nodeD->CalSubTreeProb(params);
      //nodeD->CalloglikeliofRootSitesOrReuse(params);
      //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      //UpdateAllinfoToRoot(params, nodeBend); // later to nodeC from nodeC
      nodeZ->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeZ->getnumber()] = 1;
      UpdateAllinfoToRoot(params, nodeC);
  

      //-- v25 end --//

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT


	//	cout << "caseIII " << endl;
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//


	//-- v25 start --//
	nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeZ->CalSubTreeProbHere();
	
	Pt = nodeZ->getPt();
	pi = params.getPi(); 
	

	oldPmat.resize(0);
	nodeZ->getProbFromSubTreeProb(oldPmat);


	//-- v29 start --//
	if(nodeC->getnumber() >= numLeaves){

	  Qmat.resize(0);
	  nodeC->getProbFromSubTreeProb(Qmat);

        }
	//-- v29 end --//
	
	nodeZ->FinishForCalSubTreeProbHere();
	//-- v25 end --//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();


	O_seqlenZ = nodeZ->getSeqLen();



	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	

	//-- v25 start --//
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	//nodeC->findRootSites(); // later
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	//nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
	//UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	//UpdateAllinfoToRoot(params, nodeB1); // later to Z 
	UpdateAllinfoTogivenNode(params, nodeB1, nodeZ);




	nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	nodeZ->CalSubTreeProbHere();
	
	Pmat.resize(0);
	nodeZ->getProbFromSubTreeProb(Pmat);
	
	nodeZ->FinishForCalSubTreeProbHere();

	//-- v25 end --//


    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];

      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/



	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//











      }
      //-- v29 end --//


      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//

      O_psl = 0;

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldNum = 0; // for O_psl
      oldTnum = 0;


      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqPold.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    oldTnum++;

	    if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	      oldNum++;
	    
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(Aligns[i][0]+1);
		enPosi.push_back(Aligns[i][1]+1);	    
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	  
	    }
	
	  }
      
	}

	stSeqLen.push_back(SeqPold.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      
      //O_psl += (oldTnum+newNum)*logNfixProb;
 

      //---------------------------------------------//
      //
      //  N_psl
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for O_psl
      newTnum = 0;


      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqP.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    newTnum++;
 
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	stSeqLen.push_back(SeqP.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

 
      if(nodeZ == edge0->getEnd()){

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());

	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;

	  }
	}

	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());
	
	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){
	  
	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;
	    
	  }
	}


	edge0->calHMG();
      }


     N_psl += (newTnum+oldNum)*logNfixProb;
     O_psl += (oldTnum+newNum)*logNfixProb;



	//-- v25 start --//
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	//nodeA->findRootSites();
	//nodeBend->findRootSites();
	nodeC->findRootSites(); // later
	//nodeZ->findRootSites();

	// 1'
	//if(nodeD->getRoot())
	//  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);  // later
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1; // later

	// 3
	//nodeA->CalSubTreeProb(params);
	//nodeA->CalloglikeliofRootSitesOrReuse(params);
	//UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	//UpdateAllinfoToRoot(params, nodeB1); // later to Z 
	UpdateAllinfoToRoot(params, nodeZ); 

	//-- v25 end --//

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z
	  // cout << "caseIV " << endl;

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//


	  //-- v25 start --//
	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();
	  
	  Pt = nodeZ->getPt();
	  pi = params.getPi(); 



	  oldPmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(oldPmat);

	  //-- v29 start --//
	  if(nodeC->getnumber() >= numLeaves){

	    Qmat.resize(0);
	    nodeC->getProbFromSubTreeProb(Qmat);

          }
	  //-- v29 end --//

	  nodeZ->FinishForCalSubTreeProbHere();
        
	  //-- v25 end --//


	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();


	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));


	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();    
	  nodeBend->findRootSites(); 
	  //nodeC->findRootSites(); // later
	  nodeZ->findRootSites(); 

	  // 1'
	  if(nodeD->getRoot())  
	    nodeD->findLinkedSites();
	  
	  // 2
	  //nodeC->CalloglikeliofRootSitesOrReuse(params);    // later
	  //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  nodeA->CalSubTreeProb(params);  
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  //UpdateAllinfoToRoot(params, nodeZ); // all later



	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(Pmat);
   
	  nodeZ->FinishForCalSubTreeProbHere();

	  //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];

      }else{

	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);

	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/



	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
	  }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
          }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//





      }
      //-- v29 end --//

      

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
      

      O_psl = 0;

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldNum = 0; // for O_psl
      oldTnum = 0;


      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqPold.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    oldTnum++;

	    if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	      oldNum++;
	    
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(Aligns[i][0]+1);
		enPosi.push_back(Aligns[i][1]+1);	    
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	  
	    }
	
	  }
      
	}

	stSeqLen.push_back(SeqPold.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      
      //O_psl += (oldTnum+newNum)*logNfixProb;
 

      //---------------------------------------------//
      //
      //  N_psl
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for O_psl
      newTnum = 0;


      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqP.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    newTnum++;
 
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	stSeqLen.push_back(SeqP.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

 
      if(nodeZ == edge0->getEnd()){

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());

	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;

	  }
	}

	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());
	
	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){
	  
	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;
	    
	  }
	}


	edge0->calHMG();
      }


     N_psl += (newTnum+oldNum)*logNfixProb;
     
     O_psl += (oldTnum+newNum)*logNfixProb;



	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  //nodeA->findRootSites();    
	  //nodeBend->findRootSites(); 
	  nodeC->findRootSites(); // later
	  //nodeZ->findRootSites(); 

	  // 1'
	  //if(nodeD->getRoot())  
	  //  nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);    // later
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  //nodeA->CalSubTreeProb(params);  
	  //nodeA->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ); // all later

	  //-- v25 end --//

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	}else{        // didn't hit Z

	  // cout << "caseII " << endl;

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	 


	  //-- v25 start --//
	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pt = nodeZ->getPt();
	  pi = params.getPi(); 


	  oldPmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(oldPmat);

	  //-- v29 start --//
	  if(nodeC->getnumber() >= numLeaves){

	    Qmat.resize(0);
	    nodeC->getProbFromSubTreeProb(Qmat);

          }
	  //-- v29 end --//
	  
	  nodeZ->FinishForCalSubTreeProbHere();
        
	  //-- v25 end --//

 

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

  
	  //FixHMG
	  O_seqlenZ = nodeZ->getSeqLen();
  

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));






	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  //nodeC->findRootSites(); // later
	  nodeZ->findRootSites(); 

	  // 1'
	  if(nodeBa->getRoot())   
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  //nodeC->CalloglikeliofRootSitesOrReuse(params); // later
	  //UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  //UpdateAllinfoTogivenNode(params, nodeZ, nodeBm); // later
	  
	  // 9 and 10
	  //UpdateAllinfoToRoot(params, nodeBm);	    // later


	  nodeZ->ReadyForCalSubTreeProbHere(edge0->getnumber(), edge0->getEdgeLen(),params);
	  nodeZ->CalSubTreeProbHere();

	  Pmat.resize(0);
	  nodeZ->getProbFromSubTreeProb(Pmat);
   
	  nodeZ->FinishForCalSubTreeProbHere();


	  //-- v25 end --//




    //cout << "Pmat " << endl;
    //for(i = 0; i < Pmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Pmat[i][j] << " ";
    //  cout << endl;
    //}


    //cout << "oldPmat " << endl;
    //for(i = 0; i < oldPmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << oldPmat[i][j] << " ";
    //  cout << endl;
    //}




    //cout << "Qmat " << endl;
    //for(i = 0; i < Qmat.size(); i++){
    //  for(j = 0; j < 4; j++)
    //	cout << Qmat[i][j] << " ";
    //  cout << endl;
    //}






      //-- v28 start --//
      //-------------------------------------------//
      //
      // Sampling letters which will be cancelled (We will sample reverse part too)
      //
      //--------------------------------------------//
      

      seqLen = Pmat.size();
      SeqP.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqP[i] = chars[rand.rwunif(Pmat[i])];

      seqLen = oldPmat.size();
      SeqPold.resize(seqLen);
      for(i = 0; i < seqLen; i++)
	SeqPold[i] = chars[rand.rwunif(oldPmat[i])];


      //-- v29 start --//
      if(nodeC->getnumber() >= numLeaves){

	seqLen = Qmat.size();
	SeqQ.resize(seqLen);
	for(i = 0; i < seqLen; i++)
	  SeqQ[i] = chars[rand.rwunif(Qmat[i])];

      }else{


	seqLen = nodeC->getSeqLen();
	SeqQ.resize(seqLen);


	//-- v31 start --//
	/*
	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      SeqQ[h] = chars[i];
	    }
	    inttmp /= 2;
	  }
	}
	*/

	tempI2.resize(numLetters);

	for(i = 0; i < numLetters; i++)
	  tempI2[i] = 0;
      


	for(h = 0; h < seqLen; h++){
	  inttmp = nodeC->getSeq(h);
	  tempI.resize(0);
	  tempI = tempI2;
	  j = 0;
	  k = -1;
	  for( i = 0; i < numLetters; i++){
	    if(inttmp%2==1){
	      tempI[i] = 1;
	      j++;
	      k = i;
	    }
	    inttmp /= 2;
	  }
	  if(j==1){
	    //-- Heejung is working on 
	    //SeqQ[h] = chars[rand.rwunif(tempI)];
	    SeqQ[h] = chars[k];
          }else{
	    SeqQ[h] = chars[rand.rwunif(tempI)];
	  }
	}

	tempI.resize(0);
	tempI2.resize(0);
	//-- v31 end --//





      }
      //-- v29 end --//

    //cout << "SeqP " << endl;
    //for(i = 0; i < SeqP.size(); i++)
    //  cout << SeqP[i] << " ";
    //cout << endl;

    //cout << "SeqPold " << endl;
    //for(i = 0; i < SeqPold.size(); i++)
    //  cout << SeqPold[i] << " ";
    //cout << endl;

    
    //cout << "SeqQ " << endl;
    //for(i = 0; i < SeqQ.size(); i++)
    //  cout << SeqQ[i] << " ";
    //cout << endl;

    //---------------------------------------------//
    //
    //  O_psl first!
    //
    //----------------------------------------------//
    
 
      O_psl = 0;

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      oldNum = 0; // for O_psl
      oldTnum = 0;


      if((SeqPold.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqPold.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqPold, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    oldTnum++;

	    if(oldHMG[Aligns[i][1]] == Aligns[i][0]){
	   
	      oldNum++;
	    
	      if(rand.runif()- fixProb < 0){
		stPosi.push_back(Aligns[i][0]+1);
		enPosi.push_back(Aligns[i][1]+1);	    
		stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
		enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
		IX++;
	      }
	  
	    }
	
	  }
      
	}

	stSeqLen.push_back(SeqPold.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

      O_psl += calProbIDHonEdgeWhileKeepingHMG(params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), oldIDH);
      
      //O_psl += (oldTnum+newNum)*logNfixProb;
 

      //---------------------------------------------//
      //
      //  N_psl
      //
      //----------------------------------------------//


      N_psl = 0;

      Aligns.resize(0);

      stSeqLen.resize(0);
      enSeqLen.resize(0);
      stPosi.resize(0);
      enPosi.resize(0);
      stPosi.push_back(0);
      enPosi.push_back(0);
      IX=1;
      newNum = 0; // for O_psl
      newTnum = 0;


      if((SeqP.size()==0) | (SeqQ.size() == 0)){

	stSeqLen.push_back(SeqP.size());
	enSeqLen.push_back(SeqQ.size());

	      
      }else{


	Aligns.resize(0);
	Viterbi_recurse(&pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ);
	Viterbi_trace(pVT, iDelta, iEpsilon, iTau, Pt, pi, SeqP, SeqQ, Aligns);

	delete pVT;

	Aligns.pop_back();
	intTemp = Aligns.size();

	Tnum = 0;
	Dnum = 0;
	for(s =0; s < intTemp; s++){
	  if(Aligns[s][0] == 1)
	    Aligns[s][0] = Tnum++;
	  else
	    Aligns[s][0] = -1;

	  if(Aligns[s][1] == 1)
	    Aligns[s][1] = Dnum++;
	  else
	    Aligns[s][1] = -1; 
	}
      

	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    newTnum++;
 
	    if(rand.runif()- fixProb < 0){
	      stPosi.push_back(Aligns[i][0]+1);
	      enPosi.push_back(Aligns[i][1]+1);	    
	      stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	      enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	      IX++;
	    }
	    
	  }
	  
	}
	stSeqLen.push_back(SeqP.size() -stPosi[IX-1]);
	enSeqLen.push_back(SeqQ.size() -enPosi[IX-1]);

      }

 
      if(nodeZ == edge0->getEnd()){

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());

	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){

	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;

	  }
	}

	edge0->getIDH()->ReverseIDH();
	edge0->calHMG();

      }else{

	IDH = edge0->getIDH();
	N_psl += generateNewIDHonEdgeWhileKeepingHMG(rand, params, stSeqLen, enSeqLen, stPosi, edge0->getEdgeLen(), IDH);

	HMG.resize(0);
	HMG = IDH->getHMG(IDH->getNumE());
	
	intTemp = Aligns.size();
	
	for(i = 0; i < intTemp; i++){
	  
	  if((Aligns[i][0] != -1) & (Aligns[i][1] != -1)){
	    // N_psl 
	    if(HMG[Aligns[i][1]] == Aligns[i][0])
	      newNum++;
	    
	  }
	}


	edge0->calHMG();
      }


     N_psl += (newTnum+oldNum)*logNfixProb;
     O_psl += (oldTnum+newNum)*logNfixProb;




	  //FixHMG
	  N_seqlenZ = nodeZ->getSeqLen();


	  //-- v25 start --//
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  //nodeA->findRootSites();
	  //nodeD->findRootSites();
	  nodeC->findRootSites(); // later
	  //nodeZ->findRootSites(); 

	  // 1'
	  //if(nodeBa->getRoot())   
	  //  nodeBa->findLinkedSites();
	  //else if(nodeBd->getRoot())
	  //  nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params); // later
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;  // later
	  
	  // 3
	  //nodeA->CalSubTreeProb(params);
	  //nodeA->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  //nodeD->CalSubTreeProb(params);
	  //nodeD->CalloglikeliofRootSitesOrReuse(params);
	  //UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  //UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm); // later
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	    // later

	  //-- v25 end --//

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      


	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    //if(nodeZ == edge0->getEnd()){
    //  edge0->ReverseEdge();
    //  N_psl= edge0->ProposHistory(params);
    //  edge0->ReverseEdge();
    //}else{
    //  N_psl= edge0->ProposHistory(params);
    //}     


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    //    cout << "AP : " << AP << endl;
    //cout << "N_datalike : " << N_datalike << "O_datalike : " << O_datalike << endl;
    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;



  }
  


  //cout << "done" << endl;

  Mset.resize(0);

  Pt.resize(0);
  pi.resize(0);
  oldPmat.resize(0);
  Pmat.resize(0);
  Qmat.resize(0);

  SeqP.resize(0);
  SeqPold.resize(0);
  SeqQ.resize(0);
  Aligns.resize(0);
  chars.resize(0);
  tempI.resize(0);



  delete oldIDH;

  return AP;  

} // SPRonSubTree
//--- v35 end--//



double Tree::SPRonSubTree(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c2, int start) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "AAA " << endl;
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTree(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, c2, start);

  }else{                  // else if edge which is connected to Z is selected

    //cout << "BBB " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);
    //cout << "edgeT number " << edgeT->getnumber() << endl;


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }
 
    lenXt = edgeT->getEdgeLen();
    // Heejung
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edge0->likeliHistory(params);
    //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
    //cout << "O_IDHlike " << O_IDHlike << endl;



    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      O_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      O_psl= edge0->ProposHistory(params);
    }      

    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
      
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      int O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
     if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  edge0->runEdge(rand,params);
	  edge0->calHMG();     
	  edge0->ReverseEdge();
	}else{
	  edge0->runEdge(rand,params);
	  edge0->calHMG();
	}    
       

	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      N_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      N_psl= edge0->ProposHistory(params);
    }     


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

   
    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;


  }
  
  Mset.resize(0);
 
  return AP;  

} // SPRonSubTree





double Tree::SPRonSubTree(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c2) {


  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  
  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    //cout << "AAA " << endl;
    params.setSPRonSingle(1);
    AP = SPRonSingleEdgeAsPartOfSPRonSubTree(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum, c2);

  }else{                  // else if edge which is connected to Z is selected

    //cout << "BBB " << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);
    //cout << "edgeT number " << edgeT->getnumber() << endl;


    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }
 
    lenXt = edgeT->getEdgeLen();
    // Heejung
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edge0->likeliHistory(params);
    //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
    //cout << "O_IDHlike " << O_IDHlike << endl;



    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      O_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      O_psl= edge0->ProposHistory(params);
    }      

    N_sizeMset = Mset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
      
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 
	
      // Update IDHlikelihood
      // Heejung
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      //cout << "caseIa " << endl;
      //cout << "logLikeliIDH[current] " << logLikeliIDH[current] << endl;
      //cout << "O_IDHlike " << O_IDHlike << endl;
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    
    }else if(edge0 == nodeZ->getParentEdge()){

 

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      int O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));

      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
     if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
  
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 

      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
     
      //logLikeliIDH[current] = likeliHistory(params);
      //N_IDHlike = logLikeliIDH[current];

    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);

	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  edge0->runEdge(rand,params);
	  edge0->calHMG();     
	  edge0->ReverseEdge();
	}else{
	  edge0->runEdge(rand,params);
	  edge0->calHMG();
	}    
       

	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	//logLikeliIDH[current] = likeliHistory(params);
	//N_IDHlike = logLikeliIDH[current];


      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}else{        // didn't hit Z

	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
      

	  //logLikeliIDH[current] = likeliHistory(params);
	  //N_IDHlike = logLikeliIDH[current];

	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);

    // data like
    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    // IDH like
    // done at each case
    edgeX->likeliHistory(params);
    edgeY->likeliHistory(params);
    edgeT->likeliHistory(params); 
  
    // Edge like
    edgeX->CalculatelogLikeliEdge(params);
    edgeY->CalculatelogLikeliEdge(params);
    edgeT->CalculatelogLikeliEdge(params); 
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      N_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      N_psl= edge0->ProposHistory(params);
    }     


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //N_IDHlike = logLikeliIDH[current];

   

    AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl + log(lenXt) + log((double)N_sizeMset)  - N_psl - log(lenX1) - log((double)O_sizeMset)) << " " <<  exp(O_psl - N_psl) << " " << lenXt/lenX1 << " " << ((double)N_sizeMset)/((double)O_sizeMset) << endl;


  }
  
  Mset.resize(0);
 
  return AP;  

} // SPRonSubTree




double Tree::SPRonSubTree_v0(Rand &rand,Parameters &params, int MaximumStep) {


  //cout << "In SPRonSubTree " << endl;
  //checkTree();
  //cout << "MaximumStep : " << MaximumStep << endl;
  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  //cout << "nodeZ->getRoot() " << nodeZ->getRoot() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  //cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  //cout << "nodeC->getnumber() " << nodeC->getnumber() << endl;



  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;

  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  int baseNodenum;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());     
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  lenX1 = sum_vec(lenX);
  lenX.resize(0);
  


  if(rand.runif() > 0.5)
    baseNodenum = tempNodeNum[1];
  else
    baseNodenum = tempNodeNum[0];

  //if(lenX[0] > lenX[1])
  //  baseNodenum = tempNodeNum[1];
  //else
  //  baseNodenum = tempNodeNum[0];
  
  tempNodeNum.resize(0);


  //cout << "lenX1 : " << lenX1 << " Mset size : " << Mset.size() << endl; 
  //print_veci(Mset);
  //cout << "posiDel " << posiDel << endl;
  

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  //cout << "Final Mset " << endl;
  //print_veci(Mset);

  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  //cout << "selectedposi : " << selectedposi << "TargetEdgeNum : " << TargetEdgeNum << endl;
  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    params.setSPRonSingle(1);
    //cout << "^^^^^^ Call SPRonSingleEdge ^^^^^^^" << endl;
    //AP = SPRonSingleEdgeAsPartOfSPRonSubTree(rand,params,nodeZ->getnumber(), Edgenum, baseNodenum);

  }else{                  // else if edge which is connected to Z is selected

    //cout << "^^^^^^ Not Call SPRonSingleEdge ^^^^^^^" << endl;
    params.setSPRonSingle(0);
    Edge* edgeT = getEdge(TargetEdgeNum);

    //cout << "edgeT->getnumber() " << edgeT->getnumber() << endl;

    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    if(rand.runif() > 0.5){
      posiNewZ = edgeT->getEdgeLen() - posiNewZ;
    }



    //cout << "posiNewZ : " << posiNewZ << endl;
 
    lenXt = edgeT->getEdgeLen();

    // Construct Mrevset which is a set of edges in a maximum step based on the selected edge.
    //vector<int> Mrevset(0);

    //ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, edgeT , edgeT->getStart());
    //posiDel = Mrevset.size();
    //ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, edgeT , edgeT->getEnd());

    //Mrevset.erase(Mrevset.begin() + posiDel); // Remove one of edgeT since edgeT counted two times. 

    //cout << "Final Mrevset " << endl;
    //print_veci(Mrevset);

    // Save all old information which will be used to calculate Acceptance prob.
    // Save likelihood and proposal prob of old IDH on e0 
    //O_IDHlike = edge0->likeliHistory(params);

    O_IDHlike = likeliHistory(params);

    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      O_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      O_psl= edge0->ProposHistory(params);
    }      
    N_sizeMset = Mset.size();
    //O_sizeMset = Mrevset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      //cout << "******** CASEIA *****************" << endl;

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //cout << "After reversing edgeY " << endl;
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;	  
      //edgeY->printEdge();




      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
 

      //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeT " << endl;	  
      //edgeT->printEdge();

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //cout << "After reversing edgeT " << endl;
      //cout << "edgeT " << endl;
      //edgeT->printEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      //cout << "TempEdge number : " << TempEdge->getnumber() << endl;
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      //cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
      //printTree(0);      
      //checkTree();

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
      
      //cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
      //printTree(0);    
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1

    }else if(edge0 == nodeZ->getParentEdge()){

      //cout << "******** CASEI *****************" << endl;
      //checkTree();

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();



      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //cout << "After reversing edgeY " << endl;
      //cout << "edgeY " << endl;
      //edgeY->printEdge();



      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);


      //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;	  
      //edgeY->printEdge();



      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeT " << endl;	  
      //edgeT->printEdge();


      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();


      //cout << "After reversing edgeT " << endl;
      //cout << "edgeT " << endl;
      //edgeT->printEdge();



      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      int O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));
      





      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }



      //cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
      //printTree(0);      
      //checkTree();



      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
     if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	edge0->runEdge(rand,params);
	edge0->calHMG();     
        edge0->ReverseEdge();
      }else{
	edge0->runEdge(rand,params);
	edge0->calHMG();
      }    
     
      //cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
      //printTree(0);   
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
     
    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT


	//cout << "******** CASEIII *****************" << endl;	 
	//checkTree();
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();


	//cout << "nodeA : " << endl;
	//nodeA->printNode();
	//cout << "nodeB1 : " << endl;
	//nodeB1->printNode();
	//cout << "nodeBend : " << endl;
	//nodeBend->printNode();
	//cout << "nodeD : " << endl;
	//nodeD->printNode(); 
	//cout << "edgeX " << endl;
	//edgeX->printEdge();
	//cout << "edgeY " << endl;
	//edgeY->printEdge();
	//cout << "edgeT " << endl;
	//edgeT->printEdge();


	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);


	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));


	//cout << "print Tree in SPRonSubTree after reconstruction!" << endl;
	//printTree(0);
	//checkTree();

	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  edge0->runEdge(rand,params);
	  edge0->calHMG();     
	  edge0->ReverseEdge();
	}else{
	  edge0->runEdge(rand,params);
	  edge0->calHMG();
	}    
	

	//cout << "print Tree in SPRonSubTree after generating new IDH on edge0!" << endl;
	//printTree(0);
	//checkTree();


	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1

	
      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  //cout << "******** CASEIV *****************" << endl;	  
	  //checkTree();
	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //cout << "nodeA : " << endl;
	  //nodeA->printNode();
	  //cout << "nodeB1 : " << endl;
	  //nodeB1->printNode();
	  //cout << "nodeBend : " << endl;
	  //nodeBend->printNode();
	  //cout << "nodeD : " << endl;
	  //nodeD->printNode(); 
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeY " << endl;
	  //edgeY->printEdge();
	  //cout << "edgeT " << endl;
	  //edgeT->printEdge();



	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeY " << endl;	  
	  //edgeY->printEdge();


	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeT " << endl;	  
	  //edgeT->printEdge();


	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	  

	  //cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
	  //printTree(0);      
	  //checkTree();

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	  
	  //cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
	  //printTree(0);   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
 
	}else{        // didn't hit Z

	  //cout << "******** CASEII *****************" << endl;	  
	  //checkTree();
	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();


	  //cout << "nodeA : " << endl;
	  //nodeA->printNode();
	  //cout << "nodeBa : " << endl;
	  //nodeBa->printNode();
	  //cout << "nodeBd : " << endl;
	  //nodeBd->printNode();
	  //cout << "nodeBm : " << endl;
	  //nodeBm->printNode();	  
	  //cout << "nodeD : " << endl;
	  //nodeD->printNode(); 
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeY " << endl;
	  //edgeY->printEdge();
	  //cout << "edgeT " << endl;
	  //edgeT->printEdge();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeY " << endl;	  
	  //edgeY->printEdge();

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);


	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeT " << endl;	  
	  //edgeT->printEdge();


	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	  
	  //cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
	  //printTree(0);
	  //checkTree();

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  if(nodeZ == edge0->getEnd()){
	    edge0->changeStartEnd();
	    edge0->runEdge(rand,params);
	    edge0->calHMG();     
	    edge0->ReverseEdge();
	  }else{
	    edge0->runEdge(rand,params);
	    edge0->calHMG();
	  }    
	  
	  //cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
	  //printTree(0);
	  
	  //checkTree();


	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  
 
      
	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }

    vector<int> Mrevset(0);

    Count = 0;
    for( i=0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(TempEdge->getnumber()!= edge0->getnumber()){      
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }

    Mrevset.erase(Mrevset.begin() + posiDel);
    O_sizeMset = Mrevset.size();
    Mrevset.resize(0);


    // find_bug3 //


    //N_IDHlike = edge0->likeliHistory(params); 
    logLikeliIDH[current] = likeliHistory(params);
    N_IDHlike = logLikeliIDH[current];
    logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    O_datalike = logLikeliData[current];
    root->likeliDataR_v2(params);

    //cout << "AAA" << endl;
    //printTree(0);
    //cout << "BBB" << endl;

    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];

    
    if(nodeZ == edge0->getEnd()){
      edge0->ReverseEdge();
      N_psl= edge0->ProposHistory(params);
      edge0->ReverseEdge();
    }else{
      N_psl= edge0->ProposHistory(params);
    }     

    //cout << "Updated information !!!!! " << endl;
    //cout << "N_datalike : " << N_datalike << endl;


    //cout << "N_datalike : " << N_datalike << endl;
    //cout << "O_datalike : " << O_datalike << endl;
    //cout << "N_IDHlike : " << N_IDHlike << endl;
    //cout << "O_IDHlike : " << O_IDHlike << endl;
    //cout << "IDH diff : " << (logLikeliIDH[current] - logLikeliIDH[1-current]) << endl; 
    //double edgeS = 0;
    //for(int m = 0; m < numEdges; m++){ 
    //  edgeS += getEdge(m)->getEdgeLen();
    //}
    //cout << "EdgeSum : " << edgeS << endl;

    //if(N_sizeMset!=O_sizeMset)
    //  cout << "ERROR N_sizeMset!=O_sizeMset" << endl;

    AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));

  }
  
  Mset.resize(0);
 
  return AP;

  //cout << "AP : " << AP << endl;

  

} // SPRonSubTree



/*
double Tree::SPRonSubTree(Rand &rand,const Parameters &params, int MaximumStep) {


  cout << "In SPRonSubTree " << endl;
 //checkTree();
  cout << "MaximumStep : " << MaximumStep << endl;
  int i;
  double r;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_sizeMset, N_sizeMset, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  cout << "nodeZ->getRoot() " << nodeZ->getRoot() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  cout << "nodeC->getnumber() " << nodeC->getnumber() << endl;



  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  int posiDel; 
  int Count = 0;
  lenX1 = 0;
  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      cout << "TempEdge num : " << TempEdge->getnumber() << endl;
      lenX1 += TempEdge->getEdgeLen();
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  cout << "lenX1 : " << lenX1 << " Mset size : " << Mset.size() << endl; 
  print_veci(Mset);
  cout << "posiDel " << posiDel << endl;
  

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 


  cout << "Final Mset " << endl;
  print_veci(Mset);

  // Select an edge where Z will move to.
  int selectedposi = (int)(rand.runif()*Mset.size());
  int TargetEdgeNum = Mset[selectedposi];

  cout << "selectedposi : " << selectedposi << "TargetEdgeNum : " << TargetEdgeNum << endl;
  
  if(selectedposi == 0){ // if edge which is connected to Z is selected, apply SPRonSingleEdge

    cout << "^^^^^^ Call SPRonSingleEdge ^^^^^^^" << endl;
    AP = SPRonSingleEdgeAsPartOfSPRonSubTree(rand,params,nodeZ->getnumber(), Edgenum);

  }else{                  // else if edge which is connected to Z is selected

    cout << "^^^^^^ Not Call SPRonSingleEdge ^^^^^^^" << endl;
    
    Edge* edgeT = getEdge(TargetEdgeNum);
    Edge* edgeX;
    Edge* edgeY;
    Node* nodeA;
    Node* nodeD;
    Node* nodeB1;
    Node* nodeBend; 
    Node* nodeBa; 
    Node* nodeBd; 
    Node* nodeBm; 
    Node* TempNode;

    double posiNewZ = rand.runif()*(edgeT->getEdgeLen()); // from start node of edgeT

    cout << "posiNewZ : " << posiNewZ << endl;
 
    lenXt = edgeT->getEdgeLen();

    // Construct Mrevset which is a set of edges in a maximum step based on the selected edge.
    vector<int> Mrevset(0);

    ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, edgeT , edgeT->getStart());
    posiDel = Mrevset.size();
    ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, edgeT , edgeT->getEnd());

    Mrevset.erase(Mrevset.begin() + posiDel); // Remove one of edgeT since edgeT counted two times. 

    cout << "Final Mrevset " << endl;
    print_veci(Mrevset);

    // Save all old information which will be used to calculate Acceptance prob.
    // Save likelihood and proposal prob of old IDH on e0 
    O_IDHlike = edge0->likeliHistory(params);
    O_psl= edge0->ProposHistory(params);
    N_sizeMset = Mset.size();
    O_sizeMset = Mrevset.size();

    // Set 0 at UpdatedNodeinRootSites
    set0UpdatedNodeinRootSites();

    // Determine which case should be applied and assign labels to nodes and edges
    if(nodeZ->getRoot()){

      cout << "******** CASEIA *****************" << endl;

      //----------------------//
      //                      //
      //       caseIa         //
      //                      //
      //----------------------//


     //checkTree();

      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();

      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //cout << "After reversing edgeY " << endl;
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      
      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);

      //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;	  
      //edgeY->printEdge();




      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
 

      //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeT " << endl;	  
      //edgeT->printEdge();

     //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();

      //cout << "After reversing edgeT " << endl;
      //cout << "edgeT " << endl;
      //edgeT->printEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
      
      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      //cout << "TempEdge number : " << TempEdge->getnumber() << endl;
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }

      cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
      //printTree(0);      
      //checkTree();

      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      edge0->runEdge(rand,params);
      edge0->calHMG();     
      
      cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
      //printTree(0);    
     //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeC->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }

      // 1'
      if(nodeZ->getRoot())
	nodeZ->findLinkedSites();

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

      //3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 4
      UpdateAllinfoToRoot(params, nodeBend); 

      cout << endl << "~~~~~ After updating all information " << endl;
      //printTree(0);
     //checkTree();
	
      // Update IDHlikelihood
      N_IDHlike = edge0->likeliHistory(params);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

    }else if(edge0 == nodeZ->getParentEdge()){

      cout << "******** CASEI *****************" << endl;
     //checkTree();

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//
    
      //----- Label nodes end edges ----//
      nodeA = edgeT->getEnd();
      nodeB1 = edgeT->getStart();
      TempNode = nodeB1;
      while(TempNode->getParent() != nodeZ)
	TempNode = TempNode->getParent();
      nodeBend = TempNode;
      edgeY = nodeBend->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeD = edgeX->getEnd();     


      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();



      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeY
      edgeY->ReverseEdge();

      //cout << "After reversing edgeY " << endl;
      //cout << "edgeY " << endl;
      //edgeY->printEdge();



      //      : Change IDH and edge length of edge X, edgeY and edgeT    
      combineIDHonTwoEdges(edgeY, edgeX);


      //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;	  
      //edgeY->printEdge();



      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeD->setParentEdge(edgeY);
      edgeY->setEnd(nodeD);
      edgeT->setEnd(nodeZ);
      edgeX->setEnd(nodeA);
      nodeA->setParentEdge(edgeX);
      nodeZ->setEdge(edgeY, edgeT);
      

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge X, edgeY and edgeT              
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);

      //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeT " << endl;	  
      //edgeT->printEdge();


      //      : Reverse IDH and change start and end nodes on edgeT
      edgeT->ReverseEdge();


      //cout << "After reversing edgeT " << endl;
      //cout << "edgeT " << endl;
      //edgeT->printEdge();



      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      int O_seqlenZ = nodeZ->getSeqLen();
      nodeZ->setSeqLen(edgeT->getIDH()->getN(0));
      





      //----- Reconstruct a tree ----------------------------------------------------------//
      //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
      //      : Change parent edge of nodes from B1 to Bend                                //
      Edge* TempEdge2;
      TempEdge = nodeB1->getParentEdge();
      nodeB1->changeParentEdge(edgeT);
      while(TempEdge != edgeY){
	TempNode = TempEdge->getStart();
	TempEdge->ReverseEdge();
	TempEdge2 = TempEdge;
	TempEdge = TempNode->getParentEdge();
	TempNode->changeParentEdge(TempEdge2);
      }



      cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
      //printTree(0);      
      //checkTree();



      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      edge0->runEdge(rand,params);
      edge0->calHMG();     


      cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
      //printTree(0);   
     //checkTree();
      
      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      TempNode = nodeD;
      while(TempNode != nodeZ){
	TempNode->findRootSites();
	TempNode = TempNode->getParent();
      }
      nodeZ->findRootSites();

      // 1'
      if(nodeC->getRoot())
	nodeC->findLinkedSites();

      // 2
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
	
      nodeD->CalSubTreeProb(params);
      nodeD->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;

      // 3 and 4
      UpdateAllinfoToRoot(params, nodeBend); 



      cout << endl << "~~~~~ After updating all information " << endl;
      //printTree(0);
     //checkTree();
      //-------- Update IDHlikelihood ----------------//
      r = params.getR();
      O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
      N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
      
    }else{

      vector<int> Zancestor(0);
      bool notHitNewZ = false;
      TempEdge = nodeZ->getParentEdge();
      while(TempEdge != edgeT){
	TempNode = TempEdge->getStart();
	Zancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitNewZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }

      if(!notHitNewZ){ // Hit EdgeT


	cout << "******** CASEIII *****************" << endl;	 
	checkTree();
	
	//----------------------//
	//                      //
	//       caseIII        //
	//                      //
	//----------------------//

	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeB1 = getNode(Zancestor[0]);
	nodeBend = getNode(Zancestor[Zancestor.size()-1]);
	nodeD = edgeT->getStart();


	//cout << "nodeA : " << endl;
	//nodeA->printNode();
	//cout << "nodeB1 : " << endl;
	//nodeB1->printNode();
	//cout << "nodeBend : " << endl;
	//nodeBend->printNode();
	//cout << "nodeD : " << endl;
	//nodeD->printNode(); 
	//cout << "edgeX " << endl;
	//edgeX->printEdge();
	//cout << "edgeY " << endl;
	//edgeY->printEdge();
	//cout << "edgeT " << endl;
	//edgeT->printEdge();


	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);


	//----- Reconstruct a tree -------//
	//      : tree structure          //
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);
	edgeT->setEnd(nodeZ);
	nodeBend->setParentEdge(edgeX);
	edgeX->setEnd(nodeBend);
	nodeZ->setParentEdge(edgeT);

	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
	
  	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));


	cout << "print Tree in SPRonSubTree after reconstruction!" << endl;
	//printTree(0);
	//checkTree();

	
  	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	edge0->runEdge(rand,params);
	edge0->calHMG();


	cout << "print Tree in SPRonSubTree after generating new IDH on edge0!" << endl;
	//printTree(0);
	checkTree();


	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
        // 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();

	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();

	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	

	// 4 and 5
	UpdateAllinfoToRoot(params, nodeB1);

	cout << endl << "~~~~~ After updating all information " << endl;
	//printTree(0);	
	checkTree();

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

	
      }else{          // didn't hit EdgeT
    
	vector<int> newZancestor(0);
	bool notHitZ = false;
	TempEdge = edgeT;
	while(TempEdge->getStart() != nodeZ){
	  TempNode = TempEdge->getStart();
	  newZancestor.push_back(TempNode->getnumber());
	  if(TempNode->getRoot()){
	    notHitZ = true;
	    break;
	  }
	  TempEdge = TempNode->getParentEdge();
	}	
	
	if(!notHitZ){ // Hit Z

	  cout << "******** CASEIV *****************" << endl;	  
	 //checkTree();
	  //----------------------//
	  //                      //
	  //       caseIV         //
	  //                      //
	  //----------------------//
	  
	  //----- Label nodes end edges ----//
	  nodeA = edgeT->getEnd();
	  nodeB1 = getNode(newZancestor[0]);
	  nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	  edgeX = nodeBend->getParentEdge();
	  edgeY = nodeZ->getParentEdge();
	  nodeD = edgeY->getStart();

	  //cout << "nodeA : " << endl;
	  //nodeA->printNode();
	  //cout << "nodeB1 : " << endl;
	  //nodeB1->printNode();
	  //cout << "nodeBend : " << endl;
	  //nodeBend->printNode();
	  //cout << "nodeD : " << endl;
	  //nodeD->printNode(); 
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeY " << endl;
	  //edgeY->printEdge();
	  //cout << "edgeT " << endl;
	  //edgeT->printEdge();



	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeY " << endl;	  
	  //edgeY->printEdge();


	  //----- Reconstruct a tree -------//
	  //      : tree structure          //
	  edgeY->setEnd(nodeBend);
	  nodeBend->setParentEdge(edgeY);
	  edgeT->setEnd(nodeZ);
	  edgeX->setEnd(nodeA);
	  nodeA->setParentEdge(edgeX);
	  nodeZ->setParentEdge(edgeT);

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  

	  //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeT " << endl;	  
	  //edgeT->printEdge();


	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	  

	  cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
	  //printTree(0);      
	  //checkTree();

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  edge0->runEdge(rand,params);
	  edge0->calHMG();

	  cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
	  //printTree(0);   
	 //checkTree();

	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1
	  nodeA->findRootSites();
	  nodeBend->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeD->getRoot())
	    nodeD->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4 and 5
	  UpdateAllinfoToRoot(params, nodeZ);

	  cout << endl << "~~~~~ After updating all information " << endl;
	  //printTree(0);
	 //checkTree();
	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	  
	}else{        // didn't hit Z

	  cout << "******** CASEII *****************" << endl;	  
	 //checkTree();
	  //----------------------//
	  //                      //
	  //       caseII         //
	  //                      //
	  //----------------------//	  

	  // Find Bm which is the first common node of Zancestor and newZancestor
	  for(i = 0; i < Zancestor.size(); i++){
	    if(is_element(newZancestor, Zancestor[i]))
	      break;
	  }
	  if(i == Zancestor.size())
	    cout << "Error! Zancestor and newZancestor should have common element." << endl;
	  else
	    nodeBm = getNode(Zancestor[i]);

	  //----- Label nodes end edges ----//
	  edgeY = nodeZ->getParentEdge();
	  nodeBa = getNode(Zancestor[0]);
	  edgeX = nodeZ->leftEdge(edge0, edgeY);
	  nodeA = edgeX->getEnd();
	  nodeD = edgeT->getEnd();
	  nodeBd = edgeT->getStart();


	  //cout << "nodeA : " << endl;
	  //nodeA->printNode();
	  //cout << "nodeBa : " << endl;
	  //nodeBa->printNode();
	  //cout << "nodeBd : " << endl;
	  //nodeBd->printNode();
	  //cout << "nodeBm : " << endl;
	  //nodeBm->printNode();	  
	  //cout << "nodeD : " << endl;
	  //nodeD->printNode(); 
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeY " << endl;
	  //edgeY->printEdge();
	  //cout << "edgeT " << endl;
	  //edgeT->printEdge();

	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  combineIDHonTwoEdges(edgeY, edgeX);

	  //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeY " << endl;	  
	  //edgeY->printEdge();

	  //----- Reconstruct a tree -------//
	  //      : tree structure          //	
	  nodeA->setParentEdge(edgeY);
	  edgeY->setEnd(nodeA);	  
	  nodeD->setParentEdge(edgeX);
	  edgeX->setEnd(nodeD);
	  nodeZ->setParentEdge(edgeT);
	  edgeT->setEnd(nodeZ);


	  //----- Reconstruct a tree ---------------------------------------//
	  //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	  separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	

	  //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
	  //cout << "edgeX " << endl;
	  //edgeX->printEdge();
	  //cout << "edgeT " << endl;	  
	  //edgeT->printEdge();


	  //----- Reconstruct a tree --------------//
	  //      : Change sequence length at Z    //
	  nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	  
	  cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
	  //printTree(0);
	  //checkTree();

	  //----- Reconstruct a tree --------------//
	  //      : Generate new IDH on e0         //
	  edge0->runEdge(rand,params);
	  edge0->calHMG();

	  cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
	  //printTree(0);
	  
	 //checkTree();
	  
	  //----- Update gijk, rootSites, LinkedSites and likelihood --------//
	  // 1	  

	  nodeA->findRootSites();
	  nodeD->findRootSites();
	  nodeC->findRootSites();
	  nodeZ->findRootSites();

	  // 1'
	  if(nodeBa->getRoot())
	    nodeBa->findLinkedSites();
	  else if(nodeBd->getRoot())
	    nodeBd->findLinkedSites();
	    
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3
	  nodeA->CalSubTreeProb(params);
	  nodeA->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	  
	  // 4
	  nodeD->CalSubTreeProb(params);
	  nodeD->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	  	  
	  // 5 and 6
	  UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);

	  // 7 and 8  
	  UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	  
	  // 9 and 10
	  UpdateAllinfoToRoot(params, nodeBm);	  

	  cout << endl << "~~~~~ After updating all information " << endl;
	  //printTree(0);	  
	 //checkTree();
	  //-------- Update IDHlikelihood ----------------//
	  N_IDHlike = edge0->likeliHistory(params);   
	  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

      
	}
	
	newZancestor.resize(0);
      }

      Zancestor.resize(0);
    }
    
    Mrevset.resize(0);

    O_datalike = logLikeliData[current];
    logLikeliData[current] = likeliData();    
    N_datalike = logLikeliData[current];
    N_psl= edge0->ProposHistory(params);      

    cout << "Updated information !!!!! " << endl;
    cout << "N_datalike : " << N_datalike << endl;


    AP = exp(N_datalike + N_IDHlike + O_psl + log(lenXt) + log((double)N_sizeMset) - O_datalike - O_IDHlike - N_psl - log(lenX1) - log((double)O_sizeMset));

  }
  
  Mset.resize(0);
 
  return AP;

}

*/




// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeLike(bool saveIDH, Rand &rand,const Parameters &params, int numZnode, int Edgenum, double ratio, int baseNodenum, vector<InDelHistory*> listIDH, bool UseRand) {


  int i, j, k, m, tmphmg;  
  double r, loglike, datalike, IDHlike, O_IDHlike, N_IDHlike, Treelike, Edgelike;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];

  // Select an adjacent edge e3 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  O_IDHlike = edge0->likeliHistory(params);
  
  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  

  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = ratio*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //

    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      if(UseRand)
	edge0->runEdge(rand,params);  
      else
	(*edge0->getIDH()) = (*listIDH[0]); 
      edge0->ReverseEdge();
    }else{
      if(UseRand)
	edge0->runEdge(rand,params);  
      else
	(*edge0->getIDH()) = (*listIDH[0]);
      edge0->calHMG();
    }     
        
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
        
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
 
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
    // Update IDHlikelihood
    N_IDHlike = edge0->likeliHistory(params);   
    

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = ratio*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  

    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      if(UseRand)
	edge0->runEdge(rand,params);  
      else
	(*edge0->getIDH()) = (*listIDH[0]); 
      edge0->ReverseEdge();
    }else{
      if(UseRand)
	edge0->runEdge(rand,params);
      else
	(*edge0->getIDH()) = (*listIDH[0]);
      edge0->calHMG();     
    }
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();

    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;

    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
 
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
 
    
    // Update IDHlikelihood
    r = params.getR();
    
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
     

  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
     
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = ratio*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
   
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
     

    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
   

    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      if(UseRand)
	edge0->runEdge(rand,params);  
      else
	(*edge0->getIDH()) = (*listIDH[0]); 
      edge0->ReverseEdge();
    }else{
      if(UseRand)
	edge0->runEdge(rand,params);
      else
	(*edge0->getIDH()) = (*listIDH[0]);
      edge0->calHMG();     
    }  
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeZ->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     

    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
 
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
   
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
    // Update IDHlikelihood
    N_IDHlike = edge0->likeliHistory(params);   
 
  }

  if(nodeZ == edge0->getEnd()){
    if((UseRand) & (saveIDH)){
      edge0->ReverseEdge();
      (*listIDH[0]) = (*edge0->getIDH());
      edge0->ReverseEdge();
    }
  }else{
    if((UseRand) & (saveIDH))
      (*listIDH[0]) = (*edge0->getIDH());
  }
 
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  logLikeliData[current] = likeliData();    

  
  datalike = logLikeliData[current];
  IDHlike = logLikeliIDH[current];

  Treelike = 0;
  Edgelike = 0;

  loglike = datalike + IDHlike + Treelike + Edgelike;

  return loglike;

}




// This update should be applied only to binary tree. 
// But, we could extend this to all tree structures. 
double Tree::SPRonSingleEdgeAsPartOfSPRonSubTreeLike_v0(bool saveIDH, Rand &rand,const Parameters &params, int numZnode, int Edgenum, double ratio, int baseNodenum, vector<InDelHistory*> listIDH, bool UseRand) {

  //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 1" << endl;

  int i, j, k, m, tmphmg;  
  double r, loglike, datalike, IDHlike, O_IDHlike, N_IDHlike, Treelike, Edgelike;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numZnode];
  //O_seqlenZ = nodeZ->getSeqLen();
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  //cout << "nodeZ->getRoot() " << nodeZ->getRoot() << endl;

  // Select an adjacent edge e3 at random.
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  //cout << "Edgenum " << Edgenum << endl;
  //cout << "edge3->getnumber() " << edge3->getnumber() << endl;

  O_IDHlike = edge0->likeliHistory(params);

  //cout << "O_IDHlike " << O_IDHlike << endl;

  //O_psl= edge0->ProposHistory(params);

  //cout << "O_psl " << O_psl << endl;
  
  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  //cout << "nodeC->getnumber() " << nodeC->getnumber() << endl;



  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;

  double newAlen, newBlen, lenAandB, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  

  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //cout << "******** CASEIIA *****************" << endl;

      //----------------------//
      //                      //
      //       caseIIa         //
      //                      //
      //----------------------//


      //checkTree();

      //----- Label nodes end edges ----//
      j = 0;
      for(i = 0; i < nodeZ->getnumEdges(); i++){
	if(Edgenum!=i){
	  if(j==0){
	    edgeA = nodeZ->getEdge(i);
	    nodeA = edgeA->getOtherNode(nodeZ);
	    j++;
	  }else{
	    edgeB = nodeZ->getEdge(i);
	    nodeB = edgeB->getOtherNode(nodeZ);	  
	  }
	}
      }

      //--- Assign new position --//
      lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
      templen = ratio*(lenAandB);
      if(nodeA->getnumber() == baseNodenum){
	newAlen = templen;
	newBlen = lenAandB - newAlen;
      }else{
	newBlen = templen;
	newAlen = lenAandB - newBlen;	
      }


      //----- Reconstruct a tree ---------------------------------------//
      //      : Reverse IDH and change start and end nodes on edgeA
      edgeA->ReverseEdge();


      //      : Change IDH and edge length of edge A and edge B   
      moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);

      //      : Reverse IDH and change start and end nodes on edgeA
      edgeA->ReverseEdge();

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeA->getIDH()->getN(0));


      //----- Reconstruct a tree --------------//

      //      : Generate new IDH on e0         //
      if(UseRand)
	edge0->runEdge(rand,params);
      else
	(*edge0->getIDH()) = (*listIDH[0]);
      edge0->calHMG();     
      
      //checkTree();

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeB->findRootSites();
      nodeC->findRootSites();     

      // 1'
      nodeZ->findLinkedSites();

      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 2" << endl;


      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 3" << endl;
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 4" << endl;

      //3
      nodeA->CalSubTreeProb(params);
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 5" << endl;
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 6" << endl;
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 7" << endl;


      nodeB->CalSubTreeProb(params);
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 8" << endl;
      nodeB->CalloglikeliofRootSitesOrReuse(params);
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 9" << endl;
      UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 10" << endl;

      // 4
      UpdateAllinfoToRoot(params, nodeZ); 
      
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 11" << endl;

      //cout << endl << "~~~~~ After updating all information " << endl;
      //printTree(0);
      //checkTree();
	
      // Update IDHlikelihood
      N_IDHlike = edge0->likeliHistory(params);   
      
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 12" << endl;


  }else if(nodeZ->getParentEdge()==edge0){

    
    //cout << "******** CASEII *****************" << endl;
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    

    //cout << "nodeA : " << endl;
    //nodeA->printNode();
    //cout << "nodeB : " << endl;
    //nodeB->printNode();
    //cout << "edgeA " << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();


    //--- Assign new position --//
    lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    templen = ratio*(lenAandB);
    if(nodeA->getnumber() == baseNodenum){
      newAlen = templen;
      newBlen = lenAandB - newAlen;
    }else{
      newBlen = templen;
      newAlen = lenAandB - newBlen;	
    }
    
    //cout << " templen : " << templen << " newAlen : " << newAlen << " newBlen : " << newBlen << endl;


    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
   
    //cout << " After reverse edgeA " << endl;
    //cout << "edgeA " << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();

    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //cout << " After move edge " << endl;
    //cout << "edgeA " << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();

  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    //cout << " After reverse edge A again " << endl;
    //cout << "edgeA " << endl;
    //edgeA->printEdge();
    //cout << "edgeB " << endl;
    //edgeB->printEdge();


    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    
    //      : Generate new IDH on e0         //
   if(UseRand)
      edge0->runEdge(rand,params);
    else
      (*edge0->getIDH()) = (*listIDH[0]);
    edge0->calHMG();     
    
    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();

    
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 13" << endl;
    //3
    nodeA->CalSubTreeProb(params);
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 14" << endl;
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 15" << endl;
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 16" << endl;
    
    nodeB->CalSubTreeProb(params);
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 17" << endl;
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 18" << endl;
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 19" << endl;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 20" << endl;
    
    //cout << endl << "~~~~~ After updating all information " << endl;
    //printTree(0);
    //checkTree();
    
    // Update IDHlikelihood
    r = params.getR();
    
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
      
    //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 21" << endl;

  }else{

    //cout << "******** CASEI   *****************" << endl;

      //----------------------//
      //                      //
      //       caseI          //
      //                      //
      //----------------------//


      //checkTree();
      
      //----- Label nodes end edges ----//
      for(i = 0; i < nodeZ->getnumEdges(); i++){
	if(Edgenum!=i){
	  if(nodeZ->getparentIndex()==i){
	    edgeA = nodeZ->getEdge(i);
	    nodeA = edgeA->getOtherNode(nodeZ);
	  }else{
	    edgeB = nodeZ->getEdge(i);
	    nodeB = edgeB->getOtherNode(nodeZ);	  
	  }
	}
      }


      //checkTree();
      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB : " << endl;
      //nodeB->printNode();
      //cout << "edgeA " << endl;
      //edgeA->printEdge();
      //cout << "edgeB " << endl;
      //edgeB->printEdge();



      //--- Assign new position --//
      lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
      templen = ratio*(lenAandB);
      if(nodeA->getnumber() == baseNodenum){
	newAlen = templen;
	newBlen = lenAandB - newAlen;
      }else{
	newBlen = templen;
	newAlen = lenAandB - newBlen;	
      }
    

      //checkTree();

      //cout << " templen : " << templen << " newAlen : " << newAlen << " newBlen : " << newBlen << endl;



      //cout << " Before move edge " << endl;
      //cout << "edgeA " << endl;
      //edgeA->printEdge();
      //cout << "edgeB " << endl;
      //edgeB->printEdge();
      //cout << " newAlen : " << newAlen << " newBlen : " << newBlen << endl;

      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edge A and edge B   
      moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);

      //cout << " After move edge " << endl;
      //cout << "edgeA " << endl;
      //edgeA->printEdge();
      //cout << "edgeB " << endl;
      //edgeB->printEdge();    

      //checkTree();
      //cout << " After move edge " << endl;
      //cout << "edgeA " << endl;
      //edgeA->printEdge();
      //cout << "edgeB " << endl;
      //edgeB->printEdge();
      

      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeB->getIDH()->getN(0));

      //checkTree();

      //----- Reconstruct a tree --------------//

      //      : Generate new IDH on e0         //

      //cout << "UseRand " << UseRand << endl;
      if(UseRand)
	edge0->runEdge(rand,params);
      else
	(*edge0->getIDH()) = (*listIDH[0]);
      edge0->calHMG();     
      //printTree();
      //checkTree();


      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      //cout << "findRootSites nodeZ " << endl;
      //cout << "nodeZ : " << endl;
      //nodeZ->printNode();      
      nodeZ->findRootSites();
      //cout << "findRootSites nodeB " << endl;
      //cout << "nodeB : " << endl;
      //nodeB->printNode();        
      nodeB->findRootSites();
      //cout << "findRootSites nodeC " << endl;
      //cout << "nodeC : " << endl;
      //nodeC->printNode();  
      nodeC->findRootSites();     

      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 22" << endl;

      // 1'
      if(nodeA->getRoot())
	nodeA->findLinkedSites();

      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 23" << endl;

      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 24" << endl;
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 25" << endl;

      //3      
      nodeB->CalSubTreeProb(params);
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 26" << endl;
      nodeB->CalloglikeliofRootSitesOrReuse(params);
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 27" << endl;
      UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 28" << endl;

      // 4
      UpdateAllinfoToRoot(params, nodeZ); 
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 29" << endl;

      //cout << endl << "~~~~~ After updating all information " << endl;
      //printTree(0);
      //checkTree();
	
      // Update IDHlikelihood
      N_IDHlike = edge0->likeliHistory(params);   
      //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 30" << endl;
      

  }

  //cout << "AAAAAA " << endl;

  if((UseRand) & (saveIDH))
    (*listIDH[0]) = (*edge0->getIDH());

  //cout << "BBBBBB " << endl;
  
  //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 31" << endl;
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
  //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 32" << endl;
  logLikeliData[current] = likeliData();    
  //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 33" << endl;
  
  datalike = logLikeliData[current];
  //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 34" << endl;
  IDHlike = logLikeliIDH[current];
  //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike 35" << endl;
  Treelike = 0;
  Edgelike = 0;

  loglike = datalike + IDHlike + Treelike + Edgelike;

  //cout << "In SPRonSingleEdgeAsPartOfSPRonSubTreeLike done!!!!!!!!" << endl;
  return loglike;


}





// This function will be used as part of SPRonSubTreeLike two times.
// 1. To determined edges to move (UseRand == TRUE)
// 2. To construct Tree by selected edge (UseRand == FALSE)
double Tree::SPRonSubTreeAsPartOfSPRonSubTreeLike(bool saveIDH, Rand &rand, const Parameters &params, int numZnode, int Edgenum, double ratio, int baseNodenum, int TargetEdgeNum, vector<InDelHistory*> listIDH, int index, bool UseRand) {

  int i;
  double r, templen, posiNewZ, loglike, datalike, IDHlike, O_IDHlike, N_IDHlike, Treelike, Edgelike, lenXt, lenX1;
  Edge* TempEdge;


  Node* nodeZ = nodes[numZnode];

  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_IDHlike = edge0->likeliHistory(params);
  
  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
    
  Edge* edgeT = getEdge(TargetEdgeNum);
  Edge* edgeX;
  Edge* edgeY;
  Node* nodeA;
  Node* nodeD;
  Node* nodeB1;
  Node* nodeBend; 
  Node* nodeBa; 
  Node* nodeBd; 
  Node* nodeBm; 
  Node* TempNode;

  lenXt = edgeT->getEdgeLen();

  templen = ratio*lenXt;
  if(edgeT->getStart()->getnumber() == baseNodenum)
    posiNewZ = templen; // from start node of edgeT
  else if(edgeT->getEnd()->getnumber() == baseNodenum)
    posiNewZ = lenXt - templen;
  else
    cout << "ERROR! Given base node is not connected to a target Edge!" << endl;
   
  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites();
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){
      
    //----------------------//
    //                      //
    //       caseIa         //
    //                      //
    //----------------------//
    
    //----- Label nodes end edges ----//
    nodeA = edgeT->getEnd();
    nodeB1 = edgeT->getStart();
    TempNode = nodeB1;
    while(TempNode->getParent() != nodeZ)
      TempNode = TempNode->getParent();
    nodeBend = TempNode;
    edgeY = nodeBend->getParentEdge();
    edgeX = nodeZ->leftEdge(edge0, edgeY);
    nodeD = edgeX->getEnd();
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeY
    edgeY->ReverseEdge();
    
    //      : Change IDH and edge length of edge X, edgeY and edgeT    
    combineIDHonTwoEdges(edgeY, edgeX);
    
    //----- Reconstruct a tree -------//
    //      : tree structure          //
    nodeD->setParentEdge(edgeY);
    edgeY->setEnd(nodeD);
    edgeT->setEnd(nodeZ);
    edgeX->setEnd(nodeA);
    nodeA->setParentEdge(edgeX);
    nodeZ->setEdge(edgeY, edgeT);
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge X, edgeY and edgeT              
    separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
    
    //      : Reverse IDH and change start and end nodes on edgeT
    edgeT->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
    
    //----- Reconstruct a tree ----------------------------------------------------------//
    //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
    //      : Change parent edge of nodes from B1 to Bend                                //
    Edge* TempEdge2;
    TempEdge = nodeB1->getParentEdge();
    nodeB1->changeParentEdge(edgeT);
    while(TempEdge != edgeY){
      TempNode = TempEdge->getStart();
      TempEdge->ReverseEdge();
      TempEdge2 = TempEdge;
      TempEdge = TempNode->getParentEdge();
      TempNode->changeParentEdge(TempEdge2);
    }
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      if(UseRand)
	edge0->runEdge(rand,params);  
      else
	(*edge0->getIDH()) = (*listIDH[index]); 
      edge0->ReverseEdge();
    }else{
      if(UseRand)
	edge0->runEdge(rand,params);
      else
	(*edge0->getIDH()) = (*listIDH[index]);
      edge0->calHMG();
    }     
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeC->findRootSites();
    TempNode = nodeD;
    while(TempNode != nodeZ){
      TempNode->findRootSites();
      TempNode = TempNode->getParent();
    }
    
    // 1'
    if(nodeZ->getRoot())
      nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeD->CalSubTreeProb(params);
    nodeD->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeBend); 
    
    // Update IDHlikelihood
    N_IDHlike = edge0->likeliHistory(params);   

  }else if(edge0 == nodeZ->getParentEdge()){
    
    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    //----- Label nodes end edges ----//
    nodeA = edgeT->getEnd();
    nodeB1 = edgeT->getStart();
    TempNode = nodeB1;
    while(TempNode->getParent() != nodeZ)
      TempNode = TempNode->getParent();
    nodeBend = TempNode;
    edgeY = nodeBend->getParentEdge();
    edgeX = nodeZ->leftEdge(edge0, edgeY);
    nodeD = edgeX->getEnd();     

    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeY
    edgeY->ReverseEdge();
    
    //      : Change IDH and edge length of edge X, edgeY and edgeT    
    combineIDHonTwoEdges(edgeY, edgeX);
   
    
    //----- Reconstruct a tree -------//
    //      : tree structure          //
    nodeD->setParentEdge(edgeY);
    edgeY->setEnd(nodeD);
    edgeT->setEnd(nodeZ);
    edgeX->setEnd(nodeA);
    nodeA->setParentEdge(edgeX);
    nodeZ->setEdge(edgeY, edgeT);
    
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge X, edgeY and edgeT              
    separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
    
    //      : Reverse IDH and change start and end nodes on edgeT
    edgeT->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeT->getIDH()->getN(0));
    
  
    //----- Reconstruct a tree ----------------------------------------------------------//
    //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
    //      : Change parent edge of nodes from B1 to Bend                                //
    Edge* TempEdge2;
    TempEdge = nodeB1->getParentEdge();
    nodeB1->changeParentEdge(edgeT);
    while(TempEdge != edgeY){
      TempNode = TempEdge->getStart();
      TempEdge->ReverseEdge();
      TempEdge2 = TempEdge;
      TempEdge = TempNode->getParentEdge();
      TempNode->changeParentEdge(TempEdge2);
    }
   
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(nodeZ == edge0->getEnd()){
      edge0->changeStartEnd();
      if(UseRand)
	edge0->runEdge(rand,params);  
      else
	(*edge0->getIDH()) = (*listIDH[index]); 
      edge0->ReverseEdge();
    }else{
      if(UseRand)
	edge0->runEdge(rand,params);
      else
	(*edge0->getIDH()) = (*listIDH[index]);
      edge0->calHMG();
    }     
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    TempNode = nodeD;
    while(TempNode != nodeZ){
      TempNode->findRootSites();
      TempNode = TempNode->getParent();
    }
    nodeZ->findRootSites();
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    // 2
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeD->CalSubTreeProb(params);
    nodeD->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;
    
    // 3 and 4
    UpdateAllinfoToRoot(params, nodeBend); 
    
   
    //-------- Update IDHlikelihood ----------------//
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   

  }else{
    
    vector<int> Zancestor(0);
    bool notHitNewZ = false;
    TempEdge = nodeZ->getParentEdge();
    while(TempEdge != edgeT){
      TempNode = TempEdge->getStart();
      Zancestor.push_back(TempNode->getnumber());
      if(TempNode->getRoot()){
	notHitNewZ = true;
	break;
      }
      TempEdge = TempNode->getParentEdge();
    }
    
    if(!notHitNewZ){ // Hit EdgeT
      
      
      //----------------------//
      //                      //
      //       caseIII        //
      //                      //
      //----------------------//
      
      //----- Label nodes end edges ----//
      edgeY = nodeZ->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeA = edgeX->getEnd();
      nodeB1 = getNode(Zancestor[0]);
      nodeBend = getNode(Zancestor[Zancestor.size()-1]);
      nodeD = edgeT->getStart();
     
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
      combineIDHonTwoEdges(edgeY, edgeX);
      

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeA->setParentEdge(edgeY);
      edgeY->setEnd(nodeA);
      edgeT->setEnd(nodeZ);
      nodeBend->setParentEdge(edgeX);
      edgeX->setEnd(nodeBend);
      nodeZ->setParentEdge(edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
      
      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
      
      
      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(nodeZ == edge0->getEnd()){
	edge0->changeStartEnd();
	if(UseRand)
	  edge0->runEdge(rand,params);  
	else
	  (*edge0->getIDH()) = (*listIDH[index]); 
	edge0->ReverseEdge();
      }else{
	if(UseRand)
	  edge0->runEdge(rand,params);
	else
	  (*edge0->getIDH()) = (*listIDH[index]);
	edge0->calHMG();
      }

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeBend->findRootSites();
      nodeC->findRootSites();
      nodeZ->findRootSites();
      
      // 1'
      if(nodeD->getRoot())
	nodeD->findLinkedSites();
      
      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
      
      // 3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
      
      // 4 and 5
      UpdateAllinfoToRoot(params, nodeB1);
      
      //-------- Update IDHlikelihood ----------------//
      N_IDHlike = edge0->likeliHistory(params);   
      
    }else{          // didn't hit EdgeT
      
      vector<int> newZancestor(0);
      bool notHitZ = false;
      TempEdge = edgeT;
      while(TempEdge->getStart() != nodeZ){
	TempNode = TempEdge->getStart();
	newZancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }	
      
      if(!notHitZ){ // Hit Z
	
	//----------------------//
	//                      //
	//       caseIV         //
	//                      //
	//----------------------//
	
	//----- Label nodes end edges ----//
	nodeA = edgeT->getEnd();
	nodeB1 = getNode(newZancestor[0]);
	nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	edgeX = nodeBend->getParentEdge();
	edgeY = nodeZ->getParentEdge();
	nodeD = edgeY->getStart();
	
	
	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);
	

	
	//----- Reconstruct a tree -------//
	//      : tree structure          //
	edgeY->setEnd(nodeBend);
	nodeBend->setParentEdge(edgeY);
	edgeT->setEnd(nodeZ);
	edgeX->setEnd(nodeA);
	nodeA->setParentEdge(edgeX);
	nodeZ->setParentEdge(edgeT);
	
	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  
	
	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	

	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  if(UseRand)
	    edge0->runEdge(rand,params);  
	  else
	    (*edge0->getIDH()) = (*listIDH[index]); 
	  edge0->ReverseEdge();
	}else{
	  if(UseRand)
	    edge0->runEdge(rand,params);
	  else
	    (*edge0->getIDH()) = (*listIDH[index]);
	  edge0->calHMG();
	}

	
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
	// 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();
	
	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	
	// 4 and 5
	UpdateAllinfoToRoot(params, nodeZ);
	

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	  
      }else{        // didn't hit Z
	
    
	//----------------------//
	//                      //
	//       caseII         //
	//                      //
	//----------------------//	  
	
	// Find Bm which is the first common node of Zancestor and newZancestor
	for(i = 0; i < Zancestor.size(); i++){
	  if(is_element(newZancestor, Zancestor[i]))
	    break;
	}
	if(i == Zancestor.size())
	  cout << "Error! Zancestor and newZancestor should have common element." << endl;
	else
	  nodeBm = getNode(Zancestor[i]);
	
	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	nodeBa = getNode(Zancestor[0]);
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeD = edgeT->getEnd();
	nodeBd = edgeT->getStart();
       
	
	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);
	
	//----- Reconstruct a tree -------//
	//      : tree structure          //	
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);	  
	nodeD->setParentEdge(edgeX);
	edgeX->setEnd(nodeD);
	nodeZ->setParentEdge(edgeT);
	edgeT->setEnd(nodeZ);
	
	
	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	
	
	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(nodeZ == edge0->getEnd()){
	  edge0->changeStartEnd();
	  if(UseRand)
	    edge0->runEdge(rand,params);  
	  else
	    (*edge0->getIDH()) = (*listIDH[index]); 
	  edge0->ReverseEdge();
	}else{
	  if(UseRand)
	    edge0->runEdge(rand,params);
	  else
	    (*edge0->getIDH()) = (*listIDH[index]);
	  edge0->calHMG();
	}


	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
	// 1	  
	
	nodeA->findRootSites();
	nodeD->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();
	
	// 1'
	if(nodeBa->getRoot())
	  nodeBa->findLinkedSites();
	else if(nodeBd->getRoot())
	  nodeBd->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	
	// 4
	nodeD->CalSubTreeProb(params);
	nodeD->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	
	// 5 and 6
	UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);
	
	// 7 and 8  
	UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	
	// 9 and 10
	UpdateAllinfoToRoot(params, nodeBm);	  
	

	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	
      }
      
      newZancestor.resize(0);
    }
    
    Zancestor.resize(0);
  }



  if(nodeZ == edge0->getEnd()){
    if((UseRand) & (saveIDH)){
      edge0->ReverseEdge();
      (*listIDH[index]) = (*edge0->getIDH());
      edge0->ReverseEdge();
    }
  }else{
    if((UseRand) & (saveIDH))
      (*listIDH[index]) = (*edge0->getIDH());
  }


  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
  logLikeliData[current] = likeliData();    
  
  datalike = logLikeliData[current];
  IDHlike = logLikeliIDH[current];
  Treelike = 0;
  Edgelike = 0;
  
  loglike = datalike + IDHlike + Treelike + Edgelike;
  
  return loglike;

}  // End of SPRonSubTreeAsPartOfSPRonSubTreeLike






// This function will be used as part of SPRonSubTreeLike two times.
// 1. To determined edges to move (UseRand == TRUE)
// 2. To construct Tree by selected edge (UseRand == FALSE)
double Tree::SPRonSubTreeAsPartOfSPRonSubTreeLike_v0(bool saveIDH, Rand &rand, const Parameters &params, int numZnode, int Edgenum, double ratio, int baseNodenum, int TargetEdgeNum, vector<InDelHistory*> listIDH, int index, bool UseRand) {

  //cout << "In  SPRonSubTreeAsPartOfSPRonSubTreeLike" << endl;
  //checkTree();
  //cout << "MaximumStep : " << MaximumStep << endl;
  int i;
  double r, templen, posiNewZ, loglike, datalike, IDHlike, O_IDHlike, N_IDHlike, Treelike, Edgelike, lenXt, lenX1;
  Edge* TempEdge;


  Node* nodeZ = nodes[numZnode];

  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_IDHlike = edge0->likeliHistory(params);
  
  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
    
  Edge* edgeT = getEdge(TargetEdgeNum);
  Edge* edgeX;
  Edge* edgeY;
  Node* nodeA;
  Node* nodeD;
  Node* nodeB1;
  Node* nodeBend; 
  Node* nodeBa; 
  Node* nodeBd; 
  Node* nodeBm; 
  Node* TempNode;

  lenXt = edgeT->getEdgeLen();

  templen = ratio*lenXt;
  if(edgeT->getStart()->getnumber() == baseNodenum)
    posiNewZ = templen; // from start node of edgeT
  else if(edgeT->getEnd()->getnumber() == baseNodenum)
    posiNewZ = lenXt - templen;
  else
    cout << "ERROR! Given base node is not connected to a target Edge!" << endl;
  
 
  O_IDHlike = edge0->likeliHistory(params);
 
  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites();
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){
    
    //cout << "******** CASEIA *****************" << endl;
    
    //----------------------//
    //                      //
    //       caseIa         //
    //                      //
    //----------------------//
    

    //checkTree();

    //----- Label nodes end edges ----//
    nodeA = edgeT->getEnd();
    nodeB1 = edgeT->getStart();
    TempNode = nodeB1;
    while(TempNode->getParent() != nodeZ)
      TempNode = TempNode->getParent();
    nodeBend = TempNode;
    edgeY = nodeBend->getParentEdge();
    edgeX = nodeZ->leftEdge(edge0, edgeY);
    nodeD = edgeX->getEnd();
    
    //cout << "nodeA : " << endl;
    //nodeA->printNode();
    //cout << "nodeB1 : " << endl;
    //nodeB1->printNode();
    //cout << "nodeBend : " << endl;
    //nodeBend->printNode();
    //cout << "nodeD : " << endl;
    //nodeD->printNode(); 
    //cout << "edgeX " << endl;
    //edgeX->printEdge();
    //cout << "edgeY " << endl;
    //edgeY->printEdge();
    //cout << "edgeT " << endl;
    //edgeT->printEdge();
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeY
    edgeY->ReverseEdge();
    
    //cout << "After reversing edgeY " << endl;
    //cout << "edgeY " << endl;
    //edgeY->printEdge();
    
    //      : Change IDH and edge length of edge X, edgeY and edgeT    
    combineIDHonTwoEdges(edgeY, edgeX);
    
    //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
    //cout << "edgeX " << endl;
    //edgeX->printEdge();
    //cout << "edgeY " << endl;	  
    //edgeY->printEdge();




    //----- Reconstruct a tree -------//
    //      : tree structure          //
    nodeD->setParentEdge(edgeY);
    edgeY->setEnd(nodeD);
    edgeT->setEnd(nodeZ);
    edgeX->setEnd(nodeA);
    nodeA->setParentEdge(edgeX);
    nodeZ->setEdge(edgeY, edgeT);
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge X, edgeY and edgeT              
    separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
    
    
    //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
    //cout << "edgeX " << endl;
    //edgeX->printEdge();
    //cout << "edgeT " << endl;	  
    //edgeT->printEdge();
    
    //      : Reverse IDH and change start and end nodes on edgeT
    edgeT->ReverseEdge();
    
    //cout << "After reversing edgeT " << endl;
    //cout << "edgeT " << endl;
    //edgeT->printEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeX->getIDH()->getN(0));
    
    //----- Reconstruct a tree ----------------------------------------------------------//
    //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
    //      : Change parent edge of nodes from B1 to Bend                                //
    Edge* TempEdge2;
    TempEdge = nodeB1->getParentEdge();
    //cout << "TempEdge number : " << TempEdge->getnumber() << endl;
    nodeB1->changeParentEdge(edgeT);
    while(TempEdge != edgeY){
      TempNode = TempEdge->getStart();
      TempEdge->ReverseEdge();
      TempEdge2 = TempEdge;
      TempEdge = TempNode->getParentEdge();
      TempNode->changeParentEdge(TempEdge2);
    }
    
    //cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
    //printTree(0);      
    //checkTree();
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(UseRand)
      edge0->runEdge(rand,params);
    else
      (*edge0->getIDH()) = (*listIDH[index]);
    edge0->calHMG();     
    
    //cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
    //printTree(0);    
    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeC->findRootSites();
    TempNode = nodeD;
    while(TempNode != nodeZ){
      TempNode->findRootSites();
      TempNode = TempNode->getParent();
    }
    
    // 1'
    if(nodeZ->getRoot())
      nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeD->CalSubTreeProb(params);
    nodeD->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeBend); 
    
    //cout << endl << "~~~~~ After updating all information " << endl;
    //printTree(0);
    //checkTree();
	
    // Update IDHlikelihood
    N_IDHlike = edge0->likeliHistory(params);   

  }else if(edge0 == nodeZ->getParentEdge()){
    
    //cout << "******** CASEI *****************" << endl;
    //checkTree();
    
    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    //----- Label nodes end edges ----//
    nodeA = edgeT->getEnd();
    nodeB1 = edgeT->getStart();
    TempNode = nodeB1;
    while(TempNode->getParent() != nodeZ)
      TempNode = TempNode->getParent();
    nodeBend = TempNode;
    edgeY = nodeBend->getParentEdge();
    edgeX = nodeZ->leftEdge(edge0, edgeY);
    nodeD = edgeX->getEnd();     
    
    
    //cout << "nodeA : " << endl;
    //nodeA->printNode();
    //cout << "nodeB1 : " << endl;
    //nodeB1->printNode();
    //cout << "nodeBend : " << endl;
    //nodeBend->printNode();
    //cout << "nodeD : " << endl;
    //nodeD->printNode(); 
    //cout << "edgeX " << endl;
    //edgeX->printEdge();
    //cout << "edgeY " << endl;
    //edgeY->printEdge();
    //cout << "edgeT " << endl;
    //edgeT->printEdge();
    

    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeY
    edgeY->ReverseEdge();
    
    //cout << "After reversing edgeY " << endl;
    //cout << "edgeY " << endl;
    //edgeY->printEdge();
    
    
    
    //      : Change IDH and edge length of edge X, edgeY and edgeT    
    combineIDHonTwoEdges(edgeY, edgeX);
    
    
    //cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
    //cout << "edgeX " << endl;
    //edgeX->printEdge();
    //cout << "edgeY " << endl;	  
    //edgeY->printEdge();
    
    
    
    //----- Reconstruct a tree -------//
    //      : tree structure          //
    nodeD->setParentEdge(edgeY);
    edgeY->setEnd(nodeD);
    edgeT->setEnd(nodeZ);
    edgeX->setEnd(nodeA);
    nodeA->setParentEdge(edgeX);
    nodeZ->setEdge(edgeY, edgeT);
    
    
    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge X, edgeY and edgeT              
    separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
    
    //cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
    //cout << "edgeX " << endl;
    //edgeX->printEdge();
    //cout << "edgeT " << endl;	  
    //edgeT->printEdge();
    
    
    //      : Reverse IDH and change start and end nodes on edgeT
    edgeT->ReverseEdge();
    
    
    //cout << "After reversing edgeT " << endl;
    //cout << "edgeT " << endl;
    //edgeT->printEdge();
    
    
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    int O_seqlenZ = nodeZ->getSeqLen();
    nodeZ->setSeqLen(edgeT->getIDH()->getN(0));
    
    
    

    

    //----- Reconstruct a tree ----------------------------------------------------------//
    //      : Reverse IDH and change start and end nodes on edges between B1 and Bend    //
    //      : Change parent edge of nodes from B1 to Bend                                //
    Edge* TempEdge2;
    TempEdge = nodeB1->getParentEdge();
    nodeB1->changeParentEdge(edgeT);
    while(TempEdge != edgeY){
      TempNode = TempEdge->getStart();
      TempEdge->ReverseEdge();
      TempEdge2 = TempEdge;
      TempEdge = TempNode->getParentEdge();
      TempNode->changeParentEdge(TempEdge2);
    }
    
    
    
    //cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
    //printTree(0);      
    //checkTree();
    
    
    
    //----- Reconstruct a tree --------------//
    //      : Generate new IDH on e0         //
    if(UseRand)
      edge0->runEdge(rand,params);
    else
      (*edge0->getIDH()) = (*listIDH[index]);
    edge0->calHMG();     

    
    //cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
    //printTree(0);   
    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    TempNode = nodeD;
    while(TempNode != nodeZ){
      TempNode->findRootSites();
      TempNode = TempNode->getParent();
    }
    nodeZ->findRootSites();
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    // 2
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeD->CalSubTreeProb(params);
    nodeD->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;
    
    // 3 and 4
    UpdateAllinfoToRoot(params, nodeBend); 
    
    
    
    //cout << endl << "~~~~~ After updating all information " << endl;
    //printTree(0);
    //checkTree();
    //-------- Update IDHlikelihood ----------------//
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   

  }else{
    
    vector<int> Zancestor(0);
    bool notHitNewZ = false;
    TempEdge = nodeZ->getParentEdge();
    while(TempEdge != edgeT){
      TempNode = TempEdge->getStart();
      Zancestor.push_back(TempNode->getnumber());
      if(TempNode->getRoot()){
	notHitNewZ = true;
	break;
      }
      TempEdge = TempNode->getParentEdge();
    }
    
    if(!notHitNewZ){ // Hit EdgeT
      
      
      //cout << "******** CASEIII *****************" << endl;	 
      //checkTree();
      
      //----------------------//
      //                      //
      //       caseIII        //
      //                      //
      //----------------------//
      
      //----- Label nodes end edges ----//
      edgeY = nodeZ->getParentEdge();
      edgeX = nodeZ->leftEdge(edge0, edgeY);
      nodeA = edgeX->getEnd();
      nodeB1 = getNode(Zancestor[0]);
      nodeBend = getNode(Zancestor[Zancestor.size()-1]);
      nodeD = edgeT->getStart();
      
      
      //cout << "nodeA : " << endl;
      //nodeA->printNode();
      //cout << "nodeB1 : " << endl;
      //nodeB1->printNode();
      //cout << "nodeBend : " << endl;
      //nodeBend->printNode();
      //cout << "nodeD : " << endl;
      //nodeD->printNode(); 
      //cout << "edgeX " << endl;
      //edgeX->printEdge();
      //cout << "edgeY " << endl;
      //edgeY->printEdge();
      //cout << "edgeT " << endl;
      //edgeT->printEdge();
      
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
      combineIDHonTwoEdges(edgeY, edgeX);
      

      //----- Reconstruct a tree -------//
      //      : tree structure          //
      nodeA->setParentEdge(edgeY);
      edgeY->setEnd(nodeA);
      edgeT->setEnd(nodeZ);
      nodeBend->setParentEdge(edgeX);
      edgeX->setEnd(nodeBend);
      nodeZ->setParentEdge(edgeT);
      
      //----- Reconstruct a tree ---------------------------------------//
      //      : Change IDH and edge length of edgeX, edgeY and edgeT    //
      separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);
      
      //----- Reconstruct a tree --------------//
      //      : Change sequence length at Z    //
      nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
      
      
      //cout << "print Tree in SPRonSubTree after reconstruction!" << endl;
      //printTree(0);
      //checkTree();
      
      
      //----- Reconstruct a tree --------------//
      //      : Generate new IDH on e0         //
      if(UseRand)
	edge0->runEdge(rand,params);
      else
	(*edge0->getIDH()) = (*listIDH[index]);
      edge0->calHMG();
      

      //cout << "print Tree in SPRonSubTree after generating new IDH on edge0!" << endl;
      //printTree(0);
      //checkTree();
      

      //----- Update gijk, rootSites, LinkedSites and likelihood --------//
      // 1
      nodeA->findRootSites();
      nodeBend->findRootSites();
      nodeC->findRootSites();
      nodeZ->findRootSites();
      
      // 1'
      if(nodeD->getRoot())
	nodeD->findLinkedSites();
      
      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
      
      // 3
      nodeA->CalSubTreeProb(params);
      nodeA->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
      
      // 4 and 5
      UpdateAllinfoToRoot(params, nodeB1);
      
      //cout << endl << "~~~~~ After updating all information " << endl;
      //printTree(0);	
      //checkTree();
      
      //-------- Update IDHlikelihood ----------------//
      N_IDHlike = edge0->likeliHistory(params);   
      
    }else{          // didn't hit EdgeT
      
      vector<int> newZancestor(0);
      bool notHitZ = false;
      TempEdge = edgeT;
      while(TempEdge->getStart() != nodeZ){
	TempNode = TempEdge->getStart();
	newZancestor.push_back(TempNode->getnumber());
	if(TempNode->getRoot()){
	  notHitZ = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }	
      
      if(!notHitZ){ // Hit Z
	
	//cout << "******** CASEIV *****************" << endl;	  
	//checkTree();
	//----------------------//
	//                      //
	//       caseIV         //
	//                      //
	//----------------------//
	
	//----- Label nodes end edges ----//
	nodeA = edgeT->getEnd();
	nodeB1 = getNode(newZancestor[0]);
	nodeBend = getNode(newZancestor[newZancestor.size()-1]);
	edgeX = nodeBend->getParentEdge();
	edgeY = nodeZ->getParentEdge();
	nodeD = edgeY->getStart();
	
	//cout << "nodeA : " << endl;
	//nodeA->printNode();
	//cout << "nodeB1 : " << endl;
	//nodeB1->printNode();
	//cout << "nodeBend : " << endl;
	//nodeBend->printNode();
	//cout << "nodeD : " << endl;
	//nodeD->printNode(); 
	//cout << "edgeX " << endl;
	//edgeX->printEdge();
	//cout << "edgeY " << endl;
	//edgeY->printEdge();
	//cout << "edgeT " << endl;
	//edgeT->printEdge();
	
	
	
	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);
	
	//cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
	//cout << "edgeX " << endl;
	//edgeX->printEdge();
	//cout << "edgeY " << endl;	  
	//edgeY->printEdge();
	
	
	//----- Reconstruct a tree -------//
	//      : tree structure          //
	edgeY->setEnd(nodeBend);
	nodeBend->setParentEdge(edgeY);
	edgeT->setEnd(nodeZ);
	edgeX->setEnd(nodeA);
	nodeA->setParentEdge(edgeX);
	nodeZ->setParentEdge(edgeT);
	
	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	  
	
	//cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
	//cout << "edgeX " << endl;
	//edgeX->printEdge();
	//cout << "edgeT " << endl;	  
	//edgeT->printEdge();
	
	
	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
	
	//cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
	//printTree(0);      
	//checkTree();
	
	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(UseRand)
	  edge0->runEdge(rand,params);
	else
	  (*edge0->getIDH()) = (*listIDH[index]);
	edge0->calHMG();
	
	//cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
	//printTree(0);   
	//checkTree();
	
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
	// 1
	nodeA->findRootSites();
	nodeBend->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();
	
	// 1'
	if(nodeD->getRoot())
	  nodeD->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	
	// 4 and 5
	UpdateAllinfoToRoot(params, nodeZ);
	
	//cout << endl << "~~~~~ After updating all information " << endl;
	//printTree(0);
	//checkTree();
	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	  
      }else{        // didn't hit Z
	
	//cout << "******** CASEII *****************" << endl;	  
	//checkTree();
	//----------------------//
	//                      //
	//       caseII         //
	//                      //
	//----------------------//	  
	
	// Find Bm which is the first common node of Zancestor and newZancestor
	for(i = 0; i < Zancestor.size(); i++){
	  if(is_element(newZancestor, Zancestor[i]))
	    break;
	}
	if(i == Zancestor.size())
	  cout << "Error! Zancestor and newZancestor should have common element." << endl;
	else
	  nodeBm = getNode(Zancestor[i]);
	
	//----- Label nodes end edges ----//
	edgeY = nodeZ->getParentEdge();
	nodeBa = getNode(Zancestor[0]);
	edgeX = nodeZ->leftEdge(edge0, edgeY);
	nodeA = edgeX->getEnd();
	nodeD = edgeT->getEnd();
	nodeBd = edgeT->getStart();
	
	
	//cout << "nodeA : " << endl;
	//nodeA->printNode();
	//cout << "nodeBa : " << endl;
	//nodeBa->printNode();
	//cout << "nodeBd : " << endl;
	//nodeBd->printNode();
	//cout << "nodeBm : " << endl;
	//nodeBm->printNode();	  
	//cout << "nodeD : " << endl;
	//nodeD->printNode(); 
	//cout << "edgeX " << endl;
	//edgeX->printEdge();
	//cout << "edgeY " << endl;
	//edgeY->printEdge();
	//cout << "edgeT " << endl;
	//edgeT->printEdge();
	
	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	combineIDHonTwoEdges(edgeY, edgeX);
	
	//cout << "After combineIDHonTwoEdges(edgeY, edgeX) " << endl;
	//cout << "edgeX " << endl;
	//edgeX->printEdge();
	//cout << "edgeY " << endl;	  
	//edgeY->printEdge();
	
	//----- Reconstruct a tree -------//
	//      : tree structure          //	
	nodeA->setParentEdge(edgeY);
	edgeY->setEnd(nodeA);	  
	nodeD->setParentEdge(edgeX);
	edgeX->setEnd(nodeD);
	nodeZ->setParentEdge(edgeT);
	edgeT->setEnd(nodeZ);
	
	
	//----- Reconstruct a tree ---------------------------------------//
	//      : Change IDH and edge length of edgeX, edgeY and edgeT    //
	separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ);	
	
	//cout << "After separateIDHintoTwoEdges(edgeT, edgeX, posiNewZ)" << endl;
	//cout << "edgeX " << endl;
	//edgeX->printEdge();
	//cout << "edgeT " << endl;	  
	//edgeT->printEdge();
	
	
	//----- Reconstruct a tree --------------//
	//      : Change sequence length at Z    //
	nodeZ->setSeqLen(edgeT->getIDH()->getN(edgeT->getIDH()->getNumE()));
	
	//cout << endl << "~~~~~ print Tree in SPRonSubTree after reconstruction ~~~ " << endl;
	//printTree(0);
	//checkTree();
	
	//----- Reconstruct a tree --------------//
	//      : Generate new IDH on e0         //
	if(UseRand)
	  edge0->runEdge(rand,params);
	else
	  (*edge0->getIDH()) = (*listIDH[index]);
	edge0->calHMG();
	
	//cout << endl << "~~~~~ print Tree in SPRonSubTree after generating new IDH on edge0 ~~~ " << endl;
	//printTree(0);
	
	//checkTree();
	
	//----- Update gijk, rootSites, LinkedSites and likelihood --------//
	// 1	  
	
	nodeA->findRootSites();
	nodeD->findRootSites();
	nodeC->findRootSites();
	nodeZ->findRootSites();
	
	// 1'
	if(nodeBa->getRoot())
	  nodeBa->findLinkedSites();
	else if(nodeBd->getRoot())
	  nodeBd->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3
	nodeA->CalSubTreeProb(params);
	nodeA->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;	
	
	// 4
	nodeD->CalSubTreeProb(params);
	nodeD->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeD->getnumber()] = 1;	
	
	// 5 and 6
	UpdateAllinfoTogivenNode(params, nodeBa, nodeBm);
	
	// 7 and 8  
	UpdateAllinfoTogivenNode(params, nodeZ, nodeBm);
	
	// 9 and 10
	UpdateAllinfoToRoot(params, nodeBm);	  
	
	//cout << endl << "~~~~~ After updating all information " << endl;
	//printTree(0);	  
	//checkTree();
	//-------- Update IDHlikelihood ----------------//
	N_IDHlike = edge0->likeliHistory(params);   
	
      }
      
      newZancestor.resize(0);
    }
    
    Zancestor.resize(0);
  }

  if((UseRand) & (saveIDH))
    (*listIDH[index]) = (*edge0->getIDH());
  
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
  logLikeliData[current] = likeliData();    
  
  datalike = logLikeliData[current];
  IDHlike = logLikeliIDH[current];
  Treelike = 0;
  Edgelike = 0;
  
  loglike = datalike + IDHlike + Treelike + Edgelike;
  
  return loglike;
}  // End of SPRonSubTreeAsPartOfSPRonSubTreeLike



// return node number which is close to baseNode among two nodes connected to cEdge. edge0 will be used in the function...
int Tree::findCloseNode(Node* baseNode, Edge* cEdge, Edge* edge0){

  Node* stNode = cEdge->getStart();
  Node* enNode = cEdge->getEnd();
  Edge* TempEdge;
  Node* TempNode;

  bool HitRoot = false;

  if(baseNode->getRoot())
    return stNode->getnumber();
  else{
    TempEdge = baseNode->getParentEdge();
    if(TempEdge == edge0)
      return stNode->getnumber();
    else{
      while(TempEdge != cEdge){
	TempNode = TempEdge->getStart();
	if(TempNode->getRoot()){
	  HitRoot = true;
	  break;
	}
	TempEdge = TempNode->getParentEdge();
      }
  
      if(!HitRoot) // Hit cEdge
	return enNode->getnumber();
      else  // Hit root
	return stNode->getnumber();
    }
  }
}






double Tree::SPRonSubTreeLike(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1, int start) {


  int i;
  double r, ratio, N_ratio;
  int N_sizeMset, O_sizeMset;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_Edgeslike, N_Edgeslike, O_psl, N_psl, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];


  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  int N_Edgenum; 
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_datalike = getLogLikeliData();
  O_IDHlike = getLogLikeliIDH();
  O_Edgeslike = getLogLikeliEdges();

  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    O_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    O_psl= edge0->ProposHistory(params);
  }      
  
  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  vector<int> Mrevset(0);
  int posiDel; 
  int Count = 0;


  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  vector<int> RevtempNodeNum(0);

  // Define some vectors
  vector<int> stNode(0); // start node to apply ratio into each edge
  vector<double> listLogLike(0); // posterior prob when trying each edge
  vector<double> listLike(0);
  vector<InDelHistory*> listIDH(0); // generated IDH in each edge
  vector<int> RevstNode(0); // start node to apply ratio into each edge
  vector<double> RevlistLogLike(0); // posterior prob when trying each edge
  vector<double> RevlistLike(0);

  

  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 
  N_sizeMset = Mset.size();

  // Generate ratio 
  ratio = rand.runif();
  
  lenX1 = sum_vec(lenX);
  
  if(lenX[0] > lenX[1])
    stNode.push_back(tempNodeNum[1]);
  else
    stNode.push_back(tempNodeNum[0]);
 
  // Get ready for IDH 
  listIDH.resize(N_sizeMset);
  for(i = 0; i < N_sizeMset; i++)
    listIDH[i] = new InDelHistory();
 
  // Get start nodes to apply ratio into each edge
  for(i = 1; i < N_sizeMset; i++)
    stNode.push_back(findCloseNode(nodeZ, edges[Mset[i]], edge0));
  

  //-----------------------------------//
  // 
  //     Calculate posterior prob 
  //     P(H T V | data )  prop P(H T V data) = P(data | H T V)*P(H | T V )*P(T, V) 
  //-----------------------------------//

  // save the current information 
  save();
  set0UpdatedNodeinRootSites();

  // SPRonSingleEdge
  listLogLike.push_back(SPRonSingleEdgeAsPartOfSPRonSubTreeLike(true, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, true));

  restore();
  

  // the rest node : SPRonSubTree
  for(i = 1; i < N_sizeMset; i++){
    set0UpdatedNodeinRootSites();
    listLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(true, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[i], Mset[i], listIDH, i, true));
    restore();
  }


  listLike.resize(0);
  double maxV = max_vec(listLogLike);
  for(i = 0; i < N_sizeMset; i++)
    listLike.push_back(exp(listLogLike[i]- maxV));
  double maxL = sum_vec(listLike);
  for(i = 0; i < N_sizeMset; i++)
    listLike[i] = listLike[i]/maxL;

  int finalTargetPosi = rand.rwunif(listLike);

  for(i = 0; i < N_sizeMset; i++)
    listLike[i] = exp(listLogLike[i] - maxV);
  

  double tempdouble;

  //----------------------------
  // Move to the selected Tree
  //----------------------------

  if(finalTargetPosi == 0){
    params.setSPRonSingle(1);
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSingleEdgeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, false);
    if(tempdouble != listLogLike[0])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }else{
    params.setSPRonSingle(0);
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[finalTargetPosi], Mset[finalTargetPosi], listIDH, finalTargetPosi, false);
    if(tempdouble != listLogLike[finalTargetPosi])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }

  //-----------------------------------//
  //  Reverse part 
  //-----------------------------------//

  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(nodeZ->getEdge(i) == edge0){
      N_Edgenum = i;
      break;
    }
  }



  if(finalTargetPosi == 0){  // Mrevset is exactly same as Mset 

    // Get RevstNode and Mrevset
    if(ratio > 0.5){
      if(stNode[0] == tempNodeNum[0])
	RevstNode.push_back(tempNodeNum[1]);
      else
	RevstNode.push_back(tempNodeNum[0]);
    }else{
      RevstNode.push_back(stNode[0]);
    }
    
    Mrevset.push_back(Mset[0]);
    O_sizeMset = N_sizeMset;
    for(i = 1; i < N_sizeMset; i++){
      RevstNode.push_back(stNode[i]);
      Mrevset.push_back(Mset[i]);
    }
    
    // Get new ratio which is determined
    if(RevstNode[0] == tempNodeNum[0])
      N_ratio = lenX[0]/sum_vec(lenX);
    else
      N_ratio = lenX[1]/sum_vec(lenX);

    // Get loglikelihood
    RevlistLogLike.push_back(O_datalike + O_IDHlike);
    
    // get the current tree
    restore();

    for(i = 1; i < O_sizeMset; i++){
      set0UpdatedNodeinRootSites();
      RevlistLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, N_ratio, RevstNode[i], Mrevset[i], listIDH, i, true));
      restore();    
    }


    lenXt = lenX1;

  }else{ // else if(finalTargetPosi != 0)

    // Get Mrevset 
    Count = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(i != N_Edgenum){
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	RevtempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }
    
    Mrevset.erase(Mrevset.begin() + posiDel); // Remove one of edges which is connected to Z.     
    O_sizeMset = Mrevset.size();
   
    // Get RevstNode
    if(ratio > 0.5){
      if(stNode[finalTargetPosi] == RevtempNodeNum[0])
	RevstNode.push_back(RevtempNodeNum[1]);
      else
	RevstNode.push_back(RevtempNodeNum[0]);
    }else{
      RevstNode.push_back(stNode[finalTargetPosi]);
    }

    for(i = 1; i < O_sizeMset; i++)
      RevstNode.push_back(findCloseNode(nodeZ, edges[Mrevset[i]], edge0));

    // Get new ratio which is determined
    int orig_posi;
    for(i = 1; i < O_sizeMset; i++){
      if((is_element(tempNodeNum, edges[Mrevset[i]]->getStart()->getnumber())) & (is_element(tempNodeNum, edges[Mrevset[i]]->getEnd()->getnumber()))){
	orig_posi = i;
	break;
      }
    }
    if(i == O_sizeMset)
      cout << "ERROR! in SPRonSubTreeLike. orig_posi should be found!" << endl;

    if(RevstNode[orig_posi] == tempNodeNum[0])
      N_ratio = lenX[0]/sum_vec(lenX);
    else
      N_ratio = lenX[1]/sum_vec(lenX);

    // get the current tree
    restore();

    Mrevset[0] = Mset[finalTargetPosi];

    for(i = 0; i < O_sizeMset; i++){
      if(i == orig_posi){
	RevlistLogLike.push_back(O_datalike + O_IDHlike);
      }else{
	set0UpdatedNodeinRootSites();
	RevlistLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, N_ratio, RevstNode[i], Mrevset[i], listIDH, i, true));
	restore();    
      }
    }

    lenXt = edges[Mrevset[0]]->getEdgeLen();

  }

  //----------------------------
  // Move to the selected Tree
  //----------------------------

  if(finalTargetPosi == 0){
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSingleEdgeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, false);
    if(tempdouble != listLogLike[0])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }else{
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[finalTargetPosi], Mset[finalTargetPosi], listIDH, finalTargetPosi, false);
    if(tempdouble != listLogLike[finalTargetPosi])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }




  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    N_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    N_psl= edge0->ProposHistory(params);
  }     


  // Calculate acceptance probability
  for(i = 0; i < O_sizeMset; i++)
    RevlistLike.push_back(exp(RevlistLogLike[i] - maxV));
 
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
  logLikeliIDH[current] = likeliHistory(params);

  if(start)
    AP = exp(O_psl - N_psl + log(lenXt) - log(lenX1) + log(sum_vec(listLike)) - log(sum_vec(RevlistLike)));
  else
    AP = exp(logLikeliData[current] + logLikeliIDH[current] - O_datalike - O_IDHlike);

  if(finalTargetPosi != 0){
    c << AP << " " << exp(O_psl - N_psl) << " " << sum_vec(listLike)/sum_vec(RevlistLike) << " " << lenXt/lenX1 << " " << exp(logLikeliData[current]-O_datalike) << " " << exp(logLikeliIDH[current] - O_IDHlike) << " " << (sum_vec(listLike)/sum_vec(RevlistLike))*(exp(O_datalike +  O_IDHlike - maxV)/listLike[finalTargetPosi]) << endl;
  }else{
    c1 << AP << " " << exp(O_psl - N_psl) << " " << sum_vec(listLike)/sum_vec(RevlistLike) << " " << lenXt/lenX1 << " " << exp(logLikeliData[current]-O_datalike) << " " << exp(logLikeliIDH[current] - O_IDHlike) << " " << (sum_vec(listLike)/sum_vec(RevlistLike))*(exp(O_datalike +  O_IDHlike - maxV)/listLike[finalTargetPosi]) << endl;
  }

  Mset.resize(0);
  Mrevset.resize(0);
  lenX.resize(0);
  tempNodeNum.resize(0);
  RevtempNodeNum.resize(0);
  stNode.resize(0); 
  listLogLike.resize(0); 
  listLike.resize(0);
  RevstNode.resize(0); 
  RevlistLogLike.resize(0);
  RevlistLike.resize(0);

 

  for(i = 0; i < N_sizeMset; i++)
    delete listIDH[i];

  listIDH.resize(0);


  return AP;

}   // end of SPRonSubTreeLike





double Tree::SPRonSubTreeLike(Rand &rand,Parameters &params, int MaximumStep, ofstream& c, ofstream& c1) {


  int i;
  double r, ratio, N_ratio;
  int N_sizeMset, O_sizeMset;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_Edgeslike, N_Edgeslike, O_psl, N_psl, lenX1, lenXt;
  Edge* TempEdge;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];


  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  int N_Edgenum; 
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  O_datalike = getLogLikeliData();
  O_IDHlike = getLogLikeliIDH();
  O_Edgeslike = getLogLikeliEdges();

  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    O_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    O_psl= edge0->ProposHistory(params);
  }      
  
  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);

  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  vector<int> Mrevset(0);
  int posiDel; 
  int Count = 0;


  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  vector<int> RevtempNodeNum(0);

  // Define some vectors
  vector<int> stNode(0); // start node to apply ratio into each edge
  vector<double> listLogLike(0); // posterior prob when trying each edge
  vector<double> listLike(0);
  vector<InDelHistory*> listIDH(0); // generated IDH in each edge
  vector<int> RevstNode(0); // start node to apply ratio into each edge
  vector<double> RevlistLogLike(0); // posterior prob when trying each edge
  vector<double> RevlistLike(0);

  

  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 
  N_sizeMset = Mset.size();

  // Generate ratio 
  ratio = rand.runif();
  
  lenX1 = sum_vec(lenX);
  
  if(lenX[0] > lenX[1])
    stNode.push_back(tempNodeNum[1]);
  else
    stNode.push_back(tempNodeNum[0]);
 
  // Get ready for IDH 
  listIDH.resize(N_sizeMset);
  for(i = 0; i < N_sizeMset; i++)
    listIDH[i] = new InDelHistory();
 
  // Get start nodes to apply ratio into each edge
  for(i = 1; i < N_sizeMset; i++)
    stNode.push_back(findCloseNode(nodeZ, edges[Mset[i]], edge0));
  

  //-----------------------------------//
  // 
  //     Calculate posterior prob 
  //     P(H T V | data )  prop P(H T V data) = P(data | H T V)*P(H | T V )*P(T, V) 
  //-----------------------------------//

  // save the current information 
  save();
  set0UpdatedNodeinRootSites();

  // SPRonSingleEdge
  listLogLike.push_back(SPRonSingleEdgeAsPartOfSPRonSubTreeLike(true, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, true));

  restore();
  

  // the rest node : SPRonSubTree
  for(i = 1; i < N_sizeMset; i++){
    set0UpdatedNodeinRootSites();
    listLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(true, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[i], Mset[i], listIDH, i, true));
    restore();
  }


  listLike.resize(0);
  double maxV = max_vec(listLogLike);
  for(i = 0; i < N_sizeMset; i++)
    listLike.push_back(exp(listLogLike[i]- maxV));
  double maxL = sum_vec(listLike);
  for(i = 0; i < N_sizeMset; i++)
    listLike[i] = listLike[i]/maxL;

  int finalTargetPosi = rand.rwunif(listLike);

  for(i = 0; i < N_sizeMset; i++)
    listLike[i] = exp(listLogLike[i] - maxV);
  

  double tempdouble;

  //----------------------------
  // Move to the selected Tree
  //----------------------------

  if(finalTargetPosi == 0){
    params.setSPRonSingle(1);
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSingleEdgeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, false);
    if(tempdouble != listLogLike[0])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }else{
    params.setSPRonSingle(0);
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[finalTargetPosi], Mset[finalTargetPosi], listIDH, finalTargetPosi, false);
    if(tempdouble != listLogLike[finalTargetPosi])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }

  //-----------------------------------//
  //  Reverse part 
  //-----------------------------------//

  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(nodeZ->getEdge(i) == edge0){
      N_Edgenum = i;
      break;
    }
  }



  if(finalTargetPosi == 0){  // Mrevset is exactly same as Mset 

    // Get RevstNode and Mrevset
    if(ratio > 0.5){
      if(stNode[0] == tempNodeNum[0])
	RevstNode.push_back(tempNodeNum[1]);
      else
	RevstNode.push_back(tempNodeNum[0]);
    }else{
      RevstNode.push_back(stNode[0]);
    }
    
    Mrevset.push_back(Mset[0]);
    O_sizeMset = N_sizeMset;
    for(i = 1; i < N_sizeMset; i++){
      RevstNode.push_back(stNode[i]);
      Mrevset.push_back(Mset[i]);
    }
    
    // Get new ratio which is determined
    if(RevstNode[0] == tempNodeNum[0])
      N_ratio = lenX[0]/sum_vec(lenX);
    else
      N_ratio = lenX[1]/sum_vec(lenX);

    // Get loglikelihood
    RevlistLogLike.push_back(O_datalike + O_IDHlike);
    
    // get the current tree
    restore();

    for(i = 1; i < O_sizeMset; i++){
      set0UpdatedNodeinRootSites();
      RevlistLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, N_ratio, RevstNode[i], Mrevset[i], listIDH, i, true));
      restore();    
    }


    lenXt = lenX1;

  }else{ // else if(finalTargetPosi != 0)

    // Get Mrevset 
    Count = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(i != N_Edgenum){
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	RevtempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }
    
    Mrevset.erase(Mrevset.begin() + posiDel); // Remove one of edges which is connected to Z.     
    O_sizeMset = Mrevset.size();
   
    // Get RevstNode
    if(ratio > 0.5){
      if(stNode[finalTargetPosi] == RevtempNodeNum[0])
	RevstNode.push_back(RevtempNodeNum[1]);
      else
	RevstNode.push_back(RevtempNodeNum[0]);
    }else{
      RevstNode.push_back(stNode[finalTargetPosi]);
    }

    for(i = 1; i < O_sizeMset; i++)
      RevstNode.push_back(findCloseNode(nodeZ, edges[Mrevset[i]], edge0));

    // Get new ratio which is determined
    int orig_posi;
    for(i = 1; i < O_sizeMset; i++){
      if((is_element(tempNodeNum, edges[Mrevset[i]]->getStart()->getnumber())) & (is_element(tempNodeNum, edges[Mrevset[i]]->getEnd()->getnumber()))){
	orig_posi = i;
	break;
      }
    }
    if(i == O_sizeMset)
      cout << "ERROR! in SPRonSubTreeLike. orig_posi should be found!" << endl;

    if(RevstNode[orig_posi] == tempNodeNum[0])
      N_ratio = lenX[0]/sum_vec(lenX);
    else
      N_ratio = lenX[1]/sum_vec(lenX);

    // get the current tree
    restore();

    Mrevset[0] = Mset[finalTargetPosi];

    for(i = 0; i < O_sizeMset; i++){
      if(i == orig_posi){
	RevlistLogLike.push_back(O_datalike + O_IDHlike);
      }else{
	set0UpdatedNodeinRootSites();
	RevlistLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, N_ratio, RevstNode[i], Mrevset[i], listIDH, i, true));
	restore();    
      }
    }

    lenXt = edges[Mrevset[0]]->getEdgeLen();

  }

  //----------------------------
  // Move to the selected Tree
  //----------------------------

  if(finalTargetPosi == 0){
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSingleEdgeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, false);
    if(tempdouble != listLogLike[0])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }else{
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[finalTargetPosi], Mset[finalTargetPosi], listIDH, finalTargetPosi, false);
    if(tempdouble != listLogLike[finalTargetPosi])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }




  if(nodeZ == edge0->getEnd()){
    edge0->ReverseEdge();
    N_psl= edge0->ProposHistory(params);
    edge0->ReverseEdge();
  }else{
    N_psl= edge0->ProposHistory(params);
  }     


  // Calculate acceptance probability
  for(i = 0; i < O_sizeMset; i++)
    RevlistLike.push_back(exp(RevlistLogLike[i] - maxV));
 
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
  logLikeliIDH[current] = likeliHistory(params);


  AP = exp(O_psl - N_psl + log(lenXt) - log(lenX1) + log(sum_vec(listLike)) - log(sum_vec(RevlistLike)));

  if(finalTargetPosi != 0){
    c << AP << " " << exp(O_psl - N_psl) << " " << sum_vec(listLike)/sum_vec(RevlistLike) << " " << lenXt/lenX1 << " " << exp(logLikeliData[current]-O_datalike) << " " << exp(logLikeliIDH[current] - O_IDHlike) << " " << (sum_vec(listLike)/sum_vec(RevlistLike))*(exp(O_datalike +  O_IDHlike - maxV)/listLike[finalTargetPosi]) << endl;
  }else{
    c1 << AP << " " << exp(O_psl - N_psl) << " " << sum_vec(listLike)/sum_vec(RevlistLike) << " " << lenXt/lenX1 << " " << exp(logLikeliData[current]-O_datalike) << " " << exp(logLikeliIDH[current] - O_IDHlike) << " " << (sum_vec(listLike)/sum_vec(RevlistLike))*(exp(O_datalike +  O_IDHlike - maxV)/listLike[finalTargetPosi]) << endl;
  }

  Mset.resize(0);
  Mrevset.resize(0);
  lenX.resize(0);
  tempNodeNum.resize(0);
  RevtempNodeNum.resize(0);
  stNode.resize(0); 
  listLogLike.resize(0); 
  listLike.resize(0);
  RevstNode.resize(0); 
  RevlistLogLike.resize(0);
  RevlistLike.resize(0);

 

  for(i = 0; i < N_sizeMset; i++)
    delete listIDH[i];

  listIDH.resize(0);


  return AP;

}   // end of SPRonSubTreeLike






double Tree::SPRonSubTreeLike_v0(Rand &rand,const Parameters &params, int MaximumStep) {

  //cout << "In SPRonSubTreeLike 1" << endl;
  //checkTree();
  //cout << "MaximumStep : " << MaximumStep << endl;
  int i;
  double r, ratio, N_ratio;
  int N_sizeMset, O_sizeMset;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_Edgeslike, N_Edgeslike, O_psl, N_psl, lenX1, lenXt;
  Edge* TempEdge;

  O_datalike = getLogLikeliData();
  O_IDHlike = getLogLikeliIDH();
  O_Edgeslike = getLogLikeliEdges();

  //cout << "In SPRonSubTreeLike 2" << endl;


  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  //cout << "nodeZ->getnumber() " << nodeZ->getnumber() << endl;
  //cout << "nodeZ->getRoot() " << nodeZ->getRoot() << endl;
  
  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  int N_Edgenum; 
  Edge* edge0 = nodeZ->getEdge(Edgenum);
  
  //cout << " edge0 !!! " << endl;
  //edge0->printEdge();

  O_psl= edge0->ProposHistory(params);
  
  //cout << "edge0->getnumber() " << edge0->getnumber() << endl;

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);
  //cout << "nodeC->getnumber() " << nodeC->getnumber() << endl;


  //cout << "In SPRonSubTreeLike 3" << endl;


  // Construct Mset which is a set of edges in a maximum step based on Z.
  vector<int> Mset(0);
  vector<int> Mrevset(0);
  int posiDel; 
  int Count = 0;


  vector<double> lenX(0);
  vector<int> tempNodeNum(0);
  vector<int> RevtempNodeNum(0);
    // Define some vectors
  vector<int> stNode(0); // start node to apply ratio into each edge
  vector<double> listLogLike(0); // posterior prob when trying each edge
  vector<double> listLike(0);
  vector<InDelHistory*> listIDH(0); // generated IDH in each edge
  vector<int> RevstNode(0); // start node to apply ratio into each edge
  vector<double> RevlistLogLike(0); // posterior prob when trying each edge
  vector<double> RevlistLike(0);

  

  for( i=0; i < nodeZ->getnumEdges(); i++){
    TempEdge = nodeZ->getEdge(i);
    if(TempEdge->getnumber()!= edge0->getnumber()){ 
      //cout << "TempEdge num : " << TempEdge->getnumber() << endl;
      lenX.push_back(TempEdge->getEdgeLen());
      tempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());
      ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mset, TempEdge, nodeZ);
      if(Count == 0)
	posiDel = Mset.size();
      Count++;
    }
  }

  //cout << "In SPRonSubTreeLike 4" << endl;

  
  //cout << " Mset size : " << Mset.size() << endl; 
  //print_veci(Mset);
  //cout << "posiDel " << posiDel << endl;
 


  Mset.erase(Mset.begin() + posiDel); // Remove one of edges which is connected to Z. 



  //cout << "In SPRonSubTreeLike 5" << endl;


  //cout << "Final Mset " << endl;
  //print_veci(Mset);

 

  // Generate ratio 
  ratio = rand.runif();

  //cout << "ratio : " << ratio << endl;



  N_sizeMset = Mset.size();
  
  lenX1 = sum_vec(lenX);
  
  if(lenX[0] > lenX[1])
    stNode.push_back(tempNodeNum[1]);
  else
    stNode.push_back(tempNodeNum[0]);
 
   
  //cout << "In SPRonSubTreeLike 6" << endl;

  // Get ready for IDH 
  listIDH.resize(N_sizeMset);
  for(i = 0; i < N_sizeMset; i++)
    listIDH[i] = new InDelHistory();
 
 
  // Get start nodes to apply ratio into each edge
  for(i = 1; i < N_sizeMset; i++)
    stNode.push_back(findCloseNode(nodeZ, edges[Mset[i]], edge0));
  
  //cout << "stNode " << endl;
  //print_veci(stNode);


  
  //cout << "In SPRonSubTreeLike 7" << endl;

  //-----------------------------------//
  // 
  //     Calculate posterior prob 
  //     P(H T V | data )  prop P(H T V data) = P(data | H T V)*P(H | T V )*P(T, V) 
  //-----------------------------------//
  
  // Same node..special case
  save();

  //cout << "In SPRonSubTreeLike 8" << endl;

  set0UpdatedNodeinRootSites();

  //cout << "In SPRonSubTreeLike 9" << endl;

  listLogLike.push_back(SPRonSingleEdgeAsPartOfSPRonSubTreeLike(true, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, true));

  //cout << "In SPRonSubTreeLike 10" << endl;

  restore();
  

  // the rest node
  for(i = 1; i < N_sizeMset; i++){
    set0UpdatedNodeinRootSites();
    listLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(true, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[i], Mset[i], listIDH, i, true));
    restore();
  }

 
  
  //cout << "listLogLike " << endl;
  //print_vecd(listLogLike);
  

  double maxV = max_vec(listLogLike);
  for(i = 0; i < N_sizeMset; i++)
    listLike.push_back(exp(listLogLike[i] - maxV));
  
  int finalTargetPosi = rand.rwunif(listLike);
  double tempdouble;

  //cout << " finalTargetPosi" << finalTargetPosi << endl;

  //----------------------------
  // Get the current Tree
  //----------------------------
  //restore();


  //----------------------------
  // Move to the selected Tree
  //----------------------------

  if(finalTargetPosi == 0){
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSingleEdgeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, false);
    if(tempdouble != listLogLike[0])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }else{
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[finalTargetPosi], Mset[finalTargetPosi], listIDH, finalTargetPosi, false);
    if(tempdouble != listLogLike[finalTargetPosi])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }


  //----------------------------
  // Save selected Tree to Temp
  //----------------------------

  //saveToTemp();


  //-----------------------------------//
  //  Reverse part 
  //-----------------------------------//

  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(nodeZ->getEdge(i) == edge0){
      N_Edgenum = i;
      break;
    }
  }


  //cout << " Proposed Tree " << endl;
  //printTree();
  //checkTree();
  



  if(finalTargetPosi == 0){  // Mrevset is exactly same as Mset 

    //cout << " if(finalTargetPosi == 0){ " << endl;

    // Get RevstNode and Mrevset
    if(ratio > 0.5){
      if(stNode[0] == tempNodeNum[0])
	RevstNode.push_back(tempNodeNum[1]);
      else
	RevstNode.push_back(tempNodeNum[0]);
    }else{
      RevstNode.push_back(stNode[0]);
    }
    
    Mrevset.push_back(Mset[0]);
    O_sizeMset = N_sizeMset;
    for(i = 1; i < N_sizeMset; i++){
      RevstNode.push_back(stNode[i]);
      Mrevset.push_back(Mset[i]);
    }


    //cout << "Mrevset :: " << endl;
    //print_veci(Mrevset);
    //cout << "RevstNode :: " << endl;
    //print_veci(RevstNode);   
    
    // Get new ratio which is determined
    if(RevstNode[0] == tempNodeNum[0])
      N_ratio = lenX[0]/sum_vec(lenX);
    else
      N_ratio = lenX[1]/sum_vec(lenX);


    //cout << " N_ratio : " << N_ratio << endl;

    // Get loglikelihood
    //RevlistLogLike.push_back(O_datalike + O_IDHlike + O_Edgeslike);
    RevlistLogLike.push_back(O_datalike + O_IDHlike);
    
    // get the current tree
    restore();

    for(i = 1; i < O_sizeMset; i++){
      set0UpdatedNodeinRootSites();
      RevlistLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, N_ratio, RevstNode[i], Mrevset[i], listIDH, i, true));
      restore();    
    }


    lenXt = lenX1;


    //cout << "lenXt " << lenXt << endl;
    //cout << "RevlistLogLike " << endl;
    //print_vecd(RevlistLogLike);

  }else{ // else if(finalTargetPosi != 0)


    //cout << " else if(finalTargetPosi != 0) " << endl;

    // Get Mrevset 
    Count = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      TempEdge = nodeZ->getEdge(i);
      if(i != N_Edgenum){
	ConstructSetofEdgesinMaximumStep(MaximumStep, 1, Mrevset, TempEdge, nodeZ);
	RevtempNodeNum.push_back(TempEdge->getOtherNode(nodeZ)->getnumber());
	if(Count == 0)
	  posiDel = Mrevset.size();
	Count++;
      }
    }
    
    Mrevset.erase(Mrevset.begin() + posiDel); // Remove one of edges which is connected to Z. 
    
    //cout << "Final Mrevset " << endl;
    //print_veci(Mrevset);
    
    O_sizeMset = Mrevset.size();
   
    // Get RevstNode
    if(ratio > 0.5){
      if(stNode[finalTargetPosi] == RevtempNodeNum[0])
	RevstNode.push_back(RevtempNodeNum[1]);
      else
	RevstNode.push_back(RevtempNodeNum[0]);
    }else{
      RevstNode.push_back(stNode[finalTargetPosi]);
    }

    for(i = 1; i < O_sizeMset; i++)
      RevstNode.push_back(findCloseNode(nodeZ, edges[Mrevset[i]], edge0));

    //cout << " RevstNode " << endl;
    //print_veci(RevstNode);

    
    // Get new ratio which is determined
    int orig_posi;
    for(i = 1; i < O_sizeMset; i++){
      if((is_element(tempNodeNum, edges[Mrevset[i]]->getStart()->getnumber())) & (is_element(tempNodeNum, edges[Mrevset[i]]->getEnd()->getnumber()))){
	orig_posi = i;
	break;
      }
    }

    //cout << " orig_posi : " << orig_posi << endl;


    if(RevstNode[orig_posi] == tempNodeNum[0])
      N_ratio = lenX[0]/sum_vec(lenX);
    else
      N_ratio = lenX[1]/sum_vec(lenX);


    //cout << " N_ratio : " << N_ratio << endl;

    // get the current tree
    restore();

    Mrevset[0] = Mset[finalTargetPosi];

    for(i = 0; i < O_sizeMset; i++){
      if(i == orig_posi){
	//RevlistLogLike.push_back(O_datalike + O_IDHlike + O_Edgeslike);
	RevlistLogLike.push_back(O_datalike + O_IDHlike);
      }else{
	set0UpdatedNodeinRootSites();
	RevlistLogLike.push_back(SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, N_ratio, RevstNode[i], Mrevset[i], listIDH, i, true));
	restore();    
      }
    }

    lenXt = edges[Mrevset[0]]->getEdgeLen();


    //cout << "lenXt " << lenXt << endl;
    //cout << "RevlistLogLike " << endl;
    //print_vecd(RevlistLogLike);
    
    

  }

  //----------------------------
  // Move to the selected Tree
  //----------------------------

  if(finalTargetPosi == 0){
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSingleEdgeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[0], listIDH, false);
    if(tempdouble != listLogLike[0])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }else{
    set0UpdatedNodeinRootSites();
    tempdouble = SPRonSubTreeAsPartOfSPRonSubTreeLike(false, rand, params, nodeZ->getnumber(), Edgenum, ratio, stNode[finalTargetPosi], Mset[finalTargetPosi], listIDH, finalTargetPosi, false);
    if(tempdouble != listLogLike[finalTargetPosi])
      cout << "ERROR in SPRonSubTreeLike!" << endl;
  }


  N_psl= edge0->ProposHistory(params);

  // Calculate acceptance probability
  for(i = 0; i < O_sizeMset; i++)
    RevlistLike.push_back(exp(RevlistLogLike[i] - maxV));

  
  //cout << " O_psl : " << O_psl << endl;
  //cout << " N_psl : " << N_psl << endl;
  //cout << " lenXt : " << lenXt << endl;
  //cout << " log(lenXt) : " << log(lenXt) << endl;
  //cout << " lenX1 : " << lenX1 << endl;
  //cout << " log(lenX1) : " << log(lenX1) << endl;
  //cout << " sum_vec(listLike) : " << sum_vec(listLike) << endl;
  //cout << " log(sum_vec(listLike)) : " << log(sum_vec(listLike)) << endl;
  //cout << " sum_vec(RevlistLike) : " << sum_vec(RevlistLike) << endl;
  //cout << " log(sum_vec(RevlistLike)) : " << log(sum_vec(RevlistLike)) << endl;
  

  // find_bug3 //
  logLikeliIDH[current] = likeliHistory(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);

  AP = exp(O_psl - N_psl + log(lenXt) - log(lenX1) + log(sum_vec(listLike)) - log(sum_vec(RevlistLike)));

  

  Mset.resize(0);
  Mrevset.resize(0);
  lenX.resize(0);
  tempNodeNum.resize(0);
  RevtempNodeNum.resize(0);
  stNode.resize(0); 
  listLogLike.resize(0); 
  listLike.resize(0);
  RevstNode.resize(0); 
  RevlistLogLike.resize(0);
  RevlistLike.resize(0);

 

  for(i = 0; i < N_sizeMset; i++)
    delete listIDH[i];

  listIDH.resize(0);

  //AP = 1;


  return AP;

}   // end of SPRonSubTreeLike







double Tree::UpEdgeLen(Rand &rand, const Parameters &params, ofstream& c, int start) {

  int i, numE;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_Edgeslike, N_Edgeslike;
  double gamma;
  Node* nodeC;
  Node* nodeP;
  

  //double tempA, tempB;



  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  //cout << "edgeT number " << edgeT->getnumber() << endl;


  gamma = params.getGamma();
  O_datalike = getLogLikeliData();
  // Heejung
  //cout << "In UpEdgeLen A" << endl;
  //cout << "logLikeliIDH[current] : " << logLikeliIDH[current];
  //cout << "edgeT->getlogLikeliIDH() : " << edgeT->getlogLikeliIDH();
  O_IDHlike = edgeT->getlogLikeliIDH();
  //O_IDHlike = logLikeliIDH[current];
  //tempA = logLikeliIDH[current];
  O_Edgeslike = logLikeliEdges[current];



  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();


  // Generate a multiplication factor
  double zeta = params.getZeta();
  double mulFac = exp(zeta*(rand.runif() - 0.5));


  // Change length of T and time of indel events on T by multiply mulFac
  edgeT->setEdgeLen(edgeT->getEdgeLen()*mulFac);
  InDelHistory* IDH =  edgeT->getIDH();
  numE = IDH->getNumE();
  for(i = 1; i <= (numE+1); i++)
    IDH->setV(IDH->getV(i)*mulFac, i);

  double logJ = (numE+1)*log(mulFac);

  N_IDHlike = edgeT->likeliHistory(params);

  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1 
  nodeC->CalSubTreeProb(params);
  // 2 and 3
  UpdateAllinfoToRoot(params, nodeP); 


  // data like
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();

  // IDH like
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //tempB = logLikeliIDH[current];
  //cout << "In UpEdgeLen B" << endl;
  //cout << "logLikeliIDH[current] : " << logLikeliIDH[current];
  //cout << "edgeT->getlogLikeliIDH() : " << edgeT->getlogLikeliIDH();
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  //cout << "UpEdgeLen " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;


  // Edge like
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
  N_Edgeslike = logLikeliEdges[current];

  if(start)
    AP = exp(logJ + N_datalike + N_IDHlike + N_Edgeslike - O_datalike - O_IDHlike - O_Edgeslike);
  else
    AP = exp(N_datalike + N_IDHlike + N_Edgeslike - O_datalike - O_IDHlike - O_Edgeslike);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(N_Edgeslike -O_Edgeslike) << " " << exp(logJ) << endl; 




  return AP;

} // End of UpEdgeLen






double Tree::UpEdgeLen(Rand &rand, const Parameters &params, ofstream& c) {

  int i, numE;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_Edgeslike, N_Edgeslike;
  double gamma;
  Node* nodeC;
  Node* nodeP;
  

  //double tempA, tempB;



  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  //cout << "edgeT number " << edgeT->getnumber() << endl;


  gamma = params.getGamma();
  O_datalike = getLogLikeliData();
  // Heejung
  //cout << "In UpEdgeLen A" << endl;
  //cout << "logLikeliIDH[current] : " << logLikeliIDH[current];
  //cout << "edgeT->getlogLikeliIDH() : " << edgeT->getlogLikeliIDH();
  O_IDHlike = edgeT->getlogLikeliIDH();
  //O_IDHlike = logLikeliIDH[current];
  //tempA = logLikeliIDH[current];
  O_Edgeslike = logLikeliEdges[current];



  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();


  // Generate a multiplication factor
  double zeta = params.getZeta();
  double mulFac = exp(zeta*(rand.runif() - 0.5));


  // Change length of T and time of indel events on T by multiply mulFac
  edgeT->setEdgeLen(edgeT->getEdgeLen()*mulFac);
  InDelHistory* IDH =  edgeT->getIDH();
  numE = IDH->getNumE();
  for(i = 1; i <= (numE+1); i++)
    IDH->setV(IDH->getV(i)*mulFac, i);

  double logJ = (numE+1)*log(mulFac);

  N_IDHlike = edgeT->likeliHistory(params);

  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1 
  nodeC->CalSubTreeProb(params);
  // 2 and 3
  UpdateAllinfoToRoot(params, nodeP); 


  // data like
  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();

  // IDH like
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //tempB = logLikeliIDH[current];
  //cout << "In UpEdgeLen B" << endl;
  //cout << "logLikeliIDH[current] : " << logLikeliIDH[current];
  //cout << "edgeT->getlogLikeliIDH() : " << edgeT->getlogLikeliIDH();
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  //cout << "UpEdgeLen " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;


  // Edge like
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
  N_Edgeslike = logLikeliEdges[current];


  AP = exp(logJ + N_datalike + N_IDHlike + N_Edgeslike - O_datalike - O_IDHlike - O_Edgeslike);
 

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(N_Edgeslike -O_Edgeslike) << " " << exp(logJ) << endl; 




  return AP;

} // End of UpEdgeLen







double Tree::UpEdgeLen_v0(Rand &rand, const Parameters &params) {

  //cout << "In UpEdgeLen " << endl;
  //checkTree();

  int i, numE;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_Edgeslike, N_Edgeslike;
  double gamma;
  Node* nodeC;
  Node* nodeP;
  




  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];

  gamma = params.getGamma();
  O_datalike = getLogLikeliData();
  O_IDHlike = edgeT->getlogLikeliIDH();
  O_Edgeslike = -gamma*edgeT->getEdgeLen() + log(gamma);



  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();


  // Generate a multiplication factor
  double zeta = params.getZeta();
  double mulFac = exp(zeta*(rand.runif() - 0.5));


  // Change length of T and time of indel events on T by multiply mulFac
  edgeT->setEdgeLen(edgeT->getEdgeLen()*mulFac);
  InDelHistory* IDH =  edgeT->getIDH();
  numE = IDH->getNumE();
  for(i = 1; i <= (numE+1); i++)
    IDH->setV(IDH->getV(i)*mulFac, i);

  double logJ = (numE+1)*log(mulFac);

  N_IDHlike = edgeT->likeliHistory(params);
  N_Edgeslike = -gamma*edgeT->getEdgeLen() + log(gamma);


  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1 
  nodeC->CalSubTreeProb(params);
  // 2 and 3
  UpdateAllinfoToRoot(params, nodeP); 


  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
  // find_bug3 //
  logLikeliIDH[current] = likeliHistory(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);

  //logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 

  AP = exp(logJ + N_datalike + N_IDHlike + N_Edgeslike - O_datalike - O_IDHlike - O_Edgeslike);
 
  return AP;

} // End of UpEdgeLen







double Tree::UpEdgeLen_v2(Rand &rand, const Parameters &params) {

  //cout << "In UpEdgeLen " << endl;
  //checkTree();

  int i, numE;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_Edgeslike, N_Edgeslike, O_edgeLen, N_edgeLen, logJ;
  double gamma;
  Node* nodeC;
  Node* nodeP;
  

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];


  O_edgeLen = edgeT->getEdgeLen();
  gamma = params.getGamma();
  O_datalike = getLogLikeliData();
  O_IDHlike = edgeT->getlogLikeliIDH();
  O_Edgeslike = -gamma*O_edgeLen + log(gamma);

  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();


  // Generate a new edge length
  double mulFac;
  double Utemp = ((rand.runif()*2) - 1);
  if(O_edgeLen - Utemp > 0){
    N_edgeLen = O_edgeLen - Utemp;
    mulFac = 1 - Utemp/O_edgeLen;
  }else{
    N_edgeLen = Utemp - O_edgeLen;
    mulFac = Utemp/O_edgeLen - 1;
  }


  // Change length of T and time of indel events on T by multiply mulFac
  edgeT->setEdgeLen(O_edgeLen*mulFac);
  InDelHistory* IDH =  edgeT->getIDH();
  numE = IDH->getNumE();
  for(i = 1; i <= (numE+1); i++)
    IDH->setV(IDH->getV(i)*mulFac, i);

  logJ = numE*log(mulFac);


  N_IDHlike = edgeT->likeliHistory(params);
  N_Edgeslike = -gamma*N_edgeLen + log(gamma);


  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
  // 1 
  nodeC->CalSubTreeProb(params);
  // 2 and 3
  UpdateAllinfoToRoot(params, nodeP); 


  logLikeliData[current] = likeliData();    
  N_datalike = getLogLikeliData();
  // find_bug3 //
  logLikeliIDH[current] = likeliHistory(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);

  //logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 

  AP = exp(logJ + N_datalike + N_IDHlike + N_Edgeslike - O_datalike - O_IDHlike - O_Edgeslike);
 
  return AP;

} // End of UpEdgeLen_v2



//-- v20 start --//
/*
double Tree::ProposHistory(const Parameters &para, InDelHistory* IDH){



  //cout << "In proposHistory !!! " << endl;

  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i;

  //cout << "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << endl;

  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  double logProb, logProb1, logProb2;
  double res, fD;

  int numE = IDH->getNumE();

  //cout << "numE " << numE << endl;

  if(numE==0)                           // no event is proposed
    res = -((IDH->getN(0)+1)*lambda + fDel(IDH->getN(0),rd)*mu) * (IDH->getV(numE+1));
  else{
    int numE1 = numE-1;

    logProb = 0.0;
    for( i=1; i<numE; i++){
      fD = fDel(IDH->getN(i-1),rd);   
      logProb -= ((IDH->getN(i-1)+1)*lambda + fD*mu) * (IDH->getV(i) - IDH->getV(i-1));
      if(IDH->getID(i)==1)
	logProb += (logLambda + logRi + (IDH->getL(i)-1) * logRi1);
      else
	logProb += (log(fD) + logMu - log((double)(IDH->getN(i-1)-IDH->getL(i)+1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);
    }// end of for

    //cout << "A logProb " << logProb << endl;

    fD = fDel(IDH->getN(numE1),rd); 
    logProb2 = logProb - ((IDH->getN(numE1)+1)*lambda + fD*mu) * (IDH->getV(numE) - IDH->getV(numE1)) - ((IDH->getN(numE)+1)*lambda + fDel(IDH->getN(numE),rd)*mu) * (IDH->getV(numE+1) - IDH->getV(numE));

    if(IDH->getID(numE)==1)
	logProb2 += (logLambda + logRi + (IDH->getL(numE)-1) * logRi1);
    else
        logProb2 += (log(fD) + logMu - log((double)(IDH->getN(numE-1) - IDH->getL(numE)+1)) - log(1-pow(1-rd, IDH->getN(numE-1))) + logRd + (IDH->getL(numE)-1) * logRd1);


    //cout << "B logProb2 " << logProb2 << endl;

    // the numE-th event is proposed according uniform
    logProb1 = logProb - ((IDH->getN(numE1)+1)*lambda + fD*mu) * (IDH->getV(numE+1) - IDH->getV(numE1)) - log(IDH->getV(numE+1) - IDH->getV(numE1));

    if(IDH->getID(numE)==1)
      logProb1 -= log((double)IDH->getN(numE1)+1); 
    else
      logProb1 -= log((double)IDH->getN(numE1)+1 - IDH->getL(numE));


    //cout << "C logProb1 " << logProb1 << endl;

    double tuning = (logProb1>logProb2 ? logProb1 : logProb2);
    logProb1 -= tuning;
    logProb2 -= tuning;
    res = log(exp(logProb1) + exp(logProb2)) + tuning;
  }

  //cout << "res " << res << endl;

  return res;
}
*/
//-- v20 end ---//


//-- v20 start --//
double Tree::ProposHistory(const Parameters &para, InDelHistory* IDH){



  //cout << "In proposHistory !!! " << endl;

  double lambda = para.getLambda();
  double mu = para.getMu();
  double r = para.getR();
  double ri = para.getRi();
  double rd = para.getRd();
  int i;

  //cout << "lambda " << lambda << " mu " << mu << " r " << r << " ri " << ri << " rd " << rd << endl;

  double logLambda = log(lambda), logMu = log(mu), logRi = log(ri), logRi1 = log(1-ri), logRd = log(rd), logRd1 = log(1-rd) ;
  double logProb, logProb1, logProb2;
  double res, fD;

  int numE = IDH->getNumE();

  //cout << "numE " << numE << endl;


  //-- v20 start --//
  double logProbA, logProbB;
  double C_noEvent = para.getC_noEvent(); 
  double WeiID = para.getWeiID();
  double ImulFacSD = para.getImulFacSD();
  double DmulFacSD = para.getDmulFacSD();
  double ProbTargetFragI = para.getProbTargetFragI();
  double ProbTargetFragD = para.getProbTargetFragD();
  double logprobNoE;
  double eta;
  double LimI, LimD;
  int difLen;
  int Nend = IDH->getN(numE+1);
  double Time = IDH->getV(numE+1);
  LimI = 1/ri + ImulFacSD*sqrt(1-ri)/ri;
  LimD = 1/rd + DmulFacSD*sqrt(1-rd)/rd;
  //-- v20 end --//




  if(numE==0){
    // no event is proposed
    //-- v20 start --//
    eta = (IDH->getN(0)+1)*lambda + fDel(IDH->getN(0),rd)*mu;
    logprobNoE = -eta*Time/C_noEvent;
    res = LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - eta*Time);
    //-- v20 end ---//
  }else{
    int numE1 = numE-1;

    logProb = 0.0;


    for( i=1; i<numE; i++){

      fD = fDel(IDH->getN(i-1),rd);   
      eta = (IDH->getN(i-1)+1)*lambda + fD*mu;
      
      if(IDH->getID(i)==1){ // insertion

	difLen = Nend - IDH->getN(i-1);;
	if(difLen == 0){          // insertion - 1

	  logprobNoE = -eta*(Time - IDH->getV(i-1))/C_noEvent;
	  logProb += log(1 - exp(logprobNoE)) -eta*(IDH->getV(i) - IDH->getV(i-1)) + logLambda + logRi + (IDH->getL(i)-1) * logRi1;

	}else if(difLen >= LimI){ // insertion - 3

	  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + logLambda + log(1+WeiID) + logRi + (IDH->getL(i)-1) * logRi1;

	}else if(difLen < 0){     // insertion - 4

	  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log((IDH->getN(i-1)+1)*lambda - fD*mu*WeiID) - log((double)IDH->getN(i-1)+1) + logRi + (IDH->getL(i)-1) * logRi1;

        }else{                     // insertion - 2

	  if(difLen == IDH->getL(i)){
	    
	    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + logLambda + log(1+WeiID) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1);

          }else{

	    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + logLambda + log(1+WeiID) + log(1-ProbTargetFragI)+ logRi + (IDH->getL(i)-1) * logRi1;

          }
        }

      }else{     // deletion
	
	difLen = IDH->getN(i-1); - Nend;

	if(difLen == 0){          // deletion - 1

	  logprobNoE = -eta*(Time - IDH->getV(i-1))/C_noEvent;
	  logProb += log(1 - exp(logprobNoE)) -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD) + logMu - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	}else if(difLen >= LimD){ // deletion - 3

	  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

	}else if(difLen < 0){     // deletion - 4

	  logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(fD*mu - (IDH->getN(i-1)+1)*lambda*WeiID) - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

        }else{                     // deletion - 2

	  if(difLen == IDH->getL(i)){
	    
	    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1);

          }else{

	    logProb += -eta*(IDH->getV(i) - IDH->getV(i-1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(i-1)- IDH->getL(i) + 1)) + log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(i-1))) + logRd + (IDH->getL(i)-1) * logRd1;

          }
        }

      }

    }// end of for
    //--- v20 end ---//

    //cout << "A logProb " << logProb << endl;

    
    fD = fDel(IDH->getN(numE),rd);
    eta = (IDH->getN(numE)+1)*lambda + fD*mu;
    logprobNoE = -eta*(Time - IDH->getV(numE))/C_noEvent; // No event from numE

    fD = fDel(IDH->getN(numE1),rd);
    eta = (IDH->getN(numE1)+1)*lambda + fD*mu; // eta(numE - 1)

    if(IDH->getID(numE)==1){ // insertion

      if(IDH->getL(numE) < LimI){

	logProbA = logProb - eta*(IDH->getV(numE) - IDH->getV(numE1)) + logLambda + log(1+WeiID) + LOG_SUM(log(ProbTargetFragI), log(1-ProbTargetFragI)+ logRi + (IDH->getL(numE)-1) * logRi1);

      }else{

	logProbA = logProb - eta*(IDH->getV(numE) - IDH->getV(numE1)) + logLambda + log(1+WeiID) + logRi + (IDH->getL(numE)-1) * logRi1;

      }

      logProbA += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);

      logProbB = logProb - eta*(Time - IDH->getV(numE1)) - log(Time - IDH->getV(numE1)) - log((double)IDH->getN(numE1)+1); 

    }else{  // deletion

      if(IDH->getL(numE) < LimD){

	logProbA = logProb - eta*(IDH->getV(numE) - IDH->getV(numE1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(numE1)- IDH->getL(numE) + 1)) + LOG_SUM(log(ProbTargetFragD), log(1-ProbTargetFragD) - log(1-pow(1-rd, IDH->getN(numE1))) + logRd + (IDH->getL(numE)-1) * logRd1);

      }else{

	logProbA = logProb - eta*(IDH->getV(numE) - IDH->getV(numE1)) + log(1+WeiID) + log(fD) + logMu - log((double)(IDH->getN(numE1)- IDH->getL(numE) + 1)) - log(1-pow(1-rd, IDH->getN(numE1))) + logRd + (IDH->getL(numE)-1) * logRd1;
      }

      logProbA += LOG_SUM(logprobNoE, log(1-exp(logprobNoE)) - logprobNoE*C_noEvent);

      logProbB = logProb - eta*(Time - IDH->getV(numE1)) - log(Time - IDH->getV(numE1)) - log((double)IDH->getN(numE1) - IDH->getL(numE)+1); 

    }

    res = LOG_SUM(logProbA, logProbB);
  }


  //cout << "res " << res << endl;

  return res;
}
//-- v20 end ---//




double Tree::UpIDHonEdgeRandomWindow(Rand &rand, const Parameters &params, ofstream& c, int start) {

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* subIDH = new InDelHistory();

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;


 
  //w = params.getWindowLen_UpIDHonEdge();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  w = rand.runif()*(edgeT->getEdgeLen()); 

  
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();


  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  if(Time <= w){ // Propose new history in a whole sequence

    O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();

   
    if(baseNode != nodeP){
      N0 = Nend;
      Nend = nodeP->getSeqLen();
      IDH->ReverseIDH();
      O_psl = ProposHistory(params, IDH);
    }else{
      O_psl= edgeT->ProposHistory(params);
    }
    

    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;

      tempTime = tempTime+dt;
	
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }

      if(tempTime-Time < 0){

	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;

	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	    ID.push_back(1);
	    N.push_back(N[i-1]+L[i]);
	    HMGin = HMG[i-1];
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG.push_back(HMGin);
	    HMGin.resize(0);
	    
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L  
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
       
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);      
	}   // end of if(runif(0,1)-prob1<0)
	i++;

      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
   
	if(N[i-1]<Nend){

	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG[i-1];

	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else if(N[i-1]>Nend){
	  
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
 
    numE = i;
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    HMG.push_back(HMG[numE]);    
    
    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
    HMGin.resize(0);


    N_psl = ProposHistory(params, IDH);


    if(baseNode != nodeP)
      IDH->ReverseIDH();

    edgeT->calHMG();
    N_IDHlike = edgeT->likeliHistory(params);


    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();

    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();

    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;

      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }


    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 
    //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

  }else{  

    //********************************************// 
   //
    //    Propose new history in a subsequence
    //
    //*********************************************//

    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();


    getNa = 0;
    getNb = 0;
   
    midTime = (rand.runif() * Time);
    aTime = MAX((double)0,(midTime - (w/2)));
    bTime = MIN( Time, (midTime+ (w/2))) ;
    kTime = bTime - aTime;


    numE = IDH->getNumE();

    if(aTime == 0){
      q = 0;
      st = q + 1;
      kN0 = IDH->getN(q);
      getNa = 1;
    }else{
      for(q = 0; q <= numE; q++){
	if((IDH->getV(q) < aTime) && (aTime <= IDH->getV(q+1))){
	  st = q + 1;
	  kN0 = IDH->getN(q);
	  getNa = 1;
	  break;
	}
      }
    }
    
    if(bTime == Time){
      p = numE;
      en = p;
      kNend = IDH->getN(p);
      getNb = 1;
    }else{
      for(p = q; p <= numE ; p++){
	if((IDH->getV(p) <= bTime) && (bTime < IDH->getV(p+1))){
	  en = p; 
	  kNend = IDH->getN(p);
	  getNb = 1;
	  break;
	}
      }
    }
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    knumE = en - st + 1;

    if(knumE>0){
      for( q = st; q <= en; q++){       
	V.push_back((IDH->getV(q)-aTime));
	ID.push_back(IDH->getID(q));
	P.push_back(IDH->getP(q));
	L.push_back(IDH->getL(q));
	N.push_back(IDH->getN(q));
	i = (ID.size()-1);
	HMGin.resize(0);
	if(ID[i]==1){
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k < L[i]; k++)
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
        }else{
	  HMGin = HMG[i-1];
	  for( k = 0; k < L[i]; k++)
	    HMGin.erase(HMGin.begin()+ P[i]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	  
	}
      }
    }

    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);


    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = N[0];
      subIDH->ReverseIDH();
      O_psl = ProposHistory(params, subIDH);
    }else{
      O_psl = ProposHistory(params, subIDH);
    }



    // History Updata in a subsequence given Time
    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
 

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;
      
      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime-kTime < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	
	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	  ID.push_back(1);
	  N.push_back(N[i-1]+L[i]);	
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}   // end of if(runif(0,1)-prob1<0)
	i++;
	
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<kNend){
	  ID.push_back(1);
	  L.push_back(kNend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>kNend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-kNend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));  
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	    
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
    
    knumE = i;
    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);
    
    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);
    
    N_psl = ProposHistory(params, subIDH);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = subIDH->getN(0);      
      subIDH->ReverseIDH();
    }  

    

    //To put updated subsequence to IDH
    
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);


    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
    
    if(st > 1){
      for( i = 1; i < st; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }
    
    if(knumE >= 1){
      for( i = 1; i <= knumE ; i++){
	V.push_back((subIDH->getV(i)+aTime));
	ID.push_back(subIDH->getID(i));
	P.push_back(subIDH->getP(i));
	L.push_back(subIDH->getL(i));
	N.push_back(subIDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
    
    if(en < numE){
      for( i = (en+1); i <= numE; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
      
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    numE = st - 1 + knumE + numE - en;
    HMG.push_back(HMG[numE]);


    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();




    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }
    
   
    // Data likelihood
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();

    // IDH likelihood
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;


    //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;


  }


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  Lwt.resize(0);
  
  delete subIDH;

  return AP;

} // End of UpIDHonEdge








double Tree::UpIDHonEdge(Rand &rand, const Parameters &params, ofstream& c, int start) {

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* subIDH = new InDelHistory();

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  w = params.getWindowLen_UpIDHonEdge();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();


  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  if(Time <= w){ // Propose new history in a whole sequence

    O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();

   
    if(baseNode != nodeP){
      N0 = Nend;
      Nend = nodeP->getSeqLen();
      IDH->ReverseIDH();
      O_psl = ProposHistory(params, IDH);
    }else{
      O_psl= edgeT->ProposHistory(params);
    }
    

    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;

      tempTime = tempTime+dt;
	
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }

      if(tempTime-Time < 0){

	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;

	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	    ID.push_back(1);
	    N.push_back(N[i-1]+L[i]);
	    HMGin = HMG[i-1];
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG.push_back(HMGin);
	    HMGin.resize(0);
	    
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L  
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
       
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);      
	}   // end of if(runif(0,1)-prob1<0)
	i++;

      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
   
	if(N[i-1]<Nend){

	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG[i-1];

	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else if(N[i-1]>Nend){
	  
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
 
    numE = i;
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    HMG.push_back(HMG[numE]);    
    
    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
    HMGin.resize(0);


    N_psl = ProposHistory(params, IDH);


    if(baseNode != nodeP)
      IDH->ReverseIDH();

    edgeT->calHMG();
    N_IDHlike = edgeT->likeliHistory(params);


    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();

    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();

    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;

      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }


    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 
    //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

  }else{  

    //********************************************// 
   //
    //    Propose new history in a subsequence
    //
    //*********************************************//

    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();


    getNa = 0;
    getNb = 0;
   
    midTime = (rand.runif() * Time);
    aTime = MAX((double)0,(midTime - (w/2)));
    bTime = MIN( Time, (midTime+ (w/2))) ;
    kTime = bTime - aTime;


    numE = IDH->getNumE();

    if(aTime == 0){
      q = 0;
      st = q + 1;
      kN0 = IDH->getN(q);
      getNa = 1;
    }else{
      for(q = 0; q <= numE; q++){
	if((IDH->getV(q) < aTime) && (aTime <= IDH->getV(q+1))){
	  st = q + 1;
	  kN0 = IDH->getN(q);
	  getNa = 1;
	  break;
	}
      }
    }
    
    if(bTime == Time){
      p = numE;
      en = p;
      kNend = IDH->getN(p);
      getNb = 1;
    }else{
      for(p = q; p <= numE ; p++){
	if((IDH->getV(p) <= bTime) && (bTime < IDH->getV(p+1))){
	  en = p; 
	  kNend = IDH->getN(p);
	  getNb = 1;
	  break;
	}
      }
    }
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    knumE = en - st + 1;

    if(knumE>0){
      for( q = st; q <= en; q++){       
	V.push_back((IDH->getV(q)-aTime));
	ID.push_back(IDH->getID(q));
	P.push_back(IDH->getP(q));
	L.push_back(IDH->getL(q));
	N.push_back(IDH->getN(q));
	i = (ID.size()-1);
	HMGin.resize(0);
	if(ID[i]==1){
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k < L[i]; k++)
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
        }else{
	  HMGin = HMG[i-1];
	  for( k = 0; k < L[i]; k++)
	    HMGin.erase(HMGin.begin()+ P[i]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	  
	}
      }
    }

    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);


    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = N[0];
      subIDH->ReverseIDH();
      O_psl = ProposHistory(params, subIDH);
    }else{
      O_psl = ProposHistory(params, subIDH);
    }



    // History Updata in a subsequence given Time
    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
 

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;
      
      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime-kTime < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	
	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	  ID.push_back(1);
	  N.push_back(N[i-1]+L[i]);	
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}   // end of if(runif(0,1)-prob1<0)
	i++;
	
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<kNend){
	  ID.push_back(1);
	  L.push_back(kNend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>kNend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-kNend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));  
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	    
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
    
    knumE = i;
    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);
    
    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);
    
    N_psl = ProposHistory(params, subIDH);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = subIDH->getN(0);      
      subIDH->ReverseIDH();
    }  

    

    //To put updated subsequence to IDH
    
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);


    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
    
    if(st > 1){
      for( i = 1; i < st; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }
    
    if(knumE >= 1){
      for( i = 1; i <= knumE ; i++){
	V.push_back((subIDH->getV(i)+aTime));
	ID.push_back(subIDH->getID(i));
	P.push_back(subIDH->getP(i));
	L.push_back(subIDH->getL(i));
	N.push_back(subIDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
    
    if(en < numE){
      for( i = (en+1); i <= numE; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
      
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    numE = st - 1 + knumE + numE - en;
    HMG.push_back(HMG[numE]);


    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();




    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }
    
   
    // Data likelihood
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();

    // IDH likelihood
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;


    //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    if(start)
      AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;


  }


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  Lwt.resize(0);
  
  delete subIDH;

  return AP;

} // End of UpIDHonEdge








double Tree::UpIDHonEdge(Rand &rand, const Parameters &params, ofstream& c) {

  int i, k, j, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  int tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* subIDH = new InDelHistory();

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;
  
  w = params.getWindowLen_UpIDHonEdge();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  IDH =  edgeT->getIDH();


  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  // Heejung
  //double tempA, tempB;

  if(Time <= w){ // Propose new history in a whole sequence

    O_datalike = getLogLikeliData();
    //Heejung
    //O_IDHlike = logLikeliIDH[current];
    //tempA = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();

   
    if(baseNode != nodeP){
      N0 = Nend;
      Nend = nodeP->getSeqLen();
      IDH->ReverseIDH();
      O_psl = ProposHistory(params, IDH);
    }else{
      O_psl= edgeT->ProposHistory(params);
    }
    

    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;

      tempTime = tempTime+dt;
	
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }

      if(tempTime-Time < 0){

	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;

	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	    ID.push_back(1);
	    N.push_back(N[i-1]+L[i]);
	    HMGin = HMG[i-1];
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG.push_back(HMGin);
	    HMGin.resize(0);
	    
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L  
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
       
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);      
	}   // end of if(runif(0,1)-prob1<0)
	i++;

      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
   
	if(N[i-1]<Nend){

	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG[i-1];

	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else if(N[i-1]>Nend){
	  
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
 
    numE = i;
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    HMG.push_back(HMG[numE]);    
    
    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
    HMGin.resize(0);


    N_psl = ProposHistory(params, IDH);


    if(baseNode != nodeP)
      IDH->ReverseIDH();

    edgeT->calHMG();
    N_IDHlike = edgeT->likeliHistory(params);


    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();

    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();

    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;

      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }


    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();


    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
 
    //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;

  }else{  

    //********************************************// 
   //
    //    Propose new history in a subsequence
    //
    //*********************************************//

    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();


    getNa = 0;
    getNb = 0;
   
    midTime = (rand.runif() * Time);
    aTime = MAX((double)0,(midTime - (w/2)));
    bTime = MIN( Time, (midTime+ (w/2))) ;
    kTime = bTime - aTime;


    numE = IDH->getNumE();

    if(aTime == 0){
      q = 0;
      st = q + 1;
      kN0 = IDH->getN(q);
      getNa = 1;
    }else{
      for(q = 0; q <= numE; q++){
	if((IDH->getV(q) < aTime) && (aTime <= IDH->getV(q+1))){
	  st = q + 1;
	  kN0 = IDH->getN(q);
	  getNa = 1;
	  break;
	}
      }
    }
    
    if(bTime == Time){
      p = numE;
      en = p;
      kNend = IDH->getN(p);
      getNb = 1;
    }else{
      for(p = q; p <= numE ; p++){
	if((IDH->getV(p) <= bTime) && (bTime < IDH->getV(p+1))){
	  en = p; 
	  kNend = IDH->getN(p);
	  getNb = 1;
	  break;
	}
      }
    }
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    knumE = en - st + 1;

    if(knumE>0){
      for( q = st; q <= en; q++){       
	V.push_back((IDH->getV(q)-aTime));
	ID.push_back(IDH->getID(q));
	P.push_back(IDH->getP(q));
	L.push_back(IDH->getL(q));
	N.push_back(IDH->getN(q));
	i = (ID.size()-1);
	HMGin.resize(0);
	if(ID[i]==1){
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k < L[i]; k++)
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
        }else{
	  HMGin = HMG[i-1];
	  for( k = 0; k < L[i]; k++)
	    HMGin.erase(HMGin.begin()+ P[i]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	  
	}
      }
    }

    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);


    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = N[0];
      subIDH->ReverseIDH();
      O_psl = ProposHistory(params, subIDH);
    }else{
      O_psl = ProposHistory(params, subIDH);
    }



    // History Updata in a subsequence given Time
    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
 

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;
      
      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime-kTime < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	
	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	  ID.push_back(1);
	  N.push_back(N[i-1]+L[i]);	
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}   // end of if(runif(0,1)-prob1<0)
	i++;
	
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<kNend){
	  ID.push_back(1);
	  L.push_back(kNend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>kNend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-kNend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));  
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	    
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
    
    knumE = i;
    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);
    
    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);
    
    N_psl = ProposHistory(params, subIDH);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = subIDH->getN(0);      
      subIDH->ReverseIDH();
    }  

    

    //To put updated subsequence to IDH
    
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);


    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
    
    if(st > 1){
      for( i = 1; i < st; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }
    
    if(knumE >= 1){
      for( i = 1; i <= knumE ; i++){
	V.push_back((subIDH->getV(i)+aTime));
	ID.push_back(subIDH->getID(i));
	P.push_back(subIDH->getP(i));
	L.push_back(subIDH->getL(i));
	N.push_back(subIDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
    
    if(en < numE){
      for( i = (en+1); i <= numE; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
      
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    numE = st - 1 + knumE + numE - en;
    HMG.push_back(HMG[numE]);


    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();




    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }
    
   
    // Data likelihood
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();

    // IDH likelihood
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;


    //cout << "UpIDHonEdge " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;


    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);


    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<   exp(O_psl - N_psl) <<  endl;


  }


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  Lwt.resize(0);
  
  delete subIDH;

  return AP;

} // End of UpIDHonEdge







double Tree::UpIDHonEdge_v0(Rand &rand, const Parameters &params) {

  //cout << "In UpIDHonEdge " << endl;
  //checkTree();

  int i, k, N0, Nend, numE;
  double w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1; 
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;


  InDelHistory* IDH;
  InDelHistory* subIDH = new InDelHistory();

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  vector<double> Lwt(0);


  Node* nodeC;
  Node* nodeP;
  Node* tempNode;

  
  w = params.getWindowLen();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  IDH =  edgeT->getIDH();


  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  if(Time <= w){ // Propose new history in a whole sequence

    O_datalike = getLogLikeliData();
    O_IDHlike = edgeT->getlogLikeliIDH();
    O_psl= edgeT->ProposHistory(params);



    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;

      tempTime = tempTime+dt;
	
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }

      if(tempTime-Time < 0){

	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;

	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	    ID.push_back(1);
	    N.push_back(N[i-1]+L[i]);
	    HMGin = HMG[i-1];
	    //outfiler << "HMGin size" << HMGin.size() << endl;
	    int tmphmg = -1;
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG.push_back(HMGin);
	    HMGin.resize(0);
	    
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L  
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
       
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);      
	}   // end of if(runif(0,1)-prob1<0)
	i++;

      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	//double tmp = (Nend-N[i-1]) * (lambda+mu);
	if(N[i-1]<Nend){

	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG[i-1];

	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else if(N[i-1]>Nend){
	  
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
 
    numE = i;
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    HMG.push_back(HMG[numE]);    
    
    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();


    N_IDHlike = edgeT->likeliHistory(params);
    N_psl= edgeT->ProposHistory(params);

    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();

    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();

    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;

    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;

      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }


    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    logLikeliIDH[current] = likeliHistory(params);


    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);


  }else{  // Propose new history in a subsequence



    O_datalike = getLogLikeliData();
    O_IDHlike = edgeT->getlogLikeliIDH();


    getNa = 0;
    getNb = 0;
   
    midTime = (rand.runif() * Time);
    aTime = MAX((double)0,(midTime - (w/2)));
    bTime = MIN( Time, (midTime+ (w/2))) ;
    kTime = bTime - aTime;
    //outfiler << "Here aTime bTime kTime" << aTime << " " << bTime << " " << kTime << endl;
    //cout << "Here aTime bTime kTime" << aTime << " " << bTime << " " << kTime << endl;


    numE = IDH->getNumE();

    if(aTime == 0){
      q = 0;
      st = q + 1;
      kN0 = IDH->getN(q);
      getNa = 1;
    }else{
      for(q = 0; q <= numE; q++){
	if((IDH->getV(q) < aTime) && (aTime <= IDH->getV(q+1))){
	  st = q + 1;
	  //outfiler << "Found st " << st << endl;
	  kN0 = IDH->getN(q);
	  getNa = 1;
	  break;
	}
      }
    }
    
    if(bTime == Time){
      p = numE;
      en = p;
      kNend = IDH->getN(p);
      getNb = 1;
    }else{
      for(p = q; p <= numE ; p++){
	if((IDH->getV(p) <= bTime) && (bTime < IDH->getV(p+1))){
	  en = p; 
	  //outfiler << "Found en " << en << endl;
	  kNend = IDH->getN(p);
	  getNb = 1;
	  break;
	}
      }
    }
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMG.push_back(IDH->getHMG(st-1));

    knumE = en - st + 1;

    if(knumE>0){
      for( q = st; q <= en; q++){       
	V.push_back((IDH->getV(q)-aTime));
	ID.push_back(IDH->getID(q));
	P.push_back(IDH->getP(q));
	L.push_back(IDH->getL(q));
	N.push_back(IDH->getN(q));
	HMG.push_back(IDH->getHMG(q));
      }
    }

    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);


    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);


    O_psl = ProposHistory(params, subIDH);



    // History Updata in a subsequence given Time
    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMG.push_back(IDH->getHMG(st-1));
    
    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;
      
      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime-kTime < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	
	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	  ID.push_back(1);
	  N.push_back(N[i-1]+L[i]);	
	  HMGin = HMG[i-1];
	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG[i-1];
	  //outfiler << "HMGin size" << HMGin.size() << endl;
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}   // end of if(runif(0,1)-prob1<0)
	i++;
	
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	//double tmp = (Nend-N[i-1]) * (lambda+mu);
	if(N[i-1]<kNend){
	  ID.push_back(1);
	  L.push_back(kNend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>kNend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-kNend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));  
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	    
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
    
    knumE = i;
    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);
    
    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);
    
    N_psl = ProposHistory(params, subIDH);



    

    //To put updated subsequence to IDH
    
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);


    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
    
    if(st > 1){
      for( i = 1; i < st; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }
    
    if(knumE >= 1){
      for( i = 1; i <= knumE ; i++){
	V.push_back((subIDH->getV(i)+aTime));
	ID.push_back(subIDH->getID(i));
	P.push_back(subIDH->getP(i));
	L.push_back(subIDH->getL(i));
	N.push_back(subIDH->getN(i));
	HMG.push_back(subIDH->getHMG(i));
      }
    }
    
    if(en < numE){
      for( i = (en+1); i <= numE; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }
      
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    numE = st - 1 + knumE + numE - en;
    HMG.push_back(HMG[numE]);


    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();

    N_IDHlike = edgeT->likeliHistory(params);



    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    int edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }
    
   
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();
    // find_bug3 //
    logLikeliIDH[current] = likeliHistory(params);
    //logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

  }


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  Lwt.resize(0);
  
  delete subIDH;

  return AP;

} // End of UpIDHonEdge



// stposi : [input] starting position. We know hmg[stposi] = -1
// hmg : [input] all hmg sequence
// outHMGs : [output] save all Hidden HMGs  
void Tree::getHiddenHMG(vector<int> &outHMGs, vector<int> HMGs, int stposi){


  int hmg = HMGs[stposi];

  if(hmg >= 0){
    cout << "ERROR in Tree::getHiddenHM! This function should be called when hmg is negative! " << endl;
  }else{
    bool hitLeftEnd = false;
    int st, en;
    int k;
    int lenHMGs = HMGs.size() - 1;

    // check left direction
    k = 0;
    while(hmg < 0){
      if((stposi- k) == 0){
	hmg = 0;
	hitLeftEnd = true;
      }else{
	k++;
	hmg = HMGs[stposi - k];
      }
    }    
    if(hitLeftEnd)
      st = hmg;
    else
      st = hmg + 1;
    
    // check right direction
    k = 0;
    hmg = HMGs[stposi];
    while(hmg < 0){
      if((stposi + k) == lenHMGs){
	cout << "ERROR in Tree::getHiddenHM! HMG at the end could be >= 0 " << endl;
      }else{
	k++;
	hmg = HMGs[stposi + k];
      }
    }    
    en = hmg;

    if(st > en){
      cout << "ERROR in Tree::getHiddenHM! st <= en! " << endl;
    }else{
      outHMGs.resize(0);
      for(k = st ; k <= en; k++)
	outHMGs.push_back(k);
    }
  }

}


// return index (from 0 to canN) if P is in HotSpotRegion
// otherwise, return -1
int Tree::inHotSpotRegion(vector<vector<int> > chain_v, vector<vector<int> > posi_v, vector<int> P, int numE){

  int k, ki, upd_posi, canN;
  int posi = -1;

  canN = chain_v[numE].size();

  for(k = 0; k < canN ; k++){

    upd_posi = k;
    for(ki = numE; ki > 0; ki--){
      if(P[ki] !=  posi_v[ki][upd_posi])
	break;
      upd_posi = chain_v[ki][upd_posi];
    }
    
    if(ki == 0){
      posi = k;
      break;
    }
  }

  return posi;

}
    







double Tree::UpIDHonEdgeLikeRandomWindow(Rand &rand, Parameters &params, int MaxE, int hotspotlen, ofstream& c, int start) {

  int tmpInt, tmpInt2, i, j, k, wi, ki, km, N0, Nend, numE, OnumE, tmphmg, lenPosi, upd_posi, sizeM, numPosi;
  double tmpDouble, w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1, delta; 
  double maxL, ps_n, ps_c;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  int getEnd, canN, edgeTnum;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;

  int IndexInHotSpotRegion;
  bool changePosi;


  bool goGetHiddenHMG;

  tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* tmpIDH = new InDelHistory();
  InDelHistory* oIDH = new InDelHistory();
  InDelHistory* subIDH = new InDelHistory();
  InDelHistory* tmp2IDH = new InDelHistory();
  

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  vector<double> Lwt(0);

  vector<int> INDEp; // insertion and deletion positions of current events to get hotspots
  vector<int> INDEpTmp; 
  vector<int> hotspot; // insertion hotspots among 0 through seqlen
  vector<vector<int> > chain_v;
  vector<vector<int> > posi_v;
  vector<vector<vector<int> > > hmg_v;
  vector<double> lik_n;
  vector<double> lik_wei_n;



  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;

  // Get all parameters
  
  //w = params.getWindowLen_UpIDHonEdgeLike();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();
  delta = params.getDelta();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  w = rand.runif()*(edgeT->getEdgeLen()); 


  // Save the original IDH
  (*oIDH) = (*edgeT->getIDH());

  // Get other information of the selected edge
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  IDH =  edgeT->getIDH();
  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  



  // Heejung
  //double tempA, tempB;
  if(Time <= w){ // Propose new history in a whole edge

    // Get all old information
    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();

    if(baseNode != nodeP){
      N0 = Nend;
      Nend = nodeP->getSeqLen();
      IDH->ReverseIDH();
      O_psl = ProposHistory(params, IDH);
    }else{
      O_psl= edgeT->ProposHistory(params);
    }

    // Generate new IDH

    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    while(1){

      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;

      tempTime = tempTime+dt;
	
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }

      if(tempTime-Time < 0){  // Need to generate new indel event

	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;

	if(rand.runif()-prob1 < 0){  // propose an insertion, which can be of any length, at any position

	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    L.push_back(rand.rgeom(ri));
	    ID.push_back(1);
	    N.push_back(N[i-1]+L[i]);
	    HMGin = HMG[i-1];
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG.push_back(HMGin);
	    HMGin.resize(0);
	    
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L  
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);       
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);      
	} 

	i++;

      }else{   // tempTime > Time, propose an event at any left time, at a position, with particular length

	if(N[i-1]<Nend){  // insertion

	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else if(N[i-1]>Nend){  // deletion
	  
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	

	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)

    }// end of while(1).
 
    numE = i;
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    HMG.push_back(HMG[numE]);    


    // Set newly generated IDH 
    IDH->setHistory(numE, V, ID, P, L, N, HMG);
    N_psl = ProposHistory(params, IDH);


    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
    HMGin.resize(0);
   
    if(baseNode != nodeP)
      IDH->ReverseIDH();

    edgeT->calHMG();
    


    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
     nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }

    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();






    if((0 < IDH->getNumE()) && (IDH->getNumE() <= MaxE) && (oIDH->getNumE()>0)){
    // Consider changing positions based on likelihood

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);

      //---------------------------------------------------------//
      //
      //     Construct insertion hotspot and deletion hotspot 
      //
      //----------------------------------------------------------//
     
      OnumE = oIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = oIDH->getHMG(k-1, oIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, oIDH->getHMG(k-1), oIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
	  INDEpTmp.resize(0);
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      } // End of "for( k = 1; k <= OnumE; k++)"



      // Sort
      sort(INDEp.begin(),INDEp.end());



      // Construct hotspots from INDEp
      // INDEp includes repeated positions.

      int stspot, enspot;
      
      tmpInt2 = oIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);

     


      //----------------------------------------------//
      //
      // Get possible positions in the hotspot region and get homology 
      //
      //-----------------------------------------------//


      numE = IDH->getNumE();
      

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(IDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;


      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(IDH->getID(k) == 1) // if insertion
	  numPosi *= (IDH->getN(k-1) + 1);
	else
	  numPosi *= (IDH->getN(k-1) - IDH->getL(k) + 1);
      }



      if(IDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	 
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km < IDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(IDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-IDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < IDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-IDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(IDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(IDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki] < 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
		    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < IDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - IDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < IDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - IDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(IDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"


      canN = chain_v[numE].size();

      if(canN==0){ // If there's no possible positions within hotspot region
        // B
	ps_n = 1;

      }else{       // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, IDH->getP(), numE);

	if((rand.runif()- delta) > 0)  // with prob 1 - delta, change positions  	  
	  changePosi = true;
	else                           // don't change position
	  changePosi = false;

	// should change position or current position are in a hot spot region
	if((changePosi) | (IndexInHotSpotRegion >= 0)){   

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){

	    P.resize(0);
	    HMG.resize(0);
	    P.resize(numE+2);
	    P[0] = 0;
	    P[numE+1] = 0;
	    HMG.resize(numE+2);
	    HMG[0] = IDH->getHMG(0);

	    upd_posi = k;
	    for(ki = numE; ki > 0; ki--){
	      P[ki] =  posi_v[ki][upd_posi];
	      HMG[ki] = hmg_v[ki][upd_posi];
	      upd_posi = chain_v[ki][upd_posi];
	    }

	    HMG[numE+1] = HMG[numE];

	    IDH->setP(P);
	    IDH->setHMG(HMG);
	    edgeT->calHMG();
	    P.resize(0);
	    HMG.resize(0);

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;


	  if(changePosi)  // Need to change position using likelihood
	    upd_posi = rand.rwunif(lik_wei_n); // Select new position based on posterior prob
	  else             // Don't change position
	    upd_posi = IndexInHotSpotRegion;  


	  ps_n = lik_wei_n[upd_posi]*numPosi;

	  // Move to selected position or the original
	  P.resize(0);
	  HMG.resize(0);
	  P.resize(numE+2);
	  P[0] = 0;
	  P[numE+1] = 0;
	  HMG.resize(numE+2);
	  HMG[0] = IDH->getHMG(0);
	  
	  for(ki = numE; ki > 0; ki--){
	    P[ki] =  posi_v[ki][upd_posi];
	    HMG[ki] = hmg_v[ki][upd_posi];
	    upd_posi = chain_v[ki][upd_posi];
	  }
	  
	  HMG[numE+1] = HMG[numE];
	  
	  IDH->setP(P);
	  IDH->setHMG(HMG);
	  edgeT->calHMG();
	  P.resize(0);
	  HMG.resize(0);
	  
	  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	  // 1
	  nodeC->findRootSites();
	  
	  // 1'
	  if(nodeP->getRoot())
	    nodeP->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3 4 5
	  if(nodeP->getRoot()){
	    nodeP->CalloglikeliofLinkedSites(params);
	  }else{
	    nodeP->CalSubTreeProb(params);
	    nodeP->CalloglikeliofRootSites(params);
	    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	    
	    // 4 5
	    UpdateAllinfoToRoot(params, nodeP->getParent());
	  }
	  
	  logLikeliData[current] = likeliData(); 
	  N_datalike = getLogLikeliData();
	  
	}else{  // Else of "if((changePosi) | (IndexInHotSpotRegion >= 0))"
          // C
	  ps_n = 0;  // Don't change position and the current is not in hot spot region
	  
	}       // End of "else of if((changePosi) | (IndexInHotSpotRegion >= 0))"

      }   // End of "else of if(canN==0)"

    }else{  // End of "if((0 < IDH->getNumE()) && (IDH->getNumE() <= MaxE) && (oIDH->getNumE()>0))"
      // A 
      ps_n = 1;
    }


    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);





    //-------------------------------------//
    // 
    // Reverse part
    //
    //--------------------------------------//
    
    if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0)){
    // Consider changing positions based on likelihood

      (*tmpIDH) = (*IDH);

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
      

      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      numE = IDH->getNumE();
      
      for( k = 1; k <= numE; k++){
	tmpInt = IDH->getHMG(k-1, IDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, IDH->getHMG(k-1), IDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      }  // End of "for( k = 1; k <= numE; k++)"


      sort(INDEp.begin(),INDEp.end());

 
      // Construct hotspots from INDEp
      // INDEp includes repeated positions.
      int stspot, enspot;
      
      tmpInt2 = IDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);




      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      numE = oIDH->getNumE();  

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(oIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;

      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(oIDH->getID(k) == 1) // if insertion
	  numPosi *= (oIDH->getN(k-1) + 1);
	else
	  numPosi *= (oIDH->getN(k-1) - oIDH->getL(k) + 1);
      }


      if(oIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km< oIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(oIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-oIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < oIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-oIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(oIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(oIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < oIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - oIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < oIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - oIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(oIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"

      canN = chain_v[numE].size();



      if(canN == 0){   // If there's no possible positions within hotspot region
	// B
	ps_c = 1;
	
      }else{           // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, oIDH->getP(), numE);

	if(IndexInHotSpotRegion >= 0){ // P from old IDH is in a hot spot region 

	  (*IDH) = (*oIDH);
	  edgeT->calHMG();
	  
	  numE = IDH->getNumE();
	  
	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);
	  
	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){
	    
	    P.resize(0);
	    HMG.resize(0);
	    P.resize(numE+2);
	    P[0] = 0;
	    P[numE+1] = 0;
	    HMG.resize(numE+2);
	    HMG[0] = IDH->getHMG(0);

	    upd_posi = k;
	    for(ki = numE; ki > 0; ki--){
	      P[ki] =  posi_v[ki][upd_posi];
	      HMG[ki] = hmg_v[ki][upd_posi];
	      upd_posi = chain_v[ki][upd_posi];
	    }

	    HMG[numE+1] = HMG[numE];

	    IDH->setP(P);
	    IDH->setHMG(HMG);
	    edgeT->calHMG();
	    P.resize(0);
	    HMG.resize(0);

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;

	  upd_posi = IndexInHotSpotRegion;  
	  // D
	  ps_c = lik_wei_n[upd_posi]*numPosi;


	}else{  // Else of "if(IndexInHotSpotRegion >= 0)"
          // C
	  ps_c = 0;  // P from oIDH is not in a hot spot region

	}       // End of "Else of if(IndexInHotSpotRegion >= 0)"

      }   // End of "else of if(canN==0)"

      (*IDH) = (*tmpIDH);

    }else{  // End of "if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0))"
      // A
      ps_c = 1;
    }


    // move to the IDH (not oIDH)
    edgeT->calHMG();
    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    // Date likelihood
    logLikeliData[current] = likeliData(); 
    N_datalike = getLogLikeliData();

    // IDH likelihood
    //Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike; 

    //cout << "UpIDHonEdgeLike " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    if(start)
      AP = exp( N_datalike + N_IDHlike + O_psl + log(delta + ((1-delta)*ps_c)) - O_datalike - O_IDHlike - N_psl - log(delta + ((1-delta)*ps_n)));
    else
      AP = exp( N_datalike + N_IDHlike - O_datalike - O_IDHlike);


    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp( O_psl + log(delta + ((1-delta)*ps_c)) - N_psl - log(delta + ((1-delta)*ps_n))) << endl;  




    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);


  }else{   // Else of "if(Time <= w)"
           

    //---------------------------------------
    //
    // Propose new history in a window
    //
    //---------------------------------------

    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();


    getNa = 0;
    getNb = 0;
   
    midTime = (rand.runif() * Time);
    aTime = MAX((double)0,(midTime - (w/2)));
    bTime = MIN( Time, (midTime+ (w/2))) ;
    kTime = bTime - aTime;

    numE = IDH->getNumE();

    if(aTime == 0){
      q = 0;
      st = q + 1;
      kN0 = IDH->getN(q);
      getNa = 1;
    }else{
      for(q = 0; q <= numE; q++){
	if((IDH->getV(q) < aTime) && (aTime <= IDH->getV(q+1))){
	  st = q + 1;
	  kN0 = IDH->getN(q);
	  getNa = 1;
	  break;
	}
      }
    }
    
    if(bTime == Time){
      p = numE;
      en = p;
      kNend = IDH->getN(p);
      getNb = 1;
    }else{
      for(p = q; p <= numE ; p++){
	if((IDH->getV(p) <= bTime) && (bTime < IDH->getV(p+1))){
	  en = p; 
	  kNend = IDH->getN(p);
	  getNb = 1;
	  break;
	}
      }
    }

    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    knumE = en - st + 1;

   
    if(knumE>0){

      for( q = st; q <= en; q++){
	V.push_back((IDH->getV(q)-aTime));
	ID.push_back(IDH->getID(q));
	P.push_back(IDH->getP(q));
	L.push_back(IDH->getL(q));
	N.push_back(IDH->getN(q));
	i = (ID.size()-1);
	HMGin.resize(0);
	if(ID[i]==1){
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k < L[i]; k++)
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
        }else{
	  HMGin = HMG[i-1];
	  for( k = 0; k < L[i]; k++)
	    HMGin.erase(HMGin.begin()+ P[i]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	  
	}
      }
    } // End of "if(knumE>0)"

    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);


    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = subIDH->getN(0);
      subIDH->ReverseIDH();
      O_psl = ProposHistory(params, subIDH);
      subIDH->ReverseIDH();
    }else{
      O_psl= ProposHistory(params, subIDH);
    }




    // History Update in a subsequence given Time
    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
 

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;
      
      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime-kTime < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	
	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	  ID.push_back(1);
	  N.push_back(N[i-1]+L[i]);	
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}   // end of if(runif(0,1)-prob1<0)
	i++;
	
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<kNend){
	  ID.push_back(1);
	  L.push_back(kNend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>kNend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-kNend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));  
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	    
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
    
    knumE = i;
    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);
    
    tmpIDH->setHistory(knumE, V, ID, P, L, N, HMG);
    N_psl = ProposHistory(params, tmpIDH);


    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = tmpIDH->getN(0);
      tmpIDH->ReverseIDH();
    }


    // put new sub IDH 

    numE = IDH->getNumE();

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
    
    if(st > 1){
      for( i = 1; i < st; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }
    
    if(knumE >= 1){
      for( i = 1; i <= knumE ; i++){
	V.push_back((tmpIDH->getV(i)+aTime));
	ID.push_back(tmpIDH->getID(i));
	P.push_back(tmpIDH->getP(i));
	L.push_back(tmpIDH->getL(i));
	N.push_back(tmpIDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
    
    if(en < numE){
      for( i = (en+1); i <= numE; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	int newposi = HMG.size();
	HMGin = HMG[newposi-1]; 
	if(ID[newposi] == 1){
	  for( km = 0; km < L[newposi]; km++)
	    HMGin.insert(HMGin.begin() + P[newposi] ,tmphmg);
        }else{
	  for( km = 0; km < L[newposi]; km++)
	    HMGin.erase(HMGin.begin()+ P[newposi]);
	}
	HMG.push_back(HMGin);  
	HMGin.resize(0);
      }
    }

    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    numE = st - 1 + knumE + numE - en;
    HMG.push_back(HMG[numE]);

    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();

    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();




    
    if((0 < tmpIDH->getNumE()) && (tmpIDH->getNumE() <= MaxE) && (subIDH->getNumE()>0)){
      // Consider changing positions based on likelihood


      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
    

      //---------------------------------------------------------//
      //
      //     Construct insertion hotspot and deletion hotspot 
      //
      //----------------------------------------------------------//
      
      OnumE = subIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = subIDH->getHMG(k-1, subIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, subIDH->getHMG(k-1), subIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
	  INDEpTmp.resize(0);
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"
	
      } // End of "for( k = 1; k <= OnumE; k++)"
      
      

      // Sort
      sort(INDEp.begin(),INDEp.end());



      // Construct hotspots from INDEp
      // INDEp includes repeated positions.

      int stspot, enspot;
      
      tmpInt2 = subIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      
      
      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);
      
      


      //----------------------------------------------//
      //
      // Get possible positions in the hotspot region and get homology 
      //
      //-----------------------------------------------//


      numE = tmpIDH->getNumE();
      

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(tmpIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;


      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(tmpIDH->getID(k) == 1) // if insertion
	  numPosi *= (tmpIDH->getN(k-1) + 1);
	else
	  numPosi *= (tmpIDH->getN(k-1) - tmpIDH->getL(k) + 1);
      }



      if(tmpIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	 
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km < tmpIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(tmpIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-tmpIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < tmpIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-tmpIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(tmpIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(tmpIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki] < 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
		    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < tmpIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - tmpIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < tmpIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - tmpIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(tmpIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"


      canN = chain_v[numE].size();


      if(canN==0){ // If there's no possible positions within hotspot region
        // B
	ps_n = 1;

      }else{       // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, tmpIDH->getP(), numE);

	if((rand.runif()- delta) > 0)  // with prob 1 - delta, change positions  	  
	  changePosi = true;
	else                           // don't change position
	  changePosi = false;

	// should change position or current position are in a hot spot region
	if((changePosi) | (IndexInHotSpotRegion >= 0)){   

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  knumE = numE;
	  numE = IDH->getNumE();

	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){

	    upd_posi = k;
	    for(ki = knumE; ki > 0; ki--){
	      IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	      upd_posi = chain_v[ki][upd_posi];
            }

	    for(ki = st; ki <= numE; ki++){
	      HMGin = IDH->getHMG(ki-1); 
	      if(IDH->getID(ki) == 1){
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	      }else{
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	      }
	      IDH->setHMG(HMGin, ki);
	      HMGin.resize(0);
	    }
	   
	    IDH->setHMG(IDH->getHMG(numE), numE+1);
	    edgeT->calHMG();

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;


	  if(changePosi)  // Need to change position using likelihood
	    upd_posi = rand.rwunif(lik_wei_n); // Select new position based on posterior prob
	  else             // Don't change position
	    upd_posi = IndexInHotSpotRegion;  


	  ps_n = lik_wei_n[upd_posi]*numPosi;

	  for(ki = knumE; ki > 0; ki--){
	    IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	    tmpIDH->setP(posi_v[ki][upd_posi], ki);
	    tmpIDH->setHMG(hmg_v[ki][upd_posi], ki);
	    upd_posi = chain_v[ki][upd_posi];
	  }

	  tmpIDH->setHMG(tmpIDH->getHMG(knumE), knumE + 1);
	
	  for(ki = st; ki <= numE; ki++){
	    HMGin = IDH->getHMG(ki-1); 
	    if(IDH->getID(ki) == 1){
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	    }else{
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	    }
	    IDH->setHMG(HMGin, ki);
	    HMGin.resize(0);
	  }
	  
	  IDH->setHMG(IDH->getHMG(numE), numE+1);
	  edgeT->calHMG();

	  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	  // 1
	  nodeC->findRootSites();
	  
	  // 1'
	  if(nodeP->getRoot())
	    nodeP->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3 4 5
	  if(nodeP->getRoot()){
	    nodeP->CalloglikeliofLinkedSites(params);
	  }else{
	    nodeP->CalSubTreeProb(params);
	    nodeP->CalloglikeliofRootSites(params);
	    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	    
	    // 4 5
	    UpdateAllinfoToRoot(params, nodeP->getParent());
	  }
	  
	  logLikeliData[current] = likeliData(); 
	  N_datalike = getLogLikeliData();
	  
	}else{  // Else of "if((changePosi) | (IndexInHotSpotRegion >= 0))"
          // C
	  ps_n = 0;  // Don't change position and the current is not in hot spot region
	  
	}       // End of "else of if((changePosi) | (IndexInHotSpotRegion >= 0))"

      }   // End of "else of if(canN==0)"

    }else{  // End of "if((0 < tmpIDH->getNumE()) && (tmpIDH->getNumE() <= MaxE) && (subIDH->getNumE()>0))"
      // A 
      ps_n = 1;
    }




    //-------------------------------------//
    // 
    // Reverse part
    //
    //--------------------------------------//


    if((0 < subIDH->getNumE()) && (subIDH->getNumE() <= MaxE) && (tmpIDH->getNumE()>0)){

      (*tmp2IDH) = (*IDH);

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
     

      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      numE = tmpIDH->getNumE();
      
      for( k = 1; k <= numE; k++){
	tmpInt = tmpIDH->getHMG(k-1, tmpIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, tmpIDH->getHMG(k-1), tmpIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      }  // End of "for( k = 1; k <= numE; k++)"


      sort(INDEp.begin(),INDEp.end());

 
      // Construct hotspots from INDEp
      // INDEp includes repeated positions.
      int stspot, enspot;
      
      tmpInt2 = tmpIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);




      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      numE = subIDH->getNumE();  

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(subIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;

      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(subIDH->getID(k) == 1) // if insertion
	  numPosi *= (subIDH->getN(k-1) + 1);
	else
	  numPosi *= (subIDH->getN(k-1) - subIDH->getL(k) + 1);
      }


      if(subIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km< subIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(subIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-subIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < subIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-subIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(subIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(subIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < subIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - subIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < subIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - subIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(subIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"

      canN = chain_v[numE].size();




      if(canN == 0){   // If there's no possible positions within hotspot region
	// B
	ps_c = 1;
	
      }else{           // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, subIDH->getP(), numE);

	if(IndexInHotSpotRegion >= 0){ // P from old IDH is in a hot spot region 

	  (*IDH) = (*oIDH);
	  edgeT->calHMG();
	  
	  knumE = numE;
	  numE = IDH->getNumE();
	  
	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);
	  
	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){
	    

	    upd_posi = k;
	    for(ki = knumE; ki > 0; ki--){
	      IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	      upd_posi = chain_v[ki][upd_posi];
            }

	    for(ki = st; ki <= numE; ki++){
	      HMGin = IDH->getHMG(ki-1); 
	      if(IDH->getID(ki) == 1){
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	      }else{
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	      }
	      IDH->setHMG(HMGin, ki);
	      HMGin.resize(0);
	    }
	   
	    IDH->setHMG(IDH->getHMG(numE), numE+1);
	    edgeT->calHMG();

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;


	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;

	  upd_posi = IndexInHotSpotRegion;  
	  // D
	  ps_c = lik_wei_n[upd_posi]*numPosi;


	}else{  // Else of "if(IndexInHotSpotRegion >= 0)"
          // C
	  ps_c = 0;  // P from oIDH is not in a hot spot region

	}       // End of "Else of if(IndexInHotSpotRegion >= 0)"

      }   // End of "else of if(canN==0)"

      (*IDH) = (*tmp2IDH);

    }else{  // End of "if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0))"
      // A
      ps_c = 1;
    }


    
    edgeT->calHMG();
    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    // Date likelihood
    logLikeliData[current] = likeliData(); 
    N_datalike = getLogLikeliData();

    // IDH likelihood
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike; 


    //cout << "UpIDHonEdgeLike " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    if(start)
      AP = exp( N_datalike + N_IDHlike + O_psl + log(delta + ((1-delta)*ps_c)) - O_datalike - O_IDHlike - N_psl - log(delta + ((1-delta)*ps_n)));
    else
      AP = exp( N_datalike + N_IDHlike - O_datalike - O_IDHlike);



    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp( O_psl + log(delta + ((1-delta)*ps_c)) - N_psl - log(delta + ((1-delta)*ps_n))) << endl;  

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);

  }


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  Lwt.resize(0);
  INDEp.resize(0);
  INDEpTmp.resize(0); 
  hotspot.resize(0);
  chain_v.resize(0);
  posi_v.resize(0);
  hmg_v.resize(0);
  lik_n.resize(0);
  lik_wei_n.resize(0);

  
  delete subIDH;
  delete tmpIDH;
  delete tmp2IDH;
  delete oIDH;

  return AP;

}   // End of UpIDHonEdgeLike








double Tree::UpIDHonEdgeLike(Rand &rand, Parameters &params, int MaxE, int hotspotlen, ofstream& c, int start) {

  int tmpInt, tmpInt2, i, j, k, wi, ki, km, N0, Nend, numE, OnumE, tmphmg, lenPosi, upd_posi, sizeM, numPosi;
  double tmpDouble, w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1, delta; 
  double maxL, ps_n, ps_c;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  int getEnd, canN, edgeTnum;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;

  int IndexInHotSpotRegion;
  bool changePosi;


  bool goGetHiddenHMG;

  tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* tmpIDH = new InDelHistory();
  InDelHistory* oIDH = new InDelHistory();
  InDelHistory* subIDH = new InDelHistory();
  InDelHistory* tmp2IDH = new InDelHistory();
  

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  vector<double> Lwt(0);

  vector<int> INDEp; // insertion and deletion positions of current events to get hotspots
  vector<int> INDEpTmp; 
  vector<int> hotspot; // insertion hotspots among 0 through seqlen
  vector<vector<int> > chain_v;
  vector<vector<int> > posi_v;
  vector<vector<vector<int> > > hmg_v;
  vector<double> lik_n;
  vector<double> lik_wei_n;



  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;

  // Get all parameters
  
  w = params.getWindowLen_UpIDHonEdgeLike();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();
  delta = params.getDelta();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];

  // Save the original IDH
  (*oIDH) = (*edgeT->getIDH());

  // Get other information of the selected edge
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  IDH =  edgeT->getIDH();
  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  



  // Heejung
  //double tempA, tempB;
  if(Time <= w){ // Propose new history in a whole edge

    // Get all old information
    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();

    if(baseNode != nodeP){
      N0 = Nend;
      Nend = nodeP->getSeqLen();
      IDH->ReverseIDH();
      O_psl = ProposHistory(params, IDH);
    }else{
      O_psl= edgeT->ProposHistory(params);
    }

    // Generate new IDH

    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    while(1){

      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;

      tempTime = tempTime+dt;
	
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }

      if(tempTime-Time < 0){  // Need to generate new indel event

	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;

	if(rand.runif()-prob1 < 0){  // propose an insertion, which can be of any length, at any position

	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    L.push_back(rand.rgeom(ri));
	    ID.push_back(1);
	    N.push_back(N[i-1]+L[i]);
	    HMGin = HMG[i-1];
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG.push_back(HMGin);
	    HMGin.resize(0);
	    
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L  
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);       
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);      
	} 

	i++;

      }else{   // tempTime > Time, propose an event at any left time, at a position, with particular length

	if(N[i-1]<Nend){  // insertion

	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else if(N[i-1]>Nend){  // deletion
	  
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	

	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)

    }// end of while(1).
 
    numE = i;
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    HMG.push_back(HMG[numE]);    


    // Set newly generated IDH 
    IDH->setHistory(numE, V, ID, P, L, N, HMG);
    N_psl = ProposHistory(params, IDH);


    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
    HMGin.resize(0);
   
    if(baseNode != nodeP)
      IDH->ReverseIDH();

    edgeT->calHMG();
    


    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
     nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }

    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();






    if((0 < IDH->getNumE()) && (IDH->getNumE() <= MaxE) && (oIDH->getNumE()>0)){
    // Consider changing positions based on likelihood

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);

      //---------------------------------------------------------//
      //
      //     Construct insertion hotspot and deletion hotspot 
      //
      //----------------------------------------------------------//
     
      OnumE = oIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = oIDH->getHMG(k-1, oIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, oIDH->getHMG(k-1), oIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
	  INDEpTmp.resize(0);
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      } // End of "for( k = 1; k <= OnumE; k++)"



      // Sort
      sort(INDEp.begin(),INDEp.end());



      // Construct hotspots from INDEp
      // INDEp includes repeated positions.

      int stspot, enspot;
      
      tmpInt2 = oIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);

     


      //----------------------------------------------//
      //
      // Get possible positions in the hotspot region and get homology 
      //
      //-----------------------------------------------//


      numE = IDH->getNumE();
      

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(IDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;


      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(IDH->getID(k) == 1) // if insertion
	  numPosi *= (IDH->getN(k-1) + 1);
	else
	  numPosi *= (IDH->getN(k-1) - IDH->getL(k) + 1);
      }



      if(IDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	 
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km < IDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(IDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-IDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < IDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-IDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(IDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(IDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki] < 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
		    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < IDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - IDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < IDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - IDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(IDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"


      canN = chain_v[numE].size();

      if(canN==0){ // If there's no possible positions within hotspot region
        // B
	ps_n = 1;

      }else{       // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, IDH->getP(), numE);

	if((rand.runif()- delta) > 0)  // with prob 1 - delta, change positions  	  
	  changePosi = true;
	else                           // don't change position
	  changePosi = false;

	// should change position or current position are in a hot spot region
	if((changePosi) | (IndexInHotSpotRegion >= 0)){   

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){

	    P.resize(0);
	    HMG.resize(0);
	    P.resize(numE+2);
	    P[0] = 0;
	    P[numE+1] = 0;
	    HMG.resize(numE+2);
	    HMG[0] = IDH->getHMG(0);

	    upd_posi = k;
	    for(ki = numE; ki > 0; ki--){
	      P[ki] =  posi_v[ki][upd_posi];
	      HMG[ki] = hmg_v[ki][upd_posi];
	      upd_posi = chain_v[ki][upd_posi];
	    }

	    HMG[numE+1] = HMG[numE];

	    IDH->setP(P);
	    IDH->setHMG(HMG);
	    edgeT->calHMG();
	    P.resize(0);
	    HMG.resize(0);

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;


	  if(changePosi)  // Need to change position using likelihood
	    upd_posi = rand.rwunif(lik_wei_n); // Select new position based on posterior prob
	  else             // Don't change position
	    upd_posi = IndexInHotSpotRegion;  


	  ps_n = lik_wei_n[upd_posi]*numPosi;

	  // Move to selected position or the original
	  P.resize(0);
	  HMG.resize(0);
	  P.resize(numE+2);
	  P[0] = 0;
	  P[numE+1] = 0;
	  HMG.resize(numE+2);
	  HMG[0] = IDH->getHMG(0);
	  
	  for(ki = numE; ki > 0; ki--){
	    P[ki] =  posi_v[ki][upd_posi];
	    HMG[ki] = hmg_v[ki][upd_posi];
	    upd_posi = chain_v[ki][upd_posi];
	  }
	  
	  HMG[numE+1] = HMG[numE];
	  
	  IDH->setP(P);
	  IDH->setHMG(HMG);
	  edgeT->calHMG();
	  P.resize(0);
	  HMG.resize(0);
	  
	  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	  // 1
	  nodeC->findRootSites();
	  
	  // 1'
	  if(nodeP->getRoot())
	    nodeP->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3 4 5
	  if(nodeP->getRoot()){
	    nodeP->CalloglikeliofLinkedSites(params);
	  }else{
	    nodeP->CalSubTreeProb(params);
	    nodeP->CalloglikeliofRootSites(params);
	    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	    
	    // 4 5
	    UpdateAllinfoToRoot(params, nodeP->getParent());
	  }
	  
	  logLikeliData[current] = likeliData(); 
	  N_datalike = getLogLikeliData();
	  
	}else{  // Else of "if((changePosi) | (IndexInHotSpotRegion >= 0))"
          // C
	  ps_n = 0;  // Don't change position and the current is not in hot spot region
	  
	}       // End of "else of if((changePosi) | (IndexInHotSpotRegion >= 0))"

      }   // End of "else of if(canN==0)"

    }else{  // End of "if((0 < IDH->getNumE()) && (IDH->getNumE() <= MaxE) && (oIDH->getNumE()>0))"
      // A 
      ps_n = 1;
    }


    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);





    //-------------------------------------//
    // 
    // Reverse part
    //
    //--------------------------------------//
    
    if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0)){
    // Consider changing positions based on likelihood

      (*tmpIDH) = (*IDH);

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
      

      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      numE = IDH->getNumE();
      
      for( k = 1; k <= numE; k++){
	tmpInt = IDH->getHMG(k-1, IDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, IDH->getHMG(k-1), IDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      }  // End of "for( k = 1; k <= numE; k++)"


      sort(INDEp.begin(),INDEp.end());

 
      // Construct hotspots from INDEp
      // INDEp includes repeated positions.
      int stspot, enspot;
      
      tmpInt2 = IDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);




      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      numE = oIDH->getNumE();  

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(oIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;

      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(oIDH->getID(k) == 1) // if insertion
	  numPosi *= (oIDH->getN(k-1) + 1);
	else
	  numPosi *= (oIDH->getN(k-1) - oIDH->getL(k) + 1);
      }


      if(oIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km< oIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(oIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-oIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < oIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-oIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(oIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(oIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < oIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - oIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < oIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - oIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(oIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"

      canN = chain_v[numE].size();



      if(canN == 0){   // If there's no possible positions within hotspot region
	// B
	ps_c = 1;
	
      }else{           // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, oIDH->getP(), numE);

	if(IndexInHotSpotRegion >= 0){ // P from old IDH is in a hot spot region 

	  (*IDH) = (*oIDH);
	  edgeT->calHMG();
	  
	  numE = IDH->getNumE();
	  
	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);
	  
	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){
	    
	    P.resize(0);
	    HMG.resize(0);
	    P.resize(numE+2);
	    P[0] = 0;
	    P[numE+1] = 0;
	    HMG.resize(numE+2);
	    HMG[0] = IDH->getHMG(0);

	    upd_posi = k;
	    for(ki = numE; ki > 0; ki--){
	      P[ki] =  posi_v[ki][upd_posi];
	      HMG[ki] = hmg_v[ki][upd_posi];
	      upd_posi = chain_v[ki][upd_posi];
	    }

	    HMG[numE+1] = HMG[numE];

	    IDH->setP(P);
	    IDH->setHMG(HMG);
	    edgeT->calHMG();
	    P.resize(0);
	    HMG.resize(0);

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;

	  upd_posi = IndexInHotSpotRegion;  
	  // D
	  ps_c = lik_wei_n[upd_posi]*numPosi;


	}else{  // Else of "if(IndexInHotSpotRegion >= 0)"
          // C
	  ps_c = 0;  // P from oIDH is not in a hot spot region

	}       // End of "Else of if(IndexInHotSpotRegion >= 0)"

      }   // End of "else of if(canN==0)"

      (*IDH) = (*tmpIDH);

    }else{  // End of "if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0))"
      // A
      ps_c = 1;
    }


    // move to the IDH (not oIDH)
    edgeT->calHMG();
    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    // Date likelihood
    logLikeliData[current] = likeliData(); 
    N_datalike = getLogLikeliData();

    // IDH likelihood
    //Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike; 

    //cout << "UpIDHonEdgeLike " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    if(start)
      AP = exp( N_datalike + N_IDHlike + O_psl + log(delta + ((1-delta)*ps_c)) - O_datalike - O_IDHlike - N_psl - log(delta + ((1-delta)*ps_n)));
    else
      AP = exp( N_datalike + N_IDHlike - O_datalike - O_IDHlike);


    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp( O_psl + log(delta + ((1-delta)*ps_c)) - N_psl - log(delta + ((1-delta)*ps_n))) << endl;  




    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);


  }else{   // Else of "if(Time <= w)"
           

    //---------------------------------------
    //
    // Propose new history in a window
    //
    //---------------------------------------

    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();


    getNa = 0;
    getNb = 0;
   
    midTime = (rand.runif() * Time);
    aTime = MAX((double)0,(midTime - (w/2)));
    bTime = MIN( Time, (midTime+ (w/2))) ;
    kTime = bTime - aTime;

    numE = IDH->getNumE();

    if(aTime == 0){
      q = 0;
      st = q + 1;
      kN0 = IDH->getN(q);
      getNa = 1;
    }else{
      for(q = 0; q <= numE; q++){
	if((IDH->getV(q) < aTime) && (aTime <= IDH->getV(q+1))){
	  st = q + 1;
	  kN0 = IDH->getN(q);
	  getNa = 1;
	  break;
	}
      }
    }
    
    if(bTime == Time){
      p = numE;
      en = p;
      kNend = IDH->getN(p);
      getNb = 1;
    }else{
      for(p = q; p <= numE ; p++){
	if((IDH->getV(p) <= bTime) && (bTime < IDH->getV(p+1))){
	  en = p; 
	  kNend = IDH->getN(p);
	  getNb = 1;
	  break;
	}
      }
    }

    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    knumE = en - st + 1;

   
    if(knumE>0){

      for( q = st; q <= en; q++){
	V.push_back((IDH->getV(q)-aTime));
	ID.push_back(IDH->getID(q));
	P.push_back(IDH->getP(q));
	L.push_back(IDH->getL(q));
	N.push_back(IDH->getN(q));
	i = (ID.size()-1);
	HMGin.resize(0);
	if(ID[i]==1){
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k < L[i]; k++)
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
        }else{
	  HMGin = HMG[i-1];
	  for( k = 0; k < L[i]; k++)
	    HMGin.erase(HMGin.begin()+ P[i]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	  
	}
      }
    } // End of "if(knumE>0)"

    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);


    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = subIDH->getN(0);
      subIDH->ReverseIDH();
      O_psl = ProposHistory(params, subIDH);
      subIDH->ReverseIDH();
    }else{
      O_psl= ProposHistory(params, subIDH);
    }




    // History Update in a subsequence given Time
    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
 

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;
      
      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime-kTime < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	
	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	  ID.push_back(1);
	  N.push_back(N[i-1]+L[i]);	
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}   // end of if(runif(0,1)-prob1<0)
	i++;
	
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<kNend){
	  ID.push_back(1);
	  L.push_back(kNend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>kNend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-kNend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));  
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	    
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
    
    knumE = i;
    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);
    
    tmpIDH->setHistory(knumE, V, ID, P, L, N, HMG);
    N_psl = ProposHistory(params, tmpIDH);


    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = tmpIDH->getN(0);
      tmpIDH->ReverseIDH();
    }


    // put new sub IDH 

    numE = IDH->getNumE();

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
    
    if(st > 1){
      for( i = 1; i < st; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }
    
    if(knumE >= 1){
      for( i = 1; i <= knumE ; i++){
	V.push_back((tmpIDH->getV(i)+aTime));
	ID.push_back(tmpIDH->getID(i));
	P.push_back(tmpIDH->getP(i));
	L.push_back(tmpIDH->getL(i));
	N.push_back(tmpIDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
    
    if(en < numE){
      for( i = (en+1); i <= numE; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	int newposi = HMG.size();
	HMGin = HMG[newposi-1]; 
	if(ID[newposi] == 1){
	  for( km = 0; km < L[newposi]; km++)
	    HMGin.insert(HMGin.begin() + P[newposi] ,tmphmg);
        }else{
	  for( km = 0; km < L[newposi]; km++)
	    HMGin.erase(HMGin.begin()+ P[newposi]);
	}
	HMG.push_back(HMGin);  
	HMGin.resize(0);
      }
    }

    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    numE = st - 1 + knumE + numE - en;
    HMG.push_back(HMG[numE]);

    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();

    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();




    
    if((0 < tmpIDH->getNumE()) && (tmpIDH->getNumE() <= MaxE) && (subIDH->getNumE()>0)){
      // Consider changing positions based on likelihood


      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
    

      //---------------------------------------------------------//
      //
      //     Construct insertion hotspot and deletion hotspot 
      //
      //----------------------------------------------------------//
      
      OnumE = subIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = subIDH->getHMG(k-1, subIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, subIDH->getHMG(k-1), subIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
	  INDEpTmp.resize(0);
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"
	
      } // End of "for( k = 1; k <= OnumE; k++)"
      
      

      // Sort
      sort(INDEp.begin(),INDEp.end());



      // Construct hotspots from INDEp
      // INDEp includes repeated positions.

      int stspot, enspot;
      
      tmpInt2 = subIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      
      
      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);
      
      


      //----------------------------------------------//
      //
      // Get possible positions in the hotspot region and get homology 
      //
      //-----------------------------------------------//


      numE = tmpIDH->getNumE();
      

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(tmpIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;


      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(tmpIDH->getID(k) == 1) // if insertion
	  numPosi *= (tmpIDH->getN(k-1) + 1);
	else
	  numPosi *= (tmpIDH->getN(k-1) - tmpIDH->getL(k) + 1);
      }



      if(tmpIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	 
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km < tmpIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(tmpIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-tmpIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < tmpIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-tmpIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(tmpIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(tmpIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki] < 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
		    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < tmpIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - tmpIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < tmpIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - tmpIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(tmpIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"


      canN = chain_v[numE].size();


      if(canN==0){ // If there's no possible positions within hotspot region
        // B
	ps_n = 1;

      }else{       // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, tmpIDH->getP(), numE);

	if((rand.runif()- delta) > 0)  // with prob 1 - delta, change positions  	  
	  changePosi = true;
	else                           // don't change position
	  changePosi = false;

	// should change position or current position are in a hot spot region
	if((changePosi) | (IndexInHotSpotRegion >= 0)){   

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  knumE = numE;
	  numE = IDH->getNumE();

	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){

	    upd_posi = k;
	    for(ki = knumE; ki > 0; ki--){
	      IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	      upd_posi = chain_v[ki][upd_posi];
            }

	    for(ki = st; ki <= numE; ki++){
	      HMGin = IDH->getHMG(ki-1); 
	      if(IDH->getID(ki) == 1){
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	      }else{
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	      }
	      IDH->setHMG(HMGin, ki);
	      HMGin.resize(0);
	    }
	   
	    IDH->setHMG(IDH->getHMG(numE), numE+1);
	    edgeT->calHMG();

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;


	  if(changePosi)  // Need to change position using likelihood
	    upd_posi = rand.rwunif(lik_wei_n); // Select new position based on posterior prob
	  else             // Don't change position
	    upd_posi = IndexInHotSpotRegion;  


	  ps_n = lik_wei_n[upd_posi]*numPosi;

	  for(ki = knumE; ki > 0; ki--){
	    IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	    tmpIDH->setP(posi_v[ki][upd_posi], ki);
	    tmpIDH->setHMG(hmg_v[ki][upd_posi], ki);
	    upd_posi = chain_v[ki][upd_posi];
	  }

	  tmpIDH->setHMG(tmpIDH->getHMG(knumE), knumE + 1);
	
	  for(ki = st; ki <= numE; ki++){
	    HMGin = IDH->getHMG(ki-1); 
	    if(IDH->getID(ki) == 1){
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	    }else{
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	    }
	    IDH->setHMG(HMGin, ki);
	    HMGin.resize(0);
	  }
	  
	  IDH->setHMG(IDH->getHMG(numE), numE+1);
	  edgeT->calHMG();

	  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	  // 1
	  nodeC->findRootSites();
	  
	  // 1'
	  if(nodeP->getRoot())
	    nodeP->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3 4 5
	  if(nodeP->getRoot()){
	    nodeP->CalloglikeliofLinkedSites(params);
	  }else{
	    nodeP->CalSubTreeProb(params);
	    nodeP->CalloglikeliofRootSites(params);
	    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	    
	    // 4 5
	    UpdateAllinfoToRoot(params, nodeP->getParent());
	  }
	  
	  logLikeliData[current] = likeliData(); 
	  N_datalike = getLogLikeliData();
	  
	}else{  // Else of "if((changePosi) | (IndexInHotSpotRegion >= 0))"
          // C
	  ps_n = 0;  // Don't change position and the current is not in hot spot region
	  
	}       // End of "else of if((changePosi) | (IndexInHotSpotRegion >= 0))"

      }   // End of "else of if(canN==0)"

    }else{  // End of "if((0 < tmpIDH->getNumE()) && (tmpIDH->getNumE() <= MaxE) && (subIDH->getNumE()>0))"
      // A 
      ps_n = 1;
    }




    //-------------------------------------//
    // 
    // Reverse part
    //
    //--------------------------------------//


    if((0 < subIDH->getNumE()) && (subIDH->getNumE() <= MaxE) && (tmpIDH->getNumE()>0)){

      (*tmp2IDH) = (*IDH);

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
     

      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      numE = tmpIDH->getNumE();
      
      for( k = 1; k <= numE; k++){
	tmpInt = tmpIDH->getHMG(k-1, tmpIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, tmpIDH->getHMG(k-1), tmpIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      }  // End of "for( k = 1; k <= numE; k++)"


      sort(INDEp.begin(),INDEp.end());

 
      // Construct hotspots from INDEp
      // INDEp includes repeated positions.
      int stspot, enspot;
      
      tmpInt2 = tmpIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);




      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      numE = subIDH->getNumE();  

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(subIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;

      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(subIDH->getID(k) == 1) // if insertion
	  numPosi *= (subIDH->getN(k-1) + 1);
	else
	  numPosi *= (subIDH->getN(k-1) - subIDH->getL(k) + 1);
      }


      if(subIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km< subIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(subIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-subIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < subIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-subIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(subIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(subIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < subIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - subIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < subIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - subIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(subIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"

      canN = chain_v[numE].size();




      if(canN == 0){   // If there's no possible positions within hotspot region
	// B
	ps_c = 1;
	
      }else{           // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, subIDH->getP(), numE);

	if(IndexInHotSpotRegion >= 0){ // P from old IDH is in a hot spot region 

	  (*IDH) = (*oIDH);
	  edgeT->calHMG();
	  
	  knumE = numE;
	  numE = IDH->getNumE();
	  
	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);
	  
	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){
	    

	    upd_posi = k;
	    for(ki = knumE; ki > 0; ki--){
	      IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	      upd_posi = chain_v[ki][upd_posi];
            }

	    for(ki = st; ki <= numE; ki++){
	      HMGin = IDH->getHMG(ki-1); 
	      if(IDH->getID(ki) == 1){
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	      }else{
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	      }
	      IDH->setHMG(HMGin, ki);
	      HMGin.resize(0);
	    }
	   
	    IDH->setHMG(IDH->getHMG(numE), numE+1);
	    edgeT->calHMG();

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;


	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;

	  upd_posi = IndexInHotSpotRegion;  
	  // D
	  ps_c = lik_wei_n[upd_posi]*numPosi;


	}else{  // Else of "if(IndexInHotSpotRegion >= 0)"
          // C
	  ps_c = 0;  // P from oIDH is not in a hot spot region

	}       // End of "Else of if(IndexInHotSpotRegion >= 0)"

      }   // End of "else of if(canN==0)"

      (*IDH) = (*tmp2IDH);

    }else{  // End of "if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0))"
      // A
      ps_c = 1;
    }


    
    edgeT->calHMG();
    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    // Date likelihood
    logLikeliData[current] = likeliData(); 
    N_datalike = getLogLikeliData();

    // IDH likelihood
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike; 


    //cout << "UpIDHonEdgeLike " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    if(start)
      AP = exp( N_datalike + N_IDHlike + O_psl + log(delta + ((1-delta)*ps_c)) - O_datalike - O_IDHlike - N_psl - log(delta + ((1-delta)*ps_n)));
    else
      AP = exp( N_datalike + N_IDHlike - O_datalike - O_IDHlike);



    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp( O_psl + log(delta + ((1-delta)*ps_c)) - N_psl - log(delta + ((1-delta)*ps_n))) << endl;  

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);

  }


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  Lwt.resize(0);
  INDEp.resize(0);
  INDEpTmp.resize(0); 
  hotspot.resize(0);
  chain_v.resize(0);
  posi_v.resize(0);
  hmg_v.resize(0);
  lik_n.resize(0);
  lik_wei_n.resize(0);

  
  delete subIDH;
  delete tmpIDH;
  delete tmp2IDH;
  delete oIDH;

  return AP;

}   // End of UpIDHonEdgeLike







double Tree::UpIDHonEdgeLike(Rand &rand, Parameters &params, int MaxE, int hotspotlen, ofstream& c) {

  int tmpInt, tmpInt2, i, j, k, wi, ki, km, N0, Nend, numE, OnumE, tmphmg, lenPosi, upd_posi, sizeM, numPosi;
  double tmpDouble, w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1, delta; 
  double maxL, ps_n, ps_c;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  int getEnd, canN, edgeTnum;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;

  int IndexInHotSpotRegion;
  bool changePosi;


  bool goGetHiddenHMG;

  tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* tmpIDH = new InDelHistory();
  InDelHistory* oIDH = new InDelHistory();
  InDelHistory* subIDH = new InDelHistory();
  InDelHistory* tmp2IDH = new InDelHistory();
  

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  vector<double> Lwt(0);

  vector<int> INDEp; // insertion and deletion positions of current events to get hotspots
  vector<int> INDEpTmp; 
  vector<int> hotspot; // insertion hotspots among 0 through seqlen
  vector<vector<int> > chain_v;
  vector<vector<int> > posi_v;
  vector<vector<vector<int> > > hmg_v;
  vector<double> lik_n;
  vector<double> lik_wei_n;



  Node* nodeC;
  Node* nodeP;
  Node* tempNode;
  Node* baseNode;

  // Get all parameters
  
  w = params.getWindowLen_UpIDHonEdgeLike();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();
  delta = params.getDelta();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];

  // Save the original IDH
  (*oIDH) = (*edgeT->getIDH());

  // Get other information of the selected edge
  nodeC = edgeT->getEnd();
  nodeP = edgeT->getStart();
  IDH =  edgeT->getIDH();
  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();
  if(rand.runif() < 0.5)
    baseNode = nodeC;
  else
    baseNode = nodeP;
  



  // Heejung
  //double tempA, tempB;
  if(Time <= w){ // Propose new history in a whole edge

    // Get all old information
    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();

    if(baseNode != nodeP){
      N0 = Nend;
      Nend = nodeP->getSeqLen();
      IDH->ReverseIDH();
      O_psl = ProposHistory(params, IDH);
    }else{
      O_psl= edgeT->ProposHistory(params);
    }

    // Generate new IDH

    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    while(1){

      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;

      tempTime = tempTime+dt;
	
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }

      if(tempTime-Time < 0){  // Need to generate new indel event

	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;

	if(rand.runif()-prob1 < 0){  // propose an insertion, which can be of any length, at any position

	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    L.push_back(rand.rgeom(ri));
	    ID.push_back(1);
	    N.push_back(N[i-1]+L[i]);
	    HMGin = HMG[i-1];
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG.push_back(HMGin);
	    HMGin.resize(0);
	    
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L  
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);       
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);      
	} 

	i++;

      }else{   // tempTime > Time, propose an event at any left time, at a position, with particular length

	if(N[i-1]<Nend){  // insertion

	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else if(N[i-1]>Nend){  // deletion
	  
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	

	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)

    }// end of while(1).
 
    numE = i;
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    HMG.push_back(HMG[numE]);    


    // Set newly generated IDH 
    IDH->setHistory(numE, V, ID, P, L, N, HMG);
    N_psl = ProposHistory(params, IDH);


    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
    HMGin.resize(0);
   
    if(baseNode != nodeP)
      IDH->ReverseIDH();

    edgeT->calHMG();
    


    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
     nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }

    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();






    if((0 < IDH->getNumE()) && (IDH->getNumE() <= MaxE) && (oIDH->getNumE()>0)){
    // Consider changing positions based on likelihood

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);

      //---------------------------------------------------------//
      //
      //     Construct insertion hotspot and deletion hotspot 
      //
      //----------------------------------------------------------//
     
      OnumE = oIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = oIDH->getHMG(k-1, oIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, oIDH->getHMG(k-1), oIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
	  INDEpTmp.resize(0);
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      } // End of "for( k = 1; k <= OnumE; k++)"



      // Sort
      sort(INDEp.begin(),INDEp.end());



      // Construct hotspots from INDEp
      // INDEp includes repeated positions.

      int stspot, enspot;
      
      tmpInt2 = oIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);

     


      //----------------------------------------------//
      //
      // Get possible positions in the hotspot region and get homology 
      //
      //-----------------------------------------------//


      numE = IDH->getNumE();
      

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(IDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;


      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(IDH->getID(k) == 1) // if insertion
	  numPosi *= (IDH->getN(k-1) + 1);
	else
	  numPosi *= (IDH->getN(k-1) - IDH->getL(k) + 1);
      }



      if(IDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	 
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km < IDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(IDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-IDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < IDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-IDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(IDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(IDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki] < 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
		    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < IDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - IDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < IDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - IDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(IDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"


      canN = chain_v[numE].size();

      if(canN==0){ // If there's no possible positions within hotspot region
        // B
	ps_n = 1;

      }else{       // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, IDH->getP(), numE);

	if((rand.runif()- delta) > 0)  // with prob 1 - delta, change positions  	  
	  changePosi = true;
	else                           // don't change position
	  changePosi = false;

	// should change position or current position are in a hot spot region
	if((changePosi) | (IndexInHotSpotRegion >= 0)){   

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){

	    P.resize(0);
	    HMG.resize(0);
	    P.resize(numE+2);
	    P[0] = 0;
	    P[numE+1] = 0;
	    HMG.resize(numE+2);
	    HMG[0] = IDH->getHMG(0);

	    upd_posi = k;
	    for(ki = numE; ki > 0; ki--){
	      P[ki] =  posi_v[ki][upd_posi];
	      HMG[ki] = hmg_v[ki][upd_posi];
	      upd_posi = chain_v[ki][upd_posi];
	    }

	    HMG[numE+1] = HMG[numE];

	    IDH->setP(P);
	    IDH->setHMG(HMG);
	    edgeT->calHMG();
	    P.resize(0);
	    HMG.resize(0);

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;


	  if(changePosi)  // Need to change position using likelihood
	    upd_posi = rand.rwunif(lik_wei_n); // Select new position based on posterior prob
	  else             // Don't change position
	    upd_posi = IndexInHotSpotRegion;  


	  ps_n = lik_wei_n[upd_posi]*numPosi;

	  // Move to selected position or the original
	  P.resize(0);
	  HMG.resize(0);
	  P.resize(numE+2);
	  P[0] = 0;
	  P[numE+1] = 0;
	  HMG.resize(numE+2);
	  HMG[0] = IDH->getHMG(0);
	  
	  for(ki = numE; ki > 0; ki--){
	    P[ki] =  posi_v[ki][upd_posi];
	    HMG[ki] = hmg_v[ki][upd_posi];
	    upd_posi = chain_v[ki][upd_posi];
	  }
	  
	  HMG[numE+1] = HMG[numE];
	  
	  IDH->setP(P);
	  IDH->setHMG(HMG);
	  edgeT->calHMG();
	  P.resize(0);
	  HMG.resize(0);
	  
	  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	  // 1
	  nodeC->findRootSites();
	  
	  // 1'
	  if(nodeP->getRoot())
	    nodeP->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3 4 5
	  if(nodeP->getRoot()){
	    nodeP->CalloglikeliofLinkedSites(params);
	  }else{
	    nodeP->CalSubTreeProb(params);
	    nodeP->CalloglikeliofRootSites(params);
	    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	    
	    // 4 5
	    UpdateAllinfoToRoot(params, nodeP->getParent());
	  }
	  
	  logLikeliData[current] = likeliData(); 
	  N_datalike = getLogLikeliData();
	  
	}else{  // Else of "if((changePosi) | (IndexInHotSpotRegion >= 0))"
          // C
	  ps_n = 0;  // Don't change position and the current is not in hot spot region
	  
	}       // End of "else of if((changePosi) | (IndexInHotSpotRegion >= 0))"

      }   // End of "else of if(canN==0)"

    }else{  // End of "if((0 < IDH->getNumE()) && (IDH->getNumE() <= MaxE) && (oIDH->getNumE()>0))"
      // A 
      ps_n = 1;
    }


    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);





    //-------------------------------------//
    // 
    // Reverse part
    //
    //--------------------------------------//
    
    if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0)){
    // Consider changing positions based on likelihood

      (*tmpIDH) = (*IDH);

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
      

      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      numE = IDH->getNumE();
      
      for( k = 1; k <= numE; k++){
	tmpInt = IDH->getHMG(k-1, IDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, IDH->getHMG(k-1), IDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      }  // End of "for( k = 1; k <= numE; k++)"


      sort(INDEp.begin(),INDEp.end());

 
      // Construct hotspots from INDEp
      // INDEp includes repeated positions.
      int stspot, enspot;
      
      tmpInt2 = IDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);




      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      numE = oIDH->getNumE();  

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(oIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;

      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(oIDH->getID(k) == 1) // if insertion
	  numPosi *= (oIDH->getN(k-1) + 1);
	else
	  numPosi *= (oIDH->getN(k-1) - oIDH->getL(k) + 1);
      }


      if(oIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km< oIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(oIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-oIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < oIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-oIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(oIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(oIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < oIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - oIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < oIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - oIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(oIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"

      canN = chain_v[numE].size();



      if(canN == 0){   // If there's no possible positions within hotspot region
	// B
	ps_c = 1;
	
      }else{           // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, oIDH->getP(), numE);

	if(IndexInHotSpotRegion >= 0){ // P from old IDH is in a hot spot region 

	  (*IDH) = (*oIDH);
	  edgeT->calHMG();
	  
	  numE = IDH->getNumE();
	  
	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);
	  
	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){
	    
	    P.resize(0);
	    HMG.resize(0);
	    P.resize(numE+2);
	    P[0] = 0;
	    P[numE+1] = 0;
	    HMG.resize(numE+2);
	    HMG[0] = IDH->getHMG(0);

	    upd_posi = k;
	    for(ki = numE; ki > 0; ki--){
	      P[ki] =  posi_v[ki][upd_posi];
	      HMG[ki] = hmg_v[ki][upd_posi];
	      upd_posi = chain_v[ki][upd_posi];
	    }

	    HMG[numE+1] = HMG[numE];

	    IDH->setP(P);
	    IDH->setHMG(HMG);
	    edgeT->calHMG();
	    P.resize(0);
	    HMG.resize(0);

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;

	  upd_posi = IndexInHotSpotRegion;  
	  // D
	  ps_c = lik_wei_n[upd_posi]*numPosi;


	}else{  // Else of "if(IndexInHotSpotRegion >= 0)"
          // C
	  ps_c = 0;  // P from oIDH is not in a hot spot region

	}       // End of "Else of if(IndexInHotSpotRegion >= 0)"

      }   // End of "else of if(canN==0)"

      (*IDH) = (*tmpIDH);

    }else{  // End of "if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0))"
      // A
      ps_c = 1;
    }


    // move to the IDH (not oIDH)
    edgeT->calHMG();
    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    // Date likelihood
    logLikeliData[current] = likeliData(); 
    N_datalike = getLogLikeliData();

    // IDH likelihood
    //Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike; 

    //cout << "UpIDHonEdgeLike " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;


    AP = exp( N_datalike + N_IDHlike + O_psl + log(delta + ((1-delta)*ps_c)) - O_datalike - O_IDHlike - N_psl - log(delta + ((1-delta)*ps_n)));

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp( O_psl + log(delta + ((1-delta)*ps_c)) - N_psl - log(delta + ((1-delta)*ps_n))) << endl;  




    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);


  }else{   // Else of "if(Time <= w)"
           

    //---------------------------------------
    //
    // Propose new history in a window
    //
    //---------------------------------------

    O_datalike = getLogLikeliData();
    // Heejung
    //tempA = logLikeliIDH[current];
    //O_IDHlike = logLikeliIDH[current];
    O_IDHlike = edgeT->getlogLikeliIDH();


    getNa = 0;
    getNb = 0;
   
    midTime = (rand.runif() * Time);
    aTime = MAX((double)0,(midTime - (w/2)));
    bTime = MIN( Time, (midTime+ (w/2))) ;
    kTime = bTime - aTime;

    numE = IDH->getNumE();

    if(aTime == 0){
      q = 0;
      st = q + 1;
      kN0 = IDH->getN(q);
      getNa = 1;
    }else{
      for(q = 0; q <= numE; q++){
	if((IDH->getV(q) < aTime) && (aTime <= IDH->getV(q+1))){
	  st = q + 1;
	  kN0 = IDH->getN(q);
	  getNa = 1;
	  break;
	}
      }
    }
    
    if(bTime == Time){
      p = numE;
      en = p;
      kNend = IDH->getN(p);
      getNb = 1;
    }else{
      for(p = q; p <= numE ; p++){
	if((IDH->getV(p) <= bTime) && (bTime < IDH->getV(p+1))){
	  en = p; 
	  kNend = IDH->getN(p);
	  getNb = 1;
	  break;
	}
      }
    }

    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    knumE = en - st + 1;

   
    if(knumE>0){

      for( q = st; q <= en; q++){
	V.push_back((IDH->getV(q)-aTime));
	ID.push_back(IDH->getID(q));
	P.push_back(IDH->getP(q));
	L.push_back(IDH->getL(q));
	N.push_back(IDH->getN(q));
	i = (ID.size()-1);
	HMGin.resize(0);
	if(ID[i]==1){
	  HMGin = HMG[i-1];
	  tmphmg = -1;
	  for( k = 0; k < L[i]; k++)
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
        }else{
	  HMGin = HMG[i-1];
	  for( k = 0; k < L[i]; k++)
	    HMGin.erase(HMGin.begin()+ P[i]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	  
	}
      }
    } // End of "if(knumE>0)"

    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);


    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);

    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = subIDH->getN(0);
      subIDH->ReverseIDH();
      O_psl = ProposHistory(params, subIDH);
      subIDH->ReverseIDH();
    }else{
      O_psl= ProposHistory(params, subIDH);
    }




    // History Update in a subsequence given Time
    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMGin.resize(0);
    for( k = 0; k <= kN0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
 

    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;
      
      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime-kTime < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	
	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	  ID.push_back(1);
	  N.push_back(N[i-1]+L[i]);	
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}   // end of if(runif(0,1)-prob1<0)
	i++;
	
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<kNend){
	  ID.push_back(1);
	  L.push_back(kNend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>kNend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-kNend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));  
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	    
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
    
    knumE = i;
    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);
    
    tmpIDH->setHistory(knumE, V, ID, P, L, N, HMG);
    N_psl = ProposHistory(params, tmpIDH);


    if(baseNode != nodeP){
      kN0 = kNend;
      kNend = tmpIDH->getN(0);
      tmpIDH->ReverseIDH();
    }


    // put new sub IDH 

    numE = IDH->getNumE();

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
    
    if(st > 1){
      for( i = 1; i < st; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }
    
    if(knumE >= 1){
      for( i = 1; i <= knumE ; i++){
	V.push_back((tmpIDH->getV(i)+aTime));
	ID.push_back(tmpIDH->getID(i));
	P.push_back(tmpIDH->getP(i));
	L.push_back(tmpIDH->getL(i));
	N.push_back(tmpIDH->getN(i));
	j = (ID.size()-1);
	HMGin.resize(0);
	if(ID[j]==1){
	  HMGin = HMG[j-1];
	  tmphmg = -1;
	  for( k = 0; k < L[j]; k++)
	    HMGin.insert(HMGin.begin()+ P[j],tmphmg);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	 
        }else{
 	  HMGin = HMG[j-1];
	  for( k = 0; k < L[j]; k++)
	    HMGin.erase(HMGin.begin()+ P[j]);
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}
      }
    }
    
    if(en < numE){
      for( i = (en+1); i <= numE; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	int newposi = HMG.size();
	HMGin = HMG[newposi-1]; 
	if(ID[newposi] == 1){
	  for( km = 0; km < L[newposi]; km++)
	    HMGin.insert(HMGin.begin() + P[newposi] ,tmphmg);
        }else{
	  for( km = 0; km < L[newposi]; km++)
	    HMGin.erase(HMGin.begin()+ P[newposi]);
	}
	HMG.push_back(HMGin);  
	HMGin.resize(0);
      }
    }

    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    numE = st - 1 + knumE + numE - en;
    HMG.push_back(HMG[numE]);

    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();

    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    edgeTnum = nodeP->getEdgeNum(edgeT);
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();




    
    if((0 < tmpIDH->getNumE()) && (tmpIDH->getNumE() <= MaxE) && (subIDH->getNumE()>0)){
      // Consider changing positions based on likelihood


      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
    

      //---------------------------------------------------------//
      //
      //     Construct insertion hotspot and deletion hotspot 
      //
      //----------------------------------------------------------//
      
      OnumE = subIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = subIDH->getHMG(k-1, subIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, subIDH->getHMG(k-1), subIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
	  INDEpTmp.resize(0);
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"
	
      } // End of "for( k = 1; k <= OnumE; k++)"
      
      

      // Sort
      sort(INDEp.begin(),INDEp.end());



      // Construct hotspots from INDEp
      // INDEp includes repeated positions.

      int stspot, enspot;
      
      tmpInt2 = subIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      
      
      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);
      
      


      //----------------------------------------------//
      //
      // Get possible positions in the hotspot region and get homology 
      //
      //-----------------------------------------------//


      numE = tmpIDH->getNumE();
      

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(tmpIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;


      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(tmpIDH->getID(k) == 1) // if insertion
	  numPosi *= (tmpIDH->getN(k-1) + 1);
	else
	  numPosi *= (tmpIDH->getN(k-1) - tmpIDH->getL(k) + 1);
      }



      if(tmpIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){ // Go over all possible positions
	 
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km < tmpIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(tmpIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-tmpIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < tmpIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-tmpIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(tmpIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(tmpIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki] < 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
		    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < tmpIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - tmpIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < tmpIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - tmpIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(tmpIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"


      canN = chain_v[numE].size();


      if(canN==0){ // If there's no possible positions within hotspot region
        // B
	ps_n = 1;

      }else{       // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, tmpIDH->getP(), numE);

	if((rand.runif()- delta) > 0)  // with prob 1 - delta, change positions  	  
	  changePosi = true;
	else                           // don't change position
	  changePosi = false;

	// should change position or current position are in a hot spot region
	if((changePosi) | (IndexInHotSpotRegion >= 0)){   

	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);

	  knumE = numE;
	  numE = IDH->getNumE();

	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){

	    upd_posi = k;
	    for(ki = knumE; ki > 0; ki--){
	      IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	      upd_posi = chain_v[ki][upd_posi];
            }

	    for(ki = st; ki <= numE; ki++){
	      HMGin = IDH->getHMG(ki-1); 
	      if(IDH->getID(ki) == 1){
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	      }else{
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	      }
	      IDH->setHMG(HMGin, ki);
	      HMGin.resize(0);
	    }
	   
	    IDH->setHMG(IDH->getHMG(numE), numE+1);
	    edgeT->calHMG();

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;

	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;


	  if(changePosi)  // Need to change position using likelihood
	    upd_posi = rand.rwunif(lik_wei_n); // Select new position based on posterior prob
	  else             // Don't change position
	    upd_posi = IndexInHotSpotRegion;  


	  ps_n = lik_wei_n[upd_posi]*numPosi;

	  for(ki = knumE; ki > 0; ki--){
	    IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	    tmpIDH->setP(posi_v[ki][upd_posi], ki);
	    tmpIDH->setHMG(hmg_v[ki][upd_posi], ki);
	    upd_posi = chain_v[ki][upd_posi];
	  }

	  tmpIDH->setHMG(tmpIDH->getHMG(knumE), knumE + 1);
	
	  for(ki = st; ki <= numE; ki++){
	    HMGin = IDH->getHMG(ki-1); 
	    if(IDH->getID(ki) == 1){
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	    }else{
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	    }
	    IDH->setHMG(HMGin, ki);
	    HMGin.resize(0);
	  }
	  
	  IDH->setHMG(IDH->getHMG(numE), numE+1);
	  edgeT->calHMG();

	  //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	  // 1
	  nodeC->findRootSites();
	  
	  // 1'
	  if(nodeP->getRoot())
	    nodeP->findLinkedSites();
	  
	  // 2
	  nodeC->CalloglikeliofRootSitesOrReuse(params);
	  UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	  
	  // 3 4 5
	  if(nodeP->getRoot()){
	    nodeP->CalloglikeliofLinkedSites(params);
	  }else{
	    nodeP->CalSubTreeProb(params);
	    nodeP->CalloglikeliofRootSites(params);
	    UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	    
	    // 4 5
	    UpdateAllinfoToRoot(params, nodeP->getParent());
	  }
	  
	  logLikeliData[current] = likeliData(); 
	  N_datalike = getLogLikeliData();
	  
	}else{  // Else of "if((changePosi) | (IndexInHotSpotRegion >= 0))"
          // C
	  ps_n = 0;  // Don't change position and the current is not in hot spot region
	  
	}       // End of "else of if((changePosi) | (IndexInHotSpotRegion >= 0))"

      }   // End of "else of if(canN==0)"

    }else{  // End of "if((0 < tmpIDH->getNumE()) && (tmpIDH->getNumE() <= MaxE) && (subIDH->getNumE()>0))"
      // A 
      ps_n = 1;
    }




    //-------------------------------------//
    // 
    // Reverse part
    //
    //--------------------------------------//


    if((0 < subIDH->getNumE()) && (subIDH->getNumE() <= MaxE) && (tmpIDH->getNumE()>0)){

      (*tmp2IDH) = (*IDH);

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
     

      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      numE = tmpIDH->getNumE();
      
      for( k = 1; k <= numE; k++){
	tmpInt = tmpIDH->getHMG(k-1, tmpIDH->getP(k));
	if(tmpInt < 0){
	  INDEpTmp.resize(0);
	  getHiddenHMG(INDEpTmp, tmpIDH->getHMG(k-1), tmpIDH->getP(k));
	  sizeM = INDEpTmp.size();
	  if(sizeM <= 0){
	    cout << "ERROR in UpIDHonEdgeLike! sizeM should be positive! " << endl;
	  }else{
	    for(wi = 0; wi < sizeM ; wi++)
	      INDEp.push_back(INDEpTmp[wi]);
	  }
        }else{   // else of "if(tmpInt < 0)"
	  INDEp.push_back(tmpInt);
	}        // end of else "if(tmpInt < 0)"

      }  // End of "for( k = 1; k <= numE; k++)"


      sort(INDEp.begin(),INDEp.end());

 
      // Construct hotspots from INDEp
      // INDEp includes repeated positions.
      int stspot, enspot;
      
      tmpInt2 = tmpIDH->getHMG(0).size();
      hotspot.resize(0);
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
      tmpInt = INDEp.size();

     
      // The first case
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      enspot = MIN((tmpInt2-1),(INDEp[0] + hotspotlen));      
      for( ki = stspot; ki <= enspot ; ki++){
	hotspot[ki] = 1;
      }      

      // The rest cases
      for(k = 1; k < tmpInt ; k++){
	if(INDEp[k-1] < INDEp[k]){ // To do for unique HMGs
	  stspot = MAX(0,(INDEp[k] - hotspotlen));
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));      
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }  	  
        }
      }
      INDEp.resize(0);




      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      numE = subIDH->getNumE();  

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position
      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(subIDH->getHMG(0));

      int realposi, k2;
      bool inHotSpot = false;
      goGetHiddenHMG = false;

      // Get number of all possible positions
      numPosi = 1;
      for(k = 1; k <= numE; k++){
	if(subIDH->getID(k) == 1) // if insertion
	  numPosi *= (subIDH->getN(k-1) + 1);
	else
	  numPosi *= (subIDH->getN(k-1) - subIDH->getL(k) + 1);
      }


      if(subIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"


	  if(inHotSpot){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km< subIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }
	
	}  // The End of "for( ki = 0; ki < hmg_v[0][0].size(); ki++)"
	
      }else{ // if deletion or Else of "if(subIDH->getID(1) == 1)"

	for( ki = 0; ki < (hmg_v[0][0].size()-subIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    if( ki > 0 ){	      
	      if(hmg_v[0][0][ki - 1] < 0)
		goGetHiddenHMG = false;
	      else
		goGetHiddenHMG = true; 
            }else{
	      goGetHiddenHMG = true;
	    }

	    if(goGetHiddenHMG){
	      INDEpTmp.resize(0);
	      getHiddenHMG(INDEpTmp, hmg_v[0][0], ki);
	      sizeM = INDEpTmp.size();
	      for(wi = 0; wi < sizeM; wi++){
		realposi = INDEpTmp[wi];
		if(hotspot[realposi] == 1){
		  inHotSpot = true;
		  break;
		}else{
		  inHotSpot = false;
                }
              }
	      INDEpTmp.resize(0);
	    }  // The end of "if(goGetHiddenHMG)"

	  }else{  // else of "if(hmg_v[0][0][ki] < 0)"
 	    realposi = hmg_v[0][0][ki];
	    if(hotspot[realposi] == 1)
	      inHotSpot = true;
	    else
	      inHotSpot = false;
	  }       // The end of "else of if(hmg_v[0][0][ki] < 0)"

	  if(inHotSpot){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km < subIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    hmg_v[1].push_back(HMGin);
	    HMGin.resize(0);
	  }

	} // The End of "for( ki = 0; ki < (hmg_v[0][0].size()-subIDH->getL(1)); ki++)"
	
      }   // The End of "Else of "if(subIDH->getID(1) == 1)"



      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(subIDH->getID(k) == 1){  // if insertion
	    
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		if(inHotSpot){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  for( km = 0; km < subIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      } // The End of "for( ki = 0; ki < hmg_v[k-1][i].size(); ki++)"
	    } // The End of "for(i = 0; i < chain_v[k-1].size(); i++)"
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - subIDH->getL(k)); ki++){
		
		if(hmg_v[k-1][i][ki]< 0){ 

		  if( ki > 0 ){	      
		    if(hmg_v[k-1][i][ki - 1] < 0)
		      goGetHiddenHMG = false;
		    else
		      goGetHiddenHMG = true; 
		  }else{
		    goGetHiddenHMG = true;
		  }

		  if(goGetHiddenHMG){
		    INDEpTmp.resize(0);
		    getHiddenHMG(INDEpTmp, hmg_v[k-1][i], ki);
		    sizeM = INDEpTmp.size();
		    for(wi = 0; wi < sizeM; wi++){
		      realposi = INDEpTmp[wi];
		      if(hotspot[realposi] == 1){
			inHotSpot = true;
			break;
		      }else{
			inHotSpot = false;
		      }
		    }
                    INDEpTmp.resize(0);
		  }  // The end of "if(goGetHiddenHMG)"

		}else{  // else of "if(hmg_v[k-1][i][ki] < 0)"
		  realposi = hmg_v[k-1][i][ki];
		  if(hotspot[realposi] == 1)
		    inHotSpot = true;
		  else
		    inHotSpot = false;
		}       // The end of "else of if(hmg_v[k-1][i][ki] < 0)"

		  
		if(inHotSpot){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < subIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}

	      }  // The End of for( ki = 0; ki < (hmg_v[k-1][i].size() - subIDH->getL(k)); ki++)
	    }  // The End of for(i = 0; i < chain_v[k-1].size(); i++)

	  }  // The End of "Else of if(subIDH->getID(k) == 1)"

	}  // The End of for( k = 2; k <= numE; k++)

      }  // The End of "if(numE >= 2)"

      canN = chain_v[numE].size();




      if(canN == 0){   // If there's no possible positions within hotspot region
	// B
	ps_c = 1;
	
      }else{           // Else of if(canN==0)

	IndexInHotSpotRegion = inHotSpotRegion(chain_v, posi_v, subIDH->getP(), numE);

	if(IndexInHotSpotRegion >= 0){ // P from old IDH is in a hot spot region 

	  (*IDH) = (*oIDH);
	  edgeT->calHMG();
	  
	  knumE = numE;
	  numE = IDH->getNumE();
	  
	  lik_n.resize(canN);
	  lik_wei_n.resize(canN);
	  
	  // Get all posterior prob
	  for(k = 0; k < canN ; k++){
	    

	    upd_posi = k;
	    for(ki = knumE; ki > 0; ki--){
	      IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	      upd_posi = chain_v[ki][upd_posi];
            }

	    for(ki = st; ki <= numE; ki++){
	      HMGin = IDH->getHMG(ki-1); 
	      if(IDH->getID(ki) == 1){
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	      }else{
		for( km = 0; km < IDH->getL(ki); km++)
		  HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	      }
	      IDH->setHMG(HMGin, ki);
	      HMGin.resize(0);
	    }
	   
	    IDH->setHMG(IDH->getHMG(numE), numE+1);
	    edgeT->calHMG();

	    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	    // 1
	    nodeC->findRootSites();
	    
	    // 1'
	    if(nodeP->getRoot())
	      nodeP->findLinkedSites();
	    
	    // 2
	    nodeC->CalloglikeliofRootSitesOrReuse(params);
	    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	    
	    // 3 4 5
	    if(nodeP->getRoot()){
	      nodeP->CalloglikeliofLinkedSites(params);
	    }else{
	      nodeP->CalSubTreeProb(params);
	      nodeP->CalloglikeliofRootSites(params);
	      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	      
	      // 4 5
	      UpdateAllinfoToRoot(params, nodeP->getParent());
	    }

	    logLikeliData[current] = likeliData();   
	    N_datalike = getLogLikeliData();
	    N_IDHlike = edgeT->likeliHistory(params);


	    lik_n[k] = N_datalike + N_IDHlike;


	  } // The End of "for(k = 0; k < canN ; k++)"


	  maxL = max_vec(lik_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = exp((lik_n[k] - maxL));

	  maxL = sum_vec(lik_wei_n);
	  for( k = 0; k < canN; k++)
	    lik_wei_n[k] = lik_wei_n[k]/maxL;

	  upd_posi = IndexInHotSpotRegion;  
	  // D
	  ps_c = lik_wei_n[upd_posi]*numPosi;


	}else{  // Else of "if(IndexInHotSpotRegion >= 0)"
          // C
	  ps_c = 0;  // P from oIDH is not in a hot spot region

	}       // End of "Else of if(IndexInHotSpotRegion >= 0)"

      }   // End of "else of if(canN==0)"

      (*IDH) = (*tmp2IDH);

    }else{  // End of "if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0))"
      // A
      ps_c = 1;
    }


    
    edgeT->calHMG();
    
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSites(params);
    }else{
      nodeP->CalSubTreeProb(params);
      nodeP->CalloglikeliofRootSites(params);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRoot(params, nodeP->getParent());
    }
    
    // Date likelihood
    logLikeliData[current] = likeliData(); 
    N_datalike = getLogLikeliData();

    // IDH likelihood
    // Heejung
    //logLikeliIDH[current] = likeliHistory(params);
    //tempB = logLikeliIDH[current];
    //N_IDHlike = logLikeliIDH[current];
    N_IDHlike = edgeT->likeliHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike; 


    //cout << "UpIDHonEdgeLike " << tempB - tempA << " " << N_IDHlike - O_IDHlike << endl;

    AP = exp( N_datalike + N_IDHlike + O_psl + log(delta + ((1-delta)*ps_c)) - O_datalike - O_IDHlike - N_psl - log(delta + ((1-delta)*ps_n)));

    c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp( O_psl + log(delta + ((1-delta)*ps_c)) - N_psl - log(delta + ((1-delta)*ps_n))) << endl;  

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    INDEp.resize(0);
    INDEpTmp.resize(0); 
    hotspot.resize(0);
    chain_v.resize(0);
    posi_v.resize(0);
    hmg_v.resize(0);
    lik_n.resize(0);
    lik_wei_n.resize(0);

  }


  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  Lwt.resize(0);
  INDEp.resize(0);
  INDEpTmp.resize(0); 
  hotspot.resize(0);
  chain_v.resize(0);
  posi_v.resize(0);
  hmg_v.resize(0);
  lik_n.resize(0);
  lik_wei_n.resize(0);

  
  delete subIDH;
  delete tmpIDH;
  delete tmp2IDH;
  delete oIDH;

  return AP;

}   // End of UpIDHonEdgeLike





double Tree::UpIDHonEdgeLike_v0(Rand &rand, Parameters &params, int MaxE, int hotspotlen) {

  //cout << "In UpIDHonEdgeLike " << endl;
  //checkTree();

  int tmpInt, tmpInt2, i, k, ki, km, N0, Nend, numE, OnumE, tmphmg, lenPosi, upd_posi;
  double tmpDouble, w, lambda, mu, rd, ri, Time, tempTime, eta, dt, prob1, delta; 
  double maxL, ps_n, ps_c;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  int getEnd, canN, edgeTnum;

  int getNa, getNb, q, p, st, en, kN0, kNend, knumE;
  double midTime, aTime, bTime, kTime;

  tmphmg = -1;

  InDelHistory* IDH;
  InDelHistory* tmpIDH = new InDelHistory();
  InDelHistory* oIDH = new InDelHistory();
  InDelHistory* subIDH = new InDelHistory();
  InDelHistory* tmp2IDH = new InDelHistory();
  

  vector<double> V(0);
  vector<int> ID(0);
  vector<int> P(0);
  vector<int> L(0);
  vector<int> N(0);
  vector<vector<int> > HMG;
  vector<int> HMGin(0);
  vector<double> Lwt(0);

  vector<int> INDEp; // insertion and deletion positions of current events to get hotspots
  vector<int> hotspot; // insertion hotspots among 0 through seqlen
  vector<vector<int> > chain_v;
  vector<vector<int> > posi_v;
  vector<vector<vector<int> > > hmg_v;
  vector<double> lik_n;
  vector<double> lik_wei_n;
  //vector<vector<int> > hmg_res;



  Node* nodeC;
  Node* nodeP;
  Node* tempNode;

  
  w = params.getWindowLen();
  lambda = params.getLambda();
  mu = params.getMu();
  ri = params.getRi();
  rd = params.getRd();
  delta = params.getDelta();

  // Select an edge T at random.
  Edge* edgeT  = edges[(int)(rand.runif() * numEdges)];
  //cout << "edgeT->getnumber() " << edgeT->getnumber() << endl;
  //cout << "edgeT !!! " << endl;
  //edgeT->printEdge();

  nodeC = edgeT->getEnd();
  //cout << "nodeC->getnumber() " << nodeC->getnumber() << endl;
  nodeP = edgeT->getStart();
  //cout << "nodeP->getnumber() " << nodeP->getnumber() << endl;
  (*oIDH) = (*edgeT->getIDH());
  IDH =  edgeT->getIDH();

  

  //cout << "print original IDH " << endl;
  //IDH->printIDH();



  Time = edgeT->getEdgeLen();
  N0 = nodeP->getSeqLen();
  Nend = nodeC->getSeqLen();


  //cout << "Time : " << Time << " N0 : " << N0 << " Nend : " << Nend << endl;



  if(Time <= w){ // Propose new history in a whole sequence


    //cout << " if(Time <= w){ // Propose new history in a whole sequence " << endl;

    O_datalike = getLogLikeliData();
    O_IDHlike = edgeT->getlogLikeliIDH();
    O_psl= edgeT->ProposHistory(params);

    //cout << " O_datalike : " << O_datalike << " O_IDHlike : " << O_IDHlike << " O_psl : " << O_psl << endl;


    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);

    while(1){

      //cout << "2 " << endl;
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;

      tempTime = tempTime+dt;
	
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }

      if(tempTime-Time < 0){

	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;

	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	    P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	    L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	    ID.push_back(1);
	    N.push_back(N[i-1]+L[i]);
	    HMGin = HMG[i-1];
	    //outfiler << "HMGin size" << HMGin.size() << endl;
	    //tmphmg = -1;
	    for( k = 0; k<L[i]; k++){
	      HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	    }
	    HMG.push_back(HMGin);
	    HMGin.resize(0);
	    
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L  
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
       
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);      
	}   // end of if(runif(0,1)-prob1<0)
	i++;

      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	//double tmp = (Nend-N[i-1]) * (lambda+mu);
	if(N[i-1]<Nend){

	  ID.push_back(1);
	  L.push_back(Nend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));
	  N.push_back(Nend);
	  HMGin = HMG[i-1];

	  //int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else if(N[i-1]>Nend){
	  
	  ID.push_back(-1);
	  L.push_back(N[i-1]-Nend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (Time-tempTime+dt))+tempTime-dt));  
	  N.push_back(Nend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
 
    numE = i;
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    HMG.push_back(HMG[numE]);    



    
    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0); 
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();


    //cout << " After generate new IDH " << endl;
    //cout << "edgeT !!! " << endl;
    //edgeT->printEdge();



    //cout << "3 " << endl;

      
    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    //edgeTnum = nodeP->getEdgeNum(edgeT);
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}
	/*
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }
	*/
	//printTree(current); 
 
    logLikeliData[current] = likeliData();    
    //N_IDHlike = edgeT->likeliHistory(params);
    N_datalike = getLogLikeliData();
    //logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
    //cout << "4 " << endl;

    //cout << "print IDH " << endl;
    //IDH->printIDH();

    //printTree(0);
    //cout << "logLikeli : " <<  logLikeliData[current] << endl;


    if((0 < IDH->getNumE()) && (IDH->getNumE() <= MaxE) && (oIDH->getNumE()>0)){
    // Consider changing positions based on likelihood

      //cout << " if((0 < IDH->getNumE()) && (IDH->getNumE() <= MaxE) && (oIDH->getNumE()>0)) " << endl;

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);



      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      OnumE = oIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = oIDH->getHMG(k-1, oIDH->getP(k));
	if(tmpInt < 0){
	  getEnd = 0;
          lenPosi = oIDH->getHMG(k).size() - 1;
	  tmpInt2 = tmpInt;
	  ki = 0;
	  while(tmpInt < 0){
	    if((oIDH->getP(k)- ki) == 0){
	      tmpInt = 0;
	      getEnd = 1;
	    }else{
	      ki++;
	      tmpInt = oIDH->getHMG(k-1, oIDH->getP(k)-ki);
	    }
	  }
	  ki = 0;
	  while(tmpInt2 < 0){
	    if((oIDH->getP(k)+ ki) == lenPosi)
	      tmpInt2 = oIDH->getHMG(0).size() - 1;
	    else{
	      ki++;
	      tmpInt2 = oIDH->getHMG(k-1, oIDH->getP(k)+ki);
	    }
	  }	
	  if(getEnd == 1)
	    INDEp.push_back(tmpInt);
	  if(tmpInt2 == (tmpInt + 1))
	    INDEp.push_back(tmpInt2);
	  else{
	    INDEp.push_back(tmpInt+1);
	    INDEp.push_back(tmpInt2);
          }
	}else{
	  INDEp.push_back(tmpInt);
	}
      }

      //cout << "print INDEp " << endl;
      //print_veci(INDEp);



      sort(INDEp.begin(),INDEp.end());

      //cout << "6 " << endl;
      // Construct hotspots from INDEp
      int stspot, enspot;
      
      tmpInt2 = oIDH->getHMG(0).size();
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
     
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      k = 0; 
      
      tmpInt = INDEp.size();
      
      while(1){
	if(k == (tmpInt - 1)){
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }
	  break;
	}else{
	  if((INDEp[k+1]-INDEp[k]) < 2*(hotspotlen+1)){
	    k++;
	  }else{
	    enspot = INDEp[k] + hotspotlen;
	    for( ki = stspot; ki <= enspot ; ki++)
	      hotspot[ki] = 1;
	    k++;
	    stspot = INDEp[k] - hotspotlen;
	  }
	}
      }
      INDEp.resize(0);


      //cout << " print hotspot " << endl;
      //print_veci(hotspot);

     
      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      numE = IDH->getNumE();
      

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position

      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(IDH->getHMG(0));

      int realposi, k2, seqlen;
      seqlen = IDH->getHMG(0).size() - 1;
      

      //cout << "8 " << endl;

      if(IDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){

	    int Go = false;
	    if(ki==0)
	      Go = true;
	    if(hmg_v[0][0][ki-1] >= 0)
	      Go = true;

	    if(Go){
	      getEnd = 0;
	      k2 = 0;
	      realposi = hmg_v[0][0][ki];
	      while(realposi < 0){
		if((ki - k2) == 0){
		  realposi = 0;
		  getEnd = 1;
		}else{
		  k2++;
		  realposi = hmg_v[0][0][ki-k2];
		}
	      }
	      if(getEnd ==0)
		realposi++;
	      if(hotspot[realposi] != 1){
		lenPosi = hmg_v[0][0].size() - 1;
		k2 = 0;
		realposi = hmg_v[0][0][ki];
		while(realposi < 0){
		  if((ki + k2) == lenPosi)
		    realposi = seqlen;
		  else{
		    k2++;
		    realposi = hmg_v[0][0][ki+k2];
		  }
		}		
	      }
	    }
	  }else{
	    realposi = hmg_v[0][0][ki];
	  }
          
        
	  if(hotspot[realposi] == 1){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km<IDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    
	    hmg_v[1].push_back(HMGin);
	    
	    HMGin.resize(0);
	  }
	}
	
      }else{ // if deletion
	
	for( ki = 0; ki < (hmg_v[0][0].size()-IDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    int Go = false;
	    if(ki==0)
	      Go = true;
	    else if(hmg_v[0][0][ki-1] >= 0)
	      Go = true;

	    if(Go){

	      //if((ki==0) | (hmg_v[0][0][ki-1] >= 0)){
	      getEnd = 0;
	      k2 = 0;
	      realposi = hmg_v[0][0][ki];
	      while(realposi < 0){
		if((ki - k2) == 0){
		  getEnd = 1;
		  realposi = 0;
		}else{
		  k2++;
		  realposi = hmg_v[0][0][ki-k2];
		}
	      }
	      if(getEnd == 0){
		realposi++;
              }
	      if(hotspot[realposi] != 1){
		lenPosi =  hmg_v[0][0].size() - 1;
		k2 = 0;
		realposi = hmg_v[0][0][ki];
		while(realposi < 0){
		  if((ki + k2) == lenPosi)
		    realposi = seqlen;
		  else{
		    k2++;
		    realposi = hmg_v[0][0][ki+k2];
		  }
		}		
	      }
	    }
	  }else{
	    realposi = hmg_v[0][0][ki];
	  }
         
	  if(hotspot[realposi] == 1){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km<IDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    
	    hmg_v[1].push_back(HMGin);
	    
	    HMGin.resize(0);
	  }
	}
      }


      //cout << "9 " << endl;
      
      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(IDH->getID(k) == 1){  // if insertion
 
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  int Go = false;
		  if(ki==0)
		    Go = true;
		  else if(hmg_v[0][0][ki-1] >= 0)
		    Go = true;
		  
		  if(Go){

		    //if((ki==0) | (hmg_v[k-1][i][ki-1] >= 0)){
		    getEnd = 0;
		    k2 = 0;
		    realposi = hmg_v[k-1][i][ki];
		    while(realposi < 0){
		      if((ki - k2) == 0){
			getEnd = 1;
			realposi = 0;
		      }else{
			k2++;
			realposi = hmg_v[k-1][i][ki-k2];
		      }
		    }
		    if(getEnd == 0){
		      realposi++;
                    }
		    if(hotspot[realposi] != 1){
		      lenPosi =  hmg_v[k-1][i].size() - 1;
		      k2 = 0;
		      realposi = hmg_v[k-1][i][ki];
		      while(realposi < 0){
			if((ki + k2) == lenPosi)
			  realposi = seqlen;
			else{
			  k2++;
			  realposi = hmg_v[k-1][i][ki+k2];
			}
		      }		
		    }
		  }
		}else{
		  realposi = hmg_v[k-1][i][ki];
		}


		if(hotspot[realposi] == 1){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;

		  for( km = 0; km < IDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }

		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      }
	    }
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - IDH->getL(k)); ki++){
		

		if(hmg_v[k-1][i][ki]< 0){
		  int Go = false;
		  if(ki==0)
		    Go = true;
		  else if(hmg_v[0][0][ki-1] >= 0)
		    Go = true;
		  
		  if(Go){

		    //if((ki==0) | (hmg_v[k-1][i][ki-1] >= 0)){
		    getEnd = 0;
		    k2 = 0;
		    realposi = hmg_v[k-1][i][ki];
		    while(realposi < 0){
		      if((ki - k2) == 0){
			getEnd = 1;
			realposi = 0;
		      }else{
			k2++;
			realposi = hmg_v[k-1][i][ki-k2];
		      }
		    }
		    if(getEnd == 0){
		      realposi++;
                    }
		    if(hotspot[realposi] != 1){
		      lenPosi =  hmg_v[k-1][i].size() - 1;
		      k2 = 0;
		      realposi = hmg_v[k-1][i][ki];
		      while(realposi < 0){
			if((ki + k2) == lenPosi)
			  realposi = seqlen;
			else{
			  k2++;
			  realposi = hmg_v[k-1][i][ki+k2];
			}
		      }		
		    }
		  }
		}else{
		  realposi = hmg_v[k-1][i][ki];
		}
		


		if(hotspot[realposi] == 1){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];

		  for( km = 0; km < IDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  
		  hmg_v[k].push_back(HMGin);

		  HMGin.resize(0);
		}
	      }
	    }
	  }
	}
      }

      //cout << "10 " << endl;






      canN = chain_v[numE].size();



    if(canN==0){
      ps_n = 1;
    }else{


      lik_n.resize(canN);
      lik_wei_n.resize(canN);

      for(k = 0; k < canN ; k++){

	P.resize(0);
	HMG.resize(0);
	P.resize(numE+2);
	P[0] = 0;
	P[numE+1] = 0;
        HMG.resize(numE+2);
	HMG[0] = IDH->getHMG(0);

        upd_posi = k;
	for(ki = numE; ki > 0; ki--){
	  P[ki] =  posi_v[ki][upd_posi];
	  HMG[ki] = hmg_v[ki][upd_posi];
	  upd_posi = chain_v[ki][upd_posi];
        }

	//cout << "11 " << endl;

	HMG[numE+1] = HMG[numE];

	IDH->setP(P);
	IDH->setHMG(HMG);
	edgeT->calHMG();
	P.resize(0);
	HMG.resize(0);



	//---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	// 1
	nodeC->findRootSites();
	
	// 1'
	if(nodeP->getRoot())
	  nodeP->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3 4 5
	//edgeTnum = nodeP->getEdgeNum(edgeT);

	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}

        /*
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
	}else{
	  nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	  nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	  
	  // 4 5
	  UpdateAllinfoToRootWithChangedHMG(params, nodeP);
	}
	*/


	logLikeliData[current] = likeliData();   
	//N_IDHlike = edgeT->likeliHistory(params);
	N_datalike = getLogLikeliData();
	//logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	lik_n[k] = N_datalike;

	//cout << k << "th try lik_data : " <<  N_datalike << endl;
	//printTree(0);
 


      }


      //cout << "print lik_n " << endl;
      //print_vecd(lik_n);


      //cout << "12 " << endl;
      
      if((rand.runif()- delta > 0)){    // Actually change position based on like

	//cout << " if((rand.runif()- delta > 0)){  " << endl;

	params.setTmpInt(1);

	//cout << "13 " << endl;

	maxL = max_vec(lik_n);
	for( k = 0; k < canN; k++)
	  lik_wei_n[k] = exp((lik_n[k] - maxL));
	

	//cout << "13.1 " << endl;
	//cout << "lik_n " << endl;
	//print_vecd(lik_n);
	//cout << "maxL : " << maxL << endl;
	//cout << "lik_wei_n " << endl;
	//print_vecd(lik_wei_n);


	maxL = sum_vec(lik_wei_n);
	//cout << "maxL : " << maxL << endl;
	for( k = 0; k < canN; k++)
	  lik_wei_n[k] = lik_wei_n[k]/maxL;
	//cout << "lik_wei_n " << endl;
	//print_vecd(lik_wei_n);
	    

	//cout << "13.2 " << endl;

	upd_posi = rand.rwunif(lik_wei_n);
	//cout << "upd_posi " << upd_posi << endl;


	//cout << "13.3 " << endl;

	ps_n = lik_wei_n[upd_posi]*canN;

	//cout << " ps_n : " << ps_n << endl;


	//cout << "13.4 " << endl;

	P.resize(0);
	HMG.resize(0);
	P.resize(numE+2);
	P[0] = 0;
	P[numE+1] = 0;
        HMG.resize(numE+2);
	HMG[0] = IDH->getHMG(0);

	for(ki = numE; ki > 0; ki--){
	  //cout << "13.5 " << endl;
	  P[ki] =  posi_v[ki][upd_posi];
	  HMG[ki] = hmg_v[ki][upd_posi];
	  upd_posi = chain_v[ki][upd_posi];
        }


	//cout << "13.6 " << endl;


	//cout << "14 " << endl;

	HMG[numE+1] = HMG[numE];

	IDH->setP(P);
	IDH->setHMG(HMG);
	edgeT->calHMG();
	P.resize(0);
	HMG.resize(0);

	//---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	// 1
	nodeC->findRootSites();
	
	// 1'
	if(nodeP->getRoot())
	  nodeP->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3 4 5
	//edgeTnum = nodeP->getEdgeNum(edgeT);
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}


	//if(nodeP->getRoot()){
	//  nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
	//}else{
	//  nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	//  nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	//  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	//   
	// // 4 5
	//  UpdateAllinfoToRootWithChangedHMG(params, nodeP);
	//}
	
	logLikeliData[current] = likeliData(); 
	//N_IDHlike = edgeT->likeliHistory(params);
	N_datalike = getLogLikeliData();
	//logLikeliIDH[current] = likeliHistory(params);




	
      }else{   // not changing positions based on likelihood



	//	cout << "else if((rand.runif()- delta > 0)){  " << endl;

	//cout << "15 " << endl;

	maxL = max_vec(lik_n);
	for( k = 0; k < canN; k++)
	  lik_wei_n[k] = exp((lik_n[k] - maxL));
    
	(*IDH) = (*oIDH);
	edgeT->calHMG();

	//---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	// 1
	nodeC->findRootSites();
	
	// 1'
	if(nodeP->getRoot())
	  nodeP->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3 4 5
	//	edgeTnum = nodeP->getEdgeNum(edgeT);
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}

        /*
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
	}else{
	  nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	  nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	  
	  // 4 5
	  UpdateAllinfoToRootWithChangedHMG(params, nodeP);
	}
	*/
	logLikeliData[current] = likeliData();  
	//N_IDHlike = edgeT->likeliHistory(params);
	N_datalike = getLogLikeliData();
	//logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
		

	tmpDouble =  exp((N_datalike - maxL));
	maxL = sum_vec(lik_wei_n);
	ps_n = tmpDouble/maxL*canN;


      }

    } // end else == if(can>0)


      //cout << "16 " << endl;

    }else{
      ps_n = 1;
    }

    //cout << "17 " << endl;
    //cout << " ps_n : " << ps_n << endl; 
    //printTree(0);   
    //cout << " likelihood " << getLogLikeliData() << endl;
    
    //cout << "edgeT->getnumber() " << edgeT->getnumber() << endl;
    //cout << "edgeT !!! " << endl;
    //edgeT->printEdge();

    
    if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0)){
    // Consider changing positions based on likelihood

      //cout << " if((0 < oIDH->getNumE()) && (oIDH->getNumE() <= MaxE) && (IDH->getNumE()>0)){ " << endl;

      //cout << "18 " << endl;

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);



      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      numE = IDH->getNumE();
      
      for( k = 1; k <= numE; k++){
	tmpInt = IDH->getHMG(k-1, IDH->getP(k));
	if(tmpInt < 0){
	  getEnd = 0;
          lenPosi = IDH->getHMG(k).size() - 1;
	  tmpInt2 = tmpInt;
	  ki = 0;
	  while(tmpInt < 0){
	    if((IDH->getP(k)- ki) == 0){
	      tmpInt = 0;
	      getEnd = 1;
	    }else{
	      ki++;
	      tmpInt = IDH->getHMG(k-1, IDH->getP(k)-ki);
	    }
	  }
	  ki = 0;
	  while(tmpInt2 < 0){
	    if((IDH->getP(k)+ ki) == lenPosi)
	      tmpInt2 = IDH->getHMG(0).size() - 1;
	    else{
	      ki++;
	      tmpInt2 = IDH->getHMG(k-1, IDH->getP(k)+ki);
	    }
	  }	
	  if(getEnd == 1)
	    INDEp.push_back(tmpInt);
	  if(tmpInt2 == (tmpInt + 1))
	    INDEp.push_back(tmpInt2);
	  else{
	    INDEp.push_back(tmpInt+1);
	    INDEp.push_back(tmpInt2);
          }
	}else{
	  INDEp.push_back(tmpInt);
	}
      }

      //      cout << "print INDEp " << endl;
      //print_veci(INDEp);
      
      //cout << "19 " << endl;
      sort(INDEp.begin(),INDEp.end());

      //cout << "print INDEp " << endl;
      //print_veci(INDEp);
      
      // Construct hotspots from INDEp
      int stspot, enspot;
      
      tmpInt2 = IDH->getHMG(0).size();
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
     
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      k = 0; 
      
      tmpInt = INDEp.size();
      
      while(1){
	if(k == (tmpInt - 1)){
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }
	  break;
	}else{
	  if((INDEp[k+1]-INDEp[k]) < 2*(hotspotlen+1)){
	    k++;
	  }else{
	    enspot = INDEp[k] + hotspotlen;
	    for( ki = stspot; ki <= enspot ; ki++)
	      hotspot[ki] = 1;
	    k++;
	    stspot = INDEp[k] - hotspotlen;
	  }
	}
      }
      INDEp.resize(0);

      //cout << " print hotspot " << endl;
      //print_veci(hotspot);

      //cout << "20 " << endl;

      //(*tmpIDH) = (*IDH);

      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      //(*IDH) = (*oIDH);
      //edgeT->calHMG();

      numE = oIDH->getNumE();  

      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position

      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(oIDH->getHMG(0));

      int realposi, k2, seqlen;
      seqlen = oIDH->getHMG(0).size() - 1;
      

      if(oIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){

	    int Go = false;
	    if(ki==0)
	      Go = true;
	    else if(hmg_v[0][0][ki-1] >= 0)
	      Go = true;
	    
	    if(Go){

	      //if((ki==0) | (hmg_v[0][0][ki-1] >= 0)){
	      getEnd = 0;
	      k2 = 0;
	      realposi = hmg_v[0][0][ki];
	      while(realposi < 0){
		if((ki - k2) == 0){
		  realposi = 0;
		  getEnd = 1;
		}else{
		  k2++;
		  realposi = hmg_v[0][0][ki-k2];
		}
	      }
	      if(getEnd ==0)
		realposi++;
	      if(hotspot[realposi] != 1){
		lenPosi = hmg_v[0][0].size() - 1;
		k2 = 0;
		realposi = hmg_v[0][0][ki];
		while(realposi < 0){
		  if((ki + k2) == lenPosi)
		    realposi = seqlen;
		  else{
		    k2++;
		    realposi = hmg_v[0][0][ki+k2];
		  }
		}		
	      }
	    }
	  }else{
	    realposi = hmg_v[0][0][ki];
	  }
           
	  if(hotspot[realposi] == 1){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km<oIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    
	    hmg_v[1].push_back(HMGin);

	    HMGin.resize(0);
	  }
	}
	
      }else{ // if deletion
	

	for( ki = 0; ki < (hmg_v[0][0].size()-oIDH->getL(1)); ki++){
	           
	  if(hmg_v[0][0][ki] < 0){

	    int Go = false;
	    if(ki==0)
	      Go = true;
	    else if(hmg_v[0][0][ki-1] >= 0)
	      Go = true;
	    
	    if(Go){

	      //if((ki==0) | (hmg_v[0][0][ki-1] >= 0)){
	      getEnd = 0;
	      k2 = 0;
	      realposi = hmg_v[0][0][ki];
	      while(realposi < 0){
		if((ki - k2) == 0){
		  getEnd = 1;
		  realposi = 0;
		}else{
		  k2++;
		  realposi = hmg_v[0][0][ki-k2];
		}
	      }
	      if(getEnd == 0){
		realposi++;
              }
	      if(hotspot[realposi] != 1){
		lenPosi =  hmg_v[0][0].size() - 1;
		k2 = 0;
		realposi = hmg_v[0][0][ki];
		while(realposi < 0){
		  if((ki + k2) == lenPosi)
		    realposi = seqlen;
		  else{
		    k2++;
		    realposi = hmg_v[0][0][ki+k2];
		  }
		}		
	      }
	    }
	  }else{
	    realposi = hmg_v[0][0][ki];
	  }
          
	  if(hotspot[realposi] == 1){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km<oIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    
	    hmg_v[1].push_back(HMGin);

	    HMGin.resize(0);
	  }
	}
      }

      //cout << "21 " << endl;
      
 
      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(oIDH->getID(k) == 1){  // if insertion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
 
	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){
	    
		if(hmg_v[k-1][i][ki]< 0){

		  int Go = false;
		  if(ki==0)
		    Go = true;
		  else if(hmg_v[0][0][ki-1] >= 0)
		    Go = true;
		  
		  if(Go){

		    //if((ki==0) | (hmg_v[k-1][i][ki-1] >= 0)){
		    getEnd = 0;
		    k2 = 0;
		    realposi = hmg_v[k-1][i][ki];
		    while(realposi < 0){
		      if((ki - k2) == 0){
			getEnd = 1;
			realposi = 0;
		      }else{
			k2++;
			realposi = hmg_v[k-1][i][ki-k2];
		      }
		    }
		    if(getEnd == 0){
		      realposi++;
                    }
		    if(hotspot[realposi] != 1){
		      lenPosi =  hmg_v[k-1][i].size() - 1;
		      k2 = 0;
		      realposi = hmg_v[k-1][i][ki];
		      while(realposi < 0){
			if((ki + k2) == lenPosi)
			  realposi = seqlen;
			else{
			  k2++;
			  realposi = hmg_v[k-1][i][ki+k2];
			}
		      }		
		    }
		  }
		}else{
		  realposi = hmg_v[k-1][i][ki];
		}

		if(hotspot[realposi] == 1){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;
		  
		  for( km = 0; km < oIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);		  
		}
	      }
	    }
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - oIDH->getL(k)); ki++){
		

		if(hmg_v[k-1][i][ki]< 0){

		  int Go = false;
		  if(ki==0)
		    Go = true;
		  else if(hmg_v[0][0][ki-1] >= 0)
		    Go = true;
		  
		  if(Go){
		    //if((ki==0) | (hmg_v[k-1][i][ki-1] >= 0)){
		    getEnd = 0;
		    k2 = 0;
		    realposi = hmg_v[k-1][i][ki];
		    while(realposi < 0){
		      if((ki - k2) == 0){
			getEnd = 1;
			realposi = 0;
		      }else{
			k2++;
			realposi = hmg_v[k-1][i][ki-k2];
		      }
		    }
		    if(getEnd == 0){
		      realposi++;
                    }
		    if(hotspot[realposi] != 1){
		      lenPosi =  hmg_v[k-1][i].size() - 1;
		      k2 = 0;
		      realposi = hmg_v[k-1][i][ki];
		      while(realposi < 0){
			if((ki + k2) == lenPosi)
			  realposi = seqlen;
			else{
			  k2++;
			  realposi = hmg_v[k-1][i][ki+k2];
			}
		      }		
		    }
		  }
		}else{
		  realposi = hmg_v[k-1][i][ki];
		}
		


		if(hotspot[realposi] == 1){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < oIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}
	      }
	    }
	  }
	}
      }
      //cout << "22 " << endl;

      canN = chain_v[numE].size();




   if(canN == 0){
     ps_c = 1;
   }else{

       (*tmpIDH) = (*IDH);

      (*IDH) = (*oIDH);
      edgeT->calHMG();

      numE = IDH->getNumE();

      lik_n.resize(canN);
      lik_wei_n.resize(canN);

      for(k = 0; k < canN ; k++){
	P.resize(0);
	HMG.resize(0);
	P.resize(numE+2);
	P[0] = 0;
	P[numE+1] = 0;
        HMG.resize(numE+2);
	HMG[0] = IDH->getHMG(0);
        upd_posi = k;
	for(ki = numE; ki > 0; ki--){
	  P[ki] =  posi_v[ki][upd_posi];
	  HMG[ki] = hmg_v[ki][upd_posi];
	  upd_posi = chain_v[ki][upd_posi];
        }

	HMG[numE+1] = HMG[numE];

   
	IDH->setP(P);
	IDH->setHMG(HMG);
	edgeT->calHMG();
	P.resize(0);
	HMG.resize(0);

	//---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	// 1
	nodeC->findRootSites();
	
	// 1'
	if(nodeP->getRoot())
	  nodeP->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3 4 5
	//	edgeTnum = nodeP->getEdgeNum(edgeT);

	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}
	/*
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
	}else{
	  nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	  nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	  
	  // 4 5
	  UpdateAllinfoToRootWithChangedHMG(params, nodeP);
	}
	*/
	logLikeliData[current] = likeliData();    
	N_datalike = getLogLikeliData();
	//N_IDHlike = edgeT->likeliHistory(params);
	//logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
	
	lik_n[k] = N_datalike;

	//	cout << k << "th try lik_data : " << N_datalike << endl;
	//printTree(0);
 


      } 

      //cout << "print lik_n " << endl;
      //print_vecd(lik_n);

      //cout << "23 " << endl;

      maxL = max_vec(lik_n);
      for( k = 0; k < canN; k++)
	lik_wei_n[k] = exp((lik_n[k] - maxL));

      tmpDouble =  exp((O_datalike - maxL));
      maxL = sum_vec(lik_wei_n);
      ps_c = tmpDouble/maxL*canN;
	    
      (*IDH) = (*tmpIDH);
      edgeT->calHMG();
      
      //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
      // 1
      nodeC->findRootSites();
      
      // 1'
      if(nodeP->getRoot())
	nodeP->findLinkedSites();
      
      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
      
      // 3 4 5
      //      edgeTnum = nodeP->getEdgeNum(edgeT);
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}
	/*
      if(nodeP->getRoot()){
	nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
      }else{
	nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	
	// 4 5
	UpdateAllinfoToRootWithChangedHMG(params, nodeP);
      }
	*/
      logLikeliData[current] = likeliData();    
      //N_IDHlike = edgeT->likeliHistory(params);
      N_datalike = getLogLikeliData();
      //logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      
   }

    }else{
      ps_c = 1;
    }


    //cout << " ps_c : " << ps_c << endl;
    //cout << k << "th try lik_data : " << N_datalike << endl;
    //printTree(0);
    //cout << " likelidata : " << getLogLikeliData() << endl;
    //cout << "edgeT !!! " << endl;
    //edgeT->printEdge();
   


 

    N_datalike = getLogLikeliData();
    N_IDHlike = edgeT->likeliHistory(params);
    N_psl= edgeT->ProposHistory(params);
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike; 
    logLikeliIDH[current] = likeliHistory(params);

    //cout << " N_datalike : " << N_datalike << " N_IDHlike : " << N_IDHlike << " N_psl : " << N_psl << "logLikeliIDH[current] : " << logLikeliIDH[current] << endl;


    AP = exp( N_datalike + N_IDHlike + O_psl + log(delta + ((1-delta)*ps_c)) - O_datalike - O_IDHlike - N_psl - log(delta + ((1-delta)*ps_n)));


    //cout << " AP : " << AP << endl;


    //cout << "24 " << endl;

  }else{

    //cout << " part update " << endl;


    //cout << "25 " << endl;

    O_datalike = getLogLikeliData();
    O_IDHlike = edgeT->getlogLikeliIDH();

    getNa = 0;
    getNb = 0;
   
    midTime = (rand.runif() * Time);
    aTime = MAX((double)0,(midTime - (w/2)));
    bTime = MIN( Time, (midTime+ (w/2))) ;
    kTime = bTime - aTime;

    numE = IDH->getNumE();

    if(aTime == 0){
      q = 0;
      st = q + 1;
      kN0 = IDH->getN(q);
      getNa = 1;
    }else{
      for(q = 0; q <= numE; q++){
	if((IDH->getV(q) < aTime) && (aTime <= IDH->getV(q+1))){
	  st = q + 1;
	  kN0 = IDH->getN(q);
	  getNa = 1;
	  break;
	}
      }
    }

    //cout << "26 " << endl;
    
    if(bTime == Time){
      p = numE;
      en = p;
      kNend = IDH->getN(p);
      getNb = 1;
    }else{
      for(p = q; p <= numE ; p++){
	if((IDH->getV(p) <= bTime) && (bTime < IDH->getV(p+1))){
	  en = p; 
	  kNend = IDH->getN(p);
	  getNb = 1;
	  break;
	}
      }
    }

    //cout << "27 " << endl;

    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMG.push_back(IDH->getHMG(st-1));

    knumE = en - st + 1;

    if(knumE>0){
      for( q = st; q <= en; q++){       
	V.push_back((IDH->getV(q)-aTime));
	ID.push_back(IDH->getID(q));
	P.push_back(IDH->getP(q));
	L.push_back(IDH->getL(q));
	N.push_back(IDH->getN(q));
	HMG.push_back(IDH->getHMG(q));
      }
    }

    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);


    subIDH->setHistory(knumE, V, ID, P, L, N, HMG);

    O_psl = ProposHistory(params, subIDH);

    //cout << "st : " << st << " en : " << en << endl;
    //cout << "print subIDH " << endl;
    //subIDH->printIDH();




    //cout << "28 " << endl;

    // History Updata in a subsequence given Time
    tempTime=0;
    i=1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);
    Lwt.resize(0);
    
    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kN0);
    HMG.push_back(IDH->getHMG(st-1));
    
    while(1){
      
      eta = (N[i-1]+1)*lambda + fDel(N[i-1],rd)*mu;
      dt = -log(1.0-rand.runif()) / eta;
      
      tempTime = tempTime+dt;
      if(tempTime<0){
	cerr << "Error : tempTime<0" << endl;
	exit(1);
      }
      
      if(tempTime-kTime < 0){
	
	V.push_back(tempTime);
	prob1 = (N[i-1]+1)*lambda / eta;
	
	if(rand.runif()-prob1 < 0){       	// propose an insertion, which can be of any length, at any position
	  P.push_back((int)(rand.runif() * (N[i-1]+1))); // 0, 1, ..., N
	  L.push_back(rand.rgeom(ri)); //Need to chage with Geometric
	  ID.push_back(1);
	  N.push_back(N[i-1]+L[i]);	
	  HMGin = HMG[i-1];
	  //int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin()+ P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}else{   // propose a deletion, at a position with a length
	  
	  //propose length first
	  //for( d = 1; d <= N[i-1] ; d++){
	  //  Lwt.push_back( rd * pow(rd,d-1) * (N[i-1] - d + 1) );
	  //}
	  //L.push_back( (rand.rwunif(Lwt) + 1) );   
	  //Lwt.resize(0);
	  L.push_back(rand.rTRgeom(rd,N[i-1])); 
	  P.push_back((int)(rand.runif() * (N[i-1] - L[i] + 1)));// 0, 1, ...,N-L 
	  ID.push_back(-1);
	  N.push_back(N[i-1]-L[i]);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	  
	}   // end of if(runif(0,1)-prob1<0)
	i++;
	
      }else{                                      // tempTime > Time, propose an event at any left time, at a position, with particular length
	if(N[i-1]<kNend){
	  ID.push_back(1);
	  L.push_back(kNend-N[i-1]);
	  P.push_back((int)(rand.runif() * (N[i-1]+1)));
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  //int tmphmg = -1;
	  for( k = 0; k<L[i]; k++){
	    HMGin.insert(HMGin.begin() + P[i],tmphmg);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);
	}else if(N[i-1]>kNend){
	  ID.push_back(-1);
	  L.push_back(N[i-1]-kNend);
	  P.push_back((int)(rand.runif() * (N[i-1]-L[i]+1)));  
	  V.push_back(((rand.runif() * (kTime-tempTime+dt))+tempTime-dt));  
	  N.push_back(kNend);
	  HMGin = HMG[i-1];
	  for( k = 0; k<L[i]; k++){
	    HMGin.erase(HMGin.begin()+ P[i]);
	  }
	  HMG.push_back(HMGin);
	  HMGin.resize(0);	    
	}else{
	  i--;
	}
	break;
      }// end of if(tempTime-Time<0)
    }// end of while(1).
    
    knumE = i;
    V.push_back(kTime);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(kNend);
    HMG.push_back(HMG[knumE]);
    
    tmpIDH->setHistory(knumE, V, ID, P, L, N, HMG);
    //cout << "print tmpIDH " << endl;
    //tmpIDH->printIDH();

    N_psl = ProposHistory(params, tmpIDH);



    //cout << "29 " << endl;

    // put new sub IDH 

    numE = IDH->getNumE();

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N0);
    for( k = 0; k<=N0; k++){
      HMGin.push_back(k);
    }
    HMG.push_back(HMGin);
    HMGin.resize(0);
    
    if(st > 1){
      for( i = 1; i < st; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	HMG.push_back(IDH->getHMG(i));
      }
    }


    //cout << "30  " << endl;
    
    if(knumE >= 1){
      for( i = 1; i <= knumE ; i++){
	V.push_back((tmpIDH->getV(i)+aTime));
	ID.push_back(tmpIDH->getID(i));
	P.push_back(tmpIDH->getP(i));
	L.push_back(tmpIDH->getL(i));
	N.push_back(tmpIDH->getN(i));
	HMG.push_back(tmpIDH->getHMG(i));
      }
    }
    
    if(en < numE){
      for( i = (en+1); i <= numE; i++){
	V.push_back(IDH->getV(i));
	ID.push_back(IDH->getID(i));
	P.push_back(IDH->getP(i));
	L.push_back(IDH->getL(i));
	N.push_back(IDH->getN(i));
	int newposi = HMG.size();
	HMGin = HMG[newposi-1]; 
	if(ID[newposi] == 1){
	  //int tmphmg = -1;
	  for( km = 0; km < L[newposi]; km++)
	    HMGin.insert(HMGin.begin() + P[newposi] ,tmphmg);
        }else{
	  for( km = 0; km < L[newposi]; km++)
	    HMGin.erase(HMGin.begin()+ P[newposi]);
	}
	HMG.push_back(HMGin);  
	HMGin.resize(0);
      }
    }



    //cout << "31 " << endl;
      
    V.push_back(Time);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(Nend);
    numE = st - 1 + knumE + numE - en;
    HMG.push_back(HMG[numE]);

    IDH->setHistory(numE, V, ID, P, L, N, HMG);

    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG.resize(0);
    HMGin.resize(0);

    edgeT->calHMG();

    //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
    // 1
    nodeC->findRootSites();
    
    // 1'
    if(nodeP->getRoot())
      nodeP->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    // 3 4 5
    edgeTnum = nodeP->getEdgeNum(edgeT);
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}

	/*
    if(nodeP->getRoot()){
      nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
    }else{
      nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
      nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
      UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
      
      // 4 5
      UpdateAllinfoToRootWithChangedHMG(params, nodeP);
    }
	*/
   
    logLikeliData[current] = likeliData();    
    N_datalike = getLogLikeliData();

    if((0 < tmpIDH->getNumE()) && (tmpIDH->getNumE() <= MaxE) && (subIDH->getNumE()>0)){

     //cout << "32 " << endl;
      

      // Consider changing positions based on likelihood
      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
    
      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      OnumE = subIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = subIDH->getHMG(k-1, subIDH->getP(k));
	if(tmpInt < 0){
	  getEnd = 0;
          lenPosi = subIDH->getHMG(k).size() - 1;
	  tmpInt2 = tmpInt;
	  ki = 0;
	  while(tmpInt < 0){
	    if((subIDH->getP(k)- ki) == 0){
	      tmpInt = 0;
	      getEnd = 1;
	    }else{
	      ki++;
	      tmpInt = subIDH->getHMG(k-1, subIDH->getP(k)-ki);
	    }
	  }
	  ki = 0;
	  while(tmpInt2 < 0){
	    if((subIDH->getP(k)+ ki) == lenPosi)
	      tmpInt2 = IDH->getHMG(0).size() - 1;
	    else{
	      ki++;
	      tmpInt2 = subIDH->getHMG(k-1, subIDH->getP(k)+ki);
	    }
	  }	
	  if(getEnd == 1)
	    INDEp.push_back(tmpInt);
	  if(tmpInt2 == (tmpInt + 1))
	    INDEp.push_back(tmpInt2);
	  else{
	    INDEp.push_back(tmpInt+1);
	    INDEp.push_back(tmpInt2);
          }
	}else{
	  INDEp.push_back(tmpInt);
	}
      }


     //cout << "33 " << endl;

      sort(INDEp.begin(),INDEp.end());
      
      // Construct hotspots from INDEp
      int stspot, enspot;      
      tmpInt2 = IDH->getHMG(0).size();
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
     
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      k = 0; 
      
      tmpInt = INDEp.size();
      
      while(1){
	if(k == (tmpInt - 1)){
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }
	  break;
	}else{
	  if((INDEp[k+1]-INDEp[k]) < 2*(hotspotlen+1)){
	    k++;
	  }else{
	    enspot = INDEp[k] + hotspotlen;
	    for( ki = stspot; ki <= enspot ; ki++)
	      hotspot[ki] = 1;
	    k++;
	    stspot = INDEp[k] - hotspotlen;
	  }
	}
      }
      INDEp.resize(0);


      
     //cout << "34 " << endl;
      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      numE = tmpIDH->getNumE();
     
      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position

      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(tmpIDH->getHMG(0));

      int realposi, k2, seqlen;
      seqlen = IDH->getHMG(0).size() - 1;
      
      if(tmpIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){
  
	  if(hmg_v[0][0][ki] < 0){
	    
	    int Go = false;
	    if(ki==0)
	      Go = true;
	    else if(hmg_v[0][0][ki-1] >= 0)
	      Go = true;
	    
	    if(Go){

	      //if((ki==0) | (hmg_v[0][0][ki-1] >= 0)){
	      getEnd = 0;
	      k2 = 0;
	      realposi = hmg_v[0][0][ki];
	      while(realposi < 0){
		if((ki - k2) == 0){
		  realposi = 0;
		  getEnd = 1;
		}else{
		  k2++;
		  realposi = hmg_v[0][0][ki-k2];
		}
	      }
	      if(getEnd ==0)
		realposi++;
	      if(hotspot[realposi] != 1){
		lenPosi = hmg_v[0][0].size() - 1;
		k2 = 0;
		realposi = hmg_v[0][0][ki];
		while(realposi < 0){
		  if((ki + k2) == lenPosi)
		    realposi = seqlen;
		  else{
		    k2++;
		    realposi = hmg_v[0][0][ki+k2];
		  }
		}		
	      }
	    }
	  }else{
	    realposi = hmg_v[0][0][ki];
	  }
                  
	  if(hotspot[realposi] == 1){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km<tmpIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }
	    
	    hmg_v[1].push_back(HMGin);
	    
	    HMGin.resize(0);
	  }
	}
	
      }else{ // if deletion
	
	for( ki = 0; ki < (hmg_v[0][0].size()-tmpIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    int Go = false;
	    if(ki==0)
	      Go = true;
	    else if(hmg_v[0][0][ki-1] >= 0)
	      Go = true;
	    
	    if(Go){
	      //if((ki==0) | (hmg_v[0][0][ki-1] >= 0)){
	      getEnd = 0;
	      k2 = 0;
	      realposi = hmg_v[0][0][ki];
	      while(realposi < 0){
		if((ki - k2) == 0){
		  getEnd = 1;
		  realposi = 0;
		}else{
		  k2++;
		  realposi = hmg_v[0][0][ki-k2];
		}
	      }
	      if(getEnd == 0){
		realposi++;
              }
	      if(hotspot[realposi] != 1){
		lenPosi =  hmg_v[0][0].size() - 1;
		k2 = 0;
		realposi = hmg_v[0][0][ki];
		while(realposi < 0){
		  if((ki + k2) == lenPosi)
		    realposi = seqlen;
		  else{
		    k2++;
		    realposi = hmg_v[0][0][ki+k2];
		  }
		}		
	      }
	    }
	  }else{
	    realposi = hmg_v[0][0][ki];
	  }
         
	  if(hotspot[realposi] == 1){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km<tmpIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    
	    hmg_v[1].push_back(HMGin);
	    
	    HMGin.resize(0);
	  }
	}
      }      

      
     //cout << "35 " << endl;

      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(tmpIDH->getID(k) == 1){  // if insertion
 
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  int Go = false;
		  if(ki==0)
		    Go = true;
		  else if(hmg_v[0][0][ki-1] >= 0)
		    Go = true;
		  
		  if(Go){

		    //if((ki==0) | (hmg_v[k-1][i][ki-1] >= 0)){
		    getEnd = 0;
		    k2 = 0;
		    realposi = hmg_v[k-1][i][ki];
		    while(realposi < 0){
		      if((ki - k2) == 0){
			getEnd = 1;
			realposi = 0;
		      }else{
			k2++;
			realposi = hmg_v[k-1][i][ki-k2];
		      }
		    }
		    if(getEnd == 0){
		      realposi++;
                    }
		    if(hotspot[realposi] != 1){
		      lenPosi =  hmg_v[k-1][i].size() - 1;
		      k2 = 0;
		      realposi = hmg_v[k-1][i][ki];
		      while(realposi < 0){
			if((ki + k2) == lenPosi)
			  realposi = seqlen;
			else{
			  k2++;
			  realposi = hmg_v[k-1][i][ki+k2];
			}
		      }		
		    }
		  }
		}else{
		  realposi = hmg_v[k-1][i][ki];
		}

		if(hotspot[realposi] == 1){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;

		  for( km = 0; km < tmpIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }

		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		  
		}
	      }
	    }
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - tmpIDH->getL(k)); ki++){
		if(hmg_v[k-1][i][ki]< 0){

		  int Go = false;
		  if(ki==0)
		    Go = true;
		  else if(hmg_v[0][0][ki-1] >= 0)
		    Go = true;
		  
		  if(Go){
		    //if((ki==0) | (hmg_v[k-1][i][ki-1] >= 0)){
		    getEnd = 0;
		    k2 = 0;
		    realposi = hmg_v[k-1][i][ki];
		    while(realposi < 0){
		      if((ki - k2) == 0){
			getEnd = 1;
			realposi = 0;
		      }else{
			k2++;
			realposi = hmg_v[k-1][i][ki-k2];
		      }
		    }
		    if(getEnd == 0){
		      realposi++;
                    }
		    if(hotspot[realposi] != 1){
		      lenPosi =  hmg_v[k-1][i].size() - 1;
		      k2 = 0;
		      realposi = hmg_v[k-1][i][ki];
		      while(realposi < 0){
			if((ki + k2) == lenPosi)
			  realposi = seqlen;
			else{
			  k2++;
			  realposi = hmg_v[k-1][i][ki+k2];
			}
		      }		
		    }
		  }
		}else{
		  realposi = hmg_v[k-1][i][ki];
		}
	       
		if(hotspot[realposi] == 1){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];

		  for( km = 0; km < tmpIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  
		  hmg_v[k].push_back(HMGin);

		  HMGin.resize(0);
		}
	      }
	    }
	  }
	}
      }      
      canN = chain_v[numE].size();

    if(canN==0){
      ps_n = 1;
    }else{


      lik_n.resize(canN);
      lik_wei_n.resize(canN);

      knumE = numE;
      numE = IDH->getNumE();


     //cout << "36 " << endl;

      for(k = 0; k < canN ; k++){

        upd_posi = k;
	for(ki = knumE; ki > 0; ki--){
	  IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	  IDH->setHMG(hmg_v[ki][upd_posi], ki + st - 1);
	  upd_posi = chain_v[ki][upd_posi];
        }

	if(en < oIDH->getNumE()){
	  for(ki = (st + knumE) ; ki <= numE; ki++){
	    HMGin = IDH->getHMG(ki-1); 
	    if(IDH->getID(ki) == 1){
	      //int tmphmg = -1;
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	    }else{
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	    }
	    IDH->setHMG(HMGin, ki);
	    HMGin.resize(0);
          }
        }

	IDH->setHMG(IDH->getHMG(numE), numE+1);

	edgeT->calHMG();

	//---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	// 1
	nodeC->findRootSites();
	
	// 1'
	if(nodeP->getRoot())
	  nodeP->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3 4 5
	int edgeTnum = nodeP->getEdgeNum(edgeT);
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}
	/*
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
	}else{
	  nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	  nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	  
	  // 4 5
	  UpdateAllinfoToRootWithChangedHMG(params, nodeP);
	}
	*/
	logLikeliData[current] = likeliData();   
	N_datalike = getLogLikeliData();	
	lik_n[k] = N_datalike;
      }


     //cout << "37 " << endl;

      if((rand.runif()- delta > 0)){    // Actually change position based on like


	params.setTmpInt(1);
	//cout << "38 " << endl;

	maxL = max_vec(lik_n);
	for( k = 0; k < canN; k++)
	  lik_wei_n[k] = exp((lik_n[k] - maxL));
	
	maxL = sum_vec(lik_wei_n);
	for( k = 0; k < canN; k++)
	  lik_wei_n[k] = lik_wei_n[k]/maxL;
	    
	upd_posi = rand.rwunif(lik_wei_n);

	ps_n = lik_wei_n[upd_posi]*lik_wei_n.size();

	for(ki = knumE; ki > 0; ki--){
	  IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	  IDH->setHMG(hmg_v[ki][upd_posi], ki + st - 1);
	  upd_posi = chain_v[ki][upd_posi];
        }

	if(en < oIDH->getNumE()){
	  for(ki = (st + knumE) ; ki <= numE; ki++){
	    HMGin = IDH->getHMG(ki-1); 
	    if(IDH->getID(ki) == 1){
	      //int tmphmg = -1;
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	    }else{
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	    }
	    IDH->setHMG(HMGin, ki);
	    HMGin.resize(0);
          }
        }
	IDH->setHMG(IDH->getHMG(numE), numE+1);
	edgeT->calHMG();

	//---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	// 1
	nodeC->findRootSites();
	
	// 1'
	if(nodeP->getRoot())
	  nodeP->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3 4 5
	int edgeTnum = nodeP->getEdgeNum(edgeT);

	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}
        /*
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
	}else{
	  nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	  nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	  
	  // 4 5
	  UpdateAllinfoToRootWithChangedHMG(params, nodeP);
	}
	*/
	
	logLikeliData[current] = likeliData(); 
	N_datalike = getLogLikeliData();


	
      }else{   // not changing positions based on likelihood

	//cout << "39 " << endl;




	maxL = max_vec(lik_n);
	for( k = 0; k < canN; k++)
	  lik_wei_n[k] = exp((lik_n[k] - maxL));


	//cout << "print IDH AA " << endl;
	//IDH->printIDH();

    
	for(ki = knumE; ki > 0; ki--){
	  IDH->setP(tmpIDH->getP(ki), ki + st - 1);
	  IDH->setHMG(tmpIDH->getHMG(ki), ki + st - 1);
        }

	//cout << "print IDH BB " << endl;
	//IDH->printIDH();

	

	//cout << "39-1 " << endl;
	


	if(en < oIDH->getNumE()){

	 //cout << "39-2 " << endl;
	  for(ki = (st + knumE) ; ki <= numE; ki++){
	   //cout << "39-3 " << endl;
	    HMGin = IDH->getHMG(ki-1);
	   //cout << "print HMGin " << endl;
	    //print_veci(HMGin);
	   //cout << "39-3.1 " << endl;
	    if(IDH->getID(ki) == 1){
	      //int tmphmg = -1;
	     //cout << "39-3.2 " << endl;
	      for( km = 0; km < IDH->getL(ki); km++){
		HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
		//cout << "39-3.3 " << endl;
              }
	    }else{
	     //cout << "39-3.4 " << endl;
	     //cout << " IDH->getL(ki)   " <<  IDH->getL(ki) << endl;
	     //cout << " IDH->getP(ki) : " <<  IDH->getP(ki) << endl;
	     //cout << " HMGin.size() : " << HMGin.size() << endl;
	      for( km = 0; km < IDH->getL(ki); km++){
		//cout << "39-3.5 " << endl;
		HMGin.erase(HMGin.begin()+ IDH->getP(ki));
		//cout << "39-3.5.v2 " << endl;
	      }
	     //cout << "39-3.6 " << endl;
	    }
	   //cout << "39-3.7 " << endl;
	    IDH->setHMG(HMGin, ki);
	   //cout << "39-3.8 " << endl;
	    HMGin.resize(0);
          }
	 //cout << "39-3.9 " << endl;
	  
        }

	//cout << "39-4 " << endl;

	IDH->setHMG(IDH->getHMG(numE), numE+1);
	edgeT->calHMG();

	//---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	// 1
	nodeC->findRootSites();
	
	// 1'
	if(nodeP->getRoot())
	  nodeP->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3 4 5
	int edgeTnum = nodeP->getEdgeNum(edgeT);
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}

        /*
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
	}else{
	  nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	  nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	  
	  // 4 5
	  UpdateAllinfoToRootWithChangedHMG(params, nodeP);
	}
	*/
	logLikeliData[current] = likeliData();  
	N_datalike = getLogLikeliData();

	//cout << "39-5 " << endl;

	tmpDouble =  exp((N_datalike - maxL));
	maxL = sum_vec(lik_wei_n);
	ps_n = tmpDouble/maxL*lik_wei_n.size();

	
	//cout << "39-6 " << endl;
      }

      //cout << "39-7 " << endl;
    }

    }else{
      ps_n = 1;
    }

    //cout << "39-8 " << endl;
 
    if((0 < subIDH->getNumE()) && (subIDH->getNumE() <= MaxE) && (tmpIDH->getNumE()>0)){


      //cout << "40 " << endl;

      INDEp.resize(0); 
      hotspot.resize(0); 
      chain_v.resize(0);
      posi_v.resize(0);
      hmg_v.resize(0);
      lik_n.resize(0);
      lik_wei_n.resize(0);
     
      // Construct insertion hotspot and deletion hotspot      
      //----- INDEp 
      OnumE = tmpIDH->getNumE();
      
      for( k = 1; k <= OnumE; k++){
	tmpInt = tmpIDH->getHMG(k-1, tmpIDH->getP(k));
	if(tmpInt < 0){
	  getEnd = 0;
          lenPosi = tmpIDH->getHMG(k).size() - 1;
	  tmpInt2 = tmpInt;
	  ki = 0;
	  while(tmpInt < 0){
	    if((tmpIDH->getP(k)- ki) == 0){
	      tmpInt = 0;
	      getEnd = 1;
	    }else{
	      ki++;
	      tmpInt = tmpIDH->getHMG(k-1, tmpIDH->getP(k)-ki);
	    }
	  }
	  ki = 0;
	  while(tmpInt2 < 0){
	    if((tmpIDH->getP(k)+ ki) == lenPosi)
	      tmpInt2 = IDH->getHMG(0).size() - 1;
	    else{
	      ki++;
	      tmpInt2 = tmpIDH->getHMG(k-1, tmpIDH->getP(k)+ki);
	    }
	  }	
	  if(getEnd == 1)
	    INDEp.push_back(tmpInt);
	  if(tmpInt2 == (tmpInt + 1))
	    INDEp.push_back(tmpInt2);
	  else{
	    INDEp.push_back(tmpInt+1);
	    INDEp.push_back(tmpInt2);
          }
	}else{
	  INDEp.push_back(tmpInt);
	}
      }


      //cout << "41 " << endl;

      sort(INDEp.begin(),INDEp.end());
      
      // Construct hotspots from INDEp
      int stspot, enspot;
      
      tmpInt2 = IDH->getHMG(0).size();
      for( k = 0; k < tmpInt2; k++)
	hotspot.push_back(0);
     
      stspot = MAX(0,(INDEp[0] - hotspotlen));
      k = 0; 
      
      tmpInt = INDEp.size();
      
      while(1){
	if(k == (tmpInt - 1)){
	  enspot = MIN((tmpInt2-1),(INDEp[k] + hotspotlen));
	  for( ki = stspot; ki <= enspot ; ki++){
	    hotspot[ki] = 1;
	  }
	  break;
	}else{
	  if((INDEp[k+1]-INDEp[k]) < 2*(hotspotlen+1)){
	    k++;
	  }else{
	    enspot = INDEp[k] + hotspotlen;
	    for( ki = stspot; ki <= enspot ; ki++)
	      hotspot[ki] = 1;
	    k++;
	    stspot = INDEp[k] - hotspotlen;
	  }
	}
      }
      INDEp.resize(0);


      //cout << "42 " << endl;

      //(*tmp2IDH) = (*IDH);
      //----------------------------------------------//
      //
      // Changing positions and get homology 
      //
      //-----------------------------------------------//

      //(*IDH) = (*oIDH);
      numE = subIDH->getNumE();
     
      chain_v.resize(numE+1);
      posi_v.resize(numE+1);
      hmg_v.resize(numE+1);

      // Special setup for 0-th and 1-th position

      chain_v[0].push_back(-1);
      posi_v[0].push_back(-1);
      hmg_v[0].push_back(subIDH->getHMG(0));

      int realposi, k2, seqlen;
      seqlen = IDH->getHMG(0).size() - 1;
     
      if(subIDH->getID(1) == 1){  // if insertion
	
	for( ki = 0; ki < hmg_v[0][0].size(); ki++){

	  
	  if(hmg_v[0][0][ki] < 0){
	    
	    int Go = false;
	    if(ki==0)
	      Go = true;
	    else if(hmg_v[0][0][ki-1] >= 0)
	      Go = true;
	    
	    if(Go){
	      //if((ki==0) | (hmg_v[0][0][ki-1] >= 0)){
	      getEnd = 0;
	      k2 = 0;
	      realposi = hmg_v[0][0][ki];
	      while(realposi < 0){
		if((ki - k2) == 0){
		  realposi = 0;
		  getEnd = 1;
		}else{
		  k2++;
		  realposi = hmg_v[0][0][ki-k2];
		}
	      }
	      if(getEnd ==0)
		realposi++;
	      if(hotspot[realposi] != 1){
		lenPosi = hmg_v[0][0].size() - 1;
		k2 = 0;
		realposi = hmg_v[0][0][ki];
		while(realposi < 0){
		  if((ki + k2) == lenPosi)
		    realposi = seqlen;
		  else{
		    k2++;
		    realposi = hmg_v[0][0][ki+k2];
		  }
		}		
	      }
	    }
	  }else{
	    realposi = hmg_v[0][0][ki];
	  }
                
	  if(hotspot[realposi] == 1){
	    
	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    tmphmg = -1;
	    for( km = 0; km<subIDH->getL(1); km++){
	      HMGin.insert(HMGin.begin()+ ki,tmphmg);
	    }    
	    hmg_v[1].push_back(HMGin);
	    
	    HMGin.resize(0);
	  }
	}
	
      }else{ // if deletion
	
	for( ki = 0; ki < (hmg_v[0][0].size()-subIDH->getL(1)); ki++){
	  	  
	  if(hmg_v[0][0][ki] < 0){

	    int Go = false;
	    if(ki==0)
	      Go = true;
	    else if(hmg_v[0][0][ki-1] >= 0)
	      Go = true;
	    
	    if(Go){

	      //if((ki==0) | (hmg_v[0][0][ki-1] >= 0)){
	      getEnd = 0;
	      k2 = 0;
	      realposi = hmg_v[0][0][ki];
	      while(realposi < 0){
		if((ki - k2) == 0){
		  getEnd = 1;
		  realposi = 0;
		}else{
		  k2++;
		  realposi = hmg_v[0][0][ki-k2];
		}
	      }
	      if(getEnd == 0){
		realposi++;
              }
	      if(hotspot[realposi] != 1){
		lenPosi =  hmg_v[0][0].size() - 1;
		k2 = 0;
		realposi = hmg_v[0][0][ki];
		while(realposi < 0){
		  if((ki + k2) == lenPosi)
		    realposi = seqlen;
		  else{
		    k2++;
		    realposi = hmg_v[0][0][ki+k2];
		  }
		}		
	      }
	    }
	  }else{
	    realposi = hmg_v[0][0][ki];
	  }
         
	  if(hotspot[realposi] == 1){

	    chain_v[1].push_back(-1);
	    posi_v[1].push_back(ki);
	    
	    HMGin = hmg_v[0][0];
	    for( km = 0; km<subIDH->getL(1); km++){
	      HMGin.erase(HMGin.begin()+ ki);
	    }
	    
	    hmg_v[1].push_back(HMGin);
	    
	    HMGin.resize(0);
	  }
	}
      }

      //cout << "43 " << endl;
      
      // after 2nd position
      if(numE >= 2){
	
	for( k = 2; k <= numE; k++){ 

	  if(subIDH->getID(k) == 1){  // if insertion
 
	    for(i = 0; i < chain_v[k-1].size(); i++){ 

	      for( ki = 0; ki < hmg_v[k-1][i].size(); ki++){

		if(hmg_v[k-1][i][ki]< 0){

		  int Go = false;
		  if(ki==0)
		    Go = true;
		  else if(hmg_v[0][0][ki-1] >= 0)
		    Go = true;
		  
		  if(Go){

		    //if((ki==0) | (hmg_v[k-1][i][ki-1] >= 0)){
		    getEnd = 0;
		    k2 = 0;
		    realposi = hmg_v[k-1][i][ki];
		    while(realposi < 0){
		      if((ki - k2) == 0){
			getEnd = 1;
			realposi = 0;
		      }else{
			k2++;
			realposi = hmg_v[k-1][i][ki-k2];
		      }
		    }
		    if(getEnd == 0){
		      realposi++;
                    }
		    if(hotspot[realposi] != 1){
		      lenPosi =  hmg_v[k-1][i].size() - 1;
		      k2 = 0;
		      realposi = hmg_v[k-1][i][ki];
		      while(realposi < 0){
			if((ki + k2) == lenPosi)
			  realposi = seqlen;
			else{
			  k2++;
			  realposi = hmg_v[k-1][i][ki+k2];
			}
		      }		
		    }
		  }
		}else{
		  realposi = hmg_v[k-1][i][ki];
		}

		if(hotspot[realposi] == 1){

		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  tmphmg = -1;

		  for( km = 0; km < subIDH->getL(k); km++){
		    HMGin.insert(HMGin.begin()+ ki,tmphmg);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);		  
		}
	      }
	    }
	    
	  }else{ // if deletion
	    
	    for(i = 0; i < chain_v[k-1].size(); i++){ 
	      
	      for( ki = 0; ki < (hmg_v[k-1][i].size() - subIDH->getL(k)); ki++){
		if(hmg_v[k-1][i][ki]< 0){

		  int Go = false;
		  if(ki==0)
		    Go = true;
		  else if(hmg_v[0][0][ki-1] >= 0)
		    Go = true;
		  
		  if(Go){


		    //if((ki==0) | (hmg_v[k-1][i][ki-1] >= 0)){
		    getEnd = 0;
		    k2 = 0;
		    realposi = hmg_v[k-1][i][ki];
		    while(realposi < 0){
		      if((ki - k2) == 0){
			getEnd = 1;
			realposi = 0;
		      }else{
			k2++;
			realposi = hmg_v[k-1][i][ki-k2];
		      }
		    }
		    if(getEnd == 0){
		      realposi++;
                    }
		    if(hotspot[realposi] != 1){
		      lenPosi =  hmg_v[k-1][i].size() - 1;
		      k2 = 0;
		      realposi = hmg_v[k-1][i][ki];
		      while(realposi < 0){
			if((ki + k2) == lenPosi)
			  realposi = seqlen;
			else{
			  k2++;
			  realposi = hmg_v[k-1][i][ki+k2];
			}
		      }		
		    }
		  }
		}else{
		  realposi = hmg_v[k-1][i][ki];
		}
		
		if(hotspot[realposi] == 1){
		  
		  chain_v[k].push_back(i);
		  posi_v[k].push_back(ki);
		  
		  HMGin = hmg_v[k-1][i];
		  for( km = 0; km < subIDH->getL(k); km++){
		    HMGin.erase(HMGin.begin()+ ki);
		  }
		  hmg_v[k].push_back(HMGin);
		  HMGin.resize(0);
		}
	      }
	    }
	  }
	}
      }      

      //cout << "44 " << endl;

      canN = chain_v[numE].size();

      if(canN==0){
	ps_c = 1;
      }else{

	(*tmp2IDH) = (*IDH);
	(*IDH) = (*oIDH);
	edgeT->calHMG();

      lik_n.resize(canN);
      lik_wei_n.resize(canN);

      knumE = numE;
      numE = IDH->getNumE();

      for(k = 0; k < canN ; k++){

        upd_posi = k;
	for(ki = knumE; ki > 0; ki--){
	  IDH->setP(posi_v[ki][upd_posi], ki + st - 1);
	  IDH->setHMG(hmg_v[ki][upd_posi], ki + st - 1);
	  upd_posi = chain_v[ki][upd_posi];
        }

	if(en < oIDH->getNumE()){
	  for(ki = (st + knumE) ; ki <= numE; ki++){
	    HMGin = IDH->getHMG(ki-1); 
	    if(IDH->getID(ki) == 1){
	      //int tmphmg = -1;
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.insert(HMGin.begin() + IDH->getP(ki) ,tmphmg);
	    }else{
	      for( km = 0; km < IDH->getL(ki); km++)
		HMGin.erase(HMGin.begin()+ IDH->getP(ki));
	    }
	    IDH->setHMG(HMGin, ki);
	    HMGin.resize(0);
          }
        }

	IDH->setHMG(IDH->getHMG(numE), numE+1);
	edgeT->calHMG();

	//---- Update gijk and likelihood of rootSites and LinkedSites  ----//
	// 1
	nodeC->findRootSites();
	
	// 1'
	if(nodeP->getRoot())
	  nodeP->findLinkedSites();
	
	// 2
	nodeC->CalloglikeliofRootSitesOrReuse(params);
	UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
	
	// 3 4 5
	int edgeTnum = nodeP->getEdgeNum(edgeT);
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}
        /*
	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
	}else{
	  nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	  nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	  
	  // 4 5
	  UpdateAllinfoToRootWithChangedHMG(params, nodeP);
	}
        */
	
	logLikeliData[current] = likeliData();   
	N_datalike = getLogLikeliData();
	lik_n[k] = N_datalike;
      }

      maxL = max_vec(lik_n);
      for( k = 0; k < canN; k++)
	lik_wei_n[k] = exp((lik_n[k] - maxL));
      
      tmpDouble =  exp((O_datalike - maxL));
      maxL = sum_vec(lik_wei_n);
      ps_c = tmpDouble/maxL*lik_wei_n.size();      

      (*IDH) = (*tmp2IDH);
      edgeT->calHMG();
      //---- Update gijk and likelihood of rootSites and LinkedSites  ----//
      // 1
      nodeC->findRootSites();
      
      // 1'
      if(nodeP->getRoot())
	nodeP->findLinkedSites();
      
      // 2
      nodeC->CalloglikeliofRootSitesOrReuse(params);
      UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
      
      // 3 4 5
      int edgeTnum = nodeP->getEdgeNum(edgeT);

	if(nodeP->getRoot()){
	  nodeP->CalloglikeliofLinkedSites(params);
	}else{
	  nodeP->CalSubTreeProb(params);
	  nodeP->CalloglikeliofRootSites(params);
	  UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	   
	  // 4 5
	  UpdateAllinfoToRoot(params, nodeP->getParent());
	}
	/*
      if(nodeP->getRoot()){
	nodeP->CalloglikeliofLinkedSitesWithChangedHMG(params, edgeTnum);
      }else{
	nodeP->CalSubTreeProbForSitesWithChangedHMG(params, edgeTnum);
	nodeP->CalloglikeliofRootSitesWithChangedHMG(params, edgeTnum);
	UpdatedNodeinRootSites[current][nodeP->getnumber()] = 1;
	
	// 4 5
	UpdateAllinfoToRootWithChangedHMG(params, nodeP);
      }
	*/
      logLikeliData[current] = likeliData();  
      N_datalike = getLogLikeliData();       

      }

    }else{
      ps_c = 1;
    }

    N_datalike = getLogLikeliData();
    N_IDHlike = edgeT->likeliHistory(params);
    //N_psl= edgeT->ProposHistory(params);
    // find_bug3 //
    logLikeliIDH[current] = likeliHistory(params);
    //logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;
    
    AP = exp( N_datalike + N_IDHlike + O_psl + log(delta + ((1-delta)*ps_c)) - O_datalike - O_IDHlike - N_psl - log(delta + ((1-delta)*ps_n)));

    
    //cout << "45 " << endl;
  }

  V.resize(0);
  ID.resize(0);
  P.resize(0);
  L.resize(0);
  N.resize(0);
  HMG.resize(0);
  HMGin.resize(0);
  Lwt.resize(0);
  INDEp.resize(0);
  hotspot.resize(0);
  chain_v.resize(0);
  posi_v.resize(0);
  hmg_v.resize(0);
  lik_n.resize(0);
  lik_wei_n.resize(0);

  

  
  delete subIDH;
  delete tmpIDH;
  delete tmp2IDH;
  delete oIDH;


  //cout << "46 " << endl;

  return AP;

}   // End of UpIDHonEdgeLike






double Tree::UpIDHandSeq_v2(Rand &rand,Parameters &params, ofstream& c, int start) {
 
  int i, j;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_psl_lenZ, N_psl_lenZ;
  double r;
  double UpIDHandSeq_r = params.getUpIDHandSeq_r();
  double UpIDHandSeq_epsilon = params.getUpIDHandSeq_epsilon();
  //double logr = log(UpIDHandSeq_r);
  //double log1_r = log(1-UpIDHandSeq_r);
  int minSeqLen, maxSeqLen, tmpSeqLen, newlenZ, origlenZ;
  vector<bool> rev(0);
  rev.push_back(false);
  rev.push_back(false);
  rev.push_back(false);


  Node* nodes123[3];


  //cout << "1" << endl;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  //cout << "2" << endl;
  
  origlenZ = nodeZ->getSeqLen();

  // Get minSeqLen and maxSeqLen
  Edge* edges123[3];
  edges123[0] = nodeZ->getEdge(0);
  nodes123[0] = edges123[0]->getOtherNode(nodeZ);
  minSeqLen = nodes123[0]->getSeqLen();
  maxSeqLen = minSeqLen;  
  for(i = 1; i < nodeZ->getnumEdges(); i++){
    edges123[i] = nodeZ->getEdge(i);
    nodes123[i] = edges123[i]->getOtherNode(nodeZ);
    tmpSeqLen = nodes123[i]->getSeqLen();
    minSeqLen = MIN(minSeqLen, tmpSeqLen);
    maxSeqLen = MAX(maxSeqLen, tmpSeqLen);
  }


  
  //cout << "3" << endl;

  // Calculate O_psl_lenZ
  if((origlenZ >= minSeqLen) & (origlenZ <= maxSeqLen)){
    
    O_psl_lenZ = log(UpIDHandSeq_epsilon/(double)(tmpSeqLen = maxSeqLen - minSeqLen + 1));

  }else{

    if(minSeqLen > 0){

      if(origlenZ < minSeqLen){

	O_psl_lenZ = log((1-UpIDHandSeq_epsilon)/2) + log(UpIDHandSeq_r) + (minSeqLen - origlenZ - 1)*log(1-UpIDHandSeq_r) - log(1 - pow(1-UpIDHandSeq_r, minSeqLen));
	
      }else if(origlenZ > maxSeqLen){

	O_psl_lenZ = log((1-UpIDHandSeq_epsilon)/2) + log(UpIDHandSeq_r) + (origlenZ - maxSeqLen - 1)*log(1-UpIDHandSeq_r);
	
      }else{
	cout << "ERROR in UpIDHandSeq_v2" << endl;
      }

    }else{

      if(origlenZ <= maxSeqLen)
	//cout << "ERROR in UpIDHandSeq_v2 0 " << endl;

      O_psl_lenZ = log(1-UpIDHandSeq_epsilon) + log(UpIDHandSeq_r) + (origlenZ - maxSeqLen - 1)*log(1-UpIDHandSeq_r);

    }

  }



  
  // pick new seqlen and cal N_psl_lenZ
  if(rand.runif() < UpIDHandSeq_epsilon){ // With prob epsilon

    //cout << "4" << endl;
    
    tmpSeqLen = maxSeqLen - minSeqLen + 1;
    newlenZ = minSeqLen + (int)(rand.runif() * (tmpSeqLen)); // minSeqLen + [0, 1, ...,maxSeqLen - minSeqLen]  
    N_psl_lenZ = log(UpIDHandSeq_epsilon/(double)tmpSeqLen);
    if((newlenZ < minSeqLen) | (newlenZ > maxSeqLen))
      cout << "ERROR in UpIDHandSeq_v2 A " << endl;

    //cout << "5" << endl;


  }else{

    //cout << "6" << endl;
    if(minSeqLen > 0){

      if(rand.runif() < 0.5){ // With prob (1-epsilon)/2

	//cout << "7" << endl;

	//cout << "minSeqLen : " << minSeqLen << " UpIDHandSeq_r : " << UpIDHandSeq_r << endl;

	newlenZ = minSeqLen - rand.rTRgeom(UpIDHandSeq_r, minSeqLen);

	//cout << "7-1" << endl;

	N_psl_lenZ = log((1-UpIDHandSeq_epsilon)/2) + log(UpIDHandSeq_r) + (minSeqLen - newlenZ - 1)*log(1-UpIDHandSeq_r) - log(1 - pow(1-UpIDHandSeq_r, minSeqLen));

	//cout << "7-2 " << endl;

	if(newlenZ >= minSeqLen)
	  cout << "ERROR in UpIDHandSeq_v2 B " << endl;
 
     
	//cout << "8" << endl;

      }else{  // With prob (1-epsilon)/2

	//cout << "9" << endl;
      

	newlenZ = maxSeqLen + rand.rgeom(UpIDHandSeq_r);
	N_psl_lenZ = log((1-UpIDHandSeq_epsilon)/2) + log(UpIDHandSeq_r) + (newlenZ - maxSeqLen - 1)*log(1-UpIDHandSeq_r);
	if(newlenZ <= maxSeqLen)
	  cout << "ERROR in UpIDHandSeq_v2 C " << endl;

	//cout << "10" << endl;


      }

    }else{

      newlenZ = maxSeqLen + rand.rgeom(UpIDHandSeq_r);
      N_psl_lenZ = log(1-UpIDHandSeq_epsilon) + log(UpIDHandSeq_r) + (newlenZ - maxSeqLen - 1)*log(1-UpIDHandSeq_r);
      if(newlenZ <= maxSeqLen)
	cout << "ERROR in UpIDHandSeq_v2 C " << endl;

      //cout << "10" << endl;

    }

    //cout << "11" << endl;

  }


  //cout << "12" << endl;


  // Heejung
  O_IDHlike = edges123[0]->likeliHistory(params);
  O_IDHlike += edges123[1]->likeliHistory(params);
  O_IDHlike += edges123[2]->likeliHistory(params);


  
  //cout << "13" << endl;

  

  // Save old proposal probs, generate new history and get new proposal probs 
  if(nodeZ == edges123[0]->getEnd()){
    edges123[0]->ReverseEdge();
    rev[0] = true;
  }


  //cout << "14" << endl;


  if(nodeZ == edges123[1]->getEnd()){
    edges123[1]->ReverseEdge();
    rev[1] = true;
  }

  //cout << "15" << endl;


  if(nodeZ == edges123[2]->getEnd()){
    edges123[2]->ReverseEdge();
    rev[2] = true;
  }

  //cout << "16" << endl;



  O_psl = edges123[0]->ProposHistory(params);
  O_psl += edges123[1]->ProposHistory(params);
  O_psl += edges123[2]->ProposHistory(params);


  //cout << "17" << endl;



  nodeZ->setSeqLen(newlenZ);

  //cout << "18" << endl;
  


  edges123[0]->runEdge(rand, params);
  edges123[1]->runEdge(rand, params);
  edges123[2]->runEdge(rand, params);


  //cout << "19" << endl;



  N_psl = edges123[0]->ProposHistory(params);
  N_psl += edges123[1]->ProposHistory(params);
  N_psl += edges123[2]->ProposHistory(params);


  //cout << "20" << endl;


  if(rev[0])
    edges123[0]->ReverseEdge();
  if(rev[1])
    edges123[1]->ReverseEdge();
  if(rev[2])
    edges123[2]->ReverseEdge();


  
  //cout << "21" << endl;

  N_IDHlike = edges123[0]->likeliHistory(params);
  N_IDHlike += edges123[1]->likeliHistory(params);
  N_IDHlike += edges123[2]->likeliHistory(params);



  //cout << "22" << endl;


  //Update Tree structure
  
  if(nodeZ->getRoot()){
    

    //cout << "23" << endl;
    

    // 1
    nodes123[0]->UpdateRootSites(params);
    nodes123[1]->UpdateRootSites(params);
    nodes123[2]->UpdateRootSites(params);

    


    // 2
    nodeZ->CalloglikeliofUpdatedLinkedSites(params);

    


    r = params.getR();
    // Heejung
    double logr = log(r);
    double log1_r = log(1-r);
    O_IDHlike +=  logr + origlenZ*log1_r;
    N_IDHlike +=  logr + newlenZ*log1_r;

    //cout << "24" << endl;


  }else{


    //cout << "25" << endl;

    Node* nodeR;
    Node* nodeOthers[2];
 
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(nodeZ == nodeZ->getEdge(i)->getStart()){
	nodeOthers[j] = nodeZ->getEdge(i)->getOtherNode(nodeZ);
	j++;
      }else{
	nodeR = nodeZ->getEdge(i)->getOtherNode(nodeZ);
      }
    }
    
    // 1
    for(i = 0; i < 2; i++)
      nodeOthers[i]->UpdateRootSites(params);
   
    // 2
    nodeZ->CalloglikeliofUpdatedRootSites(params);
    nodeZ->CalSubTreeProb(params);

    if(nodeR->getRoot()){
      // 3
      nodeR->CalloglikeliofUpdatedLinkedSites(params);
    }else{
      // 4 
      nodeR->CalloglikeliofRootSites(params);
      nodeR->CalSubTreeProb(params);

      // 5
      UpdateAllinfoToRoot(params, nodeR->getParent());
    }


    //cout << "26" << endl;



  }



  //cout << "27" << endl;


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];

  // IDH like
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      


  //cout << "28" << endl;
  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_lenZ - O_datalike - O_IDHlike - N_psl - N_psl_lenZ);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);
  
  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<  exp( O_psl + O_psl_lenZ - N_psl - N_psl_lenZ) << exp( O_psl_lenZ - N_psl_lenZ) <<   exp(O_psl - N_psl) <<  endl;
  


  rev.resize(0);
 

  return AP;

}





double Tree::UpIDHandSeq_v2(Rand &rand,Parameters &params, ofstream& c) {
 
  int i, j;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, O_psl_lenZ, N_psl_lenZ;
  double r;
  double UpIDHandSeq_r = params.getUpIDHandSeq_r();
  double UpIDHandSeq_epsilon = params.getUpIDHandSeq_epsilon();
  //double logr = log(UpIDHandSeq_r);
  //double log1_r = log(1-UpIDHandSeq_r);
  int minSeqLen, maxSeqLen, tmpSeqLen, newlenZ, origlenZ;
  vector<bool> rev(0);
  rev.push_back(false);
  rev.push_back(false);
  rev.push_back(false);


  Node* nodes123[3];


  //cout << "1" << endl;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  //cout << "2" << endl;
  
  origlenZ = nodeZ->getSeqLen();

  // Get minSeqLen and maxSeqLen
  Edge* edges123[3];
  edges123[0] = nodeZ->getEdge(0);
  nodes123[0] = edges123[0]->getOtherNode(nodeZ);
  minSeqLen = nodes123[0]->getSeqLen();
  maxSeqLen = minSeqLen;  
  for(i = 1; i < nodeZ->getnumEdges(); i++){
    edges123[i] = nodeZ->getEdge(i);
    nodes123[i] = edges123[i]->getOtherNode(nodeZ);
    tmpSeqLen = nodes123[i]->getSeqLen();
    minSeqLen = MIN(minSeqLen, tmpSeqLen);
    maxSeqLen = MAX(maxSeqLen, tmpSeqLen);
  }


  
  //cout << "3" << endl;

  // Calculate O_psl_lenZ
  if((origlenZ >= minSeqLen) & (origlenZ <= maxSeqLen)){
    
    O_psl_lenZ = log(UpIDHandSeq_epsilon/(double)(tmpSeqLen = maxSeqLen - minSeqLen + 1));

  }else{

    if(minSeqLen > 0){

      if(origlenZ < minSeqLen){

	O_psl_lenZ = log((1-UpIDHandSeq_epsilon)/2) + log(UpIDHandSeq_r) + (minSeqLen - origlenZ - 1)*log(1-UpIDHandSeq_r) - log(1 - pow(1-UpIDHandSeq_r, minSeqLen));
	
      }else if(origlenZ > maxSeqLen){

	O_psl_lenZ = log((1-UpIDHandSeq_epsilon)/2) + log(UpIDHandSeq_r) + (origlenZ - maxSeqLen - 1)*log(1-UpIDHandSeq_r);
	
      }else{
	cout << "ERROR in UpIDHandSeq_v2" << endl;
      }

    }else{

      if(origlenZ <= maxSeqLen)
	//cout << "ERROR in UpIDHandSeq_v2 0 " << endl;

      O_psl_lenZ = log(1-UpIDHandSeq_epsilon) + log(UpIDHandSeq_r) + (origlenZ - maxSeqLen - 1)*log(1-UpIDHandSeq_r);

    }

  }



  
  // pick new seqlen and cal N_psl_lenZ
  if(rand.runif() < UpIDHandSeq_epsilon){ // With prob epsilon

    //cout << "4" << endl;
    
    tmpSeqLen = maxSeqLen - minSeqLen + 1;
    newlenZ = minSeqLen + (int)(rand.runif() * (tmpSeqLen)); // minSeqLen + [0, 1, ...,maxSeqLen - minSeqLen]  
    N_psl_lenZ = log(UpIDHandSeq_epsilon/(double)tmpSeqLen);
    if((newlenZ < minSeqLen) | (newlenZ > maxSeqLen))
      cout << "ERROR in UpIDHandSeq_v2 A " << endl;

    //cout << "5" << endl;


  }else{

    //cout << "6" << endl;
    if(minSeqLen > 0){

      if(rand.runif() < 0.5){ // With prob (1-epsilon)/2

	//cout << "7" << endl;

	//cout << "minSeqLen : " << minSeqLen << " UpIDHandSeq_r : " << UpIDHandSeq_r << endl;

	newlenZ = minSeqLen - rand.rTRgeom(UpIDHandSeq_r, minSeqLen);

	//cout << "7-1" << endl;

	N_psl_lenZ = log((1-UpIDHandSeq_epsilon)/2) + log(UpIDHandSeq_r) + (minSeqLen - newlenZ - 1)*log(1-UpIDHandSeq_r) - log(1 - pow(1-UpIDHandSeq_r, minSeqLen));

	//cout << "7-2 " << endl;

	if(newlenZ >= minSeqLen)
	  cout << "ERROR in UpIDHandSeq_v2 B " << endl;
 
     
	//cout << "8" << endl;

      }else{  // With prob (1-epsilon)/2

	//cout << "9" << endl;
      

	newlenZ = maxSeqLen + rand.rgeom(UpIDHandSeq_r);
	N_psl_lenZ = log((1-UpIDHandSeq_epsilon)/2) + log(UpIDHandSeq_r) + (newlenZ - maxSeqLen - 1)*log(1-UpIDHandSeq_r);
	if(newlenZ <= maxSeqLen)
	  cout << "ERROR in UpIDHandSeq_v2 C " << endl;

	//cout << "10" << endl;


      }

    }else{

      newlenZ = maxSeqLen + rand.rgeom(UpIDHandSeq_r);
      N_psl_lenZ = log(1-UpIDHandSeq_epsilon) + log(UpIDHandSeq_r) + (newlenZ - maxSeqLen - 1)*log(1-UpIDHandSeq_r);
      if(newlenZ <= maxSeqLen)
	cout << "ERROR in UpIDHandSeq_v2 C " << endl;

      //cout << "10" << endl;

    }

    //cout << "11" << endl;

  }


  //cout << "12" << endl;


  // Heejung
  O_IDHlike = edges123[0]->likeliHistory(params);
  O_IDHlike += edges123[1]->likeliHistory(params);
  O_IDHlike += edges123[2]->likeliHistory(params);


  
  //cout << "13" << endl;

  

  // Save old proposal probs, generate new history and get new proposal probs 
  if(nodeZ == edges123[0]->getEnd()){
    edges123[0]->ReverseEdge();
    rev[0] = true;
  }


  //cout << "14" << endl;


  if(nodeZ == edges123[1]->getEnd()){
    edges123[1]->ReverseEdge();
    rev[1] = true;
  }

  //cout << "15" << endl;


  if(nodeZ == edges123[2]->getEnd()){
    edges123[2]->ReverseEdge();
    rev[2] = true;
  }

  //cout << "16" << endl;



  O_psl = edges123[0]->ProposHistory(params);
  O_psl += edges123[1]->ProposHistory(params);
  O_psl += edges123[2]->ProposHistory(params);


  //cout << "17" << endl;



  nodeZ->setSeqLen(newlenZ);

  //cout << "18" << endl;
  


  edges123[0]->runEdge(rand, params);
  edges123[1]->runEdge(rand, params);
  edges123[2]->runEdge(rand, params);


  //cout << "19" << endl;



  N_psl = edges123[0]->ProposHistory(params);
  N_psl += edges123[1]->ProposHistory(params);
  N_psl += edges123[2]->ProposHistory(params);


  //cout << "20" << endl;


  if(rev[0])
    edges123[0]->ReverseEdge();
  if(rev[1])
    edges123[1]->ReverseEdge();
  if(rev[2])
    edges123[2]->ReverseEdge();


  
  //cout << "21" << endl;

  N_IDHlike = edges123[0]->likeliHistory(params);
  N_IDHlike += edges123[1]->likeliHistory(params);
  N_IDHlike += edges123[2]->likeliHistory(params);



  //cout << "22" << endl;


  //Update Tree structure
  
  if(nodeZ->getRoot()){
    

    //cout << "23" << endl;
    

    // 1
    nodes123[0]->UpdateRootSites(params);
    nodes123[1]->UpdateRootSites(params);
    nodes123[2]->UpdateRootSites(params);

    


    // 2
    nodeZ->CalloglikeliofUpdatedLinkedSites(params);

    


    r = params.getR();
    // Heejung
    double logr = log(r);
    double log1_r = log(1-r);
    O_IDHlike +=  logr + origlenZ*log1_r;
    N_IDHlike +=  logr + newlenZ*log1_r;

    //cout << "24" << endl;


  }else{


    //cout << "25" << endl;

    Node* nodeR;
    Node* nodeOthers[2];
 
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(nodeZ == nodeZ->getEdge(i)->getStart()){
	nodeOthers[j] = nodeZ->getEdge(i)->getOtherNode(nodeZ);
	j++;
      }else{
	nodeR = nodeZ->getEdge(i)->getOtherNode(nodeZ);
      }
    }
    
    // 1
    for(i = 0; i < 2; i++)
      nodeOthers[i]->UpdateRootSites(params);
   
    // 2
    nodeZ->CalloglikeliofUpdatedRootSites(params);
    nodeZ->CalSubTreeProb(params);

    if(nodeR->getRoot()){
      // 3
      nodeR->CalloglikeliofUpdatedLinkedSites(params);
    }else{
      // 4 
      nodeR->CalloglikeliofRootSites(params);
      nodeR->CalSubTreeProb(params);

      // 5
      UpdateAllinfoToRoot(params, nodeR->getParent());
    }


    //cout << "26" << endl;



  }



  //cout << "27" << endl;


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];

  // IDH like
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      


  //cout << "28" << endl;

  AP = exp(N_datalike + N_IDHlike + O_psl + O_psl_lenZ - O_datalike - O_IDHlike - N_psl - N_psl_lenZ);

  
  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<  exp( O_psl + O_psl_lenZ - N_psl - N_psl_lenZ) << exp( O_psl_lenZ - N_psl_lenZ) <<   exp(O_psl - N_psl) <<  endl;
  


  rev.resize(0);
 

  return AP;

}








double Tree::UpIDHandSeq(Rand &rand,Parameters &params, ofstream& c, int start) {
 
  int i, j;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  double r;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];

  // Select an adjacent edge e3 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge3 = nodeZ->getEdge(Edgenum);
  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge3->getOtherNode(nodeZ);


  Edge* edges12[2];
  // The other two adjacent edges e1 and e2 connect Z to nodes A and B, respectively. 
  j = 0;
  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(Edgenum!=i){
      edges12[j] = nodeZ->getEdge(i);
      j++;
    }
  }

  Node* nodeA = edges12[0]->getOtherNode(nodeZ);
  Node* nodeB = edges12[1]->getOtherNode(nodeZ);



  // Heejung
  O_IDHlike = edge3->likeliHistory(params);
  O_IDHlike += edges12[0]->likeliHistory(params);
  O_IDHlike += edges12[1]->likeliHistory(params);
  //O_IDHlike = logLikeliIDH[current];
  int O_seqlenZ = nodeZ->getSeqLen();

  // Save old proposal probs, generate new history and get new proposal probs 
  if(nodeZ == edge3->getEnd()){
    O_psl = edge3->ProposHistory2(params);
    O_psl += edges12[0]->ProposHistory(params);
    O_psl += edges12[1]->ProposHistory(params);

    edge3->runEdge2(rand, params);
    edges12[0]->runEdge(rand, params);
    edges12[1]->runEdge(rand, params);

    N_psl = edge3->ProposHistory2(params);
    N_psl += edges12[0]->ProposHistory(params);
    N_psl += edges12[1]->ProposHistory(params);

  }else{
    
    edge3->ReverseEdge();

    if(nodeZ == edges12[0]->getEnd()){
     
      edges12[0]->ReverseEdge();

      O_psl = edge3->ProposHistory2(params);
      O_psl += edges12[0]->ProposHistory(params);
      O_psl += edges12[1]->ProposHistory(params);
      
      edge3->runEdge2(rand, params);
      edges12[0]->runEdge(rand, params);
      edges12[1]->runEdge(rand, params);
      
      N_psl = edge3->ProposHistory2(params);
      N_psl += edges12[0]->ProposHistory(params);
      N_psl += edges12[1]->ProposHistory(params);
      
      edges12[0]->ReverseEdge();
    }else{

      edges12[1]->ReverseEdge();

      O_psl = edge3->ProposHistory2(params);
      O_psl += edges12[0]->ProposHistory(params);
      O_psl += edges12[1]->ProposHistory(params);
      
      edge3->runEdge2(rand, params);
      edges12[0]->runEdge(rand, params);
      edges12[1]->runEdge(rand, params);
      
      N_psl = edge3->ProposHistory2(params);
      N_psl += edges12[0]->ProposHistory(params);
      N_psl += edges12[1]->ProposHistory(params);
      
      edges12[1]->ReverseEdge();
 
    }

    edge3->ReverseEdge();
  
  }


  // Heejung
  N_IDHlike = edge3->likeliHistory(params);
  N_IDHlike += edges12[0]->likeliHistory(params);
  N_IDHlike += edges12[1]->likeliHistory(params);



  //Update Tree structure
  
  if(nodeZ->getRoot()){
    
    // 1
    nodeA->UpdateRootSites(params);
    nodeB->UpdateRootSites(params);
    nodeC->UpdateRootSites(params);

    // 2
    nodeZ->CalloglikeliofUpdatedLinkedSites(params);

    r = params.getR();
    // Heejung
    O_IDHlike +=  log(r) + O_seqlenZ*log(1-r);
    N_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);

  }else{

    Node* nodeR;
    Node* nodeOthers[2];
 
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(nodeZ == nodeZ->getEdge(i)->getStart()){
	nodeOthers[j] = nodeZ->getEdge(i)->getOtherNode(nodeZ);
	j++;
      }else{
	nodeR = nodeZ->getEdge(i)->getOtherNode(nodeZ);
      }
    }
    
    // 1
    for(i = 0; i < 2; i++)
      nodeOthers[i]->UpdateRootSites(params);
   
    // 2
    nodeZ->CalloglikeliofUpdatedRootSites(params);
    nodeZ->CalSubTreeProb(params);

    if(nodeR->getRoot()){
      // 3
      nodeR->CalloglikeliofUpdatedLinkedSites(params);
    }else{
      // 4 
      nodeR->CalloglikeliofRootSites(params);
      nodeR->CalSubTreeProb(params);

      // 5
      UpdateAllinfoToRoot(params, nodeR->getParent());
    }


  }


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];

  // IDH like
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      

  if(start)
    AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
  else
    AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);


  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<  exp(O_psl - N_psl) <<  endl;


  return AP;

}





double Tree::UpIDHandSeq(Rand &rand,Parameters &params, ofstream& c) {
 
  int i, j;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  double r;

  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];

  // Select an adjacent edge e3 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge3 = nodeZ->getEdge(Edgenum);
  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge3->getOtherNode(nodeZ);


  Edge* edges12[2];
  // The other two adjacent edges e1 and e2 connect Z to nodes A and B, respectively. 
  j = 0;
  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(Edgenum!=i){
      edges12[j] = nodeZ->getEdge(i);
      j++;
    }
  }

  Node* nodeA = edges12[0]->getOtherNode(nodeZ);
  Node* nodeB = edges12[1]->getOtherNode(nodeZ);



  // Heejung
  O_IDHlike = edge3->likeliHistory(params);
  O_IDHlike += edges12[0]->likeliHistory(params);
  O_IDHlike += edges12[1]->likeliHistory(params);
  //O_IDHlike = logLikeliIDH[current];
  int O_seqlenZ = nodeZ->getSeqLen();

  // Save old proposal probs, generate new history and get new proposal probs 
  if(nodeZ == edge3->getEnd()){
    O_psl = edge3->ProposHistory2(params);
    O_psl += edges12[0]->ProposHistory(params);
    O_psl += edges12[1]->ProposHistory(params);

    edge3->runEdge2(rand, params);
    edges12[0]->runEdge(rand, params);
    edges12[1]->runEdge(rand, params);

    N_psl = edge3->ProposHistory2(params);
    N_psl += edges12[0]->ProposHistory(params);
    N_psl += edges12[1]->ProposHistory(params);

  }else{
    
    edge3->ReverseEdge();

    if(nodeZ == edges12[0]->getEnd()){
     
      edges12[0]->ReverseEdge();

      O_psl = edge3->ProposHistory2(params);
      O_psl += edges12[0]->ProposHistory(params);
      O_psl += edges12[1]->ProposHistory(params);
      
      edge3->runEdge2(rand, params);
      edges12[0]->runEdge(rand, params);
      edges12[1]->runEdge(rand, params);
      
      N_psl = edge3->ProposHistory2(params);
      N_psl += edges12[0]->ProposHistory(params);
      N_psl += edges12[1]->ProposHistory(params);
      
      edges12[0]->ReverseEdge();
    }else{

      edges12[1]->ReverseEdge();

      O_psl = edge3->ProposHistory2(params);
      O_psl += edges12[0]->ProposHistory(params);
      O_psl += edges12[1]->ProposHistory(params);
      
      edge3->runEdge2(rand, params);
      edges12[0]->runEdge(rand, params);
      edges12[1]->runEdge(rand, params);
      
      N_psl = edge3->ProposHistory2(params);
      N_psl += edges12[0]->ProposHistory(params);
      N_psl += edges12[1]->ProposHistory(params);
      
      edges12[1]->ReverseEdge();
 
    }

    edge3->ReverseEdge();
  
  }


  // Heejung
  N_IDHlike = edge3->likeliHistory(params);
  N_IDHlike += edges12[0]->likeliHistory(params);
  N_IDHlike += edges12[1]->likeliHistory(params);



  //Update Tree structure
  
  if(nodeZ->getRoot()){
    
    // 1
    nodeA->UpdateRootSites(params);
    nodeB->UpdateRootSites(params);
    nodeC->UpdateRootSites(params);

    // 2
    nodeZ->CalloglikeliofUpdatedLinkedSites(params);

    r = params.getR();
    // Heejung
    O_IDHlike +=  log(r) + O_seqlenZ*log(1-r);
    N_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);

  }else{

    Node* nodeR;
    Node* nodeOthers[2];
 
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(nodeZ == nodeZ->getEdge(i)->getStart()){
	nodeOthers[j] = nodeZ->getEdge(i)->getOtherNode(nodeZ);
	j++;
      }else{
	nodeR = nodeZ->getEdge(i)->getOtherNode(nodeZ);
      }
    }
    
    // 1
    for(i = 0; i < 2; i++)
      nodeOthers[i]->UpdateRootSites(params);
   
    // 2
    nodeZ->CalloglikeliofUpdatedRootSites(params);
    nodeZ->CalSubTreeProb(params);

    if(nodeR->getRoot()){
      // 3
      nodeR->CalloglikeliofUpdatedLinkedSites(params);
    }else{
      // 4 
      nodeR->CalloglikeliofRootSites(params);
      nodeR->CalSubTreeProb(params);

      // 5
      UpdateAllinfoToRoot(params, nodeR->getParent());
    }


  }


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];

  // IDH like
  // Heejung
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];
  logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;      

  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

  c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " <<  exp(O_psl - N_psl) <<  endl;


  return AP;

}





double Tree::UpIDHandSeq_v0(Rand &rand,Parameters &params) {

  //int i, j, k, m, tmphmg; 
  int i, j;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  // Select an adjacent edge e3 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge3 = nodeZ->getEdge(Edgenum);

  // This edge (edge3) connects node Z to node C.
  Node* nodeC = edge3->getOtherNode(nodeZ);


  Edge* edges12[2];
  // The other two adjacent edges e1 and e2 connect Z to nodes A and B, respectively. 
  j = 0;
  for(i = 0; i < nodeZ->getnumEdges(); i++){
    if(Edgenum!=i){
      edges12[j] = nodeZ->getEdge(i);
      j++;
    }
  }

  Node* nodeA = edges12[0]->getOtherNode(nodeZ);
  Node* nodeB = edges12[1]->getOtherNode(nodeZ);

  // Save old proposal probs, generate new history and get new proposal probs 
  if(nodeZ == edge3->getEnd()){
    O_psl = edge3->ProposHistory2(params);
    O_psl += edges12[0]->ProposHistory(params);
    O_psl += edges12[1]->ProposHistory(params);

    edge3->runEdge2(rand, params);
    edges12[0]->runEdge(rand, params);
    edges12[1]->runEdge(rand, params);

    N_psl = edge3->ProposHistory2(params);
    N_psl += edges12[0]->ProposHistory(params);
    N_psl += edges12[1]->ProposHistory(params);

  }else{
    
    edge3->ReverseEdge();

    if(nodeZ == edges12[0]->getEnd()){
     
      edges12[0]->ReverseEdge();

      O_psl = edge3->ProposHistory2(params);
      O_psl += edges12[0]->ProposHistory(params);
      O_psl += edges12[1]->ProposHistory(params);
      
      edge3->runEdge2(rand, params);
      edges12[0]->runEdge(rand, params);
      edges12[1]->runEdge(rand, params);
      
      N_psl = edge3->ProposHistory2(params);
      N_psl += edges12[0]->ProposHistory(params);
      N_psl += edges12[1]->ProposHistory(params);
      
      edges12[0]->ReverseEdge();
    }else{

      edges12[1]->ReverseEdge();

      O_psl = edge3->ProposHistory2(params);
      O_psl += edges12[0]->ProposHistory(params);
      O_psl += edges12[1]->ProposHistory(params);
      
      edge3->runEdge2(rand, params);
      edges12[0]->runEdge(rand, params);
      edges12[1]->runEdge(rand, params);
      
      N_psl = edge3->ProposHistory2(params);
      N_psl += edges12[0]->ProposHistory(params);
      N_psl += edges12[1]->ProposHistory(params);
      
      edges12[1]->ReverseEdge();
 
    }

    edge3->ReverseEdge();
  
  }



  //Update Tree structure
  
  if(nodeZ->getRoot()){

    nodeA->UpdateRootSites(params);
    nodeB->UpdateRootSites(params);
    nodeC->UpdateRootSites(params);


    nodeZ->CalloglikeliofUpdatedLinkedSites(params);

  }else{

    Node* nodeR;
    Node* nodeOthers[2];
 
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(nodeZ == nodeZ->getEdge(i)->getStart()){
	nodeOthers[j] = nodeZ->getEdge(i)->getOtherNode(nodeZ);
	j++;
      }else{
	nodeR = nodeZ->getEdge(i)->getOtherNode(nodeZ);
      }
    }
    
    for(i = 0; i < 2; i++)
      nodeOthers[i]->UpdateRootSites(params);
   
    nodeZ->CalloglikeliofUpdatedRootSites(params);
    nodeZ->CalSubTreeProb(params);

    if(nodeR->getRoot()){
      nodeR->CalloglikeliofUpdatedLinkedSites(params);
    }else{
      nodeR->CalloglikeliofRootSites(params);
      nodeR->CalSubTreeProb(params);

      UpdateAllinfoToRoot(params, nodeR->getParent());
    }


  }


  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();
  N_datalike = logLikeliData[current];
  
  O_IDHlike = logLikeliIDH[current];  
  logLikeliIDH[current] = likeliHistory(params);
  N_IDHlike =   logLikeliIDH[current];
  

  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

  return AP;

}


double Tree::UpOneIDH(Rand &rand, Parameters &params, ofstream& c) {

  int i, j, k, m, tmphmg, tmpI, newP;  
  vector<int> HMGin(0);
  double tmpD, r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  int O_seqlenZ, N_seqlenZ;
  bool rev;
  
  InDelHistory* edge0IDH;

  tmphmg = -1;


  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);

  //if(nodeZ == edge0->getEnd()){
  //  edge0->ReverseEdge();
  //  O_psl= edge0->ProposHistory(params);
  //  edge0->ReverseEdge();
  //}else{
  //  O_psl= edge0->ProposHistory(params);
  //}     

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;


  //----- Label nodes end edges ----//
  //j = 0;
  //for(i = 0; i < nodeZ->getnumEdges(); i++){
  //  if(Edgenum!=i){
  //    if(j==0){
  //	edgeA = nodeZ->getEdge(i);
  //	nodeA = edgeA->getOtherNode(nodeZ);
  //	j++;
  //      }else{
  //	edgeB = nodeZ->getEdge(i);
  //	nodeB = edgeB->getOtherNode(nodeZ);	  
  //   }
  //  }
  //}






  double newAlen, newBlen, Ointval, Nintval, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    //lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    if(edgeA->getIDH()->getNumE()>0){
      Ointval = edgeA->getIDH()->getV(2);
      newAlen = edgeA->getEdgeLen() - Ointval;
    }else{
      Ointval = edgeA->getEdgeLen();
      newAlen = 0;
    }

    if(edgeB->getIDH()->getNumE()>0){
      Ointval += edgeB->getIDH()->getV(2);
      newBlen = edgeB->getEdgeLen() - edgeB->getIDH()->getV(2);
    }else{
      Ointval += edgeB->getEdgeLen();
      newBlen = 0;
    }
    
    templen = rand.runif()*(Ointval);
    if(rand.runif() > 0.5)
      templen = Ointval - templen;

    newAlen += templen;
    newBlen += Ointval - templen;
    


    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    N_seqlenZ = nodeZ->getSeqLen();
    if(O_seqlenZ != N_seqlenZ){

      if(nodeZ == edge0->getStart()){
	edge0->ReverseEdge();
	rev = true;
      }else{
	rev = false;
      }

      edge0IDH = edge0->getIDH();
      tmpI = edge0IDH->getNumE();
      
      if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ)){

	N_psl = 1;
	O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	if(O_seqlenZ > N_seqlenZ) // insertion
	  O_psl += -log((double)(N_seqlenZ + 1));
        else  // deletion
	  O_psl += -log((double)(O_seqlenZ + 1));
	
	// delete the last event 
	edge0IDH->eraseHistory(false, tmpI);
	edge0IDH->eraseHistory(true, tmpI);
	edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));

	edge0->calHMG();   

      }else{

	O_psl = 1;

	tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	edge0IDH->eraseHistory(true, tmpI+1);
	if(O_seqlenZ > N_seqlenZ){ // deletion
	  newP = (int)(rand.runif()*(N_seqlenZ + 1));
	  N_psl += -log((double)(N_seqlenZ + 1));
	  HMGin.resize(0);
	  HMGin = edge0IDH->getHMG(tmpI);
	  for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	    HMGin.erase(HMGin.begin()+ newP);
	  } 
	  edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	  HMGin.resize(0);
        }else{  // insertion
	  newP = (int)(rand.runif()*(O_seqlenZ + 1));
	  N_psl += -log((double)(O_seqlenZ + 1));
	  HMGin.resize(0);
	  HMGin = edge0IDH->getHMG(tmpI);
	  for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	    HMGin.insert(HMGin.begin()+ newP,tmphmg);
	  }
	  edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	  HMGin.resize(0);
	}
	// add the last
	edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));

	edge0->calHMG();   

      }
     
      if(rev)
	edge0->ReverseEdge();

    }else{
      O_psl = 1;
      N_psl = 1;
    }
      
    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    if(edgeA->getIDH()->getNumE()>0){
      Ointval = edgeA->getIDH()->getV(2);
      newAlen = edgeA->getEdgeLen() - Ointval;
    }else{
      Ointval = edgeA->getEdgeLen();
      newAlen = 0;
    }

    if(edgeB->getIDH()->getNumE()>0){
      Ointval += edgeB->getIDH()->getV(2);
      newBlen = edgeB->getEdgeLen() - edgeB->getIDH()->getV(2);
    }else{
      Ointval += edgeB->getEdgeLen();
      newBlen = 0;
    }
    

    templen = rand.runif()*(Ointval);
    if(rand.runif() > 0.5)
      templen = Ointval - templen;

    newAlen += templen;
    newBlen += Ointval - templen;



    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //

    N_seqlenZ = nodeZ->getSeqLen();
    if(O_seqlenZ != N_seqlenZ){

      if(nodeZ == edge0->getStart()){
	edge0->ReverseEdge();
	rev = true;
      }else{
	rev = false;
      }

      edge0IDH = edge0->getIDH();
      tmpI = edge0IDH->getNumE();
      
      if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ)){

	N_psl = 1;
	O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	if(O_seqlenZ > N_seqlenZ) // insertion
	  O_psl += -log((double)(N_seqlenZ + 1));
        else  // deletion
	  O_psl += -log((double)(O_seqlenZ + 1));
	
	// delete the last event 
	edge0IDH->eraseHistory(false, tmpI);
	edge0IDH->eraseHistory(true, tmpI);
	edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));

	edge0->calHMG();   

      }else{

	O_psl = 1;

	tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	edge0IDH->eraseHistory(true, tmpI+1);
	if(O_seqlenZ > N_seqlenZ){ // deletion
	  newP = (int)(rand.runif()*(N_seqlenZ + 1));
	  N_psl += -log((double)(N_seqlenZ + 1));
	  HMGin.resize(0);
	  HMGin = edge0IDH->getHMG(tmpI);
	  for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	    HMGin.erase(HMGin.begin()+ newP);
	  }
	  edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	  HMGin.resize(0);
        }else{  // insertion
	  newP = (int)(rand.runif()*(O_seqlenZ + 1));
	  N_psl += -log((double)(O_seqlenZ + 1));
	  HMGin.resize(0);
	  HMGin = edge0IDH->getHMG(tmpI);
	  for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	    HMGin.insert(HMGin.begin()+ newP,tmphmg);
	  }
	  edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	  HMGin.resize(0);
	}
	// add the last
	edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));

	edge0->calHMG();   

      }
     
      if(rev)
	edge0->ReverseEdge();

    }else{
      O_psl = 1;
      N_psl = 1;
    }
            
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    
   //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    if(edgeA->getIDH()->getNumE()>0){
      Ointval = edgeA->getIDH()->getV(edgeA->getIDH()->getNumE()-1);
      newAlen = edgeA->getEdgeLen() - Ointval;
    }else{
      Ointval = edgeA->getEdgeLen();
      newAlen = 0;
    }

    if(edgeB->getIDH()->getNumE()>0){
      Ointval += edgeB->getIDH()->getV(2);
      newBlen = edgeB->getEdgeLen() - edgeB->getIDH()->getV(2);
    }else{
      Ointval += edgeB->getEdgeLen();
      newBlen = 0;
    }
    
    templen = rand.runif()*(Ointval);
    if(rand.runif() > 0.5)
      templen = Ointval - templen;

    newAlen += templen;
    newBlen += Ointval - templen;
    

    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//
    N_seqlenZ = nodeZ->getSeqLen();
    if(O_seqlenZ != N_seqlenZ){

      if(nodeZ == edge0->getStart()){
	edge0->ReverseEdge();
	rev = true;
      }else{
	rev = false;
      }

      edge0IDH = edge0->getIDH();
      tmpI = edge0IDH->getNumE();
      
      if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ)){

	N_psl = 1;
	O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	if(O_seqlenZ > N_seqlenZ) // insertion
	  O_psl += -log((double)(N_seqlenZ + 1));
        else  // deletion
	  O_psl += -log((double)(O_seqlenZ + 1));
	
	// delete the last event 
	edge0IDH->eraseHistory(false, tmpI);
	edge0IDH->eraseHistory(true, tmpI);
	edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));

	edge0->calHMG();   

      }else{

	O_psl = 1;

	tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	edge0IDH->eraseHistory(true, tmpI+1);
	if(O_seqlenZ > N_seqlenZ){ // deletion
	  newP = (int)(rand.runif()*(N_seqlenZ + 1));
	  N_psl += -log((double)(N_seqlenZ + 1));
	  HMGin.resize(0);
	  HMGin = edge0IDH->getHMG(tmpI);
	  for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	    HMGin.erase(HMGin.begin()+ newP);
	  }
	  edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	  HMGin.resize(0);
        }else{  // insertion
	  newP = (int)(rand.runif()*(O_seqlenZ + 1));
	  N_psl += -log((double)(O_seqlenZ + 1));
	  HMGin.resize(0);
	  HMGin = edge0IDH->getHMG(tmpI);
	  for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	    HMGin.insert(HMGin.begin()+ newP,tmphmg);
	  }
	  edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	  HMGin.resize(0);
	}
	// add the last
	edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));

	edge0->calHMG();   

      }
     
      if(rev)
	edge0->ReverseEdge();

    }else{
      O_psl = 1;
      N_psl = 1;
    }
               
   //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  //if(nodeZ == edge0->getEnd()){
  //  edge0->ReverseEdge();
  //  N_psl= edge0->ProposHistory(params);
  //  edge0->ReverseEdge();
  //}else{
  //  N_psl= edge0->ProposHistory(params);
  //}           

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];




  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);

  c << AP << " " << exp(N_datalike -  O_datalike) << exp(N_IDHlike - O_IDHlike) << exp(O_psl - N_psl) <<  endl;
 
  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 





double Tree::UpOneIDHfixHMG(Rand &rand, Parameters &params, ofstream& c) {

  int i, j, k, m, tmphmg, tmpI, newP;  
  vector<int> HMGin(0);
  double tmpD, r, AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl;
  int O_seqlenZ, N_seqlenZ;
  bool rev;
  bool dirA; 

  InDelHistory* edge0IDH;

  tmphmg = -1;


  // Select an internal node Z at random.
  Node* nodeZ = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];
  O_seqlenZ = nodeZ->getSeqLen();

  // Select an adjacent edge e0 at random.
  int Edgenum = (int)(rand.runif()*nodeZ->getnumEdges());
  Edge* edge0 = nodeZ->getEdge(Edgenum);

  // Heejung
  //O_IDHlike = logLikeliIDH[current];
  O_IDHlike = edge0->likeliHistory(params);

  //if(nodeZ == edge0->getEnd()){
  //  edge0->ReverseEdge();
  //  O_psl= edge0->ProposHistory(params);
  //  edge0->ReverseEdge();
  //}else{
  //  O_psl= edge0->ProposHistory(params);
  //}     

  // This edge (edge0) connects node Z to node C.
  Node* nodeC = edge0->getOtherNode(nodeZ);


  Node* nodeA;
  Node* nodeB;
  Edge* edgeA;
  Edge* edgeB;


  //----- Label nodes end edges ----//
  //j = 0;
  //for(i = 0; i < nodeZ->getnumEdges(); i++){
  //  if(Edgenum!=i){
  //    if(j==0){
  //	edgeA = nodeZ->getEdge(i);
  //	nodeA = edgeA->getOtherNode(nodeZ);
  //	j++;
  //      }else{
  //	edgeB = nodeZ->getEdge(i);
  //	nodeB = edgeB->getOtherNode(nodeZ);	  
  //   }
  //  }
  //}






  double newAlen, newBlen, Ointval, Nintval, templen;

  // Set 0 at UpdatedNodeinRootSites
  set0UpdatedNodeinRootSites(); 
  
  // Determine which case should be applied and assign labels to nodes and edges
  if(nodeZ->getRoot()){

    //----------------------//
    //                      //
    //       caseIIa         //
    //                      //
    //----------------------//
    
    
    //cout << "caseIIa" << endl;
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
    
    //--- Assign new position --//
    //lenAandB = edgeA->getEdgeLen()+ edgeB->getEdgeLen();
    if(edgeA->getIDH()->getNumE()>0){
      Ointval = edgeA->getIDH()->getV(2);
      newAlen = edgeA->getEdgeLen() - Ointval;
    }else{
      Ointval = edgeA->getEdgeLen();
      newAlen = 0;
    }

    if(edgeB->getIDH()->getNumE()>0){
      Ointval += edgeB->getIDH()->getV(2);
      newBlen = edgeB->getEdgeLen() - edgeB->getIDH()->getV(2);
    }else{
      Ointval += edgeB->getEdgeLen();
      newBlen = 0;
    }
    
    templen = rand.runif()*(Ointval);
    if(rand.runif() > 0.5)
      templen = Ointval - templen;

    newAlen += templen;
    newBlen += Ointval - templen;


    if(newAlen < edgeA->getEdgeLen()){
      dirA = true;
      if(edgeA->getEdgeLen() - newAlen < edgeA->getIDH()->getV(1))
	N_seqlenZ = O_seqlenZ;
      else
	N_seqlenZ = edgeA->getIDH()->getN(1);
    }else{
      dirA = false;
      if(edgeB->getEdgeLen() - newBlen < edgeB->getIDH()->getV(1))
	N_seqlenZ = O_seqlenZ;
      else
	N_seqlenZ = edgeB->getIDH()->getN(1);      
    }

    if(O_seqlenZ != N_seqlenZ){

      if(nodeZ == edge0->getStart()){
	edge0->ReverseEdge();
	rev = true;
      }else{
	rev = false;
      }

      edge0IDH = edge0->getIDH();
      tmpI = edge0IDH->getNumE();
      
      if(dirA){

	if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ) & (edgeA->getIDH()->getID(1) == edge0IDH->getID(tmpI)) & (edgeA->getIDH()->getP(1) == edge0IDH->getP(tmpI)) & (edgeA->getIDH()->getL(1) == edge0IDH->getL(tmpI)) & (edgeA->getIDH()->getN(1) == edge0IDH->getN(tmpI))){
	  // remove one event
	    
	  N_psl = 1;
	  O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	  
	  // delete the last event 
	  edge0IDH->eraseHistory(false, tmpI);
	  edge0IDH->eraseHistory(true, tmpI);
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));
	  
	  edge0->calHMG();
	  
	}else{
	  // not remove one event, put one event

	  O_psl = 1;
	  
	  tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	  N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	  edge0IDH->eraseHistory(true, tmpI+1);
	  if(edgeA->getIDH()->getID(1) == -1){ // deletion
	    newP = edgeA->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	      HMGin.erase(HMGin.begin()+ newP);
	    } 
	    edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }else{  // insertion
	    newP = edgeA->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	      HMGin.insert(HMGin.begin()+ newP,tmphmg);
	    }
	    edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }
	  // add the last
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));
	  
	  edge0->calHMG();   
	  
	} // End of else (not remove one event 

      }else{ // else of if(dirA)

	if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ) & (edgeB->getIDH()->getID(1) == edge0IDH->getID(tmpI)) & (edgeB->getIDH()->getP(1) == edge0IDH->getP(tmpI)) & (edgeB->getIDH()->getL(1) == edge0IDH->getL(tmpI)) & (edgeB->getIDH()->getN(1) == edge0IDH->getN(tmpI))){
	  // remove one event

	  N_psl = 1;
	  O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	  
	  // delete the last event 
	  edge0IDH->eraseHistory(false, tmpI);
	  edge0IDH->eraseHistory(true, tmpI);
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));
	  
	  edge0->calHMG();
	  
	  
	}else{
	  // not remove one event
	  
	  O_psl = 1;
	  
	  tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	  N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	  edge0IDH->eraseHistory(true, tmpI+1);
	  if(edgeB->getIDH()->getID(1) == -1){ // deletion
	    newP = edgeB->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	      HMGin.erase(HMGin.begin()+ newP);
	    } 
	    edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }else{  // insertion
	    newP = edgeB->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	      HMGin.insert(HMGin.begin()+ newP,tmphmg);
	    }
	    edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }
	  // add the last
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));
	  
	  edge0->calHMG();   
	  
	} // End of else (not remove one event)

      } // Else of if(dirA)  (dirB)

      if(rev)
	edge0->ReverseEdge();
      
    }else{ // Else of if(O_seqlenZ != N_seqlenZ){
      O_psl = 1;
      N_psl = 1;
    }
    


    //----- Reconstruct a tree ---------------------------------------//

    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//

    //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    nodeZ->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
	
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }else if(nodeZ->getParentEdge()==edge0){
    
    //----------------------//
    //                      //
    //       caseII         //
    //                      //
    //----------------------//
    
    
    //cout << "caseII " << endl;
    //checkTree();
    
    //----- Label nodes end edges ----//
    j = 0;
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(j==0){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	  j++;
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }
   
    //--- Assign new position --//
    if(edgeA->getIDH()->getNumE()>0){
      Ointval = edgeA->getIDH()->getV(2);
      newAlen = edgeA->getEdgeLen() - Ointval;
    }else{
      Ointval = edgeA->getEdgeLen();
      newAlen = 0;
    }

    if(edgeB->getIDH()->getNumE()>0){
      Ointval += edgeB->getIDH()->getV(2);
      newBlen = edgeB->getEdgeLen() - edgeB->getIDH()->getV(2);
    }else{
      Ointval += edgeB->getEdgeLen();
      newBlen = 0;
    }
    

    templen = rand.runif()*(Ointval);
    if(rand.runif() > 0.5)
      templen = Ointval - templen;

    newAlen += templen;
    newBlen += Ointval - templen;


    if(newAlen < edgeA->getEdgeLen()){
      dirA = true;
      if(edgeA->getEdgeLen() - newAlen < edgeA->getIDH()->getV(1))
	N_seqlenZ = O_seqlenZ;
      else
	N_seqlenZ = edgeA->getIDH()->getN(1);
    }else{
      dirA = false;
      if(edgeB->getEdgeLen() - newBlen < edgeB->getIDH()->getV(1))
	N_seqlenZ = O_seqlenZ;
      else
	N_seqlenZ = edgeB->getIDH()->getN(1);      
    }

    if(O_seqlenZ != N_seqlenZ){

      if(nodeZ == edge0->getStart()){
	edge0->ReverseEdge();
	rev = true;
      }else{
	rev = false;
      }

      edge0IDH = edge0->getIDH();
      tmpI = edge0IDH->getNumE();
      
      if(dirA){

	if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ) & (edgeA->getIDH()->getID(1) == edge0IDH->getID(tmpI)) & (edgeA->getIDH()->getP(1) == edge0IDH->getP(tmpI)) & (edgeA->getIDH()->getL(1) == edge0IDH->getL(tmpI)) & (edgeA->getIDH()->getN(1) == edge0IDH->getN(tmpI))){
	  // remove one event
	    
	  N_psl = 1;
	  O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	  
	  // delete the last event 
	  edge0IDH->eraseHistory(false, tmpI);
	  edge0IDH->eraseHistory(true, tmpI);
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));
	  
	  edge0->calHMG();
	  
	}else{
	  // not remove one event, put one event

	  O_psl = 1;
	  
	  tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	  N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	  edge0IDH->eraseHistory(true, tmpI+1);
	  if(edgeA->getIDH()->getID(1) == -1){ // deletion
	    newP = edgeA->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	      HMGin.erase(HMGin.begin()+ newP);
	    } 
	    edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }else{  // insertion
	    newP = edgeA->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	      HMGin.insert(HMGin.begin()+ newP,tmphmg);
	    }
	    edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }
	  // add the last
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));
	  
	  edge0->calHMG();   
	  
	} // End of else (not remove one event 

      }else{ // else of if(dirA)

	if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ) & (edgeB->getIDH()->getID(1) == edge0IDH->getID(tmpI)) & (edgeB->getIDH()->getP(1) == edge0IDH->getP(tmpI)) & (edgeB->getIDH()->getL(1) == edge0IDH->getL(tmpI)) & (edgeB->getIDH()->getN(1) == edge0IDH->getN(tmpI))){
	  // remove one event

	  N_psl = 1;
	  O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	  
	  // delete the last event 
	  edge0IDH->eraseHistory(false, tmpI);
	  edge0IDH->eraseHistory(true, tmpI);
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));
	  
	  edge0->calHMG();
	  
	  
	}else{
	  // not remove one event
	  
	  O_psl = 1;
	  
	  tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	  N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	  edge0IDH->eraseHistory(true, tmpI+1);
	  if(edgeB->getIDH()->getID(1) == -1){ // deletion
	    newP = edgeB->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	      HMGin.erase(HMGin.begin()+ newP);
	    } 
	    edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }else{  // insertion
	    newP = edgeB->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	      HMGin.insert(HMGin.begin()+ newP,tmphmg);
	    }
	    edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }
	  // add the last
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));
	  
	  edge0->calHMG();   
	  
	} // End of else (not remove one event)

      } // Else of if(dirA)  (dirB)

      if(rev)
	edge0->ReverseEdge();
      
    }else{ // Else of if(O_seqlenZ != N_seqlenZ){
      O_psl = 1;
      N_psl = 1;
    }
    





    //----- Reconstruct a tree ---------------------------------------//
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();
    
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
  
    //      : Reverse IDH and change start and end nodes on edgeA
    edgeA->ReverseEdge();

    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeA->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//    
    //      : Generate new IDH on e0         //


  
   //checkTree();
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1
    nodeA->findRootSites();
    nodeB->findRootSites();
    nodeZ->findRootSites();     
    
    // 1'
    if(nodeC->getRoot())
      nodeC->findLinkedSites();
    
    //3
    nodeA->CalSubTreeProb(params);
    nodeA->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeA->getnumber()] = 1;
    
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
        
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    r = params.getR();
    O_IDHlike +=  log(r) + nodeZ->getSeqLen()*log(1-r);
    N_IDHlike = edge0->likeliHistory(params) + log(r) + O_seqlenZ*log(1-r);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;  
   
  }else{

    //----------------------//
    //                      //
    //       caseI          //
    //                      //
    //----------------------//
    
    //cout << "caseI " << endl;
    //checkTree();
    
    //----- Label nodes end edges ----//
    for(i = 0; i < nodeZ->getnumEdges(); i++){
      if(Edgenum!=i){
	if(nodeZ->getparentIndex()==i){
	  edgeA = nodeZ->getEdge(i);
	  nodeA = edgeA->getOtherNode(nodeZ);
	}else{
	  edgeB = nodeZ->getEdge(i);
	  nodeB = edgeB->getOtherNode(nodeZ);	  
	}
      }
    }

    bool revA, revB;
    if(nodeZ == edgeA->getEnd()){
      edgeA->ReverseEdge();
      revA = true;
    }else{
      revA = false;
    }
    if(nodeZ == edgeB->getEnd()){
      edgeB->ReverseEdge();
      revB = true;
    }else{
      revB = false;
    }    
    
   
    //--- Assign new position --//
    if(edgeA->getIDH()->getNumE()>0){
      Ointval = edgeA->getIDH()->getV(2);
      newAlen = edgeA->getEdgeLen() - Ointval;
    }else{
      Ointval = edgeA->getEdgeLen();
      newAlen = 0;
    }

    if(edgeB->getIDH()->getNumE()>0){
      Ointval += edgeB->getIDH()->getV(2);
      newBlen = edgeB->getEdgeLen() - edgeB->getIDH()->getV(2);
    }else{
      Ointval += edgeB->getEdgeLen();
      newBlen = 0;
    }
    
    templen = rand.runif()*(Ointval);
    if(rand.runif() > 0.5)
      templen = Ointval - templen;

    newAlen += templen;
    newBlen += Ointval - templen;



    if(newAlen < edgeA->getEdgeLen()){
      dirA = true;
      if(edgeA->getEdgeLen() - newAlen < edgeA->getIDH()->getV(1))
	N_seqlenZ = O_seqlenZ;
      else
	N_seqlenZ = edgeA->getIDH()->getN(1);
    }else{
      dirA = false;
      if(edgeB->getEdgeLen() - newBlen < edgeB->getIDH()->getV(1))
	N_seqlenZ = O_seqlenZ;
      else
	N_seqlenZ = edgeB->getIDH()->getN(1);      
    }

    if(O_seqlenZ != N_seqlenZ){

      if(nodeZ == edge0->getStart()){
	edge0->ReverseEdge();
	rev = true;
      }else{
	rev = false;
      }

      edge0IDH = edge0->getIDH();
      tmpI = edge0IDH->getNumE();
      
      if(dirA){

	if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ) & (edgeA->getIDH()->getID(1) == edge0IDH->getID(tmpI)) & (edgeA->getIDH()->getP(1) == edge0IDH->getP(tmpI)) & (edgeA->getIDH()->getL(1) == edge0IDH->getL(tmpI)) & (edgeA->getIDH()->getN(1) == edge0IDH->getN(tmpI))){
	  // remove one event
	    
	  N_psl = 1;
	  O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	  
	  // delete the last event 
	  edge0IDH->eraseHistory(false, tmpI);
	  edge0IDH->eraseHistory(true, tmpI);
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));
	  
	  edge0->calHMG();
	  
	}else{
	  // not remove one event, put one event

	  O_psl = 1;
	  
	  tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	  N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	  edge0IDH->eraseHistory(true, tmpI+1);
	  if(edgeA->getIDH()->getID(1) == -1){ // deletion
	    newP = edgeA->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	      HMGin.erase(HMGin.begin()+ newP);
	    } 
	    edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }else{  // insertion
	    newP = edgeA->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	      HMGin.insert(HMGin.begin()+ newP,tmphmg);
	    }
	    edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }
	  // add the last
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));
	  
	  edge0->calHMG();   
	  
	} // End of else (not remove one event 

      }else{ // else of if(dirA)

	if((tmpI > 0) & (edge0IDH->getN(tmpI - 1) == N_seqlenZ) & (edgeB->getIDH()->getID(1) == edge0IDH->getID(tmpI)) & (edgeB->getIDH()->getP(1) == edge0IDH->getP(tmpI)) & (edgeB->getIDH()->getL(1) == edge0IDH->getL(tmpI)) & (edgeB->getIDH()->getN(1) == edge0IDH->getN(tmpI))){
	  // remove one event

	  N_psl = 1;
	  O_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI - 1));
	  
	  // delete the last event 
	  edge0IDH->eraseHistory(false, tmpI);
	  edge0IDH->eraseHistory(true, tmpI);
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI-1), edge0IDH->getHMG(tmpI-1));
	  
	  edge0->calHMG();
	  
	  
	}else{
	  // not remove one event
	  
	  O_psl = 1;
	  
	  tmpD =  rand.runif()*(edge0->getEdgeLen() - edge0IDH->getV(tmpI)) + edge0IDH->getV(tmpI);
	  N_psl = -log(edge0->getEdgeLen() - edge0IDH->getV(tmpI));
	  edge0IDH->eraseHistory(true, tmpI+1);
	  if(edgeB->getIDH()->getID(1) == -1){ // deletion
	    newP = edgeB->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (O_seqlenZ - N_seqlenZ); k++){
	      HMGin.erase(HMGin.begin()+ newP);
	    } 
	    edge0IDH->addHistory(false, tmpD, -1, newP, O_seqlenZ - N_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }else{  // insertion
	    newP = edgeB->getIDH()->getP(1);
	    HMGin.resize(0);
	    HMGin = edge0IDH->getHMG(tmpI);
	    for( k = 0; k< (N_seqlenZ - O_seqlenZ); k++){
	      HMGin.insert(HMGin.begin()+ newP,tmphmg);
	    }
	    edge0IDH->addHistory(false, tmpD, 1, newP, N_seqlenZ - O_seqlenZ, N_seqlenZ, HMGin);
	    HMGin.resize(0);
	  }
	  // add the last
	  edge0IDH->addHistory(true, edge0->getEdgeLen(), -2, 0, 0, edge0IDH->getN(tmpI+1), edge0IDH->getHMG(tmpI+1));
	  
	  edge0->calHMG();   
	  
	} // End of else (not remove one event)

      } // Else of if(dirA)  (dirB)

      if(rev)
	edge0->ReverseEdge();
      
    }else{ // Else of if(O_seqlenZ != N_seqlenZ){
      O_psl = 1;
      N_psl = 1;
    }
    


    if(revA)
      edgeA->ReverseEdge();
    
    if(revB)
      edgeB->ReverseEdge();
               





    //----- Reconstruct a tree ---------------------------------------//
    //      : Change IDH and edge length of edge A and edge B   
    moveNodeOnTwoEdges(edgeA, edgeB, newAlen, newBlen);
    
    //----- Reconstruct a tree --------------//
    //      : Change sequence length at Z    //
    nodeZ->setSeqLen(edgeB->getIDH()->getN(0));
    
    
    //----- Reconstruct a tree --------------//

               
   //checkTree();
    
    
    //----- Update gijk, rootSites, LinkedSites and likelihood --------//
    // 1  
    nodeZ->findRootSites();        
    nodeB->findRootSites();
    nodeC->findRootSites();     
    
    // 1'
    if(nodeA->getRoot())
      nodeA->findLinkedSites();
    
    // 2
    nodeC->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeC->getnumber()] = 1;
    
    //3      
    nodeB->CalSubTreeProb(params);
    nodeB->CalloglikeliofRootSitesOrReuse(params);
    UpdatedNodeinRootSites[current][nodeB->getnumber()] = 1;
    
    // 4
    UpdateAllinfoToRoot(params, nodeZ); 
    
   //checkTree();
    
    // Update IDHlikelihood
    // Heejung
    N_IDHlike = edge0->likeliHistory(params);   
    logLikeliIDH[current] = logLikeliIDH[current] - O_IDHlike + N_IDHlike;

  }
    


  // data like
  O_datalike = logLikeliData[current];
  logLikeliData[current] = likeliData();    
  N_datalike = logLikeliData[current];


  // IDH like
  // Done at each case
  edgeA->likeliHistory(params);
  edgeB->likeliHistory(params);


  // Edge like
  edgeA->CalculatelogLikeliEdge(params);
  edgeB->CalculatelogLikeliEdge(params);
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
    
  //if(nodeZ == edge0->getEnd()){
  //  edge0->ReverseEdge();
  //  N_psl= edge0->ProposHistory(params);
  //  edge0->ReverseEdge();
  //}else{
  //  N_psl= edge0->ProposHistory(params);
  //}           

  
  //logLikeliIDH[current] = likeliHistory(params);
  //N_IDHlike = logLikeliIDH[current];




  AP = exp(N_datalike + N_IDHlike + O_psl - O_datalike - O_IDHlike - N_psl);
 
  c << AP << " " << exp(N_datalike -  O_datalike) << exp(N_IDHlike - O_IDHlike) << exp(O_psl - N_psl) <<  endl;


  return AP;


} // SPRonSingleEdgeAsPartOfSPRonSubTree 








int Tree::findSmallest(vector<int> &smallest, Node *node, Edge *edge) const {
  int num=edge->getnumber();
  Node *n=edge->getOtherNode(node);
  if(n->getLeaf())
    smallest[num] = n->getnumber();
  else {
    smallest[num] = numNodes;
    for(int i=0;i<3;i++)
      if(n->getEdge(i)!=edge) {
	smallest[num] = min(smallest[num],findSmallest(smallest,n,n->getEdge(i)));
      }
  }
  return smallest[num];
}







void Tree::print(ofstream& c)
{
  //cout << "printTree " << endl;
  vector<int> smallest(numEdges);
  c << "(";
  //cout << "(";
  findSmallest(smallest,nodes[outGroupNode],nodes[outGroupNode]->getEdge(0));
  printInt(c,smallest,nodes[outGroupNode],nodes[outGroupNode]->getEdge(0));
  c << "," << nodes[outGroupNode]->getnumber()+1 << ")";
  c << ";" << endl;
  smallest.resize(0);
  return;
}

void Tree::printBL(ofstream& c)
{
  //c << "printBL " << endl;
  //cout << "printBL " << endl;
  vector<int> smallest(numEdges);
  c << "(";
  Edge *edge=nodes[outGroupNode]->getEdge(0);
  findSmallest(smallest,nodes[outGroupNode],edge);
  if(numLeaves==2)
    c << "(" << edge->getOtherNode(nodes[outGroupNode])->getnumber()+1 
      << "," << nodes[outGroupNode]->getnumber()+1 << ":" << edge->getEdgeLen() << ");";
  printIntBL(c,smallest,nodes[outGroupNode],edge);
  c << "," << nodes[outGroupNode]->getnumber()+1 << ":0);"; 
  c << ";" << endl;
  smallest.resize(0);
  return;
}




void Tree::printInt(ofstream& c, vector<int> &smallest, Node *node, Edge *edge) const {
  Node *n=edge->getOtherNode(node);
  if(n->getLeaf())
    c << n->getnumber()+1;
  else {
    int numOthers=0;
    Edge *other[2];
    for(int i=0;i<3;i++)
      if(n->getEdge(i)!=edge)
	other[numOthers++] = n->getEdge(i);
    if(smallest[other[0]->getnumber()]>smallest[other[1]->getnumber()])
      swap(other[0],other[1]);
    c << "(";
    printInt(c,smallest,n,other[0]);
    c << ",";
    printInt(c,smallest,n,other[1]);
    c << ")";
  }
}


void Tree::printIntBL(ofstream& c, vector<int> &smallest, Node *node, Edge *edge) const {
  Node *n=edge->getOtherNode(node);
  if(n->getLeaf())
    c << n->getnumber()+1 << ":" << edge->getEdgeLen();
  else {
    int numOthers=0;
    Edge *other[2];
    for(int i=0;i<3;i++)
      if(n->getEdge(i)!=edge)
	other[numOthers++] = n->getEdge(i);
    if(smallest[other[0]->getnumber()]>smallest[other[1]->getnumber()])
      swap(other[0],other[1]);
    c << "(";
    printIntBL(c,smallest,n,other[0]);
    c << ",";
    printIntBL(c,smallest,n,other[1]);
    c << "):" << edge->getEdgeLen();
  }
}

/*
//For pos position at a sequence in a given Node, homologous letters in a subtree with a given Node as a root are saved at align
void Node::getAlignment(int pos, vector<int> &align, vector<vector<int> > &alignS){


  int tmp;
  int nextpos;
  int i, j, k;
  int num; 
  Edge* tEdge;
  Node* tNode;
  vector<int> talign(0);
  int len = align.size();

  if(getLeaf()){
    //align[getnumber()] = seq[pos];
    align[getnumber()] = pos;
  }else{
    for(i = 0; i < getnumEdges(); i++){
      if(i != getparentIndex()){
	tEdge = getEdge(i);
	tNode = tEdge->getEnd();
	nextpos = tEdge->getHMG(pos);
	if(nextpos >= tNode->getSeqLen())
	  cout << "ERROR in getAlignment! nextpos is out of a range" << endl;
	if(nextpos >= 0){

	  // check there is any rooted sites before nextpos
	  tmp = nextpos - 1;
	  num = 0;
	  if(tmp >= 0){
	    while(tNode->getrootSites(tmp) == 1){
	      num++;
	      tmp = nextpos - 1 - num;
	      if(tmp < 0)
		break;
	    }
          }
	  
	  // Get alignment that rooted sites
	  if(num > 0){
	    for(j = num; j > 0; j--){
	      for(k = 0; k < len; k++)
		talign.push_back(-1);
	      tNode->getAlignment(nextpos - num, talign, alignS);
	      if(max_veci(talign) >= 0){
		alignS.push_back(talign);
              }
	      talign.resize(0);
            }
	  }
   
          // Get alignment with a given position
          tNode->getAlignment(nextpos, align, alignS);
	  
        }
      }
    }
  }
}


void Tree::getAlignments(vector<vector<int> > &alignS){

  vector<int> align(0);
  int i, j, rootSeqLen;
  Node* root;
  root = getRoot();
  rootSeqLen = root->getSeqLen();
  
  
  alignS.resize(0);

  // Get alignments
  for(i = 0; i < rootSeqLen; i++){
    for(j = 0; j < numLeaves; j++)
      align.push_back(-1);
    if(root->getLinkedSites(i)==1)
      root->getAlignment(i, align, alignS);
    if(max_veci(align) >= 0)
      alignS.push_back(align);
    align.resize(0);
  }

  align.resize(0);

}

*/











//For pos position at a sequence in a given Node, homologous letters in a subtree with a given Node as a root are saved at align
void Node::getAlignment(int pos, vector<int> &align, vector<vector<int> > &alignS){



  //cout << "In Node::getAlignment " << endl;
  //cout << "pos : " << pos << endl;



  

  bool last;
  int tmp;
  int nextpos;
  int i, j, k;
  int num; 
  Edge* tEdge;
  Node* tNode;
  vector<int> talign(0);
  int len = align.size();

  if(getLeaf()){
    //cout << "Leaf" << endl;
    //align[getnumber()] = seq[pos];
    align[getnumber()] = pos;
  }else{
    //cout << "Not leaf " << endl;
    for(i = 0; i < getnumEdges(); i++){
      if(i != getparentIndex()){
	tEdge = getEdge(i);
        //cout << "Edge num : " << tEdge->getnumber() << endl;
	tNode = tEdge->getEnd();
	nextpos = tEdge->getHMG(pos);
	//cout << "nextpos " << nextpos << endl;

	if(nextpos >= tNode->getSeqLen())
	  cout << "ERROR in getAlignment! nextpos is out of a range" << endl;
	if(nextpos >= 0){

	  // check there is any rooted sites before nextpos
	  tmp = nextpos - 1;
	  num = 0;
	  if(tmp >= 0){
	    while(tNode->getrootSites(tmp) == 1){
	      num++;
	      tmp = nextpos - 1 - num;
	      if(tmp < 0)
		break;
	    }
          }

	  //cout << "num : " << num << endl;
	  
	  // Get alignment that rooted sites
	  if(num > 0){
	    for(j = num; j > 0; j--){
	      for(k = 0; k < len; k++)
		talign.push_back(-1);
	      tNode->getAlignment(nextpos - j, talign, alignS);
	      if(max_veci(talign) >= 0){
		alignS.push_back(talign);
              }
	      talign.resize(0);
            }
	  }
   
          // Get alignment with a given position
          tNode->getAlignment(nextpos, align, alignS);


	  if(nextpos == tNode->getLastLinkedPosi())
	    last = true;


	  // Get alignment that rooted sites (Rest rooted sites) 
	  if((last) & (nextpos < (tNode->getSeqLen()-1))){
	    //cout << "AA " << endl;
	    for(j = (nextpos+1); j < tNode->getSeqLen(); j++){
	      talign.resize(0);
	      for(k = 0; k < len; k++)
		talign.push_back(-1);
	      tNode->getAlignment(j, talign, alignS);
	      if(max_veci(talign) >= 0){
		alignS.push_back(talign);
              }
	      talign.resize(0);
            }	    
	    
	  }
	  last = false;
	  
        }
      }
    }
  }
}


void Node::calLastLinkedPosi(){

  int i;
  Hitlast = false;
  lastLinkedPosi = -1;

  if(root){
    for(i = (seqLen[current]-1); i >= 0; i--){
      if(getLinkedSites(i)==1){
	lastLinkedPosi = i;
	break;
      }
    }
  }else{
    for(i = (seqLen[current]-1); i >= 0; i--){
      if(getrootSites(i)==0){
	lastLinkedPosi = i;
	break;
      }
    }    
  }

}



void Tree::getAlignments(vector<vector<int> > &alignS){

  vector<int> align(0);
  int i, j, rootSeqLen;
  Node* root;
  root = getRoot();
  rootSeqLen = root->getSeqLen();
  //bool last = false;
  alignS.resize(0);


  // Get last linked sites
  for(i = 0; i < numNodes; i++)
    nodes[i]->calLastLinkedPosi();

  //for(i = 0; i < numNodes; i++)
  //  cout << "Last "  << nodes[i]->getLastLinkedPosi() << endl;



  // Get alignments
  for(i = 0; i < rootSeqLen; i++){
    //if(i == root->getLastLinkedPosi())
    //  last = true;
    for(j = 0; j < numLeaves; j++)
      align.push_back(-1);
    if(root->getLinkedSites(i)==1)
      root->getAlignment(i, align, alignS);
    if(max_veci(align) >= 0)
      alignS.push_back(align);
    align.resize(0);
  }

  align.resize(0);

}






void Tree::printAlignments(ofstream& c, vector<vector<int> > &alignS){

  int i, j, k, m;
  int len;

  for(i = 0; i < numLeaves; i++){
    m = i + 1;
    c << ">species" << m << endl;
    len = alignS.size();
    for(j = 0; j < len; j++){
      if(alignS[j][i] == -1)
	c << "-" ;
      else if(nodes[i]->getSeq(alignS[j][i]) == 1)
	c << "A" ;
      else if(nodes[i]->getSeq(alignS[j][i]) == 2)
	c << "C" ;
      else if(nodes[i]->getSeq(alignS[j][i]) == 4)
	c << "G" ;
      else if(nodes[i]->getSeq(alignS[j][i]) == 8)
	c << "T" ;
      else
	cout << "ERROR in printAlignments! Unknown letter. " << endl;
    }
    c << endl;
  }
  return; 
}


void Tree::printAlignmentsPosi(ofstream& c, vector<vector<int> > &alignS){

  int i, j, k, m;
  int len;

  for(i = 0; i < numLeaves; i++){
    m = i + 1;
    c << ">species" << m << endl;
    len = alignS.size();
    for(j = 0; j < len; j++){
      if(alignS[j][i] == -1)
	c << "-" ;
      else
	c << alignS[j][i];
    }
    c << endl;
  }
  return; 
}




void Tree::printAlignmentsPosi_v2(ofstream& c, vector<vector<int> > &alignS){

  int i, j, k, m;
  int len = alignS.size();
  for(i = 0; i < len; i++){
    for(j = 0; j < numLeaves; j++)
      c << alignS[i][j] << " ";
    c << endl;
  }

}


void Tree::printAlignments_v2(ofstream& c, vector<vector<int> > &alignS){

  int i, j, k, m;
  int len = alignS.size();
  for(i = 0; i < len; i++){
    for(j = 0; j < numLeaves; j++){
      if(alignS[i][j] == -1)
	c << "-" ;
      else if(nodes[j]->getSeq(alignS[i][j]) == 1)
	c << "A" ;
      else if(nodes[j]->getSeq(alignS[i][j]) == 2)
	c << "C" ;
      else if(nodes[j]->getSeq(alignS[i][j]) == 4)
	c << "G" ;
      else if(nodes[j]->getSeq(alignS[i][j]) == 8)
	c << "T" ;
      else
	cout << "ERROR in printAlignments! Unknown letter. " << endl;
    }
    c << endl;
  }

}






bool Tree::UpR(Rand &rand, RNG &rng, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double r_o = params.getR();
  double r_alpha = params.getR_alpha();
  double r_beta = params.getR_beta();  
  double ri_o = params.getRi();
  double mu_o = params.getMu();
  double rd_n = params.getRd();
  double lambda_n = params.getLambda();
  double r_c = params.getR_c();


  double r_n = rng.beta(r_c*r_o + 1, r_c*(1 - r_o) + 1);
  double o_logLikeliIDH, n_logLikeliIDH;


  double ri_n = 1 - ((1-rd_n)*(1-r_n));
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  params.setR(r_n);
  params.setRi(ri_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += lgamma(r_c*r_o + 1);
  AP0 += (-1)*lgamma(r_c*r_n + 1);
  AP0 += lgamma(r_c*(1-r_o) + 1);
  AP0 += (-1)*lgamma(r_c*(1-r_n) + 1);
  AP0 += (r_alpha - 1 - r_c*r_o)*log(r_n);
  AP0 += (-1)*(r_alpha - 1 - r_c*r_n)*log(r_o);
  AP0 += (r_beta - 1 - r_c*(1 - r_o))*log(1 - r_n);
  AP0 += (-1)*(r_beta - 1 - r_c*(1 - r_n))*log(1 - r_o);

  
  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setR(r_o);
    params.setRi(ri_o);
    params.setMu(mu_o);   
    update = false;
  }    


  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}




// Beta prior
bool Tree::UpRd(Rand &rand, RNG &rng, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double rd_o = params.getRd();
  double rd_alpha = params.getRd_alpha();
  double rd_beta = params.getRd_beta();  
  double ri_o = params.getRi();
  double mu_o = params.getMu();
  double r_n = params.getR();
  double lambda_n = params.getLambda();
  double rd_c = params.getRd_c();


  double rd_n = rng.beta(rd_c*rd_o + 1, rd_c*(1 - rd_o) + 1);
  double o_logLikeliIDH, n_logLikeliIDH;


  double ri_n = 1 - ((1-rd_n)*(1-r_n));
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  params.setRd(rd_n);
  params.setRi(ri_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += lgamma(rd_c*rd_o + 1);
  AP0 += (-1)*lgamma(rd_c*rd_n + 1);
  AP0 += lgamma(rd_c*(1-rd_o) + 1);
  AP0 += (-1)*lgamma(rd_c*(1-rd_n) + 1);
  AP0 += (rd_alpha - 1 - rd_c*rd_o)*log(rd_n);
  AP0 += (-1)*(rd_alpha - 1 - rd_c*rd_n)*log(rd_o);
  AP0 += (rd_beta - 1 - rd_c*(1 - rd_o))*log(1 - rd_n);
  AP0 += (-1)*(rd_beta - 1 - rd_c*(1 - rd_n))*log(1 - rd_o);

  
  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setRd(rd_o);
    params.setRi(ri_o);
    params.setMu(mu_o);   
    update = false;
  }    

  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}




// new distribution prior
/*
bool Tree::UpRd(Rand &rand, RNG &rng, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double rd_o = params.getRd();
  double rd_epsilon = params.getRd_epsilon();  
  double ri_o = params.getRi();
  double mu_o = params.getMu();
  double r_n = params.getR();
  double lambda_n = params.getLambda();
  double rd_c = params.getRd_c();


  double rd_n = rng.beta(rd_c*rd_o + 1, rd_c*(1 - rd_o) + 1);
  double o_logLikeliIDH, n_logLikeliIDH;


  double ri_n = 1 - ((1-rd_n)*(1-r_n));
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  params.setRd(rd_n);
  params.setRi(ri_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += lgamma(rd_c*rd_o + 1);
  AP0 += (-1)*lgamma(rd_c*rd_n + 1);
  AP0 += lgamma(rd_c*(1-rd_o) + 1);
  AP0 += (-1)*lgamma(rd_c*(1-rd_n) + 1);
  AP0 += (-1)*rd_epsilon*((1/rd_n) - (1/rd_o)); 
  AP0 += (-1)*(rd_c*rd_o)*log(rd_n);
  AP0 += (rd_c*rd_n)*log(rd_o);
  AP0 += (-1)*(rd_c*(1 - rd_o))*log(1 - rd_n);
  AP0 += (rd_c*(1 - rd_n))*log(1 - rd_o);

  
  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setRd(rd_o);
    params.setRi(ri_o);
    params.setMu(mu_o);   
    update = false;
  }    

  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}
*/


// RatExp prior
/*
bool Tree::UpLambda(Rand &rand, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double rd_n = params.getRd();  
  double ri_n = params.getRi();
  double mu_o = params.getMu();
  double lambda_o = params.getLambda();
  double lambda_epsilon = params.getLambda_epsilon();
  double zeta = params.getLambda_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double lambda_n = lambda_o*mulFac;
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  double o_logLikeliIDH, n_logLikeliIDH;


  params.setLambda(lambda_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += 2*log(1+lambda_epsilon*lambda_o);
  AP0 += -2*log(1+lambda_epsilon*lambda_n);
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setLambda(lambda_o);
    params.setMu(mu_o);
    update = false;
  }    

  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}
*/


// Exp prior
bool Tree::UpLambda(Rand &rand, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double rd_n = params.getRd();  
  double ri_n = params.getRi();
  double mu_o = params.getMu();
  double lambda_o = params.getLambda();
  double lambda_epsilon = params.getLambda_epsilon();
  double zeta = params.getLambda_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double lambda_n = lambda_o*mulFac;
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  double o_logLikeliIDH, n_logLikeliIDH;


  params.setLambda(lambda_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += (-1)*lambda_epsilon*(lambda_n - lambda_o);
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setLambda(lambda_o);
    params.setMu(mu_o);
    update = false;
  }    

  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}


// Exponetial
/* 
bool Tree::UpKappa(Rand &rand, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double kappa_o = params.getKappa();
  double kappa_epsilon = params.getKappa_epsilon();
  double zeta = params.getKappa_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double kappa_n = kappa_o*mulFac;

  double o_logLikeliData, n_logLikeliData;


  params.setKappa(kappa_n);

  o_logLikeliData = getLogLikeliData();
  save_logLikeliData();
  root->likeliDataR_v2(params);
  logLikeliData[current] = likeliData();
  n_logLikeliData = logLikeliData[current];



  AP0 = n_logLikeliData - o_logLikeliData;
  AP0 += (-1)*kappa_epsilon*(kappa_n - kappa_o);
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliData();
    update = true;
  }else{
    restore_logLikeliData();
    params.setKappa(kappa_o);
    update = false;
  }    

  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}
*/

// Ratio of Exp
bool Tree::UpKappa(Rand &rand, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double kappa_o = params.getKappa();
  double kappa_epsilon = params.getKappa_epsilon();
  double zeta = params.getKappa_c();



  //cout << "In UpKappa 1" << endl;

  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double kappa_n = kappa_o*mulFac;

  double o_logLikeliData, n_logLikeliData;


  params.setKappa(kappa_n);
  //cout << "In UpKappa 2" << endl;
  o_logLikeliData = getLogLikeliData();

  //cout << "In UpKappa 3" << endl;
  save_logLikeliData();
  root->likeliDataR_v2(params);
  //cout << "In UpKappa 4" << endl;
  logLikeliData[current] = likeliData();
  //cout << "In UpKappa 5" << endl;
  n_logLikeliData = logLikeliData[current];



  AP0 = n_logLikeliData - o_logLikeliData;
  AP0 += 2*log(1+kappa_epsilon*kappa_o);
  AP0 += -2*log(1+kappa_epsilon*kappa_n);
  AP0 += log(mulFac);
 


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliData();
    update = true;
  }else{
    restore_logLikeliData();
    params.setKappa(kappa_o);
    update = false;
  }    

  c << AP << endl;
  params.setTmpDouble(AP);

  //cout << "In UpKappa 6" << endl;
  return update;
}

// RatExps prior
bool Tree::UpGamma(Rand &rand, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double gamma_o = params.getGamma();
  double gamma_epsilon = params.getGamma_epsilon();
  double zeta = params.getGamma_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double gamma_n = gamma_o*mulFac;

  double o_logLikeliEdges, n_logLikeliEdges;


  params.setGamma(gamma_n);

  o_logLikeliEdges = getLogLikeliEdges();
  save_logLikeliEdges();
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
  n_logLikeliEdges = logLikeliEdges[current];


  AP0 = n_logLikeliEdges - o_logLikeliEdges;
  AP0 += 2*log(1+gamma_epsilon*gamma_o);
  AP0 += -2*log(1+gamma_epsilon*gamma_n);
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliEdges();
    update = true;
  }else{
    restore_logLikeliEdges();
    params.setGamma(gamma_o);
    update = false;
  }    

  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}


// Gamma prior
/*
bool Tree::UpGamma(Rand &rand, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP; 
  double gamma_o = params.getGamma();
  //double gamma_epsilon = params.getGamma_epsilon();
  double gamma_alpha = params.getGamma_alpha();
  double gamma_beta = params.getGamma_beta();
  double zeta = params.getGamma_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double gamma_n = gamma_o*mulFac;

  double o_logLikeliEdges, n_logLikeliEdges;


  params.setGamma(gamma_n);

  o_logLikeliEdges = getLogLikeliEdges();
  save_logLikeliEdges();
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
  n_logLikeliEdges = logLikeliEdges[current];


  AP0 = n_logLikeliEdges - o_logLikeliEdges;
  AP0 += (gamma_alpha - 1)*(log(gamma_n) - log(gamma_o)) - (gamma_n - gamma_o)/gamma_beta; 
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliEdges();
    update = true;
  }else{
    restore_logLikeliEdges();
    params.setGamma(gamma_o);
    update = false;
  }    

  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}
*/

bool Tree::UpPi(Rand &rand, RNG &rng, Parameters &params, ofstream& c) {


  bool update;
  double AP0, AP;
  vector<double> pi_o(0);
  vector<double> pi_n(0);
  vector<double> pi_alpha(0);
  double pi_c; 

  pi_o = params.getPi();
  pi_c = params.getPi_c();
  pi_alpha = params.getPi_alpha();

  int i;
  int len = pi_o.size();
  for(i = 0; i < len; i++)
    pi_n.push_back(rng.gamma(pi_c*pi_o[i] + 1, 1));
  
  double sum = sum_vec(pi_n);

  for(i = 0; i < len; i++)
    pi_n[i] = pi_n[i]/sum;


  double o_logLikeliData, n_logLikeliData;


  params.setPi(pi_n);

  o_logLikeliData = getLogLikeliData();
  save_logLikeliData();
  root->likeliDataR_v2(params);
  logLikeliData[current] = likeliData();
  n_logLikeliData = logLikeliData[current];

  AP0 = n_logLikeliData - o_logLikeliData;
  for(i = 0; i < len ; i++){
    AP0 += lgamma(pi_c*pi_o[i] + 1) - lgamma(pi_c*pi_n[i] + 1);
    AP0 += (pi_alpha[i] - 2 - pi_c*pi_o[i])*log(pi_n[i]) - (pi_alpha[i] - 2 - pi_c*pi_n[i])*log(pi_o[i]);
  }

  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliData();
    update = true;
  }else{
    restore_logLikeliData();
    params.setPi(pi_o);
    update = false;
  }    

  pi_o.resize(0);
  pi_n.resize(0);
  pi_alpha.resize(0);

  c << AP << endl;
  params.setTmpDouble(AP);
  return update;
}





bool Tree::UpR(Rand &rand, RNG &rng, Parameters &params) {


  bool update;
  double AP0, AP; 
  double r_o = params.getR();
  double r_alpha = params.getR_alpha();
  double r_beta = params.getR_beta();  
  double ri_o = params.getRi();
  double mu_o = params.getMu();
  double rd_n = params.getRd();
  double lambda_n = params.getLambda();
  double r_c = params.getR_c();


  double r_n = rng.beta(r_c*r_o + 1, r_c*(1 - r_o) + 1);
  double o_logLikeliIDH, n_logLikeliIDH;


  double ri_n = 1 - ((1-rd_n)*(1-r_n));
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  params.setR(r_n);
  params.setRi(ri_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += lgamma(r_c*r_o + 1);
  AP0 += (-1)*lgamma(r_c*r_n + 1);
  AP0 += lgamma(r_c*(1-r_o) + 1);
  AP0 += (-1)*lgamma(r_c*(1-r_n) + 1);
  AP0 += (r_alpha - 1 - r_c*r_o)*log(r_n);
  AP0 += (-1)*(r_alpha - 1 - r_c*r_n)*log(r_o);
  AP0 += (r_beta - 1 - r_c*(1 - r_o))*log(1 - r_n);
  AP0 += (-1)*(r_beta - 1 - r_c*(1 - r_n))*log(1 - r_o);

  
  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setR(r_o);
    params.setRi(ri_o);
    params.setMu(mu_o);   
    update = false;
  }    


  params.setTmpDouble(AP);
  return update;
}




// Beta prior
bool Tree::UpRd(Rand &rand, RNG &rng, Parameters &params) {


  bool update;
  double AP0, AP; 
  double rd_o = params.getRd();
  double rd_alpha = params.getRd_alpha();
  double rd_beta = params.getRd_beta();  
  double ri_o = params.getRi();
  double mu_o = params.getMu();
  double r_n = params.getR();
  double lambda_n = params.getLambda();
  double rd_c = params.getRd_c();


  double rd_n = rng.beta(rd_c*rd_o + 1, rd_c*(1 - rd_o) + 1);
  double o_logLikeliIDH, n_logLikeliIDH;


  double ri_n = 1 - ((1-rd_n)*(1-r_n));
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  params.setRd(rd_n);
  params.setRi(ri_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += lgamma(rd_c*rd_o + 1);
  AP0 += (-1)*lgamma(rd_c*rd_n + 1);
  AP0 += lgamma(rd_c*(1-rd_o) + 1);
  AP0 += (-1)*lgamma(rd_c*(1-rd_n) + 1);
  AP0 += (rd_alpha - 1 - rd_c*rd_o)*log(rd_n);
  AP0 += (-1)*(rd_alpha - 1 - rd_c*rd_n)*log(rd_o);
  AP0 += (rd_beta - 1 - rd_c*(1 - rd_o))*log(1 - rd_n);
  AP0 += (-1)*(rd_beta - 1 - rd_c*(1 - rd_n))*log(1 - rd_o);

  
  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setRd(rd_o);
    params.setRi(ri_o);
    params.setMu(mu_o);   
    update = false;
  }    

  params.setTmpDouble(AP);
  return update;
}




// new distribution prior
/*
bool Tree::UpRd(Rand &rand, RNG &rng, Parameters &params) {


  bool update;
  double AP0, AP; 
  double rd_o = params.getRd();
  double rd_epsilon = params.getRd_epsilon();  
  double ri_o = params.getRi();
  double mu_o = params.getMu();
  double r_n = params.getR();
  double lambda_n = params.getLambda();
  double rd_c = params.getRd_c();


  double rd_n = rng.beta(rd_c*rd_o + 1, rd_c*(1 - rd_o) + 1);
  double o_logLikeliIDH, n_logLikeliIDH;


  double ri_n = 1 - ((1-rd_n)*(1-r_n));
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  params.setRd(rd_n);
  params.setRi(ri_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += lgamma(rd_c*rd_o + 1);
  AP0 += (-1)*lgamma(rd_c*rd_n + 1);
  AP0 += lgamma(rd_c*(1-rd_o) + 1);
  AP0 += (-1)*lgamma(rd_c*(1-rd_n) + 1);
  AP0 += (-1)*rd_epsilon*((1/rd_n) - (1/rd_o)); 
  AP0 += (-1)*(rd_c*rd_o)*log(rd_n);
  AP0 += (rd_c*rd_n)*log(rd_o);
  AP0 += (-1)*(rd_c*(1 - rd_o))*log(1 - rd_n);
  AP0 += (rd_c*(1 - rd_n))*log(1 - rd_o);

  
  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setRd(rd_o);
    params.setRi(ri_o);
    params.setMu(mu_o);   
    update = false;
  }    

  params.setTmpDouble(AP);
  return update;
}
*/


// RatExp prior
/*
bool Tree::UpLambda(Rand &rand, Parameters &params) {


  bool update;
  double AP0, AP; 
  double rd_n = params.getRd();  
  double ri_n = params.getRi();
  double mu_o = params.getMu();
  double lambda_o = params.getLambda();
  double lambda_epsilon = params.getLambda_epsilon();
  double zeta = params.getLambda_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double lambda_n = lambda_o*mulFac;
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  double o_logLikeliIDH, n_logLikeliIDH;


  params.setLambda(lambda_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += 2*log(1+lambda_epsilon*lambda_o);
  AP0 += -2*log(1+lambda_epsilon*lambda_n);
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setLambda(lambda_o);
    params.setMu(mu_o);
    update = false;
  }    

  params.setTmpDouble(AP);
  return update;
}
*/


// Exp prior
bool Tree::UpLambda(Rand &rand, Parameters &params) {


  bool update;
  double AP0, AP; 
  double rd_n = params.getRd();  
  double ri_n = params.getRi();
  double mu_o = params.getMu();
  double lambda_o = params.getLambda();
  double lambda_epsilon = params.getLambda_epsilon();
  double zeta = params.getLambda_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double lambda_n = lambda_o*mulFac;
  double mu_n = lambda_n*ri_n*(1-rd_n)/(rd_n*(1-ri_n));

  double o_logLikeliIDH, n_logLikeliIDH;


  params.setLambda(lambda_n);
  params.setMu(mu_n);

  o_logLikeliIDH = getLogLikeliIDH();
  save_logLikeliIDH();
  logLikeliIDH[current] = likeliHistory(params);
  n_logLikeliIDH = getLogLikeliIDH();



  AP0 = n_logLikeliIDH - o_logLikeliIDH;
  AP0 += (-1)*lambda_epsilon*(lambda_n - lambda_o);
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliIDH();
    update = true;
  }else{
    restore_logLikeliIDH();
    params.setLambda(lambda_o);
    params.setMu(mu_o);
    update = false;
  }    

  params.setTmpDouble(AP);
  return update;
}


// Exponetial 
/*
bool Tree::UpKappa(Rand &rand, Parameters &params) {


  bool update;
  double AP0, AP; 
  double kappa_o = params.getKappa();
  double kappa_epsilon = params.getKappa_epsilon();
  double zeta = params.getKappa_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double kappa_n = kappa_o*mulFac;

  double o_logLikeliData, n_logLikeliData;


  params.setKappa(kappa_n);

  o_logLikeliData = getLogLikeliData();
  save_logLikeliData();
  root->likeliDataR_v2(params);
  logLikeliData[current] = likeliData();
  n_logLikeliData = logLikeliData[current];



  AP0 = n_logLikeliData - o_logLikeliData;
  AP0 += (-1)*kappa_epsilon*(kappa_n - kappa_o);
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliData();
    update = true;
  }else{
    restore_logLikeliData();
    params.setKappa(kappa_o);
    update = false;
  }    

  params.setTmpDouble(AP);
  return update;
}
*/


// Ratio of Exp
bool Tree::UpKappa(Rand &rand, Parameters &params) {


  bool update;
  double AP0, AP; 
  double kappa_o = params.getKappa();
  double kappa_epsilon = params.getKappa_epsilon();
  double zeta = params.getKappa_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double kappa_n = kappa_o*mulFac;

  double o_logLikeliData, n_logLikeliData;


  params.setKappa(kappa_n);

  o_logLikeliData = getLogLikeliData();
  save_logLikeliData();
  root->likeliDataR_v2(params);
  logLikeliData[current] = likeliData();
  n_logLikeliData = logLikeliData[current];



  AP0 = n_logLikeliData - o_logLikeliData;
  AP0 += 2*log(1+kappa_epsilon*kappa_o);
  AP0 += -2*log(1+kappa_epsilon*kappa_n);
  AP0 += log(mulFac);
 


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliData();
    update = true;
  }else{
    restore_logLikeliData();
    params.setKappa(kappa_o);
    update = false;
  }    

  params.setTmpDouble(AP);
  return update;
}

// RatExps prior
bool Tree::UpGamma(Rand &rand, Parameters &params) {


  bool update;
  double AP0, AP; 
  double gamma_o = params.getGamma();
  double gamma_epsilon = params.getGamma_epsilon();
  double zeta = params.getGamma_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double gamma_n = gamma_o*mulFac;

  double o_logLikeliEdges, n_logLikeliEdges;


  params.setGamma(gamma_n);

  o_logLikeliEdges = getLogLikeliEdges();
  save_logLikeliEdges();
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
  n_logLikeliEdges = logLikeliEdges[current];


  AP0 = n_logLikeliEdges - o_logLikeliEdges;
  AP0 += 2*log(1+gamma_epsilon*gamma_o);
  AP0 += -2*log(1+gamma_epsilon*gamma_n);
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliEdges();
    update = true;
  }else{
    restore_logLikeliEdges();
    params.setGamma(gamma_o);
    update = false;
  }    

  params.setTmpDouble(AP);
  return update;
}


// Gamma prior
/*
bool Tree::UpGamma(Rand &rand, Parameters &params) {


  bool update;
  double AP0, AP; 
  double gamma_o = params.getGamma();
  //double gamma_epsilon = params.getGamma_epsilon();
  double gamma_alpha = params.getGamma_alpha();
  double gamma_beta = params.getGamma_beta();
  double zeta = params.getGamma_c();


  double mulFac = exp(zeta*(rand.runif() - 0.5));

  double gamma_n = gamma_o*mulFac;

  double o_logLikeliEdges, n_logLikeliEdges;


  params.setGamma(gamma_n);

  o_logLikeliEdges = getLogLikeliEdges();
  save_logLikeliEdges();
  logLikeliEdges[current] = CalculatelogLikeliEdges(params);
  n_logLikeliEdges = logLikeliEdges[current];


  AP0 = n_logLikeliEdges - o_logLikeliEdges;
  AP0 += (gamma_alpha - 1)*(log(gamma_n) - log(gamma_o)) - (gamma_n - gamma_o)/gamma_beta; 
  AP0 += log(mulFac);


  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliEdges();
    update = true;
  }else{
    restore_logLikeliEdges();
    params.setGamma(gamma_o);
    update = false;
  }    

  params.setTmpDouble(AP);
  return update;
}
*/


bool Tree::UpPi(Rand &rand, RNG &rng, Parameters &params) {


  bool update;
  double AP0, AP;
  vector<double> pi_o(0);
  vector<double> pi_n(0);
  vector<double> pi_alpha(0);
  double pi_c; 

  pi_o = params.getPi();
  pi_c = params.getPi_c();
  pi_alpha = params.getPi_alpha();

  int i;
  int len = pi_o.size();
  for(i = 0; i < len; i++)
    pi_n.push_back(rng.gamma(pi_c*pi_o[i] + 1, 1));
  
  double sum = sum_vec(pi_n);

  for(i = 0; i < len; i++)
    pi_n[i] = pi_n[i]/sum;


  double o_logLikeliData, n_logLikeliData;


  params.setPi(pi_n);

  o_logLikeliData = getLogLikeliData();
  save_logLikeliData();
  root->likeliDataR_v2(params);
  logLikeliData[current] = likeliData();
  n_logLikeliData = logLikeliData[current];

  AP0 = n_logLikeliData - o_logLikeliData;
  for(i = 0; i < len ; i++){
    AP0 += lgamma(pi_c*pi_o[i] + 1) - lgamma(pi_c*pi_n[i] + 1);
    AP0 += (pi_alpha[i] - 2 - pi_c*pi_o[i])*log(pi_n[i]) - (pi_alpha[i] - 2 - pi_c*pi_n[i])*log(pi_o[i]);
  }

  AP = MIN(((double)1),exp(AP0));

  
  if(rand.runif()-AP < 0){
    save_logLikeliData();
    update = true;
  }else{
    restore_logLikeliData();
    params.setPi(pi_o);
    update = false;
  }    

  pi_o.resize(0);
  pi_n.resize(0);
  pi_alpha.resize(0);

  params.setTmpDouble(AP);
  return update;
}




// find which splits are generated by a given edge(Edge* StEdge) [ to StNode direction 
// Splits are saved at vector<int> &splits
void Tree::GetSplits(Edge* StEdge, Node* StNode, vector<int> &splits){


  int i;
  Edge* EnEdge; 
  int StEdgeNum = StEdge->getnumber();

  if(StNode->getLeaf()){

    splits.push_back(StNode->getnumber());

  }else{
  
    for( i=0; i < StNode->getnumEdges(); i++){
      EnEdge = StNode->getEdge(i);
      if(EnEdge->getnumber()!= StEdgeNum){
	GetSplits(EnEdge, EnEdge->getOtherNode(StNode), splits);
      }
    }
  }

}

// find which splits are generated by a given edge(Edge* AEdge)
// After that, return index in a given splits set (vector<vector<int> > splits)
// int midnum is used to find a small set of split
int Tree::GetSplitsIndex(Edge* AEdge, vector<vector<int> > splits, int midnum){


  //cout << "In GetSplitsIndex " << endl;
  vector<int> EachSpt(0);
  vector<int> tmpSp(0);
  int i, size, size2, res;

  //cout << "C1" << endl;
  GetSplits(AEdge, AEdge->getEnd(), EachSpt);
  //cout << "C2" << endl;
  //cout << "midnum : " << midnum << endl;
  //cout << "EachSpt " << endl;
  //print_veci(EachSpt);


  

  size = EachSpt.size();
  if(size > midnum){
    //cout << "AA" << endl;
    //cout << "C3" << endl;
    tmpSp.resize(0);
    //cout << "C4" << endl;
    for(i=0; i < numLeaves; i++)
      tmpSp.push_back(0);
    //cout << "C5" << endl;
    for(i=0; i < size; i++)
      tmpSp[EachSpt[i]] = 1;
    EachSpt.resize(0);
    for(i=0; i < numLeaves; i++){
      if(tmpSp[i] == 0)
	EachSpt.push_back(i);
    }
    //cout << "C7" << endl;
    tmpSp.resize(0);
    //cout << "C8" << endl;
  }    




  if((numLeaves%midnum == 0) & (size == midnum)){
    
    //cout << "C9" << endl;
    if(!is_element(EachSpt,0)){
      //cout << "C10" << endl;
      tmpSp.resize(0);
      //cout << "C11" << endl;
      for(i=0; i < numLeaves; i++)
	tmpSp.push_back(0);
      //cout << "C12" << endl;
      //cout << "size " << size << endl;
      //cout << "tmpSp " << endl;
      //print_veci(tmpSp);
      //cout << "EachSpt " << endl;
      //print_veci(EachSpt);
      for(i=0; i < size; i++)
	tmpSp[EachSpt[i]] = 1;
      EachSpt.resize(0);
      for(i=0; i < numLeaves; i++){
	if(tmpSp[i] == 0)
	  EachSpt.push_back(i);
      }
      //cout << "C14" << endl;
      tmpSp.resize(0);
      //cout << "C15" << endl;
    }
    //cout << "C16" << endl;
  }

  //cout << "C17" << endl;


  //cout << "EachSptA " << endl;
  //print_veci(EachSpt);


  res = -1;
  size = EachSpt.size();
  //cout << "C18" << endl;
  size2 = splits.size();
  //cout << "C19" << endl;
  for(i = 0; i < size2; i++){
    //cout << "C20" << endl;
    if(size == splits[i].size()){
      //cout << "C21" << endl;
      if(same_vec(EachSpt, splits[i])){
	//cout << "C22" << endl;
	res = i;
	break;
      }
      //cout << "C23" << endl;
    }
    //cout << "C24" << endl;
  }


  //cout << "C25" << endl;
  if(res < 0){
    cout << "ERROR in GetSplitsIndex! " << endl;
  }
    
  tmpSp.resize(0);
  //cout << "C26" << endl;
  EachSpt.resize(0);

  
  //cout << "C27" << endl;
  //cout << "res : " << res << endl;
  return res;

}




/*** NNI start ***/
double Tree::NNIwithFixedHMG(Rand &rand, RNG &rng, const Parameters &params, ofstream& c, int start) {

  //cout << "NNIwithFixedHMG" << endl;

  //printTree();


  int NNI_c = 1;
  double NNI_Dirich_c = 10; 
  double totalEdge;

  double doubleTmp, maxL;
  // should check!
  int MaxIDsize = (int)MAX(floor(1/params.getRd())+1, floor(1/params.getRi())+1);
  //cout << "MaxIDsize in NNIwithFixedHMG : " << MaxIDsize << endl;

  int i, j, k, intTmp, intTmp2, upd_posi, FstCloseNode;
  double AP, O_datalike, N_datalike, O_IDHlike, N_IDHlike, O_psl, N_psl, T_psl;
  bool reject = false;


  /*** NNI.v2 start ****/
  bool ABroot = false;
  double T_O_IDHlike, T_N_IDHlike;
  /*** NNI.v2 end ****/



  vector<double> psl(0);
  vector<double> datalike(0);
  vector<double> IDHlike(0);

  vector<double> O_psl_v(0);
  vector<double> N_psl_v1(0);
  vector<double> N_psl_v2(0);


  O_psl_v.resize(3);
  N_psl_v1.resize(3);
  N_psl_v2.resize(3);
  
  psl.resize(2);
  datalike.resize(2);
  IDHlike.resize(2);

  Edge* TempEdge;
  vector<InDelHistory*> listIDH(0);
  InDelHistory* tmpIDH;
  
  vector<double> edgelenV(0);
  bool HitRoot;

  //---------------------------------------------------------------------------//
  //
  //  Select an internal edge E at random.
  //  but we will select one internal node first
  //  and one internal edge which is connected to this selected internal node
  //
  //---------------------------------------------------------------------------//

  Node* nodeTemp = nodes[numLeaves + (int)(rand.runif() * (numNodes - numLeaves))];

  //cout << "nodeTemp->getnumber() " << nodeTemp->getnumber() << endl;
  
 
  // list all internal edges around nodeTemp
  vector<int> temp(0);
  for( i=0; i < nodeTemp->getnumEdges(); i++){
    TempEdge = nodeTemp->getEdge(i);
    if(!TempEdge->getEnd()->getLeaf())
      temp.push_back(TempEdge->getnumber());
  }

  //cout << "all internal edges around nodeTemp " << endl;
  //print_veci(temp);

  // select on internal edge
  int selectedposi = (int)(rand.runif()*temp.size());
  int TargetEdgeNum = temp[selectedposi];
  Edge* edgeE = getEdge(TargetEdgeNum);
  temp.resize(0);

  //cout << "edgeE->getnumber() " << edgeE->getnumber() << endl;


  // Assign E1, E2, E3, E4, N1, N2, N3, N4, A and B
  Node* nodeA = edgeE->getStart();
  Edge* edgeE1;
  Edge* edgeE2;
  j = 0;
  for( i=0; i < nodeA->getnumEdges(); i++){
    TempEdge = nodeA->getEdge(i);
    if(TempEdge->getnumber() != TargetEdgeNum){
      if(j == 0)
	edgeE1 = TempEdge;
      else
	edgeE2 = TempEdge;
      j++;
    } 
  }  

  //cout << "nodeA->getnumber() " << nodeA->getnumber() << endl;
  //cout << "edgeE1->getnumber() " << edgeE1->getnumber() << endl;
  //cout << "edgeE2->getnumber() " << edgeE2->getnumber() << endl;


  Node* nodeB = edgeE->getEnd();
  Edge* edgeE3;
  Edge* edgeE4;
  j = 0;
  for( i=0; i < nodeB->getnumEdges(); i++){
    TempEdge = nodeB->getEdge(i);
    if(TempEdge->getnumber() != TargetEdgeNum){
      if(j == 0)
	edgeE3 = TempEdge;
      else
	edgeE4 = TempEdge;
      j++;
    } 
  }    

  //cout << "nodeB->getnumber() " << nodeB->getnumber() << endl;
  //cout << "edgeE3->getnumber() " << edgeE3->getnumber() << endl;
  //cout << "edgeE4->getnumber() " << edgeE4->getnumber() << endl;


  /*** NNI.v2 start ****/
  if(nodeA->getRoot() | nodeB->getRoot())
    ABroot = true;
  /*** NNI.v2 end ****/




  Node* nodeN1 = edgeE1->getOtherNode(nodeA);
  Node* nodeN2 = edgeE2->getOtherNode(nodeA);
  Node* nodeN3 = edgeE3->getOtherNode(nodeB);
  Node* nodeN4 = edgeE4->getOtherNode(nodeB);

  //cout << "nodeN1->getnumber() " << nodeN1->getnumber() << endl;
  //cout << "nodeN2->getnumber() " << nodeN2->getnumber() << endl;
  //cout << "nodeN3->getnumber() " << nodeN3->getnumber() << endl;
  //cout << "nodeN4->getnumber() " << nodeN4->getnumber() << endl;

  totalEdge = 0;
  totalEdge += edgeE->getEdgeLen();
  totalEdge += edgeE1->getEdgeLen();
  totalEdge += edgeE2->getEdgeLen();
  totalEdge += edgeE3->getEdgeLen();
  totalEdge += edgeE4->getEdgeLen();

  //cout << "totalEdge : " << totalEdge << endl;


  /*** NNI.v2 start ****/
  T_O_IDHlike = 0;
  T_O_IDHlike += edgeE->getlogLikeliIDH();
  T_O_IDHlike += edgeE1->getlogLikeliIDH();
  T_O_IDHlike += edgeE2->getlogLikeliIDH();
  T_O_IDHlike += edgeE3->getlogLikeliIDH();
  T_O_IDHlike += edgeE4->getlogLikeliIDH();
  if(ABroot)
    T_O_IDHlike += log(params.getR()) + root->getSeqLen()*log(1-params.getR());
  /*** NNI.v2 end ****/






  //----------------------------------------------------
  //
  // Get a complete alignment of N1, N2, N3, N4, A and B
  //
  //-----------------------------------------------------

  vector<vector<int> > alignS;
  vector<vector<int> > alignS_tmp;
  //vector<vector<int> > alignAB1;
  vector<vector<int> > alignAB2;
  vector<int> fix(0);
  vector<int> NodeSet(0);
  vector<int> numID(0);
  vector<vector<int> > Nalign;
  vector<vector<int> > ABtemp;
  vector<int> tempA(0);
  vector<int> tempB(0);
  vector<double> wei;


  int tempRootIX;
  alignS.resize(0);


  NodeSet.push_back(nodeN1->getnumber());
  NodeSet.push_back(nodeN2->getnumber());
  NodeSet.push_back(nodeN3->getnumber());
  NodeSet.push_back(nodeN4->getnumber());
  NodeSet.push_back(nodeA->getnumber());
  NodeSet.push_back(nodeB->getnumber());

  // search for root
  nodeTemp = nodeN1;
  while(1){
    if(nodeTemp->getRoot()){
      tempRootIX = nodeTemp->getnumber();
      break;
    }
    tempRootIX = nodeTemp->getnumber();
    nodeTemp = nodeTemp->getParent();
    if(where_element(NodeSet, nodeTemp->getnumber()) < 0)
      break;
  }

  tempRootIX = where_element(NodeSet, tempRootIX);

  //cout << "tempRootIX and NodeSet : " << tempRootIX << endl;
  //print_veci(NodeSet);


  /*** NNI.v2 start ****/
  int RootIX = NodeSet[tempRootIX];
  /*** NNI.v2 end ****/




  getAlignments(alignS, NodeSet, tempRootIX);

  //reOrderHMGs(alignS);

  //cout << "print Alignments size : " << alignS.size() << endl;
  //for(i = 0; i < alignS.size(); i++){
  //  int len = alignS[i].size();
  //  for(j = 0; j < len; j++){
  //    if(alignS[i][j] == -1)
  //	cout << "-" ;
  //    else
  //	cout << alignS[i][j];
  //  }
  //  cout << endl;
  //}
 


  // ordered?

  // check there is any column which contain gap at N1, N2, N3 and N4.
  // We will reject them.

  //cout << "here intTmp2 : " << intTmp2 << endl;
  intTmp2 = alignS.size();
  int count;
  for(i = 0; i < intTmp2; i++){
    count = 0;
    for(j = 0; j < 4; j++){
      if(alignS[i][j] == -1)
  	count++;
    }
    if(count == 4){
      reject = true;
      break;
    }
  }

  if(!reject){
    if(intTmp2 == 0)
      reject = true;
  }

  //if(reject)
  //  cout << "reject" << endl;
  //else
  //  cout << "Not reject" << endl;


  if(!reject){
    

    listIDH.resize(5);
    for(i = 0; i < 5; i++)
      listIDH[i] = new InDelHistory();
    
    save();

    alignS_tmp.resize(6);
    for(i = 0; i < intTmp2; i++){
      for(j = 0; j < 6; j++){
	if(alignS[i][j] == -1){
	  alignS_tmp[j].push_back(-1);
	}else{
	  alignS_tmp[j].push_back(1);
        }
      }
    }

    intTmp2 = alignS_tmp[0].size();


    //cout << "after transformation Size " << intTmp2 << endl;
    //for(i = 0; i < alignS_tmp.size(); i++){
    //  int len = alignS_tmp[i].size();
    //  for(j = 0; j < len; j++){
    //	if(alignS_tmp[i][j] == -1)
    //	  cout << "-" ;
    //	else
    //	  cout << alignS_tmp[i][j];
    //      }
    //      cout << endl;
    //    }
    


   //-------------------------------
    //
    // Calculate old proposals first
    //
    //-------------------------------

    O_IDHlike = logLikeliIDH[current];
    O_datalike = logLikeliData[current];
    
    //cout << "O_IDHlike : " << O_IDHlike << " O_datalike : " << O_datalike << endl;

    O_psl = 0;
    
    //------------------------
    //
    //  Consider topology 1   N1 - A - N2    N3 - B - N4
    //
    //
    //------------------------
 
    alignS.resize(0);
    alignS.resize(6);
    alignS[0] = alignS_tmp[0]; // N1 <= N1
    alignS[1] = alignS_tmp[2]; // N2 <= N3
    alignS[2] = alignS_tmp[1]; // N3 <= N2
    alignS[3] = alignS_tmp[3]; // N4 <= N4
    alignS[4] = alignS_tmp[4]; // A  <= A
    alignS[5] = alignS_tmp[5]; // B  <= B
    
    // decide determined and undetermined status
    tempA.resize(0);
    tempB.resize(0);
    fix.resize(0);
    
    tempA = alignS[4];
    tempB = alignS[5];

    intTmp2 = alignS_tmp[0].size();

    for(i = 0; i < intTmp2; i++){
      if((alignS[0][i] == -1)&(alignS[2][i] == -1)){
	fix.push_back(-2);
      }else if((alignS[1][i] == -1)&(alignS[3][i] == -1)){
	fix.push_back(2);
      }else{
	fix.push_back(1);
      }
    }

    //cout << "O_psl fix " << endl;
    //print_veci(fix);



    // Calculate undetermined status prob

    i = 0;


    if(((fix[i]!=1) & (fix.size()==1)) | ((fix[i]!=1) & (fix[i+1]!=1))){

      //cout << "i : " << i << endl;
      //cout << "Look at only this position " << endl;
      // A1
      // if 1st and 2nd are not determined.
      // we need to determin by just looking at 1st column

      // N1 and N2 are (-,-) or N3 and N4 are (-,-)
      if(fix[i] == -2){
	// N1 and N2 are (-,-)

	//cout << "include 1 is (-,-) " << endl;

	// caseI and caseII
	if((alignS[1][i] != -1)&(alignS[3][i] != -1)){


	  //cout << "caseI " << endl;
	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (-1,1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(1);
	  Nalign[1].resize(1);
	  Nalign[2].resize(1);
	  Nalign[3].resize(1);
	  Nalign[4].resize(1);
	  Nalign[5].resize(1);
	
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	
	  // N2
	  Nalign[2][0] = alignS[2][i];
	  
	  // N3
	  Nalign[3][0] = alignS[1][i];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  
	  
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);	    
	  }


	  //cout << "numID " << endl;
	  //print_veci(numID);
	  //cout << "wei " << endl;
	  //print_vecd(wei);


	  for(j = 0; j < intTmp; j++){
	    if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
	      break;
          }
	  intTmp = j;
	  O_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  //cout << "O_psl " << O_psl << " index : " << intTmp << endl;
	  wei.resize(0);

	  fix[i] = 1;
       

	}else{

	  //cout << "caseII " << endl;
	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (-1,1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(1);
	  Nalign[1].resize(1);
	  Nalign[2].resize(1);
	  Nalign[3].resize(1);
	  Nalign[4].resize(1);
	  Nalign[5].resize(1);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  
	  // N2
	  Nalign[2][0] = alignS[2][i];
	  
	  // N3
	  Nalign[3][0] = alignS[1][i];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];    
	  
	  
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }



	 
	  //cout << "numID " << endl;
	  //print_veci(numID);
	  //cout << "wei " << endl;
	  //print_vecd(wei); 
	  
	  for(j = 0; j < intTmp; j++){
	    if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
	      break;
          }
	  intTmp = j;
	  O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	  //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	  wei.resize(0);
	  fix[i] = 1;
	  
	} // End of caseI and caseII
	
      }else if(fix[i] == 2){
	// N3 and N4 are (-,-)

	//cout << "Not include 1 is (-,-) " << endl;
	
	// caseI and caseII
	if((alignS[0][i] != -1)&(alignS[2][i] != -1)){

	  //cout << "caseI " << endl;
	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(1);
	    Nalign[1].resize(1);
	    Nalign[2].resize(1);
	    Nalign[3].resize(1);
	    Nalign[4].resize(1);
	    Nalign[5].resize(1);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i];

	    // N2
	    Nalign[2][0] = alignS[2][i];

	    // N3
	    Nalign[3][0] = alignS[1][i];
        
	    // N4
	    Nalign[5][0] = alignS[3][i];
	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][0] = ABtemp[j][0];
	      Nalign[4][0] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 

	    
	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	    wei.resize(0);
	    fix[i] = 1;
	    

	  }else{

	    //cout << "caseII " << endl;
	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(1);
	    Nalign[1].resize(1);
	    Nalign[2].resize(1);
	    Nalign[3].resize(1);
	    Nalign[4].resize(1);
	    Nalign[5].resize(1);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i];
      
	    // N2
	    Nalign[2][0] = alignS[2][i];
      
	    // N3
	    Nalign[3][0] = alignS[1][i];

	    // N4
	    Nalign[5][0] = alignS[3][i];
	    

	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][0] = ABtemp[j][0];
	      Nalign[4][0] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }


	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 
	  
	    
	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	    wei.resize(0);
	    fix[i] = 1;
	    
     
          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N2 are (-,-) or N3 and N4 are (-,-)


    }else if((fix[i]!=1) & (fix[i+1]==1)){ 

      //cout << "i : " << i << endl;
      //cout << "Look at 1st and 2nd together " << endl;
      
      // if 1st is not determined but 2nd is determined.
      // we need to determin by looking at 1st and 2nd together

      // N1 and N2 are (-,-) or N3 and N4 are (-,-)
      if(fix[i] == -2){
	// N1 and N2 are (-,-)

	//cout << "include 1 is (-,-) " << endl;

	// caseI and caseII
	if((alignS[1][i] != -1)&(alignS[3][i] != -1)){


	  //cout << "caseI " << endl;
	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (-1,1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	    
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];

	  // A
	  Nalign[1][1] = tempA[i+1];

	  // N2
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];

	  // N3
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];


	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }


	  //cout << "numID " << endl;
	  //print_veci(numID);
	  //cout << "wei " << endl;
	  //print_vecd(wei); 


	  for(j = 0; j < intTmp; j++){
	    if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
	      break;
	  }
	  intTmp = j;
	  O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	  //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	  wei.resize(0);
	  fix[i] = 1;
	  
	}else{


	  //cout << "caseII " << endl;

	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (-1,1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  

	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N2
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  
	  // N3
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];


	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  //cout << "numID " << endl;
	  //print_veci(numID);
	  //cout << "wei " << endl;
	  //print_vecd(wei); 

	  for(j = 0; j < intTmp; j++){
	    if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
	      break;
	  }
	  intTmp = j;
	  O_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	  wei.resize(0);
	  fix[i] = 1;	  
	  
	  
	} // End of caseI and caseII
	
      }else if(fix[i] == 2){
	// N3 and N4 are (-,-)
	

	//cout << "Not include 1 is (-,-) " << endl;
	

	// caseI and caseII
	if((alignS[0][i] != -1)&(alignS[2][i] != -1)){
	  

	  
	  //cout << "caseI " << endl;
	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (1,-1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = -1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N2
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  
	  
	  // N3
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];
	  

	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][1] = ABtemp[j][0];
	    Nalign[4][1] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }

	  //cout << "numID " << endl;
	  //print_veci(numID);
	  //cout << "wei " << endl;
	  //print_vecd(wei); 
	  

	  
	  for(j = 0; j < intTmp; j++){
	    if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
	      break;
	  }
	  intTmp = j;
	  O_psl += log(wei[intTmp]) - log(sum_vec(wei));


	  //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	  wei.resize(0);
	  fix[i] = 1;	  	  
	  
	  
	}else{
	  

	  //cout << "caseII " << endl;
	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (1,-1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = -1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N2
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  

	  // N3
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];

	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];
	  

	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  

	  //cout << "numID " << endl;
	  //print_veci(numID);
	  //cout << "wei " << endl;
	  //print_vecd(wei); 
	  
	  
	  for(j = 0; j < intTmp; j++){
	    if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
	      break;
	  }
	  intTmp = j;
	  O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	  //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	  wei.resize(0);
	  fix[i] = 1;	  	  
	  
	  
	  
	} // End of caseI and caseII
	
      }else{
	cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
      } // End of N1 and N2 are (-,-) or N3 and N4 are (-,-)
      
    } // End of all case i==0 is undetermined.

    // when i >= 1

    //cout << "fix" << endl;
    //print_veci(fix);


    //cout << "AAAA" << endl;

    // First screen
    for(i = 1; i < (intTmp2-1); i++){


      
      if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){
      
	//cout << "i : " << i << endl;
	//cout << "look at three together " << endl;
	// N1 and N2 are (-,-) or N3 and N4 are (-,-)
	if(fix[i] == -2){

	  //cout << "include 1 is (-,-) " << endl;
	  // N1 and N2 are (-,-)

	  // caseI and caseII
	  if((alignS[1][i] != -1)&(alignS[3][i] != -1)){


	    //cout << "caseI " << endl;
	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (-1,1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N2
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N3
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }


	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 
	    
	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;
	    

	    wei.resize(0);
	    fix[i] = 1;	  	    
	    

	  }else{

	    //cout << "caseII " << endl;
	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (-1,1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N2
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N3
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 

	    
	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));


	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;
 

	    wei.resize(0);
	    fix[i] = 1;	  
	  
	  

          } // End of caseI and caseII

	}else if(fix[i] == 2){
	  // N3 and N4 are (-,-)


	  //cout << "Not include 1 is (-,-) " << endl;
	  // caseI and caseII
	  if((alignS[0][i] != -1)&(alignS[2][i] != -1)){


	    //cout << "caseI " << endl;
	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N2
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N3
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }


	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 
	  


	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;



	    wei.resize(0);
	    fix[i] = 1;	  
	  	    

	  }else{


	    //cout << "caseII " << endl;
	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N2
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N3
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }


	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 
	    
	    
	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    
	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;
 
	    wei.resize(0);
	    fix[i] = 1;	  


          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N2 are (-,-) or N3 and N4 are (-,-)

      } // End of if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){
        // right and left sides are determined.    
    } 
    // End of first screen



    // Second screen
    for(i = 1; i < intTmp2; i++){
      
      if((fix[i-1]==1) & (fix[i]!=1)){
      
	//cout << "i : " << i << endl;
	//cout << "Look at previous and current index " << endl;

	// N1 and N2 are (-,-) or N3 and N4 are (-,-)
	if(fix[i] == -2){
	  // N1 and N2 are (-,-)

	  //cout << "include 1 is (-,-) " << endl;
	  // caseI and caseII
	  if((alignS[1][i] != -1)&(alignS[3][i] != -1)){


	    //cout << "caseI " << endl;
	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (-1,1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	
	    // A
	    Nalign[1][0] = tempA[i-1];
	 
	    // N2
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N3
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
       
	    // B
	    Nalign[4][0] = tempB[i-1];
	  
	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }


	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 

	    
	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	    

	    wei.resize(0);
	    fix[i] = 1;	  
	    

	  }else{


	    //cout << "caseII " << endl;
	    
	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (-1,1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
   
	    // A
	    Nalign[1][0] = tempA[i-1];

	    // N2
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N3
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
    
	    // B
	    Nalign[4][0] = tempB[i-1];
       
	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
    

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }


	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 
	  

	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;


	    wei.resize(0);
	    fix[i] = 1;	  	    


          } // End of caseI and caseII

	}else if(fix[i] == 2){
	  // N3 and N4 are (-,-)


	  //cout << "Not include 1 is (-,-) " << endl;

	  // caseI and caseII
	  if((alignS[0][i] != -1)&(alignS[2][i] != -1)){


	    //cout << "caseI " << endl;
	    
	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
       
	    // A
	    Nalign[1][0] = tempA[i-1];
	 
	    // N2
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N3
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
    
	    // B
	    Nalign[4][0] = tempB[i-1];
     
	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }


	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 
	  


	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;
 

	    wei.resize(0);
	    fix[i] = 1;	  	    


	  }else{

	    //cout << "caseII " << endl;
	    
	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
     
	    // A
	    Nalign[1][0] = tempA[i-1];
      
	    // N2
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
  
	    // N3
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
  
	    // B
	    Nalign[4][0] = tempB[i-1];
      
	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }


	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei); 

	    for(j = 0; j < intTmp; j++){
	      if((ABtemp[j][0] == tempA[i]) & (ABtemp[j][1] == tempB[i]))
		break;
	    }
	    intTmp = j;
	    O_psl += log(wei[intTmp]) - log(sum_vec(wei));

	    //cout << "O_psl " << O_psl << " index : " << intTmp << endl;

	    wei.resize(0);
	    fix[i] = 1;	  	    



          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N2 are (-,-) or N3 and N4 are (-,-)

      } // End of if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){
        // right and left sides are determined.    
    } 
    // End of second screen

    // A
    //alignS[4] = tempA;
    // B
    //alignS[5] = tempB;

    alignS.resize(6);
    alignS[0] = alignS_tmp[0];
    alignS[1] = tempA;
    alignS[2] = alignS_tmp[1];
    alignS[3] = alignS_tmp[2];
    alignS[4] = tempB;
    alignS[5] = alignS_tmp[3];   
    


    //cout << "print alignS size : " << alignS.size() << endl;
    //for(i = 0; i < alignS.size(); i++){
    //  k = alignS[i].size();
    //  for(j = 0; j < k; j++){
    //	if(alignS[i][j] == -1)
    //	  cout << "-" ;
    //	else
    //	  cout << alignS[i][j];
    //      }
    //      cout << endl;
    //    }
    

    //----------------------------------------------
    //
    //  Count # of events at each edge roughly
    //
    //----------------------------------------------

    numID.resize(0);
    countNumIDonEachEdge(alignS, numID, MaxIDsize);

    if(is_element(numID, 0)){
      for(i = 0; i < 5; i++)
	numID[i]++;
    }
    //cout << "total numID MaxIDsize : "  << MaxIDsize << endl;
    //print_veci(numID);


    O_psl_v[0] = O_psl;

    //----------------------------------------------
    //
    // Calculate branch length generation prob
    //
    //----------------------------------------------

    wei.resize(5);
    doubleTmp = (double)sum_veci(numID);

    for(i = 0; i < 5; i++)
      wei[i] = (NNI_Dirich_c*(double)numID[i])/doubleTmp;

    edgelenV.resize(5);
    edgelenV[0] = edgeE1->getEdgeLen();
    edgelenV[1] = edgeE2->getEdgeLen();
    edgelenV[2] = edgeE3->getEdgeLen();
    edgelenV[3] = edgeE4->getEdgeLen();
    edgelenV[4] = edgeE->getEdgeLen();
   

    doubleTmp = sum_vec(edgelenV);
 
    O_psl += lgamma(NNI_Dirich_c);

    //cout << "O_psl : " << O_psl << endl;
    for(i = 0; i < 5; i++){
      edgelenV[i] /= doubleTmp;
      O_psl += (wei[i]-1)*log(edgelenV[i]) - lgamma(wei[i]);
      //cout << "O_psl : " << O_psl << endl;
    }

    //cout << "edge len " << endl;
    //print_vecd(edgelenV);
    //cout << "wei for branch length : "  << endl;
    //print_vecd(wei);

    //cout << "O_psl : " << O_psl << endl;
 
    wei.resize(0);
    edgelenV.resize(0);
    
    
    O_psl_v[1] = O_psl - O_psl_v[0];

    //----------------------------------------------
    //
    //  Calculate prob of generating IDH in each block
    //
    //----------------------------------------------    
    
    // To decide direction of IDH generation
    // Let's find which one (A and B) is close to Leaf 0.
    // save at nodeTemp


    HitRoot = false;
    TempEdge = getNode(0)->getParentEdge();
    while(TempEdge != edgeE){

	if(TempEdge->getStart()->getRoot()){
	  HitRoot = true;
	  break;
	}

	TempEdge = TempEdge->getParentEdge();
    }

    if(HitRoot)
      nodeTemp = edgeE->getStart();
    else
      nodeTemp = edgeE->getEnd();


    //cout << "close node : " << nodeTemp->getnumber() << endl; 


    //cout << "calProb" << endl;
    //cout << "alignS[1] " << endl;
    //print_veci(alignS[1]);
    //cout << "alignS[0] " << endl;
    //print_veci(alignS[0]);    

    // A -> N1
    if(edgeE1->getStart() == nodeA){
      //cout << "A->N1 a " << endl;
      O_psl += calProbIDHfromPairwiseAlignment(alignS[1], alignS[0], edgeE1->getEdgeLen(), edgeE1->getIDH(), params);
  
    }else{
      //cout << "A->N1 b " << endl;
      edgeE1->ReverseIDH();
      O_psl += calProbIDHfromPairwiseAlignment(alignS[1], alignS[0], edgeE1->getEdgeLen(), edgeE1->getIDH(), params);
      edgeE1->ReverseIDH();
    }


    //cout << "O_psl : " << O_psl << endl;

    // A -> N2
    if(edgeE2->getStart() == nodeA){
      //cout << "A->N2 a " << endl;
      O_psl += calProbIDHfromPairwiseAlignment(alignS[1], alignS[2], edgeE2->getEdgeLen(), edgeE2->getIDH(), params);
   
    }else{
      //cout << "A->N2 b " << endl;
      edgeE2->ReverseIDH();
      O_psl += calProbIDHfromPairwiseAlignment(alignS[1], alignS[2], edgeE2->getEdgeLen(), edgeE2->getIDH(), params);
      edgeE2->ReverseIDH();
    }


    //cout << "O_psl : " << O_psl << endl;

    // B -> N3
    if(edgeE3->getStart() == nodeB){
      //cout << "B->N3 a " << endl;
      O_psl += calProbIDHfromPairwiseAlignment(alignS[4], alignS[3], edgeE3->getEdgeLen(), edgeE3->getIDH(), params);
   
    }else{
      //cout << "B->N3 b " << endl;
      edgeE3->ReverseIDH();
      O_psl += calProbIDHfromPairwiseAlignment(alignS[4], alignS[3], edgeE3->getEdgeLen(), edgeE3->getIDH(), params);
      edgeE3->ReverseIDH();
    }

    //cout << "O_psl : " << O_psl << endl;

    // B -> N4
    if(edgeE4->getStart() == nodeB){
      //cout << "B->N4 a " << endl;
      O_psl += calProbIDHfromPairwiseAlignment(alignS[4], alignS[5], edgeE4->getEdgeLen(), edgeE4->getIDH(), params);
   
    }else{
      //cout << "B->N4 b " << endl;
      edgeE4->ReverseIDH();
      O_psl += calProbIDHfromPairwiseAlignment(alignS[4], alignS[5], edgeE4->getEdgeLen(), edgeE4->getIDH(), params);
      edgeE4->ReverseIDH();
    }

    //cout << "O_psl : " << O_psl << endl;

    // A -> B or B -> A
    if(nodeTemp == nodeA){
      //cout << "close == nodeA " << endl;
      // A -> B
      if(edgeE->getStart() == nodeA){
	//cout << "A->B a " << endl;
	O_psl += calProbIDHfromPairwiseAlignment(alignS[1], alignS[4], edgeE->getEdgeLen(), edgeE->getIDH(), params);

      }else{
	//cout << "A->B b " << endl;
	edgeE->ReverseIDH();
	O_psl += calProbIDHfromPairwiseAlignment(alignS[1], alignS[4], edgeE->getEdgeLen(), edgeE->getIDH(), params);
	edgeE->ReverseIDH();
	
      }

    }else{
      //cout << "close == nodeB " << endl;
      // B -> A
      if(edgeE->getStart() == nodeB){
	//cout << "B->A a " << endl;
	O_psl += calProbIDHfromPairwiseAlignment(alignS[4], alignS[1], edgeE->getEdgeLen(), edgeE->getIDH(), params);

      }else{
	//cout << "B->A b " << endl;
	edgeE->ReverseIDH();
	O_psl += calProbIDHfromPairwiseAlignment(alignS[4], alignS[1], edgeE->getEdgeLen(), edgeE->getIDH(), params);
	edgeE->ReverseIDH();
	
      }

    }

    //cout << "Final O_psl : " << O_psl << endl;

    O_psl_v[2] = O_psl - O_psl_v[1] - O_psl_v[0];

    //-------------------------------
    //
    // Start propose 
    //
    //-------------------------------

    //------------------------
    //
    //  Consider topology 1   N1 - A - N3    N2 - B - N4
    //
    //  alignS[0] = N1
    //  alignS[1] = N2
    //  alignS[2] = N3
    //  alignS[3] = N4
    //  alignS[4] = A
    //  alignS[5] = B
    //
    //------------------------

    T_psl = 0;
    alignS.resize(0);
    alignS = alignS_tmp;
        
 
    //-----------------------------
    //
    //  Generate determined status
    //
    //-----------------------------

    //alignAB1.resize(2);
    tempA.resize(0);
    tempB.resize(0);
    fix.resize(0);
    
    for(i = 0; i < intTmp2; i++){
      if((alignS[0][i] == -1)&(alignS[2][i] == -1)){
	fix.push_back(-2);
	tempA.push_back(0);
	tempB.push_back(0);
      }else if((alignS[1][i] == -1)&(alignS[3][i] == -1)){
	fix.push_back(2);
	tempA.push_back(0);
	tempB.push_back(0);
      }else{
	fix.push_back(1);
	tempA.push_back(1);
	tempB.push_back(1);
      }
    }

    //-----------------------------
    //
    //  Generate undetermined status
    //
    //-----------------------------
   
    i = 0;

    if(((fix[i]!=1) & (fix.size()==1)) | ((fix[i]!=1) & (fix[i+1]!=1))){
    //if((fix[i]!=1) & (fix[i+1]!=1)){
      // A2
      // if 1st and 2nd are not determined.
      // we need to determin by just looking at 1st column

      // N1 and N3 are (-,-) or N2 and N4 are (-,-)
      if(fix[i] == -2){
	// N1 and N3 are (-,-)

	// caseI and caseII
	if((alignS[1][i] != -1)&(alignS[3][i] != -1)){

	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (-1,1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(1);
	  Nalign[1].resize(1);
	  Nalign[2].resize(1);
	  Nalign[3].resize(1);
	  Nalign[4].resize(1);
	  Nalign[5].resize(1);
	
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	
	  // N3
	  Nalign[2][0] = alignS[2][i];
	  
	  // N2
	  Nalign[3][0] = alignS[1][i];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  
	  
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }

	    
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  

	}else{

	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (-1,1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(1);
	  Nalign[1].resize(1);
	  Nalign[2].resize(1);
	  Nalign[3].resize(1);
	  Nalign[4].resize(1);
	  Nalign[5].resize(1);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  
	  // N3
	  Nalign[2][0] = alignS[2][i];
	  
	  // N2
	  Nalign[3][0] = alignS[1][i];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];    
	  
	  
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	} // End of caseI and caseII
	
      }else if(fix[i] == 2){
	// N2 and N4 are (-,-)
	
	// caseI and caseII
	if((alignS[0][i] != -1)&(alignS[2][i] != -1)){
	  
	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(1);
	    Nalign[1].resize(1);
	    Nalign[2].resize(1);
	    Nalign[3].resize(1);
	    Nalign[4].resize(1);
	    Nalign[5].resize(1);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i];

	    // N3
	    Nalign[2][0] = alignS[2][i];

	    // N2
	    Nalign[3][0] = alignS[1][i];
        
	    // N4
	    Nalign[5][0] = alignS[3][i];
	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][0] = ABtemp[j][0];
	      Nalign[4][0] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(1);
	    Nalign[1].resize(1);
	    Nalign[2].resize(1);
	    Nalign[3].resize(1);
	    Nalign[4].resize(1);
	    Nalign[5].resize(1);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i];
      
	    // N3
	    Nalign[2][0] = alignS[2][i];
      
	    // N2
	    Nalign[3][0] = alignS[1][i];

	    // N4
	    Nalign[5][0] = alignS[3][i];
	    

	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][0] = ABtemp[j][0];
	      Nalign[4][0] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N3 are (-,-) or N2 and N4 are (-,-)


    }else if((fix[i]!=1) & (fix[i+1]==1)){ 
      // if 1st is not determined but 2nd is determined.
      // we need to determin by looking at 1st and 2nd together

      // N1 and N3 are (-,-) or N2 and N4 are (-,-)
      if(fix[i] == -2){
	// N1 and N3 are (-,-)

	// caseI and caseII
	if((alignS[1][i] != -1)&(alignS[3][i] != -1)){

	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (-1,1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	    
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];

	  // A
	  Nalign[1][1] = tempA[i+1];

	  // N3
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];

	  // N2
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];


	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }

	    
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	}else{

	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (-1,1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  

	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N3
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  
	  // N2
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];


	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	} // End of caseI and caseII
	
      }else if(fix[i] == 2){
	// N2 and N4 are (-,-)
	
	// caseI and caseII
	if((alignS[0][i] != -1)&(alignS[2][i] != -1)){
	  
	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (1,-1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = -1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N3
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  
	  
	  // N2
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];
	  

	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][1] = ABtemp[j][0];
	    Nalign[4][1] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	}else{
	  
	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (1,-1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = -1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N3
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  

	  // N2
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];

	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N4
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];
	  

	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	} // End of caseI and caseII
	
      }else{
	cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
      } // End of N1 and N3 are (-,-) or N2 and N4 are (-,-)
      
    } // End of all case i==0 is undetermined.

    // when i >= 1


    // First screen
    for(i = 1; i < (intTmp2-1); i++){
      
      if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){
      
	// N1 and N3 are (-,-) or N2 and N4 are (-,-)
	if(fix[i] == -2){
	  // N1 and N3 are (-,-)

	  // caseI and caseII
	  if((alignS[1][i] != -1)&(alignS[3][i] != -1)){

	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (-1,1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N3
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (-1,1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N3
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else if(fix[i] == 2){
	  // N2 and N4 are (-,-)

	  // caseI and caseII
	  if((alignS[0][i] != -1)&(alignS[2][i] != -1)){

	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N3
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N3
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N3 are (-,-) or N2 and N4 are (-,-)

      } // End of if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){
        // right and left sides are determined.    
    } 
    // End of first screen



    // Second screen
    for(i = 1; i < intTmp2; i++){
      
      if((fix[i-1]==1) & (fix[i]!=1)){
      
	// N1 and N3 are (-,-) or N2 and N4 are (-,-)
	if(fix[i] == -2){
	  // N1 and N3 are (-,-)

	  // caseI and caseII
	  if((alignS[1][i] != -1)&(alignS[3][i] != -1)){

	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (-1,1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	
	    // A
	    Nalign[1][0] = tempA[i-1];
	 
	    // N3
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
       
	    // B
	    Nalign[4][0] = tempB[i-1];
	  
	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (-1,1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
   
	    // A
	    Nalign[1][0] = tempA[i-1];

	    // N3
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
    
	    // B
	    Nalign[4][0] = tempB[i-1];
       
	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
    

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else if(fix[i] == 2){
	  // N2 and N4 are (-,-)

	  // caseI and caseII
	  if((alignS[0][i] != -1)&(alignS[2][i] != -1)){

	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
       
	    // A
	    Nalign[1][0] = tempA[i-1];
	 
	    // N3
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
    
	    // B
	    Nalign[4][0] = tempB[i-1];
     
	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
     
	    // A
	    Nalign[1][0] = tempA[i-1];
      
	    // N3
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
  
	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
  
	    // B
	    Nalign[4][0] = tempB[i-1];
      
	    // N4
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N3 are (-,-) or N2 and N4 are (-,-)

      } // End of if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){
        // right and left sides are determined.    
    } 
    // End of second screen

    // A
    //alignS[4] = tempA;
    // B
    //alignS[5] = tempB;

    alignS.resize(6);
    alignS[0] = alignS_tmp[0];
    alignS[1] = tempA;
    alignS[2] = alignS_tmp[2];
    alignS[3] = alignS_tmp[1];
    alignS[4] = tempB;
    alignS[5] = alignS_tmp[3];   
   
 
    //cout << "print alignS size : " << alignS.size() << endl;
    //for(i = 0; i < alignS.size(); i++){
    //  k = alignS[i].size();
    //  for(j = 0; j < k; j++){
    //	if(alignS[i][j] == -1)
    //	  cout << "-" ;
    //	else
    //	  cout << alignS[i][j];
    //   }
    //  cout << endl;
    //}
    



    //----------------------------------------------
    //
    //  Count # of events at each edge roughly
    //
    //----------------------------------------------

    numID.resize(0);
    countNumIDonEachEdge(alignS, numID, MaxIDsize);

    if(is_element(numID, 0)){
      for(i = 0; i < 5; i++)
	numID[i]++;
    }
    //cout << "total numID MaxIDsize : "  << MaxIDsize << endl;
    //print_veci(numID);


    //---------------------------------------------
    //
    //  Construct New Tree
    //
    //---------------------------------------------

    if(nodeA == edgeE2->getEnd()){ 
      // Change II
      edgeE2->setEnd(nodeB);
      nodeB->setEdge(edgeE3, edgeE2);
      nodeB->setParentEdge(edgeE2);
      edgeE3->setStart(nodeA);
      nodeA->setEdge(edgeE2, edgeE3);
      nodeA->setParentEdge(edgeE);     
      edgeE->changeStartEnd();
    }else if(nodeB == edgeE3->getEnd()){
      // Change III
      edgeE2->setStart(nodeB);
      nodeB->setEdge(edgeE3, edgeE2);
      nodeB->setParentEdge(edgeE);
      edgeE3->setEnd(nodeA);
      nodeA->setEdge(edgeE2, edgeE3);
      nodeA->setParentEdge(edgeE3);     
      edgeE->changeStartEnd();  
    }else if((nodeA == edgeE2->getStart()) & (nodeB == edgeE3->getStart())){
      //  Change I
      edgeE2->setStart(nodeB);
      nodeB->setEdge(edgeE3, edgeE2);
      edgeE3->setStart(nodeA);
      nodeA->setEdge(edgeE2, edgeE3);
    }else{
      cout << "ERROR in NNI A " << endl;
    }
    
      
    //----------------------------------------------
    //
    //  Generate branch length based on # of counts
    //    and set branch length
    //
    //----------------------------------------------    


    N_psl_v1[0] = T_psl;

    //cout << "T_psl : " << T_psl << endl;

    wei.resize(5);
    doubleTmp = (double)sum_veci(numID);

    for(i = 0; i < 5; i++)
      wei[i] = (NNI_Dirich_c*(double)numID[i])/doubleTmp;


    //cout << "wei for branch length : "  << endl;
    //print_vecd(wei);



    edgelenV.resize(5);
    for(i = 0; i < 5; i++)
      edgelenV[i] = rng.gamma(wei[i], 1);

    T_psl += lgamma(NNI_Dirich_c);
    
    doubleTmp = sum_vec(edgelenV);
    for(i = 0; i < 5; i++){
      edgelenV[i] /= doubleTmp;
      T_psl += (wei[i]-1)*log(edgelenV[i]) - lgamma(wei[i]);

      edgelenV[i] *= totalEdge;
    }
   
    //cout << "edge len " << endl;
    //print_vecd(edgelenV);
    //cout << "T_psl : " << T_psl << endl;
    // 0 -> node1
    // 1 -> node3
    // 2 -> node2
    // 3 -> node4
    // 4 -> middle
    
    edgeE1->setEdgeLen(edgelenV[0]);
    edgeE3->setEdgeLen(edgelenV[1]);
    edgeE2->setEdgeLen(edgelenV[2]);
    edgeE4->setEdgeLen(edgelenV[3]);
    edgeE->setEdgeLen(edgelenV[4]);
    

    wei.resize(0);
    edgelenV.resize(0);


    N_psl_v1[1] = T_psl - N_psl_v1[0];
    
    //----------------------------------------------
    //
    //  Generate IDH in each block
    //
    //----------------------------------------------    
    
    // To decide direction of IDH generation
    // Let's find which one (A and B) is close to Leaf 0.
    // save at nodeTemp

    HitRoot = false;
    TempEdge = getNode(0)->getParentEdge();
    while(TempEdge != edgeE){

	if(TempEdge->getStart()->getRoot()){
	  HitRoot = true;
	  break;
	}

	TempEdge = TempEdge->getParentEdge();
    }

    if(HitRoot)
      nodeTemp = edgeE->getStart();
    else
      nodeTemp = edgeE->getEnd();

    FstCloseNode = nodeTemp->getnumber();

    //cout << "FstCloseNode : " << FstCloseNode << endl;

    // Generate New IDH
    // A -> N1
    //cout << "A -> N1" << endl;
    T_psl += generateNewIDHfromPairwiseAlignment(alignS[1], alignS[0], edgeE1->getEdgeLen(), listIDH[0], rand, params);
   
    if(edgeE1->getStart() == nodeA){
      tmpIDH = edgeE1->getIDH();
      (*tmpIDH) = (*listIDH[0]);
      nodeA->setSeqLen(edgeE1->getIDH()->getN(0));
      edgeE1->calHMG();
    }else{
      tmpIDH = edgeE1->getIDH();
      (*tmpIDH) = (*listIDH[0]);      
      edgeE1->ReverseIDH();
      nodeA->setSeqLen(edgeE1->getIDH()->getN(edgeE1->getIDH()->getNumE()));      
      edgeE1->calHMG();
    }

    // A -> N3
    //cout << "A -> N3" << endl;
    T_psl += generateNewIDHfromPairwiseAlignment(alignS[1], alignS[2], edgeE3->getEdgeLen(), listIDH[1], rand, params);
   
    if(edgeE3->getStart() == nodeA){
      tmpIDH = edgeE3->getIDH();
      (*tmpIDH) = (*listIDH[1]);
      edgeE3->calHMG();
    }else{
      tmpIDH = edgeE3->getIDH();
      (*tmpIDH) = (*listIDH[1]);      
      edgeE3->ReverseIDH();      
      edgeE3->calHMG();
    }


    // B -> N2
    //cout << "B -> N2" << endl;
    T_psl += generateNewIDHfromPairwiseAlignment(alignS[4], alignS[3], edgeE2->getEdgeLen(), listIDH[2], rand, params);
   
    if(edgeE2->getStart() == nodeB){
      tmpIDH = edgeE2->getIDH();
      (*tmpIDH) = (*listIDH[2]);
      nodeB->setSeqLen(edgeE2->getIDH()->getN(0));
      edgeE2->calHMG();
    }else{
      tmpIDH = edgeE2->getIDH();
      (*tmpIDH) = (*listIDH[2]);      
      edgeE2->ReverseIDH();
      nodeB->setSeqLen(edgeE2->getIDH()->getN(edgeE2->getIDH()->getNumE()));      
      edgeE2->calHMG();
    }

    // B -> N4
    //cout << "B -> N4" << endl;
    T_psl += generateNewIDHfromPairwiseAlignment(alignS[4], alignS[5], edgeE4->getEdgeLen(), listIDH[3], rand, params);
   
    if(edgeE4->getStart() == nodeB){
      tmpIDH = edgeE4->getIDH();
      (*tmpIDH) = (*listIDH[3]);
      edgeE4->calHMG();
    }else{
      tmpIDH = edgeE4->getIDH();
      (*tmpIDH) = (*listIDH[3]);      
      edgeE4->ReverseIDH();
      edgeE4->calHMG();
    }

    // A -> B or B -> A
    
    if(nodeTemp == nodeA){

      // A -> B
      //cout << "A -> B" << endl;
      T_psl += generateNewIDHfromPairwiseAlignment(alignS[1], alignS[4], edgeE->getEdgeLen(), listIDH[4], rand, params);
   
      if(edgeE->getStart() == nodeA){
	tmpIDH = edgeE->getIDH();
	(*tmpIDH) = (*listIDH[4]);
	edgeE->calHMG();
      }else{
	tmpIDH = edgeE->getIDH();
	(*tmpIDH) = (*listIDH[4]);      
	edgeE->ReverseIDH();   
	edgeE->calHMG();
      }

    }else{

      // B -> A
      //cout << "B -> A" << endl;
      T_psl += generateNewIDHfromPairwiseAlignment(alignS[4], alignS[1], edgeE->getEdgeLen(), listIDH[4], rand, params);
   
      if(edgeE->getStart() == nodeB){
	tmpIDH = edgeE->getIDH();
	(*tmpIDH) = (*listIDH[4]);
	edgeE->calHMG();
      }else{
	tmpIDH = edgeE->getIDH();
	(*tmpIDH) = (*listIDH[4]);      
	edgeE->ReverseIDH();   
	edgeE->calHMG();
      }
 
    }



    psl[0] = T_psl;
    //IDHlike[0] = likeliHistory(params);
    //root->likeliDataR_v2(params);
    //datalike[0] = likeliData();


    /*** NNI.v2 start ****/
    T_N_IDHlike = 0;
    T_N_IDHlike += edgeE->likeliHistory(params);
    T_N_IDHlike += edgeE1->likeliHistory(params);
    T_N_IDHlike += edgeE2->likeliHistory(params);
    T_N_IDHlike += edgeE3->likeliHistory(params);
    T_N_IDHlike += edgeE4->likeliHistory(params);
    if(ABroot)
      T_N_IDHlike += log(params.getR()) + root->getSeqLen()*log(1-params.getR());
    //IDHlike[0] = likeliHistory(params);
    setlogLikeliIDH(O_IDHlike - T_O_IDHlike + T_N_IDHlike);
    IDHlike[0] = getlogLikeliIDH();
    //cout << "To check 1st IDH start " << endl;
    //cout << "original IDHlike " << IDHlike[0] << endl;
    //printTree();
    //IDHlike[0] = likeliHistory(params);
    //cout << "1st IDHlike : " << IDHlike[0] << endl;
    //cout << "To check 1st IDH end " << endl;

    /*** NNI.v2 end ****/
    

    /*** NNI.v2 start ***/
    //root->likeliDataR_v2(params);
    if(ABroot){ 
      // caseI 
      nodeN1->findRootSites();
      nodeN1->CalloglikeliofRootSitesOrReuse(params);
      nodeN1->CalSubTreeProb(params);

      nodeN2->findRootSites();
      nodeN2->CalloglikeliofRootSitesOrReuse(params);
      nodeN2->CalSubTreeProb(params);

      nodeN3->findRootSites();
      nodeN3->CalloglikeliofRootSitesOrReuse(params);
      nodeN3->CalSubTreeProb(params);

      nodeN4->findRootSites();
      nodeN4->CalloglikeliofRootSitesOrReuse(params);
      nodeN4->CalSubTreeProb(params);

      edgeE->getEnd()->findRootSites();
      edgeE->getEnd()->CalloglikeliofRootSites(params);
      edgeE->getEnd()->CalSubTreeProb(params);

      root->findLinkedSites();
      root->CalloglikeliofLinkedSites(params);

    }else{

      // caseII
      if(nodeN1->getnumber()!=RootIX){
	nodeN1->findRootSites();
	nodeN1->CalloglikeliofRootSitesOrReuse(params);
	nodeN1->CalSubTreeProb(params);      
      }

      if(nodeN2->getnumber()!=RootIX){
	nodeN2->findRootSites();
	nodeN2->CalloglikeliofRootSitesOrReuse(params);
	nodeN2->CalSubTreeProb(params);      
      }

      if(nodeN3->getnumber()!=RootIX){
	nodeN3->findRootSites();
	nodeN3->CalloglikeliofRootSitesOrReuse(params);
	nodeN3->CalSubTreeProb(params);      
      }

      if(nodeN4->getnumber()!=RootIX){
	nodeN4->findRootSites();
	nodeN4->CalloglikeliofRootSitesOrReuse(params);
	nodeN4->CalSubTreeProb(params);      
      }

      edgeE->getEnd()->findRootSites();
      edgeE->getEnd()->CalloglikeliofRootSites(params);
      edgeE->getEnd()->CalSubTreeProb(params);

      edgeE->getStart()->findRootSites();
      edgeE->getStart()->CalloglikeliofRootSites(params);
      edgeE->getStart()->CalSubTreeProb(params);

      if(nodes[RootIX]->getRoot()){
	root->findLinkedSites();
	root->CalloglikeliofLinkedSites(params);
      }else{
	UpdateAllinfoToRoot(params, nodes[RootIX]);
      } 
       
    }
    datalike[0] = likeliData(); 
    /*** NNI.v2 end ***/




    N_psl_v1[2] = T_psl - N_psl_v1[1] - N_psl_v1[0];




    //cout << "1st Tree topology " << endl;
    //printTree();
    //checkTree();


    restore();

    //------------------------
    //
    //  Consider topology 1   N1 - A - N4    N2 - B - N3
    //
    //  alignS[0] = N1
    //  alignS[1] = N2
    //  alignS[2] = N4
    //  alignS[3] = N3
    //  alignS[4] = A
    //  alignS[5] = B
    //------------------------

    T_psl = 0;
    alignS.resize(6);
    alignS[0] = alignS_tmp[0]; // N1 <= N1
    alignS[1] = alignS_tmp[1]; // N2 <= N2
    alignS[2] = alignS_tmp[3]; // N3 <= N4
    alignS[3] = alignS_tmp[2]; // N4 <= N3
    alignS[4] = alignS_tmp[4]; // A  <= A
    alignS[5] = alignS_tmp[5]; // B  <= B
    

    //-----------------------------
    //
    //  Generate determined status
    //
    //-----------------------------

    intTmp2 = alignS_tmp[0].size();
    //alignAB1.resize(2);
    tempA.resize(0);
    tempB.resize(0);
    fix.resize(0);
    
    for(i = 0; i < intTmp2; i++){
      if((alignS[0][i] == -1)&(alignS[2][i] == -1)){
	fix.push_back(-2);
	tempA.push_back(0);
	tempB.push_back(0);
      }else if((alignS[1][i] == -1)&(alignS[3][i] == -1)){
	fix.push_back(2);
	tempA.push_back(0);
	tempB.push_back(0);
      }else{
	fix.push_back(1);
	tempA.push_back(1);
	tempB.push_back(1);
      }
    }

    //-----------------------------
    //
    //  Generate undetermined status
    //
    //-----------------------------
   
    i = 0;

    if(((fix[i]!=1) & (fix.size()==1)) | ((fix[i]!=1) & (fix[i+1]!=1))){
    //if((fix[i]!=1) & (fix[i+1]!=1)){
      // A3
      // if 1st and 2nd are not determined.
      // we need to determin by just looking at 1st column

      // N1 and N4 are (-,-) or N2 and N3 are (-,-)
      if(fix[i] == -2){
	// N1 and N4 are (-,-)

	// caseI and caseII
	if((alignS[1][i] != -1)&(alignS[3][i] != -1)){

	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (-1,1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(1);
	  Nalign[1].resize(1);
	  Nalign[2].resize(1);
	  Nalign[3].resize(1);
	  Nalign[4].resize(1);
	  Nalign[5].resize(1);
	
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	
	  // N4
	  Nalign[2][0] = alignS[2][i];
	  
	  // N2
	  Nalign[3][0] = alignS[1][i];
	  
	  // N3
	  Nalign[5][0] = alignS[3][i];
	  
	  
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }

	    
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  

	}else{

	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (-1,1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(1);
	  Nalign[1].resize(1);
	  Nalign[2].resize(1);
	  Nalign[3].resize(1);
	  Nalign[4].resize(1);
	  Nalign[5].resize(1);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  
	  // N4
	  Nalign[2][0] = alignS[2][i];
	  
	  // N2
	  Nalign[3][0] = alignS[1][i];
	  
	  // N3
	  Nalign[5][0] = alignS[3][i];    
	  
	  
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	} // End of caseI and caseII
	
      }else if(fix[i] == 2){
	// N2 and N3 are (-,-)
	
	// caseI and caseII
	if((alignS[0][i] != -1)&(alignS[2][i] != -1)){
	  
	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(1);
	    Nalign[1].resize(1);
	    Nalign[2].resize(1);
	    Nalign[3].resize(1);
	    Nalign[4].resize(1);
	    Nalign[5].resize(1);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i];

	    // N4
	    Nalign[2][0] = alignS[2][i];

	    // N2
	    Nalign[3][0] = alignS[1][i];
        
	    // N3
	    Nalign[5][0] = alignS[3][i];
	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][0] = ABtemp[j][0];
	      Nalign[4][0] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(1);
	    Nalign[1].resize(1);
	    Nalign[2].resize(1);
	    Nalign[3].resize(1);
	    Nalign[4].resize(1);
	    Nalign[5].resize(1);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i];
      
	    // N4
	    Nalign[2][0] = alignS[2][i];
      
	    // N2
	    Nalign[3][0] = alignS[1][i];

	    // N3
	    Nalign[5][0] = alignS[3][i];
	    

	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][0] = ABtemp[j][0];
	      Nalign[4][0] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N4 are (-,-) or N2 and N3 are (-,-)


    }else if((fix[i]!=1) & (fix[i+1]==1)){ 
      // if 1st is not determined but 2nd is determined.
      // we need to determin by looking at 1st and 2nd together

      // N1 and N4 are (-,-) or N2 and N3 are (-,-)
      if(fix[i] == -2){
	// N1 and N4 are (-,-)

	// caseI and caseII
	if((alignS[1][i] != -1)&(alignS[3][i] != -1)){

	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (-1,1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	    
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];

	  // A
	  Nalign[1][1] = tempA[i+1];

	  // N4
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];

	  // N2
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N3
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];


	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }

	    
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	}else{

	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (-1,1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = 1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  

	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N4
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  
	  // N2
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N3
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];


	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	} // End of caseI and caseII
	
      }else if(fix[i] == 2){
	// N2 and N3 are (-,-)
	
	// caseI and caseII
	if((alignS[0][i] != -1)&(alignS[2][i] != -1)){
	  
	  // caseI
	  numID.resize(2);
	  // caseI - 1 (A,B) = (1,1)
	  // caseI - 1 (A,B) = (1,-1)
	  ABtemp.resize(2);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = -1;
	  ABtemp[1] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N4
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  
	  
	  // N2
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];
	  
	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N3
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];
	  

	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][1] = ABtemp[j][0];
	    Nalign[4][1] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	}else{
	  
	  // case II
	  numID.resize(3);
	  // caseII - 1 (A,B) = (1,1)
	  // caseII - 2 (A,B) = (1,-1)
	  // caseII - 3 (A,B) = (-1,-1)
	  ABtemp.resize(3);
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = 1;
	  ABtemp[0] = temp;
	  temp.resize(2);
	  temp[0] = 1;
	  temp[1] = -1;
	  ABtemp[1] = temp;
	  temp.resize(2);
	  temp[0] = -1;
	  temp[1] = -1;
	  ABtemp[2] = temp;
	  
	  
	  Nalign.resize(6);
	  Nalign[0].resize(2);
	  Nalign[1].resize(2);
	  Nalign[2].resize(2);
	  Nalign[3].resize(2);
	  Nalign[4].resize(2);
	  Nalign[5].resize(2);
	  
	  // N1 
	  Nalign[0][0] = alignS[0][i];
	  Nalign[0][1] = alignS[0][i+1];
	  
	  // A
	  Nalign[1][1] = tempA[i+1];
	  
	  // N4
	  Nalign[2][0] = alignS[2][i];
	  Nalign[2][1] = alignS[2][i+1];
	  

	  // N2
	  Nalign[3][0] = alignS[1][i];
	  Nalign[3][1] = alignS[1][i+1];

	  // B
	  Nalign[4][1] = tempB[i+1];
	  
	  // N3
	  Nalign[5][0] = alignS[3][i];
	  Nalign[5][1] = alignS[3][i+1];
	  

	    
	  intTmp = numID.size();
	  wei.resize(intTmp);
	  
	  for(j = 0; j < intTmp; j++){
	    
	    Nalign[1][0] = ABtemp[j][0];
	    Nalign[4][0] = ABtemp[j][1];
	    
	    numID[j] = countNumID(Nalign);
	    wei[j] = pow(1/(double)numID[j], NNI_c);
	    
	  }
	  
	  
	  intTmp = rand.rwunif(wei);
	  T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	  wei.resize(0);

	  fix[i] = 1;
	  tempA[i] = ABtemp[intTmp][0];
	  tempB[i] = ABtemp[intTmp][1];
	  
	  
	} // End of caseI and caseII
	
      }else{
	cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
      } // End of N1 and N4 are (-,-) or N2 and N3 are (-,-)
      
    } // End of all case i==0 is undetermined.

    // when i >= 1


    // First screen
    for(i = 1; i < (intTmp2-1); i++){
      
      if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){



	//cout << "Fst screen " << i << endl;
	// N1 and N4 are (-,-) or N2 and N3 are (-,-)
	if(fix[i] == -2){
	  // N1 and N4 are (-,-)

	  // caseI and caseII
	  if((alignS[1][i] != -1)&(alignS[3][i] != -1)){

	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (-1,1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N4
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N3
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{
	    //cout << "caseII " << endl;
	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (-1,1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N4
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N3
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    //cout << "numID " << endl;
	    //print_veci(numID);
	    //cout << "wei " << endl;
	    //print_vecd(wei);
	    
	    intTmp = rand.rwunif(wei);

	    //cout << "intTmp " << intTmp << endl;
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else if(fix[i] == 2){
	  // N2 and N3 are (-,-)

	  // caseI and caseII
	  if((alignS[0][i] != -1)&(alignS[2][i] != -1)){

	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N4
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N3
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(3);
	    Nalign[1].resize(3);
	    Nalign[2].resize(3);
	    Nalign[3].resize(3);
	    Nalign[4].resize(3);
	    Nalign[5].resize(3);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	    Nalign[0][2] = alignS[0][i+1];

	    // A
	    Nalign[1][0] = tempA[i-1];
	    //Nalign[1][1] = 1;
	    Nalign[1][2] = tempA[i+1];

	    // N4
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
	    Nalign[2][2] = alignS[2][i+1];


	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
	    Nalign[3][2] = alignS[1][i+1];

	    // B
	    Nalign[4][0] = tempB[i-1];
	    //Nalign[4][1] = 1;
	    Nalign[4][2] = tempB[i+1];

	    // N3
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
	    Nalign[5][2] = alignS[3][i+1];


	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N4 are (-,-) or N2 and N3 are (-,-)

      } // End of if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){
        // right and left sides are determined.    
    } 
    // End of first screen



    // Second screen
    for(i = 1; i < intTmp2; i++){
      
      if((fix[i-1]==1) & (fix[i]!=1)){
      
	// N1 and N4 are (-,-) or N2 and N3 are (-,-)
	if(fix[i] == -2){
	  // N1 and N4 are (-,-)

	  // caseI and caseII
	  if((alignS[1][i] != -1)&(alignS[3][i] != -1)){

	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (-1,1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
	
	    // A
	    Nalign[1][0] = tempA[i-1];
	 
	    // N4
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
       
	    // B
	    Nalign[4][0] = tempB[i-1];
	  
	    // N3
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (-1,1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = 1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
   
	    // A
	    Nalign[1][0] = tempA[i-1];

	    // N4
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
    
	    // B
	    Nalign[4][0] = tempB[i-1];
       
	    // N3
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];
    

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else if(fix[i] == 2){
	  // N2 and N3 are (-,-)

	  // caseI and caseII
	  if((alignS[0][i] != -1)&(alignS[2][i] != -1)){

	    // caseI
	    numID.resize(2);
	    // caseI - 1 (A,B) = (1,1)
	    // caseI - 1 (A,B) = (1,-1)
	    ABtemp.resize(2);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
       
	    // A
	    Nalign[1][0] = tempA[i-1];
	 
	    // N4
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];

	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
    
	    // B
	    Nalign[4][0] = tempB[i-1];
     
	    // N3
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


	  }else{

	    // case II
	    numID.resize(3);
	    // caseII - 1 (A,B) = (1,1)
	    // caseII - 2 (A,B) = (1,-1)
	    // caseII - 3 (A,B) = (-1,-1)
	    ABtemp.resize(3);
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = 1;
	    ABtemp[0] = temp;
	    temp.resize(2);
	    temp[0] = 1;
	    temp[1] = -1;
	    ABtemp[1] = temp;
	    temp.resize(2);
	    temp[0] = -1;
	    temp[1] = -1;
	    ABtemp[2] = temp;
	    

	    Nalign.resize(6);
	    Nalign[0].resize(2);
	    Nalign[1].resize(2);
	    Nalign[2].resize(2);
	    Nalign[3].resize(2);
	    Nalign[4].resize(2);
	    Nalign[5].resize(2);
	
	    // N1 
	    Nalign[0][0] = alignS[0][i-1];
	    Nalign[0][1] = alignS[0][i];
     
	    // A
	    Nalign[1][0] = tempA[i-1];
      
	    // N4
	    Nalign[2][0] = alignS[2][i-1];
	    Nalign[2][1] = alignS[2][i];
  
	    // N2
	    Nalign[3][0] = alignS[1][i-1];
	    Nalign[3][1] = alignS[1][i];
  
	    // B
	    Nalign[4][0] = tempB[i-1];
      
	    // N3
	    Nalign[5][0] = alignS[3][i-1];
	    Nalign[5][1] = alignS[3][i];

	    
	    intTmp = numID.size();
	    wei.resize(intTmp);

	    for(j = 0; j < intTmp; j++){

	      Nalign[1][1] = ABtemp[j][0];
	      Nalign[4][1] = ABtemp[j][1];

	      numID[j] = countNumID(Nalign);
	      wei[j] = pow(1/(double)numID[j], NNI_c);

	    }

	    
	    intTmp = rand.rwunif(wei);
	    T_psl += log(wei[intTmp]) - log(sum_vec(wei));
	    wei.resize(0);

	    fix[i] = 1;
	    tempA[i] = ABtemp[intTmp][0];
	    tempB[i] = ABtemp[intTmp][1];


          } // End of caseI and caseII

	}else{
	  cout << "ERROR in NNIwithFixedHMG! fix[i] should be -2 or 2 now. " << endl;
        } // End of N1 and N4 are (-,-) or N2 and N3 are (-,-)

      } // End of if(((fix[i-1]==1) & (fix[i]!=1)) & (fix[i+1]==1)){
        // right and left sides are determined.    
    } 
    // End of second screen

    // A
    //alignS[4] = tempA;
    // B
    //alignS[5] = tempB;

    alignS.resize(6);
    alignS[0] = alignS_tmp[0];
    alignS[1] = tempA;
    alignS[2] = alignS_tmp[3];
    alignS[3] = alignS_tmp[1];
    alignS[4] = tempB;
    alignS[5] = alignS_tmp[2];   
    



    //cout << "print alignS size : " << alignS.size() << endl;
    //for(i = 0; i < alignS.size(); i++){
    //  k = alignS[i].size();
    //  for(j = 0; j < k; j++){
    //	if(alignS[i][j] == -1)
    //	  cout << "-" ;
    //	else
    //	  cout << alignS[i][j];
    //     }
    //      cout << endl;
    //    }
    



    //----------------------------------------------
    //
    //  Count # of events at each edge roughly
    //
    //----------------------------------------------

    numID.resize(0);
    countNumIDonEachEdge(alignS, numID, MaxIDsize);

    if(is_element(numID, 0)){
      for(i = 0; i < 5; i++)
	numID[i]++;
    }
    //cout << "total numID MaxIDsize : "  << MaxIDsize << endl;
    //print_veci(numID);

    //---------------------------------------------
    //
    //  Construct New Tree
    //
    //---------------------------------------------

    if(nodeA == edgeE2->getEnd()){ 
      // Change II
      edgeE2->setEnd(nodeB);
      nodeB->setEdge(edgeE4, edgeE2);
      nodeB->setParentEdge(edgeE2);
      edgeE4->setStart(nodeA);
      nodeA->setEdge(edgeE2, edgeE4);
      nodeA->setParentEdge(edgeE);     
      edgeE->changeStartEnd();
    }else if(nodeB == edgeE4->getEnd()){
      // Change III
      edgeE2->setStart(nodeB);
      nodeB->setEdge(edgeE4, edgeE2);
      nodeB->setParentEdge(edgeE);
      edgeE4->setEnd(nodeA);
      nodeA->setEdge(edgeE2, edgeE4);
      nodeA->setParentEdge(edgeE4);     
      edgeE->changeStartEnd();  
    }else if((nodeA == edgeE2->getStart()) & (nodeB == edgeE4->getStart())){
      //  Change I
      edgeE2->setStart(nodeB);
      nodeB->setEdge(edgeE4, edgeE2);
      edgeE4->setStart(nodeA);
      nodeA->setEdge(edgeE2, edgeE4);
    }else{
      cout << "ERROR in NNI A " << endl;
    }
    
      
    //----------------------------------------------
    //
    //  Generate branch length based on # of counts
    //    and set branch length
    //
    //----------------------------------------------    


    N_psl_v2[0] = T_psl;

    //cout << "T_psl : " << T_psl << endl;

    wei.resize(5);
    doubleTmp = (double)sum_veci(numID);

    for(i = 0; i < 5; i++)
      wei[i] = (NNI_Dirich_c*(double)numID[i])/doubleTmp;


    //cout << "wei for branch length : "  << endl;
    //print_vecd(wei);

    edgelenV.resize(5);
    for(i = 0; i < 5; i++)
      edgelenV[i] = rng.gamma(wei[i], 1);

    T_psl += lgamma(NNI_Dirich_c);
    
    doubleTmp = sum_vec(edgelenV);
    for(i = 0; i < 5; i++){
      edgelenV[i] /= doubleTmp;
      T_psl += (wei[i]-1)*log(edgelenV[i]) - lgamma(wei[i]);

      edgelenV[i] *= totalEdge;
    }
   
    //cout << "edge len " << endl;
    //print_vecd(edgelenV);
    //cout << "T_psl : " << T_psl << endl;


    // 0 -> node1
    // 1 -> node4
    // 2 -> node2
    // 3 -> node3
    // 4 -> middle
    
    edgeE1->setEdgeLen(edgelenV[0]);
    edgeE4->setEdgeLen(edgelenV[1]);
    edgeE2->setEdgeLen(edgelenV[2]);
    edgeE3->setEdgeLen(edgelenV[3]);
    edgeE->setEdgeLen(edgelenV[4]);
    
    wei.resize(0);
    edgelenV.resize(0);


    N_psl_v2[1] = T_psl - N_psl_v2[0];
    
    //----------------------------------------------
    //
    //  Generate IDH in each block
    //
    //----------------------------------------------    
    
    // To decide direction of IDH generation
    // Let's find which one (A and B) is close to Leaf 0.
    // save at nodeTemp

    HitRoot = false;
    TempEdge = getNode(0)->getParentEdge();
    while(TempEdge != edgeE){

	if(TempEdge->getStart()->getRoot()){
	  HitRoot = true;
	  break;
	}

	TempEdge = TempEdge->getParentEdge();
    }

    if(HitRoot)
      nodeTemp = edgeE->getStart();
    else
      nodeTemp = edgeE->getEnd();


    //cout << "close node " << nodeTemp->getnumber() << endl;

    // Generate New IDH
    // A -> N1
    T_psl += generateNewIDHfromPairwiseAlignment(alignS[1], alignS[0], edgeE1->getEdgeLen(), edgeE1->getIDH(), rand, params);
   
    if(edgeE1->getStart() == nodeA){
      nodeA->setSeqLen(edgeE1->getIDH()->getN(0));
      edgeE1->calHMG();
    }else{  
      edgeE1->ReverseIDH();
      nodeA->setSeqLen(edgeE1->getIDH()->getN(edgeE1->getIDH()->getNumE()));      
      edgeE1->calHMG();
    }

    // A -> N4
    T_psl += generateNewIDHfromPairwiseAlignment(alignS[1], alignS[2], edgeE4->getEdgeLen(), edgeE4->getIDH(), rand, params);
   
    if(edgeE4->getStart() == nodeA){
      edgeE4->calHMG();
    }else{  
      edgeE3->ReverseIDH();      
      edgeE3->calHMG();
    }


    // B -> N2
    T_psl += generateNewIDHfromPairwiseAlignment(alignS[4], alignS[3], edgeE2->getEdgeLen(), edgeE2->getIDH(), rand, params);
   
    if(edgeE2->getStart() == nodeB){
      nodeB->setSeqLen(edgeE2->getIDH()->getN(0));
      edgeE2->calHMG();
    }else{  
      edgeE2->ReverseIDH();
      nodeB->setSeqLen(edgeE2->getIDH()->getN(edgeE2->getIDH()->getNumE()));      
      edgeE2->calHMG();
    }

    // B -> N3
    T_psl += generateNewIDHfromPairwiseAlignment(alignS[4], alignS[5], edgeE3->getEdgeLen(), edgeE3->getIDH(), rand, params);
   
    if(edgeE3->getStart() == nodeB){
      edgeE3->calHMG();
    }else{      
      edgeE3->ReverseIDH();
      edgeE3->calHMG();
    }

    // A -> B or B -> A
    if(nodeTemp == nodeA){

      // A -> B

      T_psl += generateNewIDHfromPairwiseAlignment(alignS[1], alignS[4], edgeE->getEdgeLen(), edgeE->getIDH(), rand, params);
   
      if(edgeE->getStart() == nodeA){
	edgeE->calHMG();
      }else{   
	edgeE->ReverseIDH();   
	edgeE->calHMG();
      }

    }else{

      // B -> A

      T_psl += generateNewIDHfromPairwiseAlignment(alignS[4], alignS[1], edgeE->getEdgeLen(), edgeE->getIDH(), rand, params);
   
      if(edgeE->getStart() == nodeB){
	edgeE->calHMG();
      }else{   
	edgeE->ReverseIDH();   
	edgeE->calHMG();
      }
 
    }




    N_psl_v2[2] = T_psl - N_psl_v2[1] - N_psl_v2[0];

    psl[1] = T_psl;
    //IDHlike[1] = likeliHistory(params);
    //root->likeliDataR_v2(params);
    //datalike[1] = likeliData();


    /*** NNI.v2 start ****/
    T_N_IDHlike = 0;
    T_N_IDHlike += edgeE->likeliHistory(params);
    T_N_IDHlike += edgeE1->likeliHistory(params);
    T_N_IDHlike += edgeE2->likeliHistory(params);
    T_N_IDHlike += edgeE3->likeliHistory(params);
    T_N_IDHlike += edgeE4->likeliHistory(params);
    if(ABroot)
      T_N_IDHlike += log(params.getR()) + root->getSeqLen()*log(1-params.getR());
    //IDHlike[1] = likeliHistory(params);
    setlogLikeliIDH(O_IDHlike - T_O_IDHlike + T_N_IDHlike);
    IDHlike[1] = getlogLikeliIDH();

    //cout << "To check 2nd IDH start " << endl;
    //cout << "original IDHlike " << IDHlike[1] << endl;
    //printTree();
    //IDHlike[1] = likeliHistory(params);
    //cout << "2nd IDHlike : " << IDHlike[1] << endl;
    //cout << "To check 2nd IDH end " << endl;
    /*** NNI.v2 end ****/


    /*** NNI.v2 start ***/
    //root->likeliDataR_v2(params);
    if(ABroot){ 
      // caseI 
      nodeN1->findRootSites();
      nodeN1->CalloglikeliofRootSitesOrReuse(params);
      nodeN1->CalSubTreeProb(params);

      nodeN2->findRootSites();
      nodeN2->CalloglikeliofRootSitesOrReuse(params);
      nodeN2->CalSubTreeProb(params);

      nodeN3->findRootSites();
      nodeN3->CalloglikeliofRootSitesOrReuse(params);
      nodeN3->CalSubTreeProb(params);

      nodeN4->findRootSites();
      nodeN4->CalloglikeliofRootSitesOrReuse(params);
      nodeN4->CalSubTreeProb(params);

      edgeE->getEnd()->findRootSites();
      edgeE->getEnd()->CalloglikeliofRootSites(params);
      edgeE->getEnd()->CalSubTreeProb(params);

      root->findLinkedSites();
      root->CalloglikeliofLinkedSites(params);

    }else{

      // caseII
      if(nodeN1->getnumber()!=RootIX){
	nodeN1->findRootSites();
	nodeN1->CalloglikeliofRootSitesOrReuse(params);
	nodeN1->CalSubTreeProb(params);      
      }

      if(nodeN2->getnumber()!=RootIX){
	nodeN2->findRootSites();
	nodeN2->CalloglikeliofRootSitesOrReuse(params);
	nodeN2->CalSubTreeProb(params);      
      }

      if(nodeN3->getnumber()!=RootIX){
	nodeN3->findRootSites();
	nodeN3->CalloglikeliofRootSitesOrReuse(params);
	nodeN3->CalSubTreeProb(params);      
      }

      if(nodeN4->getnumber()!=RootIX){
	nodeN4->findRootSites();
	nodeN4->CalloglikeliofRootSitesOrReuse(params);
	nodeN4->CalSubTreeProb(params);      
      }

      edgeE->getEnd()->findRootSites();
      edgeE->getEnd()->CalloglikeliofRootSites(params);
      edgeE->getEnd()->CalSubTreeProb(params);

      edgeE->getStart()->findRootSites();
      edgeE->getStart()->CalloglikeliofRootSites(params);
      edgeE->getStart()->CalSubTreeProb(params);

      if(nodes[RootIX]->getRoot()){
	root->findLinkedSites();
	root->CalloglikeliofLinkedSites(params);
      }else{
	UpdateAllinfoToRoot(params, nodes[RootIX]);
      } 
       
    }
    datalike[1] = likeliData(); 
    /*** NNI.v2 end ***/




    //cout << "2nd Tree topology " << endl;
    //printTree();
    //checkTree();

    // pick one of the topologies based on their likelihood
    wei.resize(2);
    wei[0] = IDHlike[0] + datalike[0];
    wei[1] = IDHlike[1] + datalike[1];
    maxL = max_vec(wei);
    for( i = 0; i < 2; i++)
      wei[i] = exp((wei[i] - maxL));

    maxL = sum_vec(wei);
    for( i = 0; i < 2; i++)
      wei[i] = wei[i]/maxL;

    upd_posi = rand.rwunif(wei);

    //cout << "upd_posi : " << upd_posi << endl; 
    //cout << "wei" << endl;
    //print_vecd(wei);
    //cout << "IDHlike" << endl;
    //print_vecd(IDHlike);
    //cout << "datalike" << endl;
    //print_vecd(datalike);    
    //cout << "psl" << endl;
    //print_vecd(psl);      


    if(upd_posi==0){
      // we need to move to!
      restore();
      

      if(nodeA == edgeE2->getEnd()){ 
	// Change II
	edgeE2->setEnd(nodeB);
	nodeB->setEdge(edgeE3, edgeE2);
	nodeB->setParentEdge(edgeE2);
	edgeE3->setStart(nodeA);
	nodeA->setEdge(edgeE2, edgeE3);
	nodeA->setParentEdge(edgeE);     
	edgeE->changeStartEnd();
      }else if(nodeB == edgeE3->getEnd()){
	// Change III
	edgeE2->setStart(nodeB);
	nodeB->setEdge(edgeE3, edgeE2);
	nodeB->setParentEdge(edgeE);
	edgeE3->setEnd(nodeA);
	nodeA->setEdge(edgeE2, edgeE3);
	nodeA->setParentEdge(edgeE3);     
	edgeE->changeStartEnd();  
      }else if((nodeA == edgeE2->getStart()) & (nodeB == edgeE3->getStart())){
	//  Change I
	edgeE2->setStart(nodeB);
	nodeB->setEdge(edgeE3, edgeE2);
	edgeE3->setStart(nodeA);
	nodeA->setEdge(edgeE2, edgeE3);
      }else{
	cout << "ERROR in NNI A " << endl;
      }
    

      // Set IDH and branch length


      // A -> N1   
      edgeE1->setEdgeLen(listIDH[0]->getV(listIDH[0]->getNumE() + 1));


      if(edgeE1->getStart() == nodeA){
	tmpIDH = edgeE1->getIDH();
	(*tmpIDH) = (*listIDH[0]);
	nodeA->setSeqLen(edgeE1->getIDH()->getN(0));
	edgeE1->calHMG();
      }else{
	tmpIDH = edgeE1->getIDH();
	(*tmpIDH) = (*listIDH[0]);      
	edgeE1->ReverseIDH();
	nodeA->setSeqLen(edgeE1->getIDH()->getN(edgeE1->getIDH()->getNumE()));      
	edgeE1->calHMG();
      }
      //edgeE1->setEdgeLen(edgeE1->getIDH()->getV(edgeE1->getIDH()->getNumE() + 1));


      edgeE3->setEdgeLen(listIDH[1]->getV(listIDH[1]->getNumE() + 1));
       
      // A -> N3
      if(edgeE3->getStart() == nodeA){
	tmpIDH = edgeE3->getIDH();
	(*tmpIDH) = (*listIDH[1]);
	edgeE3->calHMG();
      }else{
	tmpIDH = edgeE3->getIDH();
	(*tmpIDH) = (*listIDH[1]);      
	edgeE3->ReverseIDH();      
	edgeE3->calHMG();
      }
      //edgeE3->setEdgeLen(edgeE3->getIDH()->getV(edgeE3->getIDH()->getNumE() + 1));


      edgeE2->setEdgeLen(listIDH[2]->getV(listIDH[2]->getNumE() + 1));
       

      // B -> N2
      if(edgeE2->getStart() == nodeB){
	tmpIDH = edgeE2->getIDH();
	(*tmpIDH) = (*listIDH[2]);
	nodeB->setSeqLen(edgeE2->getIDH()->getN(0));
	edgeE2->calHMG();
      }else{
	tmpIDH = edgeE2->getIDH();
	(*tmpIDH) = (*listIDH[2]);      
	edgeE2->ReverseIDH();
	nodeB->setSeqLen(edgeE2->getIDH()->getN(edgeE2->getIDH()->getNumE()));      
	edgeE2->calHMG();
      }
      //edgeE2->setEdgeLen(edgeE2->getIDH()->getV(edgeE2->getIDH()->getNumE() + 1));


      edgeE4->setEdgeLen(listIDH[3]->getV(listIDH[3]->getNumE() + 1));
       
      // B -> N4
      if(edgeE4->getStart() == nodeB){
	tmpIDH = edgeE4->getIDH();
	(*tmpIDH) = (*listIDH[3]);
	edgeE4->calHMG();
      }else{
	tmpIDH = edgeE4->getIDH();
	(*tmpIDH) = (*listIDH[3]);      
	edgeE4->ReverseIDH();
	edgeE4->calHMG();
      }
      //edgeE4->setEdgeLen(edgeE4->getIDH()->getV(edgeE4->getIDH()->getNumE() + 1));


      edgeE->setEdgeLen(listIDH[4]->getV(listIDH[4]->getNumE() + 1));
       

      // A -> B or B -> A
      if(FstCloseNode== nodeA->getnumber()){
	
	// A -> B
	
	if(edgeE->getStart() == nodeA){
	  tmpIDH = edgeE->getIDH();
	  (*tmpIDH) = (*listIDH[4]);
	  edgeE->calHMG();
	}else{
	  tmpIDH = edgeE->getIDH();
	  (*tmpIDH) = (*listIDH[4]);      
	  edgeE->ReverseIDH();   
	  edgeE->calHMG();
	}
	//edgeE->setEdgeLen(edgeE->getIDH()->getV(edgeE->getIDH()->getNumE() + 1));
	
      }else{
	
	// B -> A
	
	if(edgeE->getStart() == nodeB){
	  tmpIDH = edgeE->getIDH();
	  (*tmpIDH) = (*listIDH[4]);
	  edgeE->calHMG();
	}else{
	  tmpIDH = edgeE->getIDH();
	  (*tmpIDH) = (*listIDH[4]);      
	  edgeE->ReverseIDH();   
	  edgeE->calHMG();
	}
	
      }


      //N_IDHlike = likeliHistory(params);
      //root->likeliDataR_v2(params);
      //N_datalike = likeliData();


      /*** NNI.v2 start ****/
      T_N_IDHlike = 0;
      T_N_IDHlike += edgeE->likeliHistory(params);
      T_N_IDHlike += edgeE1->likeliHistory(params);
      T_N_IDHlike += edgeE2->likeliHistory(params);
      T_N_IDHlike += edgeE3->likeliHistory(params);
      T_N_IDHlike += edgeE4->likeliHistory(params);
      if(ABroot)
	T_N_IDHlike += log(params.getR()) + root->getSeqLen()*log(1-params.getR());
      //N_IDHlike = likeliHistory(params);
      setlogLikeliIDH(O_IDHlike - T_O_IDHlike + T_N_IDHlike);
      N_IDHlike = getlogLikeliIDH();
      /*** NNI.v2 end ****/

      /*** NNI.v2 start ***/
      //root->likeliDataR_v2(params);
      if(ABroot){ 
	// caseI 
	nodeN1->findRootSites();
	nodeN1->CalloglikeliofRootSitesOrReuse(params);
	nodeN1->CalSubTreeProb(params);
	
	nodeN2->findRootSites();
	nodeN2->CalloglikeliofRootSitesOrReuse(params);
	nodeN2->CalSubTreeProb(params);
	
	nodeN3->findRootSites();
	nodeN3->CalloglikeliofRootSitesOrReuse(params);
	nodeN3->CalSubTreeProb(params);
	
	nodeN4->findRootSites();
	nodeN4->CalloglikeliofRootSitesOrReuse(params);
	nodeN4->CalSubTreeProb(params);
	
	edgeE->getEnd()->findRootSites();
	edgeE->getEnd()->CalloglikeliofRootSites(params);
	edgeE->getEnd()->CalSubTreeProb(params);
	
	root->findLinkedSites();
	root->CalloglikeliofLinkedSites(params);
	
      }else{
	
	// caseII
	if(nodeN1->getnumber()!=RootIX){
	  nodeN1->findRootSites();
	  nodeN1->CalloglikeliofRootSitesOrReuse(params);
	  nodeN1->CalSubTreeProb(params);      
	}
	
	if(nodeN2->getnumber()!=RootIX){
	  nodeN2->findRootSites();
	  nodeN2->CalloglikeliofRootSitesOrReuse(params);
	  nodeN2->CalSubTreeProb(params);      
	}
	
	if(nodeN3->getnumber()!=RootIX){
	  nodeN3->findRootSites();
	  nodeN3->CalloglikeliofRootSitesOrReuse(params);
	  nodeN3->CalSubTreeProb(params);      
	}
	
	if(nodeN4->getnumber()!=RootIX){
	  nodeN4->findRootSites();
	  nodeN4->CalloglikeliofRootSitesOrReuse(params);
	  nodeN4->CalSubTreeProb(params);      
	}
	
	edgeE->getEnd()->findRootSites();
	edgeE->getEnd()->CalloglikeliofRootSites(params);
	edgeE->getEnd()->CalSubTreeProb(params);
	
	edgeE->getStart()->findRootSites();
	edgeE->getStart()->CalloglikeliofRootSites(params);
	edgeE->getStart()->CalSubTreeProb(params);
	
	if(nodes[RootIX]->getRoot()){
	  root->findLinkedSites();
	  root->CalloglikeliofLinkedSites(params);
	}else{
	  UpdateAllinfoToRoot(params, nodes[RootIX]);
	} 
	
      }
      N_datalike = likeliData(); 
      /*** NNI.v2 end ***/



    }

    N_psl = psl[upd_posi];
    N_datalike = datalike[upd_posi];
    N_IDHlike = IDHlike[upd_posi];
    if(start)
      AP = exp( O_psl - N_psl + LOG_SUM(N_datalike + N_IDHlike - datalike[1-upd_posi] - IDHlike[1-upd_posi], 0) - LOG_SUM(O_datalike + O_IDHlike - datalike[1-upd_posi] - IDHlike[1-upd_posi], 0));
    else
      AP = exp(N_datalike + N_IDHlike - O_datalike - O_IDHlike);
    
    edgeE1->CalculatelogLikeliEdge(params);
    edgeE2->CalculatelogLikeliEdge(params);
    edgeE3->CalculatelogLikeliEdge(params);
    edgeE4->CalculatelogLikeliEdge(params);
    edgeE->CalculatelogLikeliEdge(params);

    
    if(upd_posi == 0){
      c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl_v[0] - N_psl_v1[0]) << " " << exp(O_psl_v[1] - N_psl_v1[1]) << " " <<  exp(O_psl_v[2] - N_psl_v1[2]) << " " << exp(sum_vec(O_psl_v) -sum_vec(N_psl_v1)) << " " << exp(LOG_SUM(N_datalike + N_IDHlike - datalike[1-upd_posi] - IDHlike[1-upd_posi], 0) - LOG_SUM(O_datalike + O_IDHlike - datalike[1-upd_posi] - IDHlike[1-upd_posi], 0)) << endl;
    }else{
      c << AP << " " << exp(N_datalike-O_datalike) << " " << exp(N_IDHlike - O_IDHlike) << " " << exp(O_psl_v[0] - N_psl_v2[0]) << " " << exp(O_psl_v[1] - N_psl_v2[1]) << " " <<  exp(O_psl_v[2] - N_psl_v2[2]) << " " << exp(sum_vec(O_psl_v) -sum_vec(N_psl_v2)) << " " << exp(LOG_SUM(N_datalike + N_IDHlike - datalike[1-upd_posi] - IDHlike[1-upd_posi], 0) - LOG_SUM(O_datalike + O_IDHlike - datalike[1-upd_posi] - IDHlike[1-upd_posi], 0)) << endl;
    }


    //cout << "final !!!!!!!!!!!!!!!! " << endl;
    //printTree(0);
    //checkTree();
    //cout << "AP " << AP << endl;
    //cout << "proposal ration O/N" << endl;
    //if(upd_posi == 0){
    //  cout << exp(O_psl_v[0] - N_psl_v1[0]) << " " << exp(O_psl_v[1] - N_psl_v1[1]) << " " <<  exp(O_psl_v[2] - N_psl_v1[2]) << " " << exp(sum_vec(O_psl_v) -sum_vec(N_psl_v1)) << endl;
    //}else{
    //  cout << exp(O_psl_v[0] - N_psl_v2[0]) << " " << exp(O_psl_v[1] - N_psl_v2[1]) << " " <<  exp(O_psl_v[2] - N_psl_v2[2]) << " " << exp(sum_vec(O_psl_v) -sum_vec(N_psl_v2)) << endl;
    //}
    //cout << "IDHlike ratio " << endl;
    //cout << exp(N_IDHlike - O_IDHlike) << endl;
    //cout << "datalike ratio " << endl;
    //cout << exp(N_datalike - O_datalike) << endl;    
    //cout << "rest part " << endl;
    //cout << exp(LOG_SUM(N_datalike + N_IDHlike - datalike[1-upd_posi] - IDHlike[1-upd_posi], 0) - LOG_SUM(O_datalike + O_IDHlike - datalike[1-upd_posi] - IDHlike[1-upd_posi], 0)) << endl;

    for(i = 0; i < 5; i++)
      delete listIDH[i];


  }else{  // we will just reject
    AP = 0;  
    c << -1 << " " << 0 << " " << 0 << " " << 0 << " " << 0 << " " << 0 << " " << 0 << " " << 0 << endl;
  }

  return AP;

}
/*** NNI end ***/



/*** NNI start ***/ 
double Tree::generateNewIDHfromPairwiseAlignment(vector<int> stAlign, vector<int> enAlign, double edge0len, InDelHistory* IDH, Rand &rand, const Parameters &params){


  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  vector<int> delBasePosi(0);
  int stCount, enCount;
  int i, j, IX;
  int len = stAlign.size();

  if(len != enAlign.size()){
    cout << "ERROR in generateNewIDHfromPairwiseAlignment! stAlign and enAlign should be in the same length." << endl;
    return (double)-1;
  }else{


    //---------------------------------
    //
    // Generate all information 
    //
    //---------------------------------

    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    delBasePosi.resize(0);
    
    IX = 1;
    stCount = 0;
    enCount = 0;
    stPosi.push_back(0);
    enPosi.push_back(0);
    
    for(i = 0; i < len; i++){
      if(stAlign[i] == 1){
	stCount++;
       
	if(enAlign[i] == 1){
	  enCount++;
	  
	  stPosi.push_back(stCount);
	  enPosi.push_back(enCount);
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  
	  if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
	    delBasePosi.push_back(1);
          else
	    delBasePosi.push_back(0);

	  IX++;
        }
	

      }else{

	if(enAlign[i] == 1)
	  enCount++;
      
      }

    }


    stSeqLen.push_back(stCount-stPosi[IX-1]);
    enSeqLen.push_back(enCount-enPosi[IX-1]);
    
    if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
      delBasePosi.push_back(1);
    else
      delBasePosi.push_back(0);


    //cout << "edge len : " << edge0len << endl;
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi" << endl;
    //print_veci(delBasePosi);


    //-------------------------
    //
    // Generate IDH
    //
    //-------------------------

    
    double logProbs = 0;

    //some vectors to generate events
    vector<double> V(0);
    vector<int> ID(0);
    vector<int> P(0);
    vector<int> L(0);
    vector<int> N(0);
    vector<vector<int> > HMG0;
    vector<int> HMGin(0);  
    int numE;
    vector<vector<double> > delWeight(0);
    vector<int> delBasePosiIX(0);

    vector<InDelHistory*> listIDH(0);
    vector<double> timeS(0);
    int k, eventIX, Nend; 
    IX = stPosi.size();

    eventIX = 1;
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG0.resize(0);
    HMGin.resize(0);
    

    V.push_back(0);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(stPosi[IX-1] + stSeqLen[IX-1]);
    for(k = 0; k <= N[0]; k++){
      HMGin.push_back(k);
    }
    HMG0.push_back(HMGin);
    HMGin.resize(0);


    // 3. Generate new IDH on Edge0 while keeping the original HMG.
    //            - in separate regions.
    listIDH.resize(IX);
    for(i = 0; i < IX ; i++)
      listIDH[i] = new InDelHistory();
  


    for(i = 0; i < IX; i++){
      if(delBasePosi[i] == 0){
	runEdge(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len);
	logProbs += ProposHistory(params, listIDH[i]);
      }else{

	delWeight.resize(0);
	delBasePosiIX.resize(0);
	for(j = 0; j < stSeqLen[i] ; j++)
	  delBasePosiIX.push_back(1);
	delBasePosiIX.push_back(0);
	//cout << "i : " << i << endl;
	//cout << "delBasePosiIX " << endl;
	//print_veci(delBasePosiIX);
	runEdgeWithDeletionConstraint(rand, params, listIDH[i], stSeqLen[i], enSeqLen[i], edge0len, delBasePosiIX, delWeight);
	//logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX, delWeight);
	logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX);
	delWeight.resize(0);
	delBasePosiIX.resize(0);
      }
    }
 
    
    // 4. Need to combine all 
    int total;
    int selPosi = 0;  
    timeS.resize(IX);
  
    while(1){
      total = 0;
      for(j = 0; j < IX; j++){
	if(listIDH[j]->getNumE() > 0){
	  timeS[j] = listIDH[j]->getV(1);
	}else{
	  total++;
	  timeS[j] = edge0len;
	}
      }
      if(total == IX)
	break;
      selPosi = which_min_vec(timeS);
      V.push_back(listIDH[selPosi]->getV(1));
      ID.push_back(listIDH[selPosi]->getID(1));
      L.push_back(listIDH[selPosi]->getL(1));
      P.push_back(listIDH[selPosi]->getP(1) + stPosi[selPosi]);
      if(ID[eventIX] == 1){
	N.push_back(N[eventIX-1]+L[eventIX]);
	HMGin = HMG0[eventIX-1];
	for( k = 0; k< L[eventIX]; k++)
	  HMGin.insert(HMGin.begin()+ P[eventIX],-1);
	HMG0.push_back(HMGin);
	HMGin.resize(0);
	for(i = selPosi+1; i < IX; i++)
	  stPosi[i] = stPosi[i] + L[eventIX];
      }else{
	N.push_back(N[eventIX-1]-L[eventIX]);
	HMGin = HMG0[eventIX-1];
	for( k = 0; k< L[eventIX]; k++)
	  HMGin.erase(HMGin.begin()+ P[eventIX]);
	HMG0.push_back(HMGin);
	HMGin.resize(0);
	for(i = selPosi+1; i < IX; i++)
	  stPosi[i] = stPosi[i] - L[eventIX];
      }
      eventIX++;
      listIDH[selPosi]->eraseHistory(false, 1); 
    }
    
    numE = eventIX-1;
    V.push_back(edge0len);
    ID.push_back(-2);
    P.push_back(0);
    L.push_back(0);
    N.push_back(N[numE]);    
    HMG0.push_back(HMG0[numE]);
    
  
    IDH->setHistory(numE, V, ID, P, L, N, HMG0); 
  

    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);

    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG0.resize(0);
    HMGin.resize(0);
    delWeight.resize(0);
    delBasePosiIX.resize(0);
    delBasePosi.resize(0);
    
    for(i = 0; i < listIDH.size(); i++)
      delete listIDH[i];
  
    timeS.resize(0);
    listIDH.resize(0);
  
    return logProbs;

  }
}
/*** NNI end ***/


/*** NNI start ***/
double Tree::calProbIDHfromPairwiseAlignment(vector<int> stAlign, vector<int> enAlign, double edge0len, InDelHistory* IDH, const Parameters &params){


  //cout << "In calProbIDHfromPairwiseAlignment " << endl;

  vector<int> stSeqLen(0);
  vector<int> enSeqLen(0);
  vector<int> stPosi(0);
  vector<int> enPosi(0);
  vector<int> delBasePosi(0);
  int stCount, enCount;
  int i, IX;
  int len = stAlign.size();

  if(len != enAlign.size()){
    cout << "ERROR in generateNewIDHfromPairwiseAlignment! stAlign and enAlign should be in the same length." << endl;
    return (double)-1;
  }else{


    //---------------------------------
    //
    // Generate all information 
    //
    //---------------------------------

    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    enPosi.resize(0);
    delBasePosi.resize(0);
    
    IX = 1;
    stCount = 0;
    enCount = 0;
    stPosi.push_back(0);
    enPosi.push_back(0);
    
    for(i = 0; i < len; i++){
      if(stAlign[i] == 1){
	stCount++;
       
	if(enAlign[i] == 1){
	  enCount++;
	  
	  stPosi.push_back(stCount);
	  enPosi.push_back(enCount);
	  stSeqLen.push_back(stPosi[IX]-stPosi[IX-1]-1);
	  enSeqLen.push_back(enPosi[IX]-enPosi[IX-1]-1);
	  
	  if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
	    delBasePosi.push_back(1);
          else
	    delBasePosi.push_back(0);

	  IX++;
        }
	

      }else{

	if(enAlign[i] == 1)
	  enCount++;
      
      }

    }


    stSeqLen.push_back(stCount-stPosi[IX-1]);
    enSeqLen.push_back(enCount-enPosi[IX-1]);
    
    if((stSeqLen[IX-1] > 0) & (enSeqLen[IX-1] > 0))
      delBasePosi.push_back(1);
    else
      delBasePosi.push_back(0);


    //cout << "edge len : " << edge0len << endl;
    //cout << "stSeqLen" << endl;
    //print_veci(stSeqLen);
    //cout << "enSeqLen" << endl;
    //print_veci(enSeqLen);
    //cout << "stPosi" << endl;
    //print_veci(stPosi);
    //cout << "delBasePosi" << endl;
    //print_veci(delBasePosi);

    //-------------------------
    //
    // Generate IDH
    //
    //-------------------------

    //IDH->printIDH();
    
    double logProbs = 0;

    //some vectors to generate events
    vector<vector<double> > V;
    vector<vector<int> > ID;
    vector<vector<int> > P;
    vector<vector<int> > L;
    vector<vector<int> > N;
    vector<vector<int> >  HMG0;
    vector<int> HMGin(0);
    vector<int> numEall(0);
    vector<int> delBasePosiIX(0);


    vector<InDelHistory*> listIDH(0);
    int IX, i, j, k, numE, tmpnumE, posi, selPosi;
    IX = stPosi.size();

    listIDH.resize(IX);
    numEall.resize(IX);
    
    V.resize(IX);
    ID.resize(IX);
    P.resize(IX);
    L.resize(IX);
    N.resize(IX);
    
    // First part
    for(i = 0; i < IX ; i++){
      numEall[i] = 1;
      V[i].push_back(0);
      ID[i].push_back(-2);
      P[i].push_back(0);
      L[i].push_back(0);
      N[i].push_back(stSeqLen[i]);
    }
    

    // Separate IDH into several blocks
    listIDH.resize(IX);
    for(i = 0; i < IX ; i++)
      listIDH[i] = new InDelHistory();
   

    numE = IDH->getNumE();
    if(numE > 0){

      for(i = 1; i <= numE; i++){
   
	posi = IDH->getP(i);
	for(j = 0; j < IX; j++){
	  if(j == (IX -1)){
	    selPosi = IX -1;
	    break;
	  }else if((stPosi[j] <= posi) & (posi < stPosi[j+1])){
	    selPosi = j;
	    break;
	  }
	}   
	V[selPosi].push_back(IDH->getV(i));
	ID[selPosi].push_back(IDH->getID(i));
	L[selPosi].push_back(IDH->getL(i));
	P[selPosi].push_back(IDH->getP(i) - stPosi[selPosi]);
	tmpnumE = numEall[selPosi];
	if(ID[selPosi][tmpnumE] == 1){
	  N[selPosi].push_back(N[selPosi][tmpnumE-1]+L[selPosi][tmpnumE]);      
	  for(k = selPosi+1; k < IX; k++)
	    stPosi[k] = stPosi[k] + L[selPosi][tmpnumE];
	}else{
	  N[selPosi].push_back(N[selPosi][tmpnumE-1]-L[selPosi][tmpnumE]); 
	  for(k = selPosi+1; k < IX; k++)
	    stPosi[k] = stPosi[k] - L[selPosi][tmpnumE];
	}
	numEall[selPosi] = numEall[selPosi] + 1;
      }
    }
    
  
    for(i = 0; i < IX ; i++){
  
      numEall[i] =  numEall[i] - 1;
      V[i].push_back(edge0len);
      ID[i].push_back(-2);
      P[i].push_back(0);
      L[i].push_back(0);
      N[i].push_back(enSeqLen[i]);
      if(delBasePosi[i] == 0){
    
	listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 
	logProbs += ProposHistory(params, listIDH[i]);

	//cout << "i : " << i << endl;
	//listIDH[i]->printIDHwoHMG();
	//cout << "logProbs : " << logProbs << endl; 
  
      }else{
      
	HMG0.resize(0);
	HMGin.resize(0);
	for(k = 0; k <= N[i][0]; k++){
	  HMGin.push_back(k);
	}
	HMG0.push_back(HMGin);
	HMGin.resize(0);
	for(j = 1; j <= numEall[i]; j++){ 
	  HMGin = HMG0[j-1];
	  if(ID[i][j]==1){
	    for(k = 0; k < L[i][j]; k++)
	      HMGin.insert(HMGin.begin()+ P[i][j],-1);
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);
	  }else{
	    for(k = 0; k< L[i][j]; k++)
	      HMGin.erase(HMGin.begin()+ P[i][j]);
	    HMG0.push_back(HMGin);
	    HMGin.resize(0);
	  }
	}
	HMG0.push_back(HMG0[numEall[i]]);
	listIDH[i]->setHistory(numEall[i], V[i], ID[i], P[i], L[i], N[i], HMG0); 

	delBasePosiIX.resize(0);
	for(j = 0; j < N[i][0] ; j++)
	  delBasePosiIX.push_back(1);
	delBasePosiIX.push_back(0);

	//cout << "i : " << i << endl;
	//cout << "delBasePosiIX " << endl;
	//print_veci(delBasePosiIX);
	logProbs += ProposHistoryWithDeletionConstraint(params, listIDH[i], delBasePosiIX);

	//cout << "i : " << i << endl;
	//listIDH[i]->printIDH();
	//cout << "logProbs : " << logProbs << endl; 
  


      }
    }



    stSeqLen.resize(0);
    enSeqLen.resize(0);
    stPosi.resize(0);
    
    V.resize(0);
    ID.resize(0);
    P.resize(0);
    L.resize(0);
    N.resize(0);
    HMG0.resize(0);
    HMGin.resize(0);
    numEall.resize(0);
    delBasePosiIX.resize(0);
    delBasePosi.resize(0);
    
    for(i = 0; i < listIDH.size(); i++)
      delete listIDH[i];
    
    listIDH.resize(0);
    
    return logProbs;

  }

}
/*** NNI end ***/

/*** NNI start ***/
int Tree::countNumID(vector<vector<int> > align){

  int res = 0;
  int len = align[1].size();
  int i;

  if(align.size()!=6)
    cout << "ERROR in countNumID! " << endl;
    
  i = 0;
  if(align[0][i] != align[1][i])
    res++;
  for(i = 1; i < len; i++){
    if(align[0][i] != align[1][i]){
      if(!((align[0][i] == align[0][i-1]) & (align[1][i] == align[1][i-1])))
	res++;
    }
  }
  
  i = 0;
  if(align[2][i] != align[1][i])
    res++;
  for(i = 1; i < len; i++){
    if(align[2][i] != align[1][i]){
      if(!((align[2][i] == align[2][i-1]) & (align[1][i] == align[1][i-1])))
	res++;
    }
  }
  
  i = 0;
  if(align[3][i] != align[4][i])
    res++;
  for(i = 1; i < len; i++){
    if(align[3][i] != align[4][i]){
      if(!((align[3][i] == align[3][i-1]) & (align[4][i] == align[4][i-1])))
	  res++;
    }
  }
  
  i = 0;
  if(align[5][i] != align[4][i])
    res++;
  for(i = 1; i < len; i++){
    if(align[5][i] != align[4][i]){
      if(!((align[5][i] == align[5][i-1]) & (align[4][i] == align[4][i-1])))
	res++;
    }
  }
  
  i = 0;
  if(align[1][i] != align[4][i])
    res++;
  for(i = 1; i < len; i++){
    if(align[1][i] != align[4][i]){
      if(!((align[1][i] == align[1][i-1]) & (align[4][i] == align[4][i-1])))
	res++;
    }
  }

  if(res == 0)
    cout << "ERROR in countNumID! Count shouldn't be zero." << endl;
  
  return res;

}
/*** NNI start ***/




/*** NNI start ***/
void Tree::countNumIDonEachEdge(vector<vector<int> > align, vector<int> &count, int MaxIDsize){


  //cout << "countNumIDonEachEdge " << endl;
  int res = 0;
  int len = align[1].size();
  int i, j;

  if(align.size()!=6)
    cout << "ERROR in countNumID! " << endl;

  //cout << "len : " << len << endl;
  //cout << "MaxIDsize : " << MaxIDsize << endl;


  count.resize(5);
  
  i = 0;
  res = 0;
  while(i < len){

    //cout << "i : " << i << endl;
    if(align[0][i] != align[1][i]){
      res++;
      j = 1;
      while((j < MaxIDsize) & (i+j < len)){
	if(!((align[0][i] == align[0][i+j]) & (align[1][i] == align[1][i+j])))
	  break;
	j++;
      }
      i = i + j;
    }else
      i++;
  }


  count[0] = res;

  //cout << "countNumIDonEachEdge 0" << endl;


  i = 0;
  res = 0;
  while(i < len){

    if(align[2][i] != align[1][i]){
      res++;
      j = 1;
      while((j < MaxIDsize) & (i+j < len)){
	if(!((align[2][i] == align[2][i+j]) & (align[1][i] == align[1][i+j])))
	  break;
	j++;
      }
      i = i + j;
    }else
      i++;
  }


  count[1] = res;

  //cout << "countNumIDonEachEdge 1" << endl;

  i = 0;
  res = 0;
  while(i < len){

    if(align[3][i] != align[4][i]){
      res++;
      j = 1;
      while((j < MaxIDsize) & (i+j < len)){
	if(!((align[3][i] == align[3][i+j]) & (align[4][i] == align[4][i+j])))
	  break;
	j++;
      }
      i = i + j;
    }else
      i++;
  }


  count[2] = res;

  
  //cout << "countNumIDonEachEdge 2" << endl;

  i = 0;
  res = 0;
  while(i < len){

    if(align[5][i] != align[4][i]){
      res++;
      j = 1;
      while((j < MaxIDsize) & (i+j < len)){
	if(!((align[5][i] == align[5][i+j]) & (align[4][i] == align[4][i+j])))
	  break;
	j++;
      }
      i = i + j;
    }else
      i++;
  }


  count[3] = res;

  //cout << "countNumIDonEachEdge 3" << endl;

  i = 0;
  res = 0;
  while(i < len){

    if(align[1][i] != align[4][i]){
      res++;
      j = 1;
      while((j < MaxIDsize) & (i+j < len)){
	if(!((align[1][i] == align[1][i+j]) & (align[4][i] == align[4][i+j])))
	  break;
	j++;
      }
      i = i + j;
    }else
      i++;
  }


  count[4] = res;

  
  //cout << "countNumIDonEachEdge 4" << endl;

}
/*** NNI end ***/




/*** NNI start ***/
void Tree::getAlignments(vector<vector<int> > &alignS, vector<int> NodeSet, int tempRootIX){

  vector<int> align(0);
  int i, j, rootSeqLen, intTmp;
  
  Node* root;
  root = nodes[NodeSet[tempRootIX]];

  rootSeqLen = root->getSeqLen();
 
  alignS.resize(0);

  //cout << "rootSeqLen : " << rootSeqLen << endl;

  // Get last linked sites
  intTmp = NodeSet.size();
  for(i = 0; i < intTmp; i++)
    nodes[NodeSet[i]]->calLastLinkedPosi();

  // Get alignments
  for(i = 0; i < rootSeqLen; i++){
    for(j = 0; j < intTmp; j++)
      align.push_back(-1);
    root->getAlignment(i, align, alignS, NodeSet);
    /*
    if(root->getRoot()){
      if(root->getLinkedSites(i)==1)
	root->getAlignment(i, align, alignS, NodeSet);
    }else{
      //if(root->getLinkedSites(i)==1)
      if(root->getrootSites(i)==1)
	root->getAlignment(i, align, alignS, NodeSet);
      else
	align[tempRootIX] = 1;
    }
    */
    if(max_veci(align) >= 0)
      alignS.push_back(align);
    align.resize(0);
  }

  for(i = 0; i < root->getnumEdges(); i++){
    if(i != root->getparentIndex())
      root->getEdge(i)->getEnd()->getAlignmentLastPart(alignS, NodeSet);
  }

  align.resize(0);

}
/*** NNI end ***/






/*** NNI start ***/
//For pos position at a sequence in a given Node, homologous letters in a subtree with a given Node as a root are saved at align
void Node::getAlignmentLastPart(vector<vector<int> > &alignS, vector<int> NodeSet){


  //cout << "In getAlignmentLastPart" << endl;
  //cout << "node number " << getnumber() << endl;

  //bool last;
  //int tmp;
  //int nextpos;
  int i, j, k, m, p;
  //int num; 
  Edge* tEdge;
  Node* tNode;
  vector<int> talign(0);
  int len;
  

  m = where_element(NodeSet, getnumber());
  //cout << "m : " << m << endl;
  
  if(m>=0){

    if((Hitlast) | (lastLinkedPosi== -1)){

      len = 6;
      if(lastLinkedPosi < (getSeqLen()-1)){
	  
	for(j = (lastLinkedPosi+1); j < getSeqLen(); j++){
	
	  talign.resize(0);
	  for(k = 0; k < len; k++)
	    talign.push_back(-1);

	  getAlignment(j, talign, alignS, NodeSet);
	  if(max_veci(talign) >= 0){
	    alignS.push_back(talign);
	  }
	  talign.resize(0);

        }
      }

      for(i = 0; i < getnumEdges(); i++){

	if(i != getparentIndex()){

	  tEdge = getEdge(i);
	  tNode = tEdge->getEnd();
	  
	  j = where_element(NodeSet, tNode->getnumber());
	  if(j >= 0)	    
	    tNode->getAlignmentLastPart(alignS, NodeSet);
        }
      }

    }else
      cout << "ERROR in getAlignmentLastPart! It should be called after hitting last position. " << endl;

  }

}

/*** NNI end ***/











/*** NNI start ***/
//For pos position at a sequence in a given Node, homologous letters in a subtree with a given Node as a root are saved at align
void Node::getAlignment(int pos, vector<int> &align, vector<vector<int> > &alignS, vector<int> NodeSet){


  
  //cout << "In getAlignmentLast" << endl;
  //cout << "node number " << getnumber() << endl;
  //cout << "pos : " << pos << endl;
  
  //bool last;
  int tmp;
  int nextpos;
  int i, j, k, m;
  int num; 
  Edge* tEdge;
  Node* tNode;
  vector<int> talign(0);
  int len = align.size();
  
  m = where_element(NodeSet, getnumber());
  //cout << "m : " << m << endl;

  if(m>=0){
    //align[m] = 1;
    align[m] = pos;
    for(i = 0; i < getnumEdges(); i++){
      if(i != getparentIndex()){

	tEdge = getEdge(i);
	tNode = tEdge->getEnd();
	
	j = where_element(NodeSet, tNode->getnumber());
	if(j >= 0){
	  
	  nextpos = tEdge->getHMG(pos);
	  if(nextpos >= tNode->getSeqLen())
	    cout << "ERROR in getAlignment! nextpos is out of a range" << endl;
	  if(nextpos >= 0){

	    // check there is any rooted sites before nextpos
	    tmp = nextpos - 1;
	    num = 0;
	    if(tmp >= 0){
	      while(tNode->getrootSites(tmp) == 1){
		num++;
		tmp = nextpos - 1 - num;
		if(tmp < 0)
		  break;
	      }
	    }
	    
	    // Get alignment that rooted sites
	    if(num > 0){
	      for(j = num; j > 0; j--){
		for(k = 0; k < len; k++)
		  talign.push_back(-1);
		tNode->getAlignment(nextpos - j, talign, alignS, NodeSet);
		if(max_veci(talign) >= 0){
		  alignS.push_back(talign);
		}
		talign.resize(0);
	      }
	    }
	    
	    // Get alignment with a given position
	    tNode->getAlignment(nextpos, align, alignS, NodeSet);
	    

	    //if(nextpos == tNode->getLastLinkedPosi())
	    //  last = true;

	    
	    // Get alignment that rooted sites (Rest rooted sites)
	    /*
	    if((last) & (nextpos < (tNode->getSeqLen()-1))){
	      for(j = (nextpos+1); j < tNode->getSeqLen(); j++){
		talign.resize(0);
		for(k = 0; k < len; k++)
		  talign.push_back(-1);
		tNode->getAlignment(j, talign, alignS, NodeSet);
		if(max_veci(talign) >= 0){
		  alignS.push_back(talign);
		}
		talign.resize(0);
	      }	    
	      
	    }
	    last = false;
	    */
	  }
        }
      }
    }
    if(pos == lastLinkedPosi){
      //cout << "Hit LastlinkedPosi " << endl;
      Hitlast = true;
    }
  }
  
}
/*** NNI end ***/






int main(){
  //int main(int argc, char *argv[]){


  int rank = 4;
  int np = 0;

  /* clean1 start */
  //int MClen = 1100000;   // length of Markov Chain with burning part
  //int MClen2 = 1000000;  // length of Markov Chain without burning part
  //int burnlen = 100000;  // length of Markov Chain for burning 

  int MClen = 1100;   // length of Markov Chain with burning part
  int MClen2 = 1000;  // length of Markov Chain without burning part
  int burnlen = 100;  // length of Markov Chain for burning 
  /* clean1 end */

  int Fstburnlen = burnlen*3/4;
  int Sndburnlen = Fstburnlen/3;



  /* clean1 start */
  int printIX = burnlen;
  //int printIV = 1000;
  int printIV = 10;
  /* clean1 end */

  int tuningIXA = 100;
  int tuningIV = 100;
  double tuningInc = 0.05;


  int checkIX = burnlen;
  int checkIV = burnlen;
  double cutpt = 1.01;


  double AP, P_ac, I_ac, mP_ac, mI_ac, double_tmp, value;
  int i, j, m;
  Rand rand(1111111 + 33333*rank,999999);
  Rand rand2(111111,9999 + 1345*rank);
  RNG rng(11134*rank + 10000);


  Parameters para;


  double kappa = 2;
  double gamma = 2; 
  double rd = 1/(double)6;
  double r =  1/(double)123;
  double lambda = 0.005;
  double pA = 0.19;
  double pC = 0.31;
  double pG = 0.33;  
  double pT = 1 - pA - pC - pG;
  vector<double> pi(4);
  pi[0] = pA;
  pi[1] = pC;
  pi[2] = pG;
  pi[3] = pT;

  double ri = 1 - ((1-rd)*(1-r));
  double mu = lambda*ri*(1-rd)/(rd*(1-ri));

  para.setParameters(r, ri, rd, lambda, mu, gamma, pi);
  para.setKappa(kappa);



  double t_kappa = 2;
  double t_gamma = 2; 
  //double t_rd = 0.9875;
  //double t_r =   0.2;
  double t_lambda = 0.005;
  double piA = 0.19;
  double piC = 0.31;
  double piG = 0.33;   
  double piT = 1 - piA - piC - piG;
  double pi_overVar = 70; // larger means small variance.
  double gamma_epsilon = 1/t_gamma;
  double kappa_epsilon = 1/t_kappa;
  double lambda_epsilon = 1/t_lambda;
  vector<double> pi_alpha(4);
  pi_alpha[0] = piA*pi_overVar;
  pi_alpha[1] = piC*pi_overVar;
  pi_alpha[2] = piG*pi_overVar;
  pi_alpha[3] = piT*pi_overVar;
  double r_alpha = 100;
  double r_beta = 12200;
  double rd_alpha = 3;
  double rd_beta = 15;
  //double rd_epsilon = 0.5;
  //double gamma_alpha = 5;
  //double gamma_beta = 1;


  double r_c =  10000000;
  double rd_c = 1000;
  double pi_c = 10000000; 

  double zeta = 0.5; // Used when generate muliplication factor for edge proposal 
  double kappa_c = 0.9;
  double lambda_c = 0.3;
  double gamma_c = 0.5;
  double SPRonSubTreeWithTarget_c = 0.4;
  double UpIDHandSeq_epsilon = 0.9;
  double UpIDHandSeq_r = 1/1.5;
  double windowLen = 0.1;                // window width  
  double delta = 0.1;
  int MaxStepSize = 2;

  double MINwindowLen = 0.05;     // window width  
  double windowLen_UpIDHonEdge = 0.3;     // window width  
  double windowLen_UpIDHonEdgeLike = 0.3;     // window width  
  double windowLen_SPRonSubTreeWithinWindow = 0.3;     // window width  
  double windowLen_SPRonSubTreeWithTargetWithinWindow = 0.3;     // window width  
  double UpBoundAP, LowBoundAP;
  double UpBoundAP_UpR = 0.7;
  double LowBoundAP_UpR = 0.2;
  double UpBoundAP_UpRd = 0.7;
  double LowBoundAP_UpRd = 0.2;  
  double UpBoundAP_UpKappa = 0.7;
  double LowBoundAP_UpKappa = 0.2;
  double UpBoundAP_UpLambda = 0.7;
  double LowBoundAP_UpLambda = 0.2;
  double UpBoundAP_UpGamma = 0.7;
  double LowBoundAP_UpGamma = 0.2;
  double UpBoundAP_UpPi = 0.7;
  double LowBoundAP_UpPi = 0.2;
  double UpBoundAP_UpEdgeLen = 0.7;
  double LowBoundAP_UpEdgeLen = 0.2;
  double UpBoundAP_windowLen_SPRonSubTreeWithinWindow = 0.7;
  double LowBoundAP_windowLen_SPRonSubTreeWithinWindow = 0.1;
  double UpBoundAP_windowLen_SPRonSubTreeWithTargetWithinWindow = 0.7;
  double LowBoundAP_windowLen_SPRonSubTreeWithTargetWithinWindow = 0.1;
  double UpBoundAP_windowLen_UpIDHonEdge = 0.7;
  double LowBoundAP_windowLen_UpIDHonEdge = 0.2;
  double UpBoundAP_windowLen_UpIDHonEdgeLike = 0.7;
  double LowBoundAP_windowLen_UpIDHonEdgeLike = 0.2;




  para.setGamma_epsilon(gamma_epsilon);
  para.setKappa_epsilon(kappa_epsilon);
  para.setLambda_epsilon(lambda_epsilon);
  //para.setGamma_alpha(gamma_alpha);
  //para.setGamma_beta(gamma_beta);
  para.setPi_alpha(pi_alpha);
  para.setR_alpha(r_alpha);
  para.setR_beta(r_beta);
  para.setRd_alpha(rd_alpha);
  para.setRd_beta(rd_beta);
  //para.setRd_epsilon(rd_epsilon);
  para.setR_c(r_c);
  para.setRd_c(rd_c);
  para.setPi_c(pi_c);
  para.setGamma_c(gamma_c);
  para.setKappa_c(kappa_c);
  para.setLambda_c(lambda_c);
  para.setZeta(zeta);
  para.setWindowLen(windowLen);
  para.setWindowLen_UpIDHonEdge(windowLen_UpIDHonEdge);
  para.setWindowLen_UpIDHonEdgeLike(windowLen_UpIDHonEdgeLike);
  para.setWindowLen_SPRonSubTreeWithinWindow(windowLen_SPRonSubTreeWithinWindow);
  para.setWindowLen_SPRonSubTreeWithTargetWithinWindow(windowLen_SPRonSubTreeWithTargetWithinWindow);
  para.setDelta(delta);
  para.setSPRonSubTreeWithTarget_c(SPRonSubTreeWithTarget_c);		       
  para.setUpIDHandSeq_epsilon(UpIDHandSeq_epsilon);
  para.setUpIDHandSeq_r(UpIDHandSeq_r);				 


  pi_alpha.resize(0);



  //-- v20 start --//
  double InsertDownWei = 0.1;
  para.setInsertDownWei(InsertDownWei);  

  double C_noEvent = 100;
  para.setC_noEvent(C_noEvent);

  double WeiID = 0.5;
  para.setWeiID(WeiID);

  double ImulFacSD = 1.96;
  para.setImulFacSD(ImulFacSD);

  double DmulFacSD = 1.96;
  para.setDmulFacSD(DmulFacSD);

  double ProbTargetFragI = 0.8;
  para.setProbTargetFragI(ProbTargetFragI);

  double ProbTargetFragD = 0.8;
  para.setProbTargetFragD(ProbTargetFragD);
  //-- v20 end --//


  //--- v21 start ---//
  double delProb = 0.8;
  para.setDelProb(delProb);
  //--- v21 end ---//

  //--- v24 start ---//
  int MaxCases = 36;
  para.setMaxCases(MaxCases);
  //--- v24 end ---//

  //-- v26 start --//
  double powWei = 0.5;
  para.setPowWei(powWei);
  //-- v26 end --//


  vector<string> seqDataS(0);

  seqDataS.push_back("TGCCTGGCGGCCGTAGCGCGGTGGTCCCACCTGACCCCATGCCGAACTCAGAAGTGAAACGCCGTAGCGCCGATGGTAGTGTGGGGTCTCCCCATGCGAGAGTAGGGAACTGCCAGGCAT");
  seqDataS.push_back("GTCTACGGCCATACCACCCTGAACGCGCCCGATCTCGTCTGATCTCGGAAGCTAAGCAGGGTCGGGCCTGGTTAGTACTTGGATGGGAGACCGCCTGGGAATACCGGGTGCTGTAGGCTTT");
  seqDataS.push_back("TTAAGGCGGCCATAGCGGTGGGGTTACTCCCGTACCCATCCCGAACACGGAAGATAAGCCCGCCTGCGTTCCGGTCAGTACTGGAGTGCGAGCCTCTGGGAAATCCGGTTCGCCGCCTAC");
  seqDataS.push_back("GGTACGGCGGTCATAGCGGGGGGGCCACACCCGGTCTCATTTCGAACCCGGAAGTTAAGCCCCCCAGCGATCCCGGCTGTACTGCCCTCCGAGAGGGGGCGGGAACCGGGGACGCCGCCGGCCA");
  seqDataS.push_back("GCCCACCCGGTCACAGTGAGCGGGCAACACCCGGACTCATTTCGAACCCGGAAGTTAAGCCGCTCACGTTAGTGGGGCCGTGGATACCGTGAGGATCCGCAGCCCCACTAAGCTGGGATGGGTTTT");

  //seqDataS.push_back("AAAAACCCCCTTTTTAAAAACC");
  //seqDataS.push_back("ATTAACGGCCTTTTTAAAACGG");
  //seqDataS.push_back("ACACACACACACACACCCTTTTT");
  //seqDataS.push_back("ACACAGAGAGAGACCCTTTTTT");
  //seqDataS.push_back("AAAAACTTCCTTTTT");
  //seqDataS.push_back("TTCTATCCTTTTACTCTTTTATTTCTCTAATCTTTC");
  //seqDataS.push_back("TCACTTTTCACTTTTAT");







 
  int numLeaves = seqDataS.size();
  int numNodes = 2*numLeaves-2;
  int numEdges = 2*numLeaves-3;
  int numSplits;
  vector<vector<int> > splits;
  vector<int> intVec;

  splits.resize(0);

  int half, midnum;
  vector<int> comb(0);
  comb.push_back(-1);

  // get all kinds of splits

  if(numLeaves%2==1){ // odd number
    
    half = (numLeaves-1)/2;
    for(i = 1; i <= half ; i++){
      comb.resize(i);
      comb[0] = -1;
      while(enumerateCombinations(numLeaves, i, comb)){
        intVec.resize(0);
        for(j = 0; j < i ; j++)
          intVec.push_back((comb[j]));
        splits.push_back(intVec);
      }
    }
    
    midnum = half;
  
  }else{             // even number

    half = (numLeaves-2)/2;
    for(i = 1; i <= half ; i++){
      comb.resize(i);
      comb[0] = -1;
      while(enumerateCombinations(numLeaves, i, comb)){
        intVec.resize(0);
        for(j = 0; j < i ; j++)
          intVec.push_back(comb[j]);
        splits.push_back(intVec);
      }
    }    
    
    m = 0;
    i = half + 1;
    comb.resize(i);
    comb[0] = -1;
    while(enumerateCombinations(numLeaves, i, comb)){
      intVec.resize(0);
      for(j = 0; j < i ; j++)
        intVec.push_back(comb[j]);
      splits.push_back(intVec);
      m++;
    }    

    if(m%2==1){
      cout << "ERROR! In making splits! " << endl;
    }else{
      m /= 2;
      
      for(i=0; i < m; i++)
        splits.pop_back();
    }
    
    midnum = half + 1;
  }
  
  intVec.resize(0);
  comb.resize(0);
  numSplits = splits.size();


 


  //---------------------------------------------------//
  //
  //          to keep track of all information
  //
  //---------------------------------------------------//


  ofstream outfile, OmnumI, OmnumD, OtotalEdgeLen, OmedgeLen, OmnumIinAll, OmnumDinAll, OmR, OmRd, OmRi, OmLambda, OmMu, OmKappa, OmGamma, OmP, OloglikeliData, OloglikeliIDH, OloglikeliEdges, OthetaPrior;

  ofstream Otree;
  ofstream OtreeBL;
  ofstream OAlignment;
  
  ofstream OIleninAll;
  ofstream ODleninAll;

  ofstream OSPRonSubTree;
  ofstream OSPRonSubTreeLike;
  ofstream OSPRonSubTreeWithinWindow;
  ofstream OSPRonSubTreeWithTarget;
  ofstream OSPRonSubTreeWithTargetWithinWindow;
  ofstream OSPRonSingleEdge;
  ofstream OSPRonSubTree_s;
  ofstream OSPRonSubTreeWithinWindow_s;
  ofstream OSPRonSubTreeWithTarget_s;
  ofstream OSPRonSubTreeWithTargetWithinWindow_s;
  ofstream OSPRonSubTreeLike_s; 
  ofstream OUpEdgeLen; 
  ofstream OUpIDHandSeq; 
  ofstream OUpIDHandSeq_v2;
  ofstream OUpIDHonEdge;
  ofstream OUpIDHonEdgeLike; 
  //ofstream OUpOneIDH;
  //ofstream OUpOneIDHfixHMG;
  ofstream OUpIDHonEdgeWithFixedHMG;
  ofstream OUpIDHonEdgebyDP;
  ofstream OUpIDHonEdgebyDPbestLetters;
  ofstream OUpIDHonEdgeWithFixedHMGbyDP;
  ofstream OSPRonSubTreeWithFixedHMG;
  ofstream OSPRonSubTreeWithFixedHMG_s;
  ofstream OSPRonSubTreebyDP;
  ofstream OSPRonSubTreebyDP_s;
  ofstream OSPRonSubTreebyDPbestLetters;
  ofstream OSPRonSubTreebyDPbestLetters_s;  
  ofstream OSPRonSubTreeWithFixedHMGbyDP;
  ofstream OSPRonSubTreeWithFixedHMGbyDP_s;
  ofstream OUpR;
  ofstream OUpRd;
  ofstream OUpPi;
  ofstream OUpKappa;
  ofstream OUpLambda;
  ofstream OUpGamma;

  
  vector<vector<int> > alignS(0); // To save alignments
  

  string path = "";
  string Nm(20, 'c');
  string temp;

  Nm[0] = 'a';
  Nm[1] = 'b';
  Nm[2] = 'c';
  Nm[3] = 'd';
  Nm[4] = 'e';
  Nm[5] = 'f';
  Nm[6] = 'g';
  Nm[7] = 'h';
  Nm[8] = 'i';
  Nm[9] = 'j';
  Nm[10] = 'k';
  Nm[11] = 'l';
  Nm[12] = 'm';
  Nm[13] = 'n';
  Nm[14] = 'o';
  Nm[15] = 'p';
  Nm[16] = 'q';
  Nm[17] = 'r';
  Nm[18] = 's';
  Nm[19] = 't';            



  temp = "RESSPRonSingleEdge";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSingleEdge.open(temp.c_str());
  temp = "RESUpEdgeLen";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpEdgeLen.open(temp.c_str());
  temp = "RESUpIDHandSeq";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpIDHandSeq.open(temp.c_str());
  temp = "RESUpIDHandSeq_v2";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpIDHandSeq_v2.open(temp.c_str());
  temp = "RESUpIDHonEdge";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpIDHonEdge.open(temp.c_str());
  temp = "RESUpIDHonEdgeLike";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpIDHonEdgeLike.open(temp.c_str());

  temp = "RESUpIDHonEdgeWithFixedHMG";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpIDHonEdgeWithFixedHMG.open(temp.c_str());

  temp = "RESUpIDHonEdgebyDP";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpIDHonEdgebyDP.open(temp.c_str());


  temp = "RESUpIDHonEdgebyDPbestLetters";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpIDHonEdgebyDPbestLetters.open(temp.c_str());

  temp = "RESUpIDHonEdgeWithFixedHMGbyDP";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpIDHonEdgeWithFixedHMGbyDP.open(temp.c_str());

  temp = "RESSPRonSubTreeWithFixedHMG";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithFixedHMG.open(temp.c_str());

  temp = "RESSPRonSubTreeWithFixedHMG_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithFixedHMG_s.open(temp.c_str());

  temp = "RESSPRonSubTreebyDP";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreebyDP.open(temp.c_str());

  temp = "RESSPRonSubTreebyDP_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreebyDP_s.open(temp.c_str());


  temp = "RESSPRonSubTreebyDPbestLetters";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreebyDPbestLetters.open(temp.c_str());

  temp = "RESSPRonSubTreebyDPbestLetters_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreebyDPbestLetters_s.open(temp.c_str());

  temp = "RESSPRonSubTreeWithFixedHMGbyDP";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithFixedHMGbyDP.open(temp.c_str());

  temp = "RESSPRonSubTreeWithFixedHMGbyDP_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithFixedHMGbyDP_s.open(temp.c_str());



  //temp = "RESUpOneIDH";
  //temp = path + temp;
  //temp = temp + Nm[rank];
  //OUpOneIDH.open(temp.c_str());
  //temp = "RESUpOneIDHfixHMG";
  //temp = path + temp;
  //temp = temp + Nm[rank];
  //OUpOneIDHfixHMG.open(temp.c_str());
  temp = "RESUpR";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpR.open(temp.c_str());
  temp = "RESUpRd";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpRd.open(temp.c_str());
  temp = "RESUpPi";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpPi.open(temp.c_str());
  temp = "RESUpLambda";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpLambda.open(temp.c_str());
  temp = "RESUpKappa";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpKappa.open(temp.c_str());
  temp = "RESUpGamma";
  temp = path + temp;
  temp = temp + Nm[rank];
  OUpGamma.open(temp.c_str());




  temp = "RESSPRonSubTree_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTree_s.open(temp.c_str());
  temp = "RESSPRonSubTreeLike_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeLike_s.open(temp.c_str());  
  temp = "RESSPRonSubTreeWithinWindow_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithinWindow_s.open(temp.c_str());
  temp = "RESSPRonSubTreeWithTarget_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithTarget_s.open(temp.c_str());
  temp = "RESSPRonSubTreeWithTargetWithinWindow_s";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithTargetWithinWindow_s.open(temp.c_str());

  temp = "RESSPRonSubTree";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTree.open(temp.c_str());
  temp = "RESSPRonSubTreeLike";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeLike.open(temp.c_str());  
  temp = "RESSPRonSubTreeWithinWindow";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithinWindow.open(temp.c_str());
  temp = "RESSPRonSubTreeWithTarget";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithTarget.open(temp.c_str());
  temp = "RESSPRonSubTreeWithTargetWithinWindow";
  temp = path + temp;
  temp = temp + Nm[rank];
  OSPRonSubTreeWithTargetWithinWindow.open(temp.c_str());



  temp = "RESthetaPrior";
  temp = path + temp;
  temp = temp + Nm[rank];
  OthetaPrior.open(temp.c_str());
  temp = "RES";
  temp = path + temp;
  temp = temp + Nm[rank];
  outfile.open(temp.c_str());
  temp = "RESmnumI";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmnumI.open(temp.c_str());
  temp = "RESmnumD";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmnumD.open(temp.c_str());
  temp = "RESIleninAll";
  temp = path + temp;
  temp = temp + Nm[rank];
  OIleninAll.open(temp.c_str());
  temp = "RESDleninAll";
  temp = path + temp;
  temp = temp + Nm[rank];
  ODleninAll.open(temp.c_str());
  temp = "RESmtotalEdgeLen";
  temp = path + temp;
  temp = temp + Nm[rank];
  OtotalEdgeLen.open(temp.c_str());  
  temp = "RESmnumIinAll";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmnumIinAll.open(temp.c_str());
  temp = "RESmnumDinAll";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmnumDinAll.open(temp.c_str());
  temp = "RESmedgeLen";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmedgeLen.open(temp.c_str());
  temp = "RESmR";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmR.open(temp.c_str());
  temp = "RESmRd";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmRd.open(temp.c_str());
  temp = "RESmRi";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmRi.open(temp.c_str());
  temp = "RESmMu";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmMu.open(temp.c_str());
  temp = "RESmLambda";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmLambda.open(temp.c_str());
  temp = "RESmKappa";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmKappa.open(temp.c_str());
  temp = "RESmGamma";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmGamma.open(temp.c_str());
  temp = "RESmP";
  temp = path + temp;
  temp = temp + Nm[rank];
  OmP.open(temp.c_str());
  temp = "RESloglikeliData";
  temp = path + temp;
  temp = temp + Nm[rank];
  OloglikeliData.open(temp.c_str());
  temp = "RESloglikeliIDH";
  temp = path + temp;
  temp = temp + Nm[rank];
  OloglikeliIDH.open(temp.c_str());
  temp = "RESloglikeliEdges";
  temp = path + temp;
  temp = temp + Nm[rank];
  OloglikeliEdges.open(temp.c_str());
  temp = "REStree";
  temp = path + temp;
  temp = temp + Nm[rank];
  Otree.open(temp.c_str());
  temp = "REStreeBL";
  temp = path + temp;
  temp = temp + Nm[rank];
  OtreeBL.open(temp.c_str());
  temp = "RESAlignment";
  temp = path + temp;
  temp = temp + Nm[rank];
  OAlignment.open(temp.c_str());






  //outfile << "1" << seqDataS[0] << endl;
  //outfile << "2" << seqDataS[1] << endl;
  //outfile << "3" << seqDataS[2] << endl;
  //outfile << "4" << seqDataS[3] << endl;
  //outfile << "5" << seqDataS[4] << endl;

  //seqDataS.resize(0);






  InDelHistory* tmpIDH;

  int tmpint;
  double tmpdouble;

  double numI, numD, totalEdgeLen;
  double unumI, unumD, uIlen, uDlen,  utotalEdgeLen;
  double mnumI, mnumD, mIlen, mDlen, mtotalEdgeLen;
  int dIlen, dDlen;

  // To calculate mean and standard deviation during MCMC //  
  double m_numI, m_numD, m_Ilen, m_Dlen, m_totalEdgeLen, tempmean;
  double s_numI, s_numD, s_Ilen, s_Dlen, s_totalEdgeLen;
  int k_numID, k_Ilen, k_Dlen;
  k_numID = 0;
  k_Ilen = 0;
  k_Dlen = 0;


  double b_numI, b_numD, b_Ilen, b_Dlen, b_totalEdgeLen;
  double w_numI, w_numD, w_Ilen, w_Dlen, w_totalEdgeLen;
  double psrf_numI, psrf_numD, psrf_Ilen, psrf_Dlen, psrf_totalEdgeLen;
  

  vector<vector<double> > mcIleninAll(numSplits);
  vector<vector<double> > mcDleninAll(numSplits);


  double uR, mR, m_R, s_R, b_R, w_R, psrf_R;
  double uRd, mRd, m_Rd, s_Rd, b_Rd, w_Rd, psrf_Rd;
  double uRi, mRi, m_Ri, s_Ri, b_Ri, w_Ri, psrf_Ri;
  double uLambda, mLambda, m_Lambda, s_Lambda, b_Lambda, w_Lambda, psrf_Lambda;
  double uMu, mMu, m_Mu, s_Mu, b_Mu, w_Mu, psrf_Mu;
  double uKappa, mKappa, m_Kappa, s_Kappa, b_Kappa, w_Kappa, psrf_Kappa;
  double uGamma, mGamma, m_Gamma, s_Gamma, b_Gamma, w_Gamma, psrf_Gamma;
  vector<double> uPi(4);
  vector<double> mPi(4);
  vector<double> m_Pi(4);
  vector<double> s_Pi(4);
  vector<double> b_Pi(4);
  vector<double> w_Pi(4);
  vector<double> psrf_Pi(4);
  





  vector<int> numEachSplit(numSplits);

  vector<double> edgeLen(numSplits);
  vector<double> uedgeLen(numSplits);
  vector<double> medgeLen(numSplits);
  vector<double> m_edgeLen(numSplits);
  vector<double> s_edgeLen(numSplits);
  vector<double> b_edgeLen(numSplits);
  vector<double> w_edgeLen(numSplits);
  vector<double> psrf_edgeLen(numSplits);

  vector<double> numIinAll(numSplits);
  vector<double> unumIinAll(numSplits);
  vector<double> mnumIinAll(numSplits);
  vector<double> m_numIinAll(numSplits);
  vector<double> s_numIinAll(numSplits);
  vector<double> b_numIinAll(numSplits);
  vector<double> w_numIinAll(numSplits);
  vector<double> psrf_numIinAll(numSplits);

  vector<double> numDinAll(numSplits);
  vector<double> unumDinAll(numSplits);
  vector<double> mnumDinAll(numSplits);
  vector<double> m_numDinAll(numSplits);
  vector<double> s_numDinAll(numSplits);
  vector<double> b_numDinAll(numSplits);
  vector<double> w_numDinAll(numSplits); 
  vector<double> psrf_numDinAll(numSplits); 


  vector<double> MPIm_numI(np);
  vector<double> MPIs_numI(np);
  vector<double> MPIm_numD(np);
  vector<double> MPIs_numD(np);
  vector<double> MPIm_Ilen(np);
  vector<double> MPIs_Ilen(np);
  vector<double> MPIm_Dlen(np);
  vector<double> MPIs_Dlen(np);
  vector<double> MPIm_totalEdgeLen(np);
  vector<double> MPIs_totalEdgeLen(np);
  vector<double> MPIm_R(np);
  vector<double> MPIs_R(np);
  vector<double> MPIm_Rd(np);
  vector<double> MPIs_Rd(np);
  vector<double> MPIm_Ri(np);
  vector<double> MPIs_Ri(np);
  vector<double> MPIm_Lambda(np);
  vector<double> MPIs_Lambda(np);
  vector<double> MPIm_Mu(np);
  vector<double> MPIs_Mu(np);
  vector<double> MPIm_Kappa(np);
  vector<double> MPIs_Kappa(np);
  vector<double> MPIm_Gamma(np);
  vector<double> MPIs_Gamma(np);


  vector<vector<double> > MPIm_numIinAll(numSplits);
  vector<vector<double> > MPIm_numDinAll(numSplits);
  vector<vector<double> > MPIm_edgeLen(numSplits);
  vector<vector<double> > MPIs_numIinAll(numSplits);
  vector<vector<double> > MPIs_numDinAll(numSplits);
  vector<vector<double> > MPIs_edgeLen(numSplits);
  vector<vector<double> > MPIm_Pi(4);
  vector<vector<double> > MPIs_Pi(4);


  for( i = 0; i < numSplits ; i++){
    MPIm_numIinAll[i].resize(np);
    MPIm_numDinAll[i].resize(np);
    MPIm_edgeLen[i].resize(np);
    MPIs_numIinAll[i].resize(np);
    MPIs_numDinAll[i].resize(np);
    MPIs_edgeLen[i].resize(np);
  }

  for( i = 0; i < 4 ; i++){
   MPIm_Pi[i].resize(np);
   MPIs_Pi[i].resize(np);
  }



  

  outfile << "numSplits " << numSplits << endl;
  
  for(int ms =0; ms < splits.size() ; ms++){
    for(int js=0; js < splits[ms].size(); js++)
      outfile << splits[ms][js] << " ";
    outfile << endl;
  }
  outfile << endl;



  int psNum;
  int SizePslSet = 25;
  vector<int> setPsl(SizePslSet);
  vector<double> setWeight(SizePslSet);
 
  setPsl[0] = 1;
  setWeight[0] = 1;
  setPsl[1] = 2;
  setWeight[1] = 1;
  setPsl[2] = 3;
  setWeight[2] = 3;
  setPsl[3] = 4;
  setWeight[3] = 10;
  setPsl[4] = 6;
  setWeight[4] = 1;
  setPsl[5] = 7;
  setWeight[5] = 3;
  setPsl[6] = 8;
  setWeight[6] = 3;
  setPsl[7] = 9;
  setWeight[7] = 3;
  setPsl[8] = 10;
  setWeight[8] = 3;
  setPsl[9] = 11;
  setWeight[9] = 3;
  setPsl[10] = 12;
  setWeight[10] = 3;
  setPsl[11] = 13;
  setWeight[11] = 3;
  setPsl[12] = 5;
  setWeight[12] = 2;
  setPsl[13] = 14;
  setWeight[13] = 3;
  setPsl[14] = 15;
  setWeight[14] = 1;
  setPsl[15] = 16;
  setWeight[15] = 2;
  setPsl[16] = 17;
  setWeight[16] = 0;
  setPsl[17] = 18;
  setWeight[17] = 4;
  setPsl[18] = 19;
  setWeight[18] = 4;
  setPsl[19] = 20;
  setWeight[19] = 0;  
  setPsl[20] = 21;
  setWeight[20] = 0;
  setPsl[21] = 22;
  setWeight[21] = 0;  
  setPsl[22] = 23;
  setWeight[22] = 0;
  setPsl[23] = 24;
  setWeight[23] = 15;  
  setPsl[24] = 25;
  setWeight[24] = 15; 


  //SizePslSet + 5
  // SPRonSubTree, SPRonSubTreeLike, SPRonSubTreeWithinWindow, SPRonSubTreeWithTarget, SPRonSubTreeWithTargetWithinWindow


  vector<int> SPRonSubIX(0);
  SPRonSubIX.push_back(2);
  SPRonSubIX.push_back(3);
  SPRonSubIX.push_back(14);
  SPRonSubIX.push_back(15);
  SPRonSubIX.push_back(16);
  SPRonSubIX.push_back(19);
  SPRonSubIX.push_back(21);
  SPRonSubIX.push_back(23);  
  SPRonSubIX.push_back(25);  


  para.iniPr(SizePslSet+9);
  para.iniIr(SizePslSet+9);
  vector<int> num(SizePslSet+9);
  for(i = 0; i < (SizePslSet+9); i++){
    num[i] = 0;
  }  

  para.iniPrT(SizePslSet+9);
  para.iniIrT(SizePslSet+9);
  vector<int> numT(SizePslSet+9);
  for(i = 0; i < (SizePslSet+9); i++){
    numT[i] = 0;
  }
  vector<int> tuningIX(SizePslSet+9);
  for(i = 0; i < (SizePslSet+9); i++){
    tuningIX[i] = tuningIXA;
  }
    

  
  Tree *TREE;
  //Tree_HMG * TREE_HMG;
  TREE = new Tree(numLeaves, rand, para, seqDataS); 
  //TREE_HMG = new Tree_HMG();
  

  cout << "after construction " << endl;
  TREE->printTree();
  cout << "priting tree are done" << endl;

  seqDataS.resize(0);
  //TREE->printTree(0);
  
  P_ac = 0;
  I_ac = 0;

  
  double AP0;
  bool getOut = false;
  double getOutasNum = 0;

  TREE->save();

  // set up

  unumI = 0;
  unumD = 0;
  uIlen = 0;
  uDlen = 0;
  utotalEdgeLen = 0;
  dIlen = 0; 
  dDlen = 0;
  uR = 0;
  uRd = 0;
  uRi = 0;
  uLambda = 0;
  uMu = 0;
  uKappa = 0;
  uGamma = 0;


  for(i = 0; i < numSplits; i++){
    numEachSplit[i] = 0;
    uedgeLen[i] = 0;
    unumIinAll[i] = 0;
    unumDinAll[i] = 0;
  }
  
  for(i = 0; i < 4; i++)
    uPi[i] = 0;



  for( m = 0; m<MClen; m++){


    bool hyper = false;
    bool hyperup = false;
    psNum = setPsl[rand2.rwunif(setWeight)];
    //TREE->printTree();
    //cout << TREE->getLogLikeliData() << endl;
    //cout << "m : " << m << " psNum : " << psNum << endl;
    int start; // start == 0 means don't consider proposal ratio
    if(m >= Fstburnlen)
      start = 1;
    else
      start = 0;

    switch (psNum){
    case 1:
      AP0 = TREE->SPRonSingleEdge(rand2, para, OSPRonSingleEdge, start);
      break;
    case 2:
      AP0 = TREE->SPRonSubTree(rand2, para, MaxStepSize, OSPRonSubTree, OSPRonSubTree_s, start);
      break;
    case 3:
      AP0 = TREE->SPRonSubTreeLike(rand2, para, MaxStepSize, OSPRonSubTreeLike, OSPRonSubTreeLike_s, start);
      break;
    case 4: 
      AP0 = TREE->UpEdgeLen(rand2, para, OUpEdgeLen, start);
      break;
    case 5:
      //AP0 = TREE->UpIDHandSeq(rand2, para,OUpIDHandSeq, start);
      TREE->UpIDHonEdgeWithFixedHMGbyDistanceAndAdjust(rand2, para, OUpIDHandSeq, start);
      break;
    case 6:
      AP0 = TREE->UpIDHonEdge(rand2, para, OUpIDHonEdge, start);
      break;
    case 7:
      AP0 = TREE->UpIDHonEdgeLike(rand2, para, 2, 2, OUpIDHonEdgeLike, start);
      break;
    case 8:
      hyper = true;
      hyperup = TREE->UpR(rand2, rng, para, OUpR);
      break;
    case 9:
      hyper = true;
      hyperup = TREE->UpRd(rand2, rng, para, OUpRd);
      break;
    case 10:
      hyper = true;
      hyperup = TREE->UpLambda(rand2, para, OUpLambda);
      break;
    case 11:
      hyper = true;
      hyperup = TREE->UpKappa(rand2, para, OUpKappa);
      break;
    case 12:
      hyper = true;
      hyperup = TREE->UpGamma(rand2, para, OUpGamma);
      break;
    case 13:
      hyper = true;
      hyperup = TREE->UpPi(rand2, rng, para, OUpPi);
      break;
    case 14:
      AP0 = TREE->SPRonSubTreeWithinWindow(rand2, para, MaxStepSize, OSPRonSubTreeWithinWindow, OSPRonSubTreeWithinWindow_s, start);
      break;
    case 15:
      AP0 = TREE->SPRonSubTreeWithTarget(rand2, para, MaxStepSize,OSPRonSubTreeWithTarget, OSPRonSubTreeWithTarget_s, start);
      break;
    case 16:
      AP0 = TREE->SPRonSubTreeWithTargetWithinWindow(rand2, para, MaxStepSize,OSPRonSubTreeWithTargetWithinWindow, OSPRonSubTreeWithTargetWithinWindow_s, start);
      break;
    case 17:
      //AP0 = TREE->UpIDHandSeq_v2(rand2, para, OUpIDHandSeq_v2, start);
      AP0 = TREE->NNIwithFixedHMG(rand2, rng, para, OUpIDHandSeq_v2, start);
      break;
    case 18:  
      AP0 = TREE->UpIDHonEdgeWithFixedHMG(rand2, para, OUpIDHonEdgeWithFixedHMG, start);
      break;
    case 19:  
      AP0 = TREE->SPRonSubTreeWithFixedHMG(rand2, para, MaxStepSize, OSPRonSubTreeWithFixedHMG, OSPRonSubTreeWithFixedHMG_s, start);
      break;
    case 20:
      AP0 = TREE->UpIDHonEdgebyDP(rand2, para, OUpIDHonEdgebyDP, start);
      break;
    case 21:
      AP0 = TREE->SPRonSubTreebyDP(rand2, para, MaxStepSize, OSPRonSubTreebyDP, OSPRonSubTreebyDP_s, start);
      break;
    case 22:
      AP0 = TREE->UpIDHonEdgebyDPbestLetters(rand2, para, OUpIDHonEdgebyDPbestLetters, start);
      break;
    case 23:
      AP0 = TREE->SPRonSubTreebyDPbestLetters(rand2, para, MaxStepSize, OSPRonSubTreebyDPbestLetters, OSPRonSubTreebyDPbestLetters_s, start);
      break;
    case 24:
      AP0 = TREE->UpIDHonEdgeWithFixedHMGbyDP(rand2, para, OUpIDHonEdgeWithFixedHMGbyDP, start);
      break;
    case 25:
      AP0 = TREE->SPRonSubTreeWithFixedHMGbyDP(rand2, para, MaxStepSize, OSPRonSubTreeWithFixedHMGbyDP, OSPRonSubTreeWithFixedHMGbyDP_s, start);
      break;
    default:
      cout << "psNum should be between 1 to 7. " << endl;
      break;
    }

    //cout << TREE->getLogLikeliData() << endl;
    //TREE->printTree();

    //cout << TREE->getLogLikeliData() << endl;
    //cout << "11111" << endl;
    


    if(!hyper){

      AP = MIN(((double)1),AP0);

      
      
      if(rand.runif()-AP < 0){
        //cout << "---------------------- Update ------------------------" << endl;
        if(m >= burnlen){
          P_ac = P_ac + AP;
          I_ac = I_ac +1;
          if(is_element(SPRonSubIX, psNum)){
            for(int sh = 0; sh < 9; sh++){
              if(psNum == SPRonSubIX[sh]){
                if(para.getSPRonSingle()==1){
                  para.setPr((SizePslSet+sh), para.getPr((SizePslSet+sh))+AP);
                  para.setIr((SizePslSet+sh), para.getIr((SizePslSet+sh))+1);
                  num[SizePslSet+sh]++;
                }else{
                  para.setPr((psNum-1), para.getPr((psNum-1))+AP);
                  para.setIr((psNum-1), para.getIr((psNum-1))+1);
                  num[psNum-1]++;
                }
                break;
              }
            }
          }else{
            para.setPr((psNum-1), para.getPr((psNum-1))+AP);
            para.setIr((psNum-1), para.getIr((psNum-1))+1);
            num[psNum-1]++;
          }
	  
	  //if(psNum==2){
	  //  if(para.getSPRonSingle()==1){
	  //    para.setPr((SizePslSet), para.getPr((SizePslSet))+AP);
	  //    para.setIr((SizePslSet), para.getIr((SizePslSet))+1);
	  //    num[SizePslSet]++;
          //  }else{
	  //    para.setPr((psNum-1), para.getPr((psNum-1))+AP);
	  //    para.setIr((psNum-1), para.getIr((psNum-1))+1);
	  //    num[psNum-1]++;
          //  }
          //}else{
	  //  para.setPr((psNum-1), para.getPr((psNum-1))+AP);
	  //  para.setIr((psNum-1), para.getIr((psNum-1))+1);
	  //  num[psNum-1]++;
          //}
       
        }else if((m >= Fstburnlen) & (m < Sndburnlen)){
          
          // For tuning
          if(is_element(SPRonSubIX, psNum)){
            for(int sh = 0; sh < 9; sh++){
              if(psNum == SPRonSubIX[sh]){
                if(para.getSPRonSingle()==1){
                  para.setPrT((SizePslSet+sh), para.getPrT((SizePslSet+sh))+AP);
                  para.setIrT((SizePslSet+sh), para.getIrT((SizePslSet+sh))+1);
                  numT[SizePslSet+sh]++;
                }else{
                  para.setPrT((psNum-1), para.getPrT((psNum-1))+AP);
                  para.setIrT((psNum-1), para.getIrT((psNum-1))+1);
                  numT[psNum-1]++;
                }
                break;
              }
            }
          }else{
            para.setPrT((psNum-1), para.getPrT((psNum-1))+AP);
            para.setIrT((psNum-1), para.getIrT((psNum-1))+1);
            numT[psNum-1]++;
          }
        }
        
        TREE->save();

      }else{
        //cout << "---------------------- No Update ------------------------" << endl;
        if(m >= burnlen){
          P_ac = P_ac + AP;
          if(is_element(SPRonSubIX, psNum)){
            for(int sh = 0; sh < 9; sh++){
              if(psNum == SPRonSubIX[sh]){
                if(para.getSPRonSingle()==1){
                  para.setPr((SizePslSet+sh), para.getPr((SizePslSet+sh))+AP);
                  num[SizePslSet+sh]++;
                }else{
                  para.setPr((psNum-1), para.getPr((psNum-1))+AP);
                  num[psNum-1]++;
                }
                break;
              }
            }
          }else{
            para.setPr((psNum-1), para.getPr((psNum-1))+AP);
            num[psNum-1]++;
          }

        }else if((m >= Fstburnlen) & (m < Sndburnlen)){
          // For tuning
          if(is_element(SPRonSubIX, psNum)){
            for(int sh = 0; sh < 9; sh++){
              if(psNum == SPRonSubIX[sh]){
                if(para.getSPRonSingle()==1){
                  para.setPrT((SizePslSet+sh), para.getPrT((SizePslSet+sh))+AP);
                  numT[SizePslSet+sh]++;
                }else{
                  para.setPrT((psNum-1), para.getPrT((psNum-1))+AP);
                  numT[psNum-1]++;
                }
                break;
              }
            }
          }else{
            para.setPrT((psNum-1), para.getPrT((psNum-1))+AP);
            numT[psNum-1]++;
          }
        }
        TREE->restore();
      }
    
    }else{
      
 
      if(m >= burnlen){
        
        if(hyperup){
          P_ac = P_ac + para.getTmpDouble();
          I_ac = I_ac +1;
          para.setPr((psNum-1), para.getPr((psNum-1))+para.getTmpDouble());
          para.setIr((psNum-1), para.getIr((psNum-1))+1);
          num[psNum-1]++;
        }else{
          P_ac = P_ac + para.getTmpDouble();
          para.setPr((psNum-1), para.getPr((psNum-1))+para.getTmpDouble());
          num[psNum-1]++;
        }
        
      }else if((m >= Fstburnlen) & (m < Sndburnlen)){
        
        if(hyperup){
          para.setPrT((psNum-1), para.getPrT((psNum-1))+para.getTmpDouble());
          para.setIrT((psNum-1), para.getIrT((psNum-1))+1);
          numT[psNum-1]++;
        }else{
          para.setPrT((psNum-1), para.getPrT((psNum-1))+para.getTmpDouble());
          numT[psNum-1]++;
        }
      }
    }


    // To check
    
    //vector<double> check(numEdges+1);
    //for(int checkNum = 0; checkNum < numEdges; checkNum++)
    //  check[checkNum] = TREE->getEdge(checkNum)->getlogLikeliIDH();
    //check[numEdges] = TREE->getLogLikeliIDH();
    //
    //double tttt = check[numEdges] - TREE->likeliHistory(para);
    //if(tttt < 0){
    //  tttt = (-1)*tttt;
    //}
    //if(tttt > pow((double)10, (double)-6)){
    //  cout << "ERROR A " << check[numEdges] << " " << TREE->likeliHistory(para) << endl;
    //}
    //for(int checkNum = 0; checkNum < numEdges; checkNum++){
    //  if(check[checkNum] != TREE->getEdge(checkNum)->getlogLikeliIDH()){
    //	cout << "ERROR B " << checkNum << " " << check[checkNum] << " " << TREE->getEdge(checkNum)->getlogLikeliIDH() << endl;
    //  }
    //}    
    //cout << "AAAA " << endl;
    TREE->checkTree();
   

    if((m >= Fstburnlen + tuningIXA)  & (m < Sndburnlen)){

      // UpR
      i = 7;
      if(numT[i] == tuningIX[i]){
        
        value = para.getR_c();
        UpBoundAP = UpBoundAP_UpR;
        LowBoundAP = LowBoundAP_UpR;
        
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1-tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1+tuningInc);
        
        para.setR_c(value);
        
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
        
      }
      
      
      
      // UpRd
      i = 8;
      if(numT[i] == tuningIX[i]){
        
        value = para.getRd_c();
        UpBoundAP = UpBoundAP_UpRd;
        LowBoundAP = LowBoundAP_UpRd;
        
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1-tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1+tuningInc);
        
        para.setRd_c(value);
	
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
	
      }
      
      
      // UpPi
      i = 12;
      if(numT[i] == tuningIX[i]){
        
        value = para.getPi_c();
        UpBoundAP = UpBoundAP_UpPi;
        LowBoundAP = LowBoundAP_UpPi;
        
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1-tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1+tuningInc);
        
        para.setPi_c(value);
	
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
        
      }
      
      
      // UpLambda
      i = 9;
      
      if(numT[i] == tuningIX[i]){
        
        value = para.getLambda_c();
        UpBoundAP = UpBoundAP_UpLambda;
        LowBoundAP = LowBoundAP_UpLambda;
        
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1+tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1-tuningInc);
        
        para.setLambda_c(value);
	
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
	
      }
      
      // UpKappa
      i = 10;
      if(numT[i] == tuningIX[i]){
	
        value = para.getKappa_c();
        UpBoundAP = UpBoundAP_UpKappa;
        LowBoundAP = LowBoundAP_UpKappa;
        
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1+tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1-tuningInc);
	
        para.setKappa_c(value);
        
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
        
      }
      
      
      // UpGamma
      i = 11;
      if(numT[i] == tuningIX[i]){
	
        value = para.getGamma_c();
        UpBoundAP = UpBoundAP_UpGamma;
        LowBoundAP = LowBoundAP_UpGamma;
	
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1+tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1-tuningInc);
        
        para.setGamma_c(value);
        
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
        
      }
      
      
      
      // UpEdgeLen
      i = 3;
      if(numT[i] == tuningIX[i]){
	
        value = para.getZeta();
        UpBoundAP = UpBoundAP_UpEdgeLen;
        LowBoundAP = LowBoundAP_UpEdgeLen;
	
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1+tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1-tuningInc);
	
        para.setZeta(value);
	
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
        
      }
      
      
      
      
      // UpIDHonEdge
      i = 5;
      if(numT[i] == tuningIX[i]){

	
        value = para.getWindowLen_UpIDHonEdge();
        UpBoundAP = UpBoundAP_windowLen_UpIDHonEdge;
        LowBoundAP = LowBoundAP_windowLen_UpIDHonEdge;
	
        double_tmp = para.getPrT(i)/(double)numT[i];
        //cout << "i : " << i << " value : " << value << " UpBoundAP : " << UpBoundAP << " LowBoundAP : " << LowBoundAP << endl;
        if(double_tmp > UpBoundAP)
          value *= (1+tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1-tuningInc);
        
        para.setWindowLen_UpIDHonEdge(MAX(value, MINwindowLen));
	
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
	
      }
      
      
      // UpIDHonEdgeLike
      i = 6;
      if(numT[i] == tuningIX[i]){
	
        value = para.getWindowLen_UpIDHonEdgeLike();
        UpBoundAP = UpBoundAP_windowLen_UpIDHonEdgeLike;
        LowBoundAP = LowBoundAP_windowLen_UpIDHonEdgeLike;
        
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1+tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1-tuningInc);
        
        para.setWindowLen_UpIDHonEdgeLike(MAX(value, MINwindowLen));
	
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
        
      }
      
      // SPRonSubTreeWithinWindowGivenWindowLen
      i = 13;
      if(numT[i] == tuningIX[i]){
	
        value = para.getWindowLen_SPRonSubTreeWithinWindow();
        UpBoundAP = UpBoundAP_windowLen_SPRonSubTreeWithinWindow;
        LowBoundAP = LowBoundAP_windowLen_SPRonSubTreeWithinWindow;
        
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1+tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1-tuningInc);
        
        para.setWindowLen_SPRonSubTreeWithinWindow(MAX(value, MINwindowLen));
        
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
	
      }
      
      // SPRonSubTreeWithTargetWithinWindowGivenWindowLen
      i = 15;
      if(numT[i] == tuningIX[i]){
	
        value = para.getWindowLen_SPRonSubTreeWithTargetWithinWindow();
        UpBoundAP = UpBoundAP_windowLen_SPRonSubTreeWithTargetWithinWindow;
        LowBoundAP = LowBoundAP_windowLen_SPRonSubTreeWithTargetWithinWindow;
	
        double_tmp = para.getPrT(i)/(double)numT[i];
        if(double_tmp > UpBoundAP)
          value *= (1+tuningInc);
        else if(double_tmp < LowBoundAP)
          value *= (1-tuningInc);
        
        para.setWindowLen_SPRonSubTreeWithTargetWithinWindow(MAX(value, MINwindowLen));
	
        cout << i << " " << double_tmp << " " << value << endl;
        tuningIX[i] += tuningIV;
	
      }
      
      
    }
    
    //-------------------------------------------------
    //
    //           Keep track of all information
    //
    //-------------------------------------------------


    //cout << "AAA" << endl;
    
    if(m >= burnlen){

      
 
      
      // Summarize alignments
      //alignS.resize(0);
      //cout << "MMM" << endl;
      //TREE->getAlignments(alignS);
      //cout << "BBB : " << alignS.size() << endl;
      //TREE->printTree();
      //TREE->printAlignments(OAlignment, alignS);
      //cout << "CCC" << endl;
      //TREE_HMG->constructHMGTree(alignS);
      //cout << "HHH" << endl;
      //alignS.resize(0);




      numI = 0;
      numD = 0; 
      totalEdgeLen = 0;

      for(i = 0; i < numSplits; i++){
        numIinAll[i] = -1;
        numDinAll[i] = -1;
        edgeLen[i] = -1;
      }

      uR += para.getR();
      uRd += para.getRd();
      uRi += para.getRi();
      uMu += para.getMu();
      uGamma += para.getGamma();
      uKappa += para.getKappa();
      uLambda += para.getLambda();
      for(i = 0; i < 4; i++)
        uPi[i] += para.getPi(i);

      

      for(i = 0; i < numEdges; i++){
        tmpIDH = TREE->getEdge(i)->getIDH();
        int newi = TREE->GetSplitsIndex(TREE->getEdge(i), splits, midnum);
        numIinAll[newi] = 0;
        numDinAll[newi] = 0;
        for(j = 1; j <= tmpIDH->getNumE(); j++){
          if(tmpIDH->getID(j) == 1){
            unumIinAll[newi]++;
            unumI++;
            dIlen++;
            uIlen += tmpIDH->getL(j);
            numI++;
            numIinAll[newi]++;
            k_Ilen++;
            if(k_Ilen == 1){
              m_Ilen = tmpIDH->getL(j);
              s_Ilen= 0;
            }else{
              tempmean = m_Ilen + (1/(double)(k_Ilen))*(tmpIDH->getL(j) - m_Ilen);
              s_Ilen = s_Ilen+ (tmpIDH->getL(j) - m_Ilen)*(tmpIDH->getL(j) - tempmean);
              m_Ilen = tempmean;
            }
          }else{
            unumDinAll[newi]++;
            unumD++;
            dDlen++;
            uDlen += tmpIDH->getL(j);
            numD++;
            numDinAll[newi]++;
            k_Dlen++;
            if(k_Dlen == 1){
              m_Dlen = tmpIDH->getL(j);
              s_Dlen= 0;
            }else{
              tempmean = m_Dlen + (1/(double)(k_Dlen))*(tmpIDH->getL(j) - m_Dlen);
              s_Dlen = s_Dlen+ (tmpIDH->getL(j) - m_Dlen)*(tmpIDH->getL(j) - tempmean);
              m_Dlen = tempmean;
            }
          }
        }

        numEachSplit[newi]++;
        edgeLen[newi] = TREE->getEdge(i)->getEdgeLen();
        uedgeLen[newi] += edgeLen[newi];
        utotalEdgeLen += edgeLen[newi];
        totalEdgeLen += edgeLen[newi];
      } // End of "for(i = 0; i < numEdges; i++)"



      
      
      
      if(printIX == m){



        OthetaPrior << TREE->calPriorParas(para) << " ";
        OloglikeliData << TREE->getLogLikeliData() << " ";
        OloglikeliIDH << TREE->getLogLikeliIDH() << " ";
        OloglikeliEdges << TREE->CalculatelogLikeliEdges(para) << " ";
        OmnumI << numI << " ";
        OmnumD << numD << " ";
        OtotalEdgeLen << totalEdgeLen << " ";

        for(i = 0; i < numSplits; i++){
          OmedgeLen << edgeLen[i] << " "; 
          OmnumIinAll << numIinAll[i] << " "; 
          OmnumDinAll << numDinAll[i] << " ";  
        }
        OmedgeLen << endl; 
        OmnumIinAll << endl; 
        OmnumDinAll << endl;  

        // print out indel fragment sizes for each split (insertion and deletion separately).
        mcIleninAll.resize(numSplits);
        mcDleninAll.resize(numSplits);
        for(i = 0; i < numEdges; i++){
           tmpIDH = TREE->getEdge(i)->getIDH();
           int newi = TREE->GetSplitsIndex(TREE->getEdge(i), splits, midnum);
           mcIleninAll[newi].resize(0);
           mcDleninAll[newi].resize(0);  
           for(j = 1; j <= tmpIDH->getNumE(); j++){
             if(tmpIDH->getID(j) == 1){
               mcIleninAll[newi].push_back(tmpIDH->getL(j));
             }else{
               mcDleninAll[newi].push_back(tmpIDH->getL(j));
             }
           }
        }
        
        // for insertion fragment sizes
        for(i = 0; i < numSplits; i++){
            for(j = 0; j < mcIleninAll[i].size(); j++)
              OIleninAll << mcIleninAll[i][j] << " ";
            OIleninAll << ";";
        }
        OIleninAll << endl;
        // for deletion fragment sizes
        for(i = 0; i < numSplits; i++){
            for(j = 0; j < mcDleninAll[i].size(); j++)
              ODleninAll << mcDleninAll[i][j] << " ";
            ODleninAll << ";";
        }
        ODleninAll << endl;
       

        OmR << para.getR() << " ";
        OmRd << para.getRd() << " ";
        OmRi << para.getRi() << " ";
        OmMu << para.getMu() << " ";
        OmGamma << para.getGamma() << " ";
        OmKappa << para.getKappa() << " ";
        OmLambda << para.getLambda() << " ";
        for(i = 0; i < 4; i++){
          OmP << para.getPi(i) << " ";
        }
        OmP << endl;

        TREE->print(Otree);
        TREE->printBL(OtreeBL);    



    
        // Summarize alignments
        alignS.resize(0);
        TREE->getAlignments(alignS);
        //cout << "BBB : " << alignS.size() << endl;
        //TREE->printTree();
        OAlignment << ">alignment " << m-burnlen << endl;
        TREE->printAlignmentsPosi_v2(OAlignment, alignS);
        //TREE->printAlignments(OAlignment, alignS);
        //cout << "CCC" << endl;
        //TREE_HMG->constructHMGTree(alignS);
        //cout << "HHH" << endl;
        alignS.resize(0);


        printIX += printIV;
      
      } // End of "if(printIX == m)"




      // Start of calculating mean and sd
      k_numID++;
      if(k_numID == 1){
        m_numI = numI;
        s_numI = 0;
        m_numD = numD;
        s_numD = 0;
        m_totalEdgeLen = totalEdgeLen;
        s_totalEdgeLen = 0;
        
        m_R = para.getR();
        s_R = 0;
        m_Ri = para.getRi();
        s_Ri = 0;
        m_Rd = para.getRd();
        s_Rd = 0;
        m_Lambda = para.getLambda();
        s_Lambda = 0;
        m_Mu = para.getMu();
        s_Mu = 0;
        m_Kappa = para.getKappa();
        s_Kappa = 0;
        m_Gamma = para.getGamma();
        s_Gamma = 0;
	

        for( i = 0; i < numLeaves ; i++){ 
          m_numIinAll[i] = numIinAll[i];
          m_numDinAll[i] = numDinAll[i];
          m_edgeLen[i] = edgeLen[i];
          s_numIinAll[i] = 0;
          s_numDinAll[i] = 0;
          s_edgeLen[i] = 0;	  
        }

        for(i = 0; i < 4; i++){
          m_Pi[i] = para.getPi(i);
          s_Pi[i] = 0;
        }


      }else{

        tempmean = m_numI + (1/(double)(k_numID))*(numI - m_numI);
        s_numI = s_numI + (numI - m_numI)*(numI- tempmean);
        m_numI = tempmean;
        
        tempmean = m_numD + (1/(double)(k_numID))*(numD - m_numD);
        s_numD = s_numD + (numD - m_numD)*(numD- tempmean);
        m_numD = tempmean;
        
        tempmean = m_totalEdgeLen + (1/(double)(k_numID))*(totalEdgeLen - m_totalEdgeLen);
        s_totalEdgeLen = s_totalEdgeLen + (totalEdgeLen - m_totalEdgeLen)*(totalEdgeLen- tempmean);
        m_totalEdgeLen = tempmean;

        tempmean = m_R + (1/(double)(k_numID))*(para.getR() - m_R);
        s_R = s_R + (para.getR() - m_R)*(para.getR() - tempmean);
        m_R = tempmean;


        tempmean = m_Rd + (1/(double)(k_numID))*(para.getRd() - m_Rd);
        s_Rd = s_Rd + (para.getRd() - m_Rd)*(para.getRd() - tempmean);
        m_Rd = tempmean;


        tempmean = m_Ri + (1/(double)(k_numID))*(para.getRi() - m_Ri);
        s_Ri = s_Ri + (para.getRi() - m_Ri)*(para.getRi() - tempmean);
        m_Ri = tempmean;


        tempmean = m_Lambda + (1/(double)(k_numID))*(para.getLambda() - m_Lambda);
        s_Lambda = s_Lambda + (para.getLambda() - m_Lambda)*(para.getLambda() - tempmean);
        m_Lambda = tempmean;


        tempmean = m_Mu + (1/(double)(k_numID))*(para.getMu() - m_Mu);
        s_Mu = s_Mu + (para.getMu() - m_Mu)*(para.getMu() - tempmean);
        m_Mu = tempmean;


        tempmean = m_Gamma + (1/(double)(k_numID))*(para.getGamma() - m_Gamma);
        s_Gamma = s_Gamma + (para.getGamma() - m_Gamma)*(para.getGamma() - tempmean);
        m_Gamma = tempmean;


        tempmean = m_Kappa + (1/(double)(k_numID))*(para.getKappa() - m_Kappa);
        s_Kappa = s_Kappa + (para.getKappa() - m_Kappa)*(para.getKappa() - tempmean);
        m_Kappa = tempmean;

        for( i = 0; i < 4 ; i++){ 
          tempmean = m_Pi[i] + (1/(double)(k_numID))*(para.getPi(i) - m_Pi[i]);
          s_Pi[i] = s_Pi[i]+ (para.getPi(i) - m_Pi[i])*(para.getPi(i) - tempmean);
          m_Pi[i] = tempmean;
        }

        for( i = 0; i < numLeaves ; i++){ 
          tempmean = m_numIinAll[i] + (1/(double)(k_numID))*(numIinAll[i] - m_numIinAll[i]);
          s_numIinAll[i] = s_numIinAll[i]+ (numIinAll[i] - m_numIinAll[i])*(numIinAll[i] - tempmean);
          m_numIinAll[i] = tempmean;
          
          tempmean = m_numDinAll[i] + (1/(double)(k_numID))*(numDinAll[i] - m_numDinAll[i]);
          s_numDinAll[i] = s_numDinAll[i]+ (numDinAll[i] - m_numDinAll[i])*(numDinAll[i] - tempmean);
          m_numDinAll[i] = tempmean;

          tempmean = m_edgeLen[i] + (1/(double)(k_numID))*(edgeLen[i] - m_edgeLen[i]);
          s_edgeLen[i] = s_edgeLen[i]+ (edgeLen[i] - m_edgeLen[i])*(edgeLen[i] - tempmean);
          m_edgeLen[i] = tempmean;	  
        }
      } // End of calculating mean and sd

   
    }  // End of "if(m >= burnlen)"


  } // End of "for( m = 0; m<MClen; m++)"
  




 


  mnumI = unumI/(double)MClen2;
  mnumD = unumD/(double)MClen2;
  mIlen = uIlen/(double)dIlen;
  mDlen = uDlen/(double)dDlen;
  mtotalEdgeLen = utotalEdgeLen/(double)MClen2;
  mP_ac = P_ac/(double)MClen2;
  mI_ac = I_ac/(double)MClen2;

  mR = uR/(double)MClen2;
  mRd = uRd/(double)MClen2;
  mRi = uRi/(double)MClen2;
  mMu = uMu/(double)MClen2;
  mLambda = uLambda/(double)MClen2;
  mKappa = uKappa/(double)MClen2;
  mGamma = uGamma/(double)MClen2;

  for(i = 0; i < 4; i++)
    mPi[i] = uPi[i]/(double)MClen2;


 
  for(i = 0; i < numSplits; i++){
    if(numEachSplit[i] == 0){
      medgeLen[i] = -1;
      mnumIinAll[i] = -1;
      mnumDinAll[i] = -1;
    }else{
      medgeLen[i] = uedgeLen[i]/(double)numEachSplit[i];
      mnumIinAll[i] = unumIinAll[i]/(double)numEachSplit[i];
      mnumDinAll[i] = unumDinAll[i]/(double)numEachSplit[i];
    }
  }



  // print all information

  outfile << "MClen2: "  <<  MClen2 << endl;
  outfile << "num of Splits " << endl;
  for(i = 0; i < numSplits; i++)
    outfile << numEachSplit[i] << " ";
  outfile << endl;  

  outfile << "#############################################" << endl;
  outfile << "##                                         ##" << endl;
  outfile << "##             Acceptance prob             ##" << endl;
  outfile << "##                                         ##" << endl;
  outfile << "#############################################" << endl;
  outfile  << "mP_ac : "  << mP_ac << '\n';
  outfile  << "mI_ac : "  << mI_ac << '\n';
  outfile << "Proposal   proportion P   I  " << endl;

  i = 0;
  outfile << "SPRonSingleEdge " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = SizePslSet;
  outfile << "SPRonSubTree(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 1;
  outfile << "SPRonSubTree(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = SizePslSet+2;
  outfile << "SPRonSubTreeWithinWindow(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 13;
  outfile << "SPRonSubTreeWithinWindow(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = SizePslSet+3;
  outfile << "SPRonSubTreeWithTarget(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 14;
  outfile << "SPRonSubTreeWithTarget(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = SizePslSet+4;
  outfile << "SPRonSubTreeWithTargetWithinWindow(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 15;
  outfile << "SPRonSubTreeWithTargetWithinWindow(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = SizePslSet+1;
  outfile << "SPRonSubTreeLike(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;  
  i = 2;
  outfile << "SPRonSubTreeLike(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;  
  i = SizePslSet+5;
  outfile << "SPRonSubTreeWithFixedHMG(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 18;
  outfile << "SPRonSubTreeWithFixedHMG(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = SizePslSet+6;
  outfile << "SPRonSubTreebyDP(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 20;
  outfile << "SPRonSubTreebyDP(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = SizePslSet+7;
  outfile << "SPRonSubTreebyDPbestLetters(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 22;
  outfile << "SPRonSubTreebyDPbestLetters(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = SizePslSet+8;
  outfile << "SPRonSubTreeWithFixedHMGbyDP(Single) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 24;
  outfile << "SPRonSubTreeWithFixedHMGbyDP(realSubTree) " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 3;
  outfile << "UpEdgeLen " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;  
  i = 4;
  outfile << "UpIDHonEdgeWithFixedHMGbyDistanceAndAdjust " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 16;
  outfile << "NNIwithFixedHMG " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 5;
  outfile << "UpIDHonEdge " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;  
  i = 6;
  outfile << "UpIDHonEdgeLike " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;  
  i = 17;
  outfile << "UpIDHonEdgeWithFixedHMG " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 19;
  outfile << "UpIDHonEdgebyDP " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 21;
  outfile << "UpIDHonEdgebyDPbestLetters " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 23;
  outfile << "UpIDHonEdgeWithFixedHMGbyDP " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 7;
  outfile << "UpR " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 8;
  outfile << "UpRd " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 9;
  outfile << "UpLambda " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 10;
  outfile << "UpKappa " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 11;
  outfile << "UpGamma " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  i = 12;
  outfile << "UpPi " << num[i]/(double)MClen2 << " " << para.getPr(i)/(double)num[i] << " " << para.getIr(i)/(double)num[i] << endl;
  outfile << "R_c st : " << r_c << " en : " << para.getR_c() << endl;
  outfile << "Rd_c st : " << rd_c << " en : " << para.getRd_c() << endl;
  outfile << "Pi_c st : " << pi_c << " en : " << para.getPi_c() << endl;
  outfile << "zeta st : " << zeta << " en : " << para.getZeta() << endl;
  outfile << "Kappa_c st : " << kappa_c << " en : " << para.getKappa_c() << endl;
  outfile << "Lambda_c st : " << lambda_c << " en : " << para.getLambda_c() << endl;
  outfile << "Gamma_c st : " << gamma_c << " en : " << para.getGamma_c() << endl;
  outfile << "UpIDHonEdge st : " << windowLen_UpIDHonEdge << " en : " << para.getWindowLen_UpIDHonEdge() << endl;
  outfile << "UpIDHonEdgeLike st : " << windowLen_UpIDHonEdgeLike << " en : " << para.getWindowLen_UpIDHonEdgeLike() << endl;
  outfile << "SPRonSubTreeWithinWindow st : " << windowLen_SPRonSubTreeWithinWindow << " en : " << para.getWindowLen_SPRonSubTreeWithinWindow() << endl;
  outfile << "SPRonSubTreeWithTargetWithinWindow st : " << windowLen_SPRonSubTreeWithTargetWithinWindow << " en : " << para.getWindowLen_SPRonSubTreeWithTargetWithinWindow() << endl;


  outfile << "#############################################" << endl;
  outfile << "##                                         ##" << endl;
  outfile << "##  Mean(m), Mean(m_), sd(s_), psrf(psrf_) ##" << endl;
  outfile << "##                                         ##" << endl;
  outfile << "#############################################" << endl;
  


  for( i = 0; i < numLeaves ; i++){
    outfile  << "edgeLen[" << i << "] : " << medgeLen[i] << " " << m_edgeLen[i] << " " << sqrt(s_edgeLen[i]/(double)(MClen2-1)) << " " << psrf_edgeLen[i] << endl;
  }
  for( i = numLeaves; i < numSplits ; i++){
    outfile  << "edgeLen[" << i << "] : " << medgeLen[i]  << endl;
  }
  for( i = 0; i < numLeaves ; i++){
    outfile  << "numIinAll[" << i << "] : " << mnumIinAll[i] << " " << m_numIinAll[i] << " " << sqrt(s_numIinAll[i]/(double)(MClen2-1)) << " " << psrf_numIinAll[i] << endl;
    outfile  << "numDinAll[" << i << "] : " << mnumDinAll[i] << " " << m_numDinAll[i] << " " << sqrt(s_numDinAll[i]/(double)(MClen2-1)) << " " << psrf_numDinAll[i] << endl;
  }  
  for( i = numLeaves; i < numSplits ; i++){
    outfile  << "numIinAll[" << i << "] : " << mnumIinAll[i] << endl;
    outfile  << "numDinAll[" << i << "] : " << mnumDinAll[i] << endl;
  }  
  for( i = 0; i < 4 ; i++){
    outfile  << "pi[" << i << "] : " << mPi[i] << " " << m_Pi[i] << " " << sqrt(s_Pi[i]/(double)(MClen2-1)) << " " << psrf_Pi[i] << endl;
  }  
  outfile  << "R : "  << mR << " " << m_R << " " << sqrt(s_R/(double)(MClen2-1)) << " " << psrf_R << '\n';
  outfile  << "Rd : "  << mRd << " " << m_Rd << " " << sqrt(s_Rd/(double)(MClen2-1)) << " " << psrf_Rd << '\n';
  outfile  << "Ri : "  << mRi << " " << m_Ri << " " << sqrt(s_Ri/(double)(MClen2-1)) << " " << psrf_Ri << '\n';
  outfile  << "Lambda : "  << mLambda << " " << m_Lambda << " " << sqrt(s_Lambda/(double)(MClen2-1)) << " " << psrf_Lambda << '\n';
  outfile  << "Mu : "  << mMu << " " << m_Mu << " " << sqrt(s_Mu/(double)(MClen2-1)) << " " << psrf_Mu << '\n';
  outfile  << "Kappa : "  << mKappa << " " << m_Kappa << " " << sqrt(s_Kappa/(double)(MClen2-1)) << " " << psrf_Kappa << '\n';
  outfile  << "Gamma : "  << mGamma << " " << m_Gamma << " " << sqrt(s_Gamma/(double)(MClen2-1)) << " " << psrf_Gamma << '\n';
  outfile  << "numI : "  << mnumI << " " << m_numI << " " << sqrt(s_numI/(double)(MClen2-1)) << " " << psrf_numI << '\n';
  outfile  << "numD : "  << mnumD << " " << m_numD << " " << sqrt(s_numD/(double)(MClen2-1)) << " " << psrf_numD << '\n';
  outfile  << "Ilen : "  << mIlen << " " << m_Ilen << " " << sqrt(s_Ilen/(double)(MClen2-1)) << '\n';
  outfile  << "Dlen : "  << mDlen << " " << m_Dlen << " " << sqrt(s_Dlen/(double)(MClen2-1)) << '\n';
  outfile  << "ntotalEdgeLen : "  << mtotalEdgeLen << " " << m_totalEdgeLen << " " << sqrt(s_totalEdgeLen/(double)(MClen2-1)) << '\n';


  delete TREE;
  //delete TREE_HMG;



  seqDataS.resize(0);
  splits.resize(0);
  intVec.resize(0);
  comb.resize(0);
  alignS.resize(0);

  uPi.resize(0);
  mPi.resize(0);
  m_Pi.resize(0);
  s_Pi.resize(0);
  b_Pi.resize(0);
  w_Pi.resize(0);
  psrf_Pi.resize(0);
  
  numEachSplit.resize(0);

  edgeLen.resize(0);
  uedgeLen.resize(0);
  medgeLen.resize(0);
  m_edgeLen.resize(0);
  s_edgeLen.resize(0);
  b_edgeLen.resize(0);
  w_edgeLen.resize(0);
  psrf_edgeLen.resize(0);

  numIinAll.resize(0);
  unumIinAll.resize(0);
  mnumIinAll.resize(0);
  m_numIinAll.resize(0);
  s_numIinAll.resize(0);
  b_numIinAll.resize(0);
  w_numIinAll.resize(0);
  psrf_numIinAll.resize(0);

  numDinAll.resize(0);
  unumDinAll.resize(0);
  mnumDinAll.resize(0);
  m_numDinAll.resize(0);
  s_numDinAll.resize(0);
  b_numDinAll.resize(0);
  w_numDinAll.resize(0); 
  psrf_numDinAll.resize(0); 


  mcIleninAll.resize(0);
  mcDleninAll.resize(0);
 

  MPIm_numI.resize(0);
  MPIs_numI.resize(0);
  MPIm_numD.resize(0);
  MPIs_numD.resize(0);
  MPIm_Ilen.resize(0);
  MPIs_Ilen.resize(0);
  MPIm_Dlen.resize(0);
  MPIs_Dlen.resize(0);
  MPIm_totalEdgeLen.resize(0);
  MPIs_totalEdgeLen.resize(0);
  MPIm_R.resize(0);
  MPIs_R.resize(0);
  MPIm_Rd.resize(0);
  MPIs_Rd.resize(0);
  MPIm_Ri.resize(0);
  MPIs_Ri.resize(0);
  MPIm_Lambda.resize(0);
  MPIs_Lambda.resize(0);
  MPIm_Mu.resize(0);
  MPIs_Mu.resize(0);
  MPIm_Kappa.resize(0);
  MPIs_Kappa.resize(0);
  MPIm_Gamma.resize(0);
  MPIs_Gamma.resize(0);



  MPIm_numIinAll.resize(0);
  MPIm_numDinAll.resize(0);
  MPIm_edgeLen.resize(0);
  MPIs_numIinAll.resize(0);
  MPIs_numDinAll.resize(0);
  MPIs_edgeLen.resize(0);
  MPIm_Pi.resize(0);
  MPIs_Pi.resize(0);

  setPsl.resize(0);
  setWeight.resize(0);
  num.resize(0);
  numT.resize(0);
  tuningIX.resize(0);


  outfile.close();
  Otree.close();
  OtreeBL.close();
  OAlignment.close();
  OmnumI.close();
  OmnumD.close();
  OmedgeLen.close();
  OmnumIinAll.close();
  OmnumDinAll.close();
  OtotalEdgeLen.close();
  OmR.close();
  OmRd.close(); 
  OmRi.close();
  OmMu.close();
  OmGamma.close();
  OmKappa.close(); 
  OmLambda.close(); 
  OmP.close();
  OloglikeliData.close();
  OloglikeliIDH.close();
  OloglikeliEdges.close();

  OIleninAll.close();
  ODleninAll.close();



  return 0;

}
