/* Code generated by HMMoC version 1.3, Copyright (C) 2006 Gerton Lunter */
/* Generated from file aligner.xml (author:  Gerton Lunter ) on Sat Apr 25 19:05:34 CDT 2009 */

/*
This file is a work based on HMMoC 1.3, a hidden Markov model compiler.
Copyright (C) 2006 by Gerton Lunter, Oxford University.

HMMoC and works based on it are free software; you can redistribute 
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

HMMOC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HMMoC; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#ifndef _aligner_h_
#define _aligner_h_


#include "dptablesHJ.h"
#include "algebrasHJ.h"

#include <vector>
#include <iostream>
#include <string>
#include <algorithm>

using std::vector;
using std::cout;
using std::string;

#include <map>

using std::map;

#include <stdlib.h>
#include <math.h>


// Here go the state memory clique typedefs:
typedef States<bfloat,3> Statesblock2;
typedef States<bfloat,1> Statesblock1;
typedef States<bfloat,1> Statesblock3;

class AlignDPTable {
    public:
    // If true, this class' destructor will delete the DP arrays
    bool isInCharge;
    // Pointers to arrays containing ids of states and transitions
    const string* const stateId;
    const string* const emissionId;
    const string* const transitionId;
    const string* const transitionFrom;
    const string* const transitionTo;
    const string* const transitionProb;
    const string* const transitionEmit;
    const string* const outputId;
    // The actual DP tables, and total sequence lengths (which determine size of DP arrays) follow:
    int iLen1;
    int iLen2;
    DPTable<Statesblock2,2> StateMemoryblock2;
    DPTable<Statesblock1,0> StateMemoryblock1;
    DPTable<Statesblock3,0> StateMemoryblock3;
    // Member functions:
    public:
    // Default copy constructor is used; user has to set isInCharge appropriately afterwards!
    AlignDPTable(int iLen1,int iLen2);
    ~AlignDPTable();
    // returns probability from DP table, given position and int or string state identifier
    bfloat getProb(int iState ,int ,int ) const;
    bfloat getProb(const string sState ,int ,int ) const;
    // converts string identifier (for state, transition or emission) into integer id
    static int getId(const string& sState);
    static const string& getTransitionId(int id);
    static const string& getEmissionId(int id);
    static const string& getStateId(int id);
    static const string& getOutputId(int id);
    static void _cleanup() { getId("_cleanup_"); }
};

// give a name to the real type used for this HMM
typedef bfloat AlignReal;
// define type for a 'short' real -- usually double, but can be logspace for efficiency
typedef double AlignShortReal;



// Here go the state memory clique typedefs:
typedef States<bfloat,3> Statesblock2;
typedef States<bfloat,1> Statesblock3;
typedef States<bfloat,1> Statesblock1;

class AlignFoldedDPTable {
    public:
    // If true, this class' destructor will delete the DP arrays
    bool isInCharge;
    // Pointers to arrays containing ids of states and transitions
    const string* const stateId;
    const string* const emissionId;
    const string* const transitionId;
    const string* const transitionFrom;
    const string* const transitionTo;
    const string* const transitionProb;
    const string* const transitionEmit;
    const string* const outputId;
    // The actual DP tables, and total sequence lengths (which determine size of DP arrays) follow:
    int iLen1;
    int iLen2;
    FoldedTable<DPTable,Statesblock2,2> StateMemoryblock2;
    DPTable<Statesblock3,0> StateMemoryblock3;
    DPTable<Statesblock1,0> StateMemoryblock1;
    // Member functions:
    public:
    // Default copy constructor is used; user has to set isInCharge appropriately afterwards!
    AlignFoldedDPTable(int iLen1,int iLen2);
    ~AlignFoldedDPTable();
    // returns probability from DP table, given position and int or string state identifier
    bfloat getProb(int iState ,int ,int ) const;
    bfloat getProb(const string sState ,int ,int ) const;
    // converts string identifier (for state, transition or emission) into integer id
    static int getId(const string& sState);
    static const string& getTransitionId(int id);
    static const string& getEmissionId(int id);
    static const string& getStateId(int id);
    static const string& getOutputId(int id);
    static void _cleanup() { getId("_cleanup_"); }
};



class AlignBaumWelch {
    public:
    // Default copy constructor is used.
    // Void constructor:
    AlignBaumWelch() { resetCounts(); }
    // Not calling resetCounts() across calls allows to aggregate results over multiple datasets
    void resetCounts();
    void scaleCounts(bfloat scale);
    // Translate an identifier (string or integer) to the index into their corresponding Baum-Welch counter array (below)
    // Which array is used for any particular emission/transition depends on its order signature - see documentation for details
    int transitionIndex(int intId) const { return atransitionIdx[intId]; }
    int transitionIndex(string strId) const;
    int emissionIndex(int intId) const { return aemissionIdx[intId]; }
    int emissionIndex(string strId) const;
    // Now follow, in triplets (one for each order signature):
    //  Transition or emission counters;
    //  Array of identifiers; and
    //  Dimension of array (number of counters).
    bfloat transitionBaumWelchCount00[16];
    static int transitionIdentifier00[16];   
    static const int transitionDimension00 = 16;
    private:
    static int atransitionIdx[16];
    static int aemissionIdx[4];
    static map<const string,int> mId;
};







// Here go the state memory clique typedefs:
typedef States<bfloat,3> Statesblock2withbanding;
typedef States<bfloat,1> Statesblock1;
typedef States<bfloat,1> Statesblock3;

class AlignWithBandingDPTable {
    public:
    // If true, this class' destructor will delete the DP arrays
    bool isInCharge;
    // Pointers to arrays containing ids of states and transitions
    const string* const stateId;
    const string* const emissionId;
    const string* const transitionId;
    const string* const transitionFrom;
    const string* const transitionTo;
    const string* const transitionProb;
    const string* const transitionEmit;
    const string* const outputId;
    // The actual DP tables, and total sequence lengths (which determine size of DP arrays) follow:
    int iLen1;
    int iLen2;
    DPTable<Statesblock2withbanding,2> StateMemoryblock2withbanding;
    DPTable<Statesblock1,0> StateMemoryblock1;
    DPTable<Statesblock3,0> StateMemoryblock3;
    // Member functions:
    public:
    // Default copy constructor is used; user has to set isInCharge appropriately afterwards!
    AlignWithBandingDPTable(int iLen1,int iLen2);
    ~AlignWithBandingDPTable();
    // returns probability from DP table, given position and int or string state identifier
    bfloat getProb(int iState ,int ,int ) const;
    bfloat getProb(const string sState ,int ,int ) const;
    // converts string identifier (for state, transition or emission) into integer id
    static int getId(const string& sState);
    static const string& getTransitionId(int id);
    static const string& getEmissionId(int id);
    static const string& getStateId(int id);
    static const string& getOutputId(int id);
    static void _cleanup() { getId("_cleanup_"); }
};

// give a name to the real type used for this HMM
typedef bfloat AlignWithBandingReal;
// define type for a 'short' real -- usually double, but can be logspace for efficiency
typedef double AlignWithBandingShortReal;



// Here go the state memory clique typedefs:
typedef States<bfloat,3> Statesblock2withbanding;
typedef States<bfloat,1> Statesblock3;
typedef States<bfloat,1> Statesblock1;

class AlignWithBandingFoldedDPTable {
    public:
    // If true, this class' destructor will delete the DP arrays
    bool isInCharge;
    // Pointers to arrays containing ids of states and transitions
    const string* const stateId;
    const string* const emissionId;
    const string* const transitionId;
    const string* const transitionFrom;
    const string* const transitionTo;
    const string* const transitionProb;
    const string* const transitionEmit;
    const string* const outputId;
    // The actual DP tables, and total sequence lengths (which determine size of DP arrays) follow:
    int iLen1;
    int iLen2;
    FoldedTable<DPTable,Statesblock2withbanding,2> StateMemoryblock2withbanding;
    DPTable<Statesblock3,0> StateMemoryblock3;
    DPTable<Statesblock1,0> StateMemoryblock1;
    // Member functions:
    public:
    // Default copy constructor is used; user has to set isInCharge appropriately afterwards!
    AlignWithBandingFoldedDPTable(int iLen1,int iLen2);
    ~AlignWithBandingFoldedDPTable();
    // returns probability from DP table, given position and int or string state identifier
    bfloat getProb(int iState ,int ,int ) const;
    bfloat getProb(const string sState ,int ,int ) const;
    // converts string identifier (for state, transition or emission) into integer id
    static int getId(const string& sState);
    static const string& getTransitionId(int id);
    static const string& getEmissionId(int id);
    static const string& getStateId(int id);
    static const string& getOutputId(int id);
    static void _cleanup() { getId("_cleanup_"); }
};



class AlignWithBandingBaumWelch {
    public:
    // Default copy constructor is used.
    // Void constructor:
    AlignWithBandingBaumWelch() { resetCounts(); }
    // Not calling resetCounts() across calls allows to aggregate results over multiple datasets
    void resetCounts();
    void scaleCounts(bfloat scale);
    // Translate an identifier (string or integer) to the index into their corresponding Baum-Welch counter array (below)
    // Which array is used for any particular emission/transition depends on its order signature - see documentation for details
    int transitionIndex(int intId) const { return atransitionIdx[intId]; }
    int transitionIndex(string strId) const;
    int emissionIndex(int intId) const { return aemissionIdx[intId]; }
    int emissionIndex(string strId) const;
    // Now follow, in triplets (one for each order signature):
    //  Transition or emission counters;
    //  Array of identifiers; and
    //  Dimension of array (number of counters).
    bfloat transitionBaumWelchCount00[16];
    static int transitionIdentifier00[16];   
    static const int transitionDimension00 = 16;
    private:
    static int atransitionIdx[16];
    static int aemissionIdx[4];
    static map<const string,int> mId;
};





#ifndef _PATH_CLASS_DEFINED_
#define _PATH_CLASS_DEFINED_

class Path {
    //protected:
    public:
    vector<int> transitions;
    public:
    unsigned int size() const {                             // Number of transitions in path
        return transitions.size(); 
    }
    int transition(int i) const {                           // i-th transition
        return transitions[i]; 
    }
    virtual double prob(int) const = 0;                  // i-th transition*emission probability:
    virtual const vector<int>& emission(int) const = 0;  // i-th emission vector
    virtual int fromState(int) const = 0;                // State at from-end of i-th transition
    virtual int toState(int) const = 0;                  // State at to-end of i-th transition
    virtual int nextFrom(int) const = 0;                 // index of next sibling, -1 if no more (always -1 for simple paths)
    virtual int nextTo(int) const = 0;                   // index of child (always i+1 for simple paths), or -1 if no more
    virtual ~Path() {} 
};

ostream& operator<<(ostream& os, const Path& p);

class SimplePath: public Path {
    public:
    vector<double> probs;
    vector<vector<int> > emissions;
    vector<int> froms;
    vector<int> tos;
    public:
    void addEdge(int transition, double prob, vector<int>& emission, int from, int to);
    double prob(int index) const;
    int nextFrom(int index) const;
    int nextTo(int index) const;
    const vector<int>& emission(int index) const;
    int fromState(int index) const;
    int toState(int index) const;
    void reverse();
};  

#endif // _PATH_CLASS_DEFINED_

bfloat Forward(AlignDPTable** ppOutTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2);

bfloat BackwardBaumWelch(AlignBaumWelch& bw,AlignDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2);


//-- Heejung start --//
bfloat Backward(AlignDPTable** ppOutTable,double iDelta,double iR,double iTau, vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2);

double Sample(AlignDPTable* pInTable,double iDelta,double iR, double iTau, vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2, vector<vector<int> >& HMG);

double CalProbSample(AlignDPTable* pInTable,double iDelta,double iR, double iTau,vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2, vector<vector<int> >& HMG);


double Viterbi_recurse(AlignDPTable** ppOutTable,double iDelta,double iR, double iTau, vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2);

double Viterbi_trace(AlignDPTable* pInTable,double iDelta,double iR, double iTau, vector<vector<double> >& Pt, vector<double>& pi, vector<char>& iSequence1,vector<char>& iSequence2, vector<vector<int> >& HMG);

//-- Heejung end --//



bfloat ForwardBanding(AlignWithBandingDPTable** ppOutTable,double iDelta,double iR,double iSigma,double iTau,int iWidth,vector<char>& iSequence1,vector<char>& iSequence2);

bfloat BackwardBaumWelchBanding(AlignWithBandingBaumWelch& bw,AlignWithBandingDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,int iWidth,vector<char>& iSequence1,vector<char>& iSequence2);

bfloat BackwardBanding(AlignWithBandingDPTable** ppOutTable,double iDelta,double iR,double iSigma,double iTau,int iWidth,vector<char>& iSequence1,vector<char>& iSequence2);

//-- Heejung start --//
Path& SampleBanding(AlignWithBandingDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2, double* prob);

double CalProbSampleBanding(AlignWithBandingDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2, vector<vector<int> >& HMG);
//-- Heejung end --//

bfloat ViterbiBanding_recurse(AlignWithBandingDPTable** ppOutTable,double iDelta,double iR,double iSigma,double iTau,int iWidth,vector<char>& iSequence1,vector<char>& iSequence2);

Path& ViterbiBanding_trace(AlignWithBandingDPTable* pInTable,double iDelta,double iR,double iSigma,double iTau,vector<char>& iSequence1,vector<char>& iSequence2);

#endif // _aligner_h_

/* --- end of HMMoC-generated file --- */
